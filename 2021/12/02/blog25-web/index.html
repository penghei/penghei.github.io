<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>网络知识学习总结 | XingYeBlog</title><meta name="keywords" content="日常学习"><meta name="author" content="Xing Ye,632885485@qq.com"><meta name="copyright" content="Xing Ye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="网络基础知识协议间关系 链接&#x2F;超链接 网站的三大支柱：  URL, 跟踪 Web 文档的地址系统 HTTP, 一个传输协议，以便在给定 URL 时查找文档 HTML, 允许嵌入超链接的文档格式   链接可以将任何文本与 URL 相关联，因此用户只要激活链接就可以到达目标文档。链接的类型有：  内链：网页内的链接，用于网页里面的变化，比如滚动条滚动 外链：网页到另一个网页的链接 传入链接：从其他人的">
<meta property="og:type" content="article">
<meta property="og:title" content="网络知识学习总结">
<meta property="og:url" content="http://example.com/2021/12/02/blog25-web/index.html">
<meta property="og:site_name" content="XingYeBlog">
<meta property="og:description" content="网络基础知识协议间关系 链接&#x2F;超链接 网站的三大支柱：  URL, 跟踪 Web 文档的地址系统 HTTP, 一个传输协议，以便在给定 URL 时查找文档 HTML, 允许嵌入超链接的文档格式   链接可以将任何文本与 URL 相关联，因此用户只要激活链接就可以到达目标文档。链接的类型有：  内链：网页内的链接，用于网页里面的变化，比如滚动条滚动 外链：网页到另一个网页的链接 传入链接：从其他人的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/web.png">
<meta property="article:published_time" content="2021-12-02T04:19:49.000Z">
<meta property="article:modified_time" content="2022-06-05T03:32:54.520Z">
<meta property="article:author" content="Xing Ye">
<meta property="article:tag" content="日常学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/web.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2021/12/02/blog25-web/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '网络知识学习总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-05 11:32:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/pinkstar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/web.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XingYeBlog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">网络知识学习总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-02T04:19:49.000Z" title="发表于 2021-12-02 12:19:49">2021-12-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-05T03:32:54.520Z" title="更新于 2022-06-05 11:32:54">2022-06-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%8E%9F%E7%90%86/">原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">27.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>89分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="网络知识学习总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="网络基础知识"><a href="#网络基础知识" class="headerlink" title="网络基础知识"></a>网络基础知识</h1><h2 id="协议间关系"><a href="#协议间关系" class="headerlink" title="协议间关系"></a>协议间关系</h2><p><img src="https://i.loli.net/2021/12/02/Uwe2Sb3oAJZKGVq.jpg" alt="协议关系.jpg"></p>
<h2 id="链接-超链接"><a href="#链接-超链接" class="headerlink" title="链接/超链接"></a>链接/超链接</h2><blockquote>
<p>网站的三大支柱：</p>
<ul>
<li>URL, 跟踪 Web 文档的地址系统</li>
<li>HTTP, 一个传输协议，以便在给定 URL 时查找文档</li>
<li>HTML, 允许嵌入超链接的文档格式</li>
</ul>
</blockquote>
<p>链接可以将任何文本与 URL 相关联，因此用户只要激活链接就可以到达目标文档。<br>链接的类型有：</p>
<ul>
<li>内链：网页内的链接，用于网页里面的变化，比如滚动条滚动</li>
<li>外链：网页到另一个网页的链接</li>
<li>传入链接：从其他人的网页链接到你的网页的链接。</li>
</ul>
<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><blockquote>
<p>URI 和 URL<br><img src="https://pic.imgdb.cn/item/623429625baa1a80abfeda20.jpg"><br>统一资源标志符 URI 就是在某一规则下能把一个资源独一无二地标识出来的<strong>字符串</strong>。URI 是唯一的，一个资源对应一个 URI，且只能通过该 URI 定位该资源<br>URI 分为 URL 和 URN，这两个是 URI 的一种形式：即，URL 通过标识位置的形式表示资源，同样起到了 URI 的作用，所以 URL 是 URI 的子集，URL 就是用定位的方式实现的 URI。URN 则是用资源名标识，不过不常用。</p>
</blockquote>
<p>URL 的组成：<br><img src="https://pic.imgdb.cn/item/623426a85baa1a80abfcb591.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com:80/path/to/myfile.html?key1=value1&amp;key2=value2#SomewhereInTheDocument</span><br></pre></td></tr></table></figure>

<ol>
<li><code>http://</code> ，超文本传输协议，它表明了浏览器必须使用何种协议，也可是 HTTPS；当然还可以是 <code>file://</code> 文件协议，或者邮箱协议等</li>
<li><code>www.example.com</code> 是域名，这个也可以用域名代替</li>
<li><code>:80</code>是端口。IP 地址与网络服务的关系是一对多的，所以需要表示用于访问 Web 服务器上的资源的技术“门”。如果 Web 服务器使用 HTTP 协议的标准端口（HTTP 为 80，HTTPS 为 443）来授予其资源的访问权限，则通常会被忽略。否则是强制性的。一般 80 端口就是网络服务器，如果你自己想有个网站，就需要通过 80 端口来向外展示</li>
<li><code>/path/to/myfile.html </code>是文件或资源位于服务器上的路径（服务器也是一台电脑），也被称为路由；当然路由时一种抽象的路径</li>
<li><code>?key1=value1&amp;key2=value2</code>传输的参数，这种一般是 query 或者 parmas 参数</li>
<li><code>#SomewhereInTheDocument</code> 是资源本身的另一部分的锚点. 锚点表示资源中的一种“书签”，给浏览器显示位于该“加书签”位置的内容的方向。</li>
</ol>
<p>上面给出的 URL 是<strong>绝对 URL</strong>，因访问服务器没有上下文，所以要用绝对路径访问</p>
<h3 id="URL-的编码"><a href="#URL-的编码" class="headerlink" title="URL 的编码"></a>URL 的编码</h3><p>URI 只能使用<code>ASCII</code>，其他编码方式不支持。因此可以直接表示在 URL 上的被称为“元字符”，也就是<code>ASCII</code>码中的全部字符。<br>其他编码的字符需要被转码，方式是将所有非 <code>ASCII</code> 码字符和界定符转为十六进制字节值，然后在前面加个%<br>详见 <a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2010/02/url_encoding.html">https://www.ruanyifeng.com/blog/2010/02/url_encoding.html</a></p>
<h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>域名需要从右到左阅读。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.google.com</span><br></pre></td></tr></table></figure>

<ol>
<li><code>.com</code>是顶级域名, 除了.com 之外还有一些顶级域名都有要求</li>
</ol>
<ul>
<li>地区的顶级域名，如.us，.fr，或.cn，可以要求必须提供给定语言的服务器或者托管在指定国家。</li>
<li>包含.gov 的顶级域名只能被政府部门使用。</li>
<li>.edu 只能为教育或研究机构使用。</li>
</ul>
<blockquote>
<p>注: 域名用<code>.</code>分割,从右向左分别为顶级,二级,三级以及更后,上不设限,所以比如<code>www.a.b.c.d.e.f.com</code>,这里的 abcdef 都是不同级别的域名,每一级的域名控制它下一级域名的分配。每个域名内部是标签,标签在下面解释;</p>
</blockquote>
<ol start="2">
<li><code>google</code>是标签, 标签由 1 到 63 个大小写不敏感的字符组成，这些字符包含字母 A-z，数字 0-9，还有<code>-</code>号.一般都是小写字母,但可以是大写,都是一样的;为了区分 I 和 l,一般把 L 大写</li>
<li><code>www</code>是主机名,这里就是万维网,或者还可以是<code>blog``sina</code>等等</li>
</ol>
<h2 id="MIME"><a href="#MIME" class="headerlink" title="MIME"></a>MIME</h2><p>MIME(Multipurpose Internet Mail Extensions, 多用途互联网邮件扩展)。它首先用在电子邮件系统中，让邮件可以发任意类型的数据，这对于 HTTP 来说也是通用的。</p>
<p>因此，HTTP 从 MIME type 取了一部分来标记报文 body 部分的数据类型，这些类型体现在<code>Content-Type</code>这个字段; 接收端想要收到特定类型的数据，也可以用<code>Accept</code>字段。</p>
<p>具体而言，这两个字段的取值可以分为下面几类:</p>
<ul>
<li>text： <code>text/html</code>, <code>text/plain</code>, <code>text/css</code> 等</li>
<li>image: <code>image/gif</code>, <code>image/jpeg</code>, <code>image/png</code> 等</li>
<li>audio/video: <code>audio/mpeg</code>, <code>video/mp4</code> 等</li>
<li>application: <code>application/json</code>, <code>application/javascript</code>, <code>application/pdf</code>, <code>application/octet-stream</code></li>
</ul>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p><strong>浏览器</strong>遵循同源策略，非同源站点有这样一些限制:</p>
<ul>
<li>不能读取和修改对方的 DOM</li>
<li>不读访问对方的 Cookie、IndexDB 和 LocalStorage</li>
<li>限制 XMLHttpRequest 请求，即请求可以发出，但是不能接收到响应。</li>
</ul>
<p>同源的条件：</p>
<ul>
<li>主机名相同</li>
<li>协议相同（http 和 https 不同）</li>
<li>端口相同</li>
</ul>
<p>因为不符合同源策略的 ajax 请求会被禁用，因此就要想办法解决同源策略带来的限制。解决的方法有如下几种：</p>
<ul>
<li>CORS：跨域资源共享</li>
<li>JSONP</li>
<li>nginx 反向代理</li>
<li>配置代理</li>
<li>nodejs 中间件</li>
</ul>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS 其实是 W3C 的一个标准，全称是<code>跨域资源共享</code>；它需要浏览器和服务器的共同支持。</p>
<h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>浏览器根据请求方法和请求头的特定字段，将请求做了一下分类，具体来说规则是这样，凡是满足下面条件的属于简单请求:</p>
<p><strong>简单请求</strong>的范围:</p>
<ol>
<li>请求方法是以下三种方法之一：</li>
</ol>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<ol start="2">
<li>HTTP 的头信息不超出以下几种字段：</li>
</ol>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：<ul>
<li>application/x-www-form-urlencoded</li>
<li>multipart/form-data</li>
<li>text/plain</li>
</ul>
</li>
</ul>
<p>浏览器画了这样一个圈，在这个圈里面的就是简单请求, 圈外面的就是非简单请求，然后针对这两种不同的请求进行不同的处理。</p>
<hr>
<p>对于简单请求，浏览器会在请求头加上<code>Origin</code>字段，用来说明请求来自于哪个<code>源</code>；<br>服务器拿到请求之后，会在响应头添加一些字段，主要有：</p>
<ul>
<li><code>Access-Control-Allow-Origin</code>：如果<code>Origin</code>不在这个字段的范围中，浏览器就会将响应拦截。<blockquote>
<p>Access-Control-Allow-Origin 字段设置为*有什么问题？<br>除了安全问题之外，还有一个问题是只要设置为*就不能发送 cookies，即使<code>Access-Control-Allow-Credentials</code>为 true 也不行。<br>如果需要发送，就必须指定明确的、与请求网页一致的域名。</p>
</blockquote>
</li>
<li><code>Access-Control-Allow-Credentials</code>：表示是否允许发送 Cookie<blockquote>
<p>这一项的属性只能为 true，否则就不添加这个字段</p>
</blockquote>
</li>
<li><code>Access-Control-Expose-Headers</code>：允许 xhr 可以拿到除了 6 个基本响应字段（<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>和<code>Pragma</code>）之外的其他字段。</li>
</ul>
<p>这其中最主要的是第一个字段；如果设置的 origin 中包含当前请求，就可以不受同源策略的限制；如果设置为<code>*</code>，相当于完全不受同源策略影响，任何源都可以访问。</p>
<h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>非简单请求和简单请求处理的不同主要体现在两方面：</p>
<ul>
<li>预检请求</li>
<li>响应字段</li>
</ul>
<p>非简单请求发送之前会先发送一个预检请求，方法固定是<code>options</code>；会加上 Origin 源地址和 Host 目标地址。同时也会加上两个关键的字段:</p>
<ul>
<li><code>Access-Control-Request-Method</code>， 列出 CORS 请求用到哪个 HTTP 方法</li>
<li><code>Access-Control-Request-Headers</code>，指定 CORS 请求将要加上什么请求头</li>
</ul>
<p>预检请求会像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS / HTTP/1.1</span><br><span class="line">Origin: 当前地址</span><br><span class="line">Host: xxx.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br></pre></td></tr></table></figure>

<p>随后响应字段也会有所不同；响应字段除了响应预检请求本身，还有对 CORS 的相关字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure>

<p>其中有这样几个关键的响应头字段:</p>
<ul>
<li><code>Access-Control-Allow-Origin</code>: 表示可以允许请求的源，可以填具体的源名，也可以填<code>*</code>表示允许任意源请求，和简单请求的该字段一样</li>
<li><code>Access-Control-Allow-Methods</code>: 表示允许的请求方法列表。</li>
<li><code>Access-Control-Allow-Credentials</code>: 同简单请求</li>
<li><code>Access-Control-Allow-Headers</code>: 表示允许发送的请求头字段</li>
<li><code>Access-Control-Max-Age</code>: 预检请求的有效期，在此期间，不用发出另外一条预检请求。</li>
</ul>
<p>在预检请求的响应返回后：</p>
<ul>
<li>如果请求不满足响应头的条件，则触发<code>XMLHttpRequest</code>的<code>onerror</code>，当然后面真正的 CORS 请求也不会发出去了。</li>
<li>如果满足条件，则会和简单请求一样，浏览器自动加上<code>Origin</code>字段，响应头返回<code>Access-Control-Allow-Origin</code>。</li>
</ul>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p><code>XMLHttpRequest</code> 对象遵循同源政策，但是<code>&lt;script&gt;</code>标签不一样，它可以通过 src 填上目标地址从而发出 GET 请求，实现跨域请求并拿到响应。这也就是 JSONP 的原理。<br>基本原理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.src = <span class="string">`http://example.com?callback=callback`</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br></pre></td></tr></table></figure>

<p>简单实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">&#123; url, params, callback &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">  script.src = <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;<span class="built_in">JSON</span>.stringfy(params)&#125;</span>`</span>; <span class="comment">// 这一步封装url还有更详细的操作，这里只是简单表示</span></span><br><span class="line">  <span class="comment">// 为了避免全局污染，使用一个随机函数名</span></span><br><span class="line">  <span class="keyword">const</span> cbFnName = <span class="string">`JSONP_PADDING_<span class="subst">$&#123;<span class="built_in">Math</span>.random().toString().slice(<span class="number">2</span>)&#125;</span>`</span>;</span><br><span class="line">  <span class="built_in">window</span>[cbFnName] = callback; <span class="comment">// 把回调插入window上，这里也可以直接定义一个全局函数</span></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonp(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;http://localhost:8080&quot;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123; <span class="attr">id</span>: <span class="number">10000</span> &#125;,</span><br><span class="line">  <span class="function"><span class="title">callback</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Data:&quot;</span>, data);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Promise 实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*封装jsonp*/</span></span><br><span class="line"><span class="keyword">const</span> jsonp = <span class="function">(<span class="params">&#123; url, params, callbackName &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//把params封装到url中</span></span><br><span class="line">  <span class="keyword">const</span> generateURL = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> dataStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">      dataStr += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>&amp;`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dataStr += <span class="string">`callback=<span class="subst">$&#123;callbackName&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;dataStr&#125;</span>`</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化回调函数名称</span></span><br><span class="line">    callbackName = callbackName || <span class="built_in">Math</span>.random().toString.replace(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建 script 元素并加入到当前文档中</span></span><br><span class="line">    <span class="keyword">let</span> scriptEle = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">    scriptEle.src = generateURL();</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(scriptEle);</span><br><span class="line">    <span class="comment">// 绑定到 window 上，为了后面调用</span></span><br><span class="line">    <span class="built_in">window</span>[callbackName] = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(data);</span><br><span class="line">      <span class="comment">// script 执行完了，成为无用元素，需要清除</span></span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(scriptEle);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用*/</span></span><br><span class="line">jsonp(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;http://localhost:3000&quot;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 拿到数据进行处理</span></span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// 数据包</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*服务端*/</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line">app.get(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; a, b, callback &#125; = req.query;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br><span class="line">  <span class="comment">// 注意，返回给script标签，浏览器直接把这部分字符串执行；因此就相当于执行了一个全局定义的callback</span></span><br><span class="line">  res.end(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(&#x27;数据包&#x27;)`</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到，JSONP 最大的优势在于兼容性好缺点也很明显，请求方法单一，只支持 GET 请求。</p>
<hr>
<p>还有一种方法是显式添加<code>&lt;script&gt;</code>标签，然后通过回调的方式取出 script 中的数据：</p>
<p>把要获取的数据封装成一个 js 文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//weather.js</span></span><br><span class="line">showWeather(</span><br><span class="line">  <span class="built_in">JSON</span>.parse(&#123;</span><br><span class="line">    <span class="attr">weather</span>: <span class="string">&quot;sunny&quot;</span>,</span><br><span class="line">    <span class="attr">time</span>: <span class="string">&quot;2021-12-03 16:30&quot;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>然后在 js 中的 script 标签获取</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/api/weather.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">showWeather</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(data);</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Nginx-反向代理"><a href="#Nginx-反向代理" class="headerlink" title="Nginx 反向代理"></a>Nginx 反向代理</h3><p><img src="https://pic.imgdb.cn/item/6234574f5baa1a80ab235752.jpg"></p>
<ul>
<li>正向代理帮助客户端访问客户端自己访问不到的服务器，然后将结果返回给客户端。</li>
<li>反向代理拿到客户端的请求，将请求转发给其他的服务器，主要的场景是维持服务器集群的负载均衡，换句话说，反向代理帮其它的服务器拿到请求，然后选择一个合适的服务器，将请求转交给它。</li>
</ul>
<p>因此正向代理服务器是帮<strong>客户端</strong>做事情，而反向代理服务器是帮<strong>其它的服务器</strong>做事情。</p>
<p>Nginx 的配置原理很像一般脚手架提供的配置方法，即利用<strong>服务器之间没有同源限制</strong>，把代理服务器设置在和客户端同源的路由下，然后转发请求到服务器；收到响应后再转发回客户端。<br>比如这样的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen  80;</span><br><span class="line">  server_name  client.com;</span><br><span class="line">  location /api &#123;</span><br><span class="line">    proxy_pass server.com;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Nginx 相当于起了一个跳板机，这个跳板机的域名也是<code>client.com</code>，让客户端首先访问 <code>client.com/api</code>，这当然没有跨域，然后 Nginx 服务器作为反向代理，将请求转发给<code>server.com</code>，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程。</p>
<h3 id="http-proxy-middleware"><a href="#http-proxy-middleware" class="headerlink" title="http-proxy-middleware"></a>http-proxy-middleware</h3><p>http-proxy-middleware 解决跨域的方案，是通过本地起了一个 node 代理服务器（<code>var httpProxy = require(&#39;http-proxy&#39;)</code>），通过代理服务器去请求目标服务器，然后返回请求结果。由于浏览器请求的是本地路径，所以不会有跨域问题。</p>
<p>这个中间件的使用有两个方式，一是在 nodejs 服务端设定该代理服务器，然后作为中间件的形式使用；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中间代理服务器</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">&quot;http-proxy-middleware&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(</span><br><span class="line">  <span class="string">&quot;/&quot;</span>,</span><br><span class="line">  proxy(&#123;</span><br><span class="line">    <span class="comment">// 代理跨域目标接口</span></span><br><span class="line">    <span class="attr">target</span>: <span class="string">&quot;http://www.proxy2.com:8080&quot;</span>,</span><br><span class="line">    <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 修改响应头信息，实现跨域并允许带 cookie</span></span><br><span class="line">    <span class="attr">onProxyRes</span>: <span class="function"><span class="keyword">function</span> (<span class="params">proxyRes, req, res</span>) </span>&#123;</span><br><span class="line">      res.header(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;http://localhost&quot;</span>);</span><br><span class="line">      res.header(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 修改响应信息中的 cookie 域名</span></span><br><span class="line">    <span class="attr">cookieDomainRewrite</span>: <span class="string">&quot;localhost&quot;</span>, <span class="comment">// 可以为 false，表示不修改</span></span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>还有一种形式是利用 webpack 的 devServer 配置项，在其中引入该代理服务器的配置。webpack 会把这个中间件用在配置本地启动的服务器上：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&quot;/api&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&quot;http://localhost:3000&quot;</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123; <span class="string">&quot;^/api&quot;</span>: <span class="string">&quot;&quot;</span> &#125;,</span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p><img src="https://pic.imgdb.cn/item/623464365baa1a80ab2d7eee.png"></p>
<ul>
<li>应用层 (application layer)：直接为应用进程提供服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如 HTTP 协议（万维网服务）、FTP 协议（文件传输）、SMTP 协议（电子邮件）、DNS（域名查询）等。<ul>
<li>表示层：用于解决两个系统间交换信息的语法与语义问题，还有数据表示转化(转为主机无关编码)，加解密和压缩与解压缩功能。</li>
<li>会话层：用于建立会话 SSL 等</li>
</ul>
</li>
<li>传输层 (transport layer)：有时也译为运输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议：<ul>
<li>传输控制协议 (Transmission Control Protocol，TCP)：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）；</li>
<li>用户数据报协议 (User Datagram Protocol，UDP)：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。</li>
</ul>
</li>
<li>网络层 (internet layer)：有时也译为网际层，它负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。</li>
<li>数据链路层 (data link layer)：负责将网络层交下来的 IP 数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息（如同步信息、地址信息、差错控制等）。</li>
<li>物理层 (physical Layer)：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/623464f65baa1a80ab2dcd4e.jpg"></p>
<h2 id="鉴权校验相关"><a href="#鉴权校验相关" class="headerlink" title="鉴权校验相关"></a>鉴权校验相关</h2><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><blockquote>
<p>有关于 session/token/JWT 的更多解释可以看这里：<a target="_blank" rel="noopener" href="https://mubu.com/doc/12i79Sq9hmP">https://mubu.com/doc/12i79Sq9hmP</a></p>
</blockquote>
<p><img src="https://pic.imgdb.cn/item/61e92b252ab3f51d915b1405.png"><br>是另一种 cookie，同时依赖于 cookie，但是存储在服务端，sessionId 会被存储到客户端的 cookie 中</p>
<ul>
<li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session</li>
<li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器</li>
<li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名</li>
<li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li>
</ul>
<blockquote>
<p>session 和 cookie 有什么区别:<br>cookie 是 Web 服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个 Web 服务器存储 cookie。以后浏览器在给特定的 Web 服务器发请求的时候，同时会发送所有为该服务器存储的 cookie。下面列出了 session 和 cookie 的区别：<br>无论客户端浏览器做怎么样的设置，session 都应该能正常工作。客户端可以选择禁用 cookie，但是，session 仍然是能够工作的，因为客户端无法禁用服务端的 session。<br>在存储的数据量方面 session 和 cookies 也是不一样的。session 能够存储任意的 Java 对象，cookie 只能存储 String 类型的对象。</p>
</blockquote>
<h3 id="Token（令牌）"><a href="#Token（令牌）" class="headerlink" title="Token（令牌）"></a>Token（令牌）</h3><h4 id="Access-Token"><a href="#Access-Token" class="headerlink" title="Access Token"></a>Access Token</h4><p>访问资源接口（API）时所需要的资源凭证，相当于展示证件才能进入或访问的过程<br>简单 token 的组成： uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）<br><img src="https://i.loli.net/2021/12/02/EKhFUQzAP3vcjxa.png" alt="accesstoken.png"></p>
<ul>
<li>客户端每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里</li>
<li>token 完全由应用管理，所以它可以避开同源策略</li>
<li>客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里</li>
</ul>
<h4 id="Refresh-Token"><a href="#Refresh-Token" class="headerlink" title="Refresh Token"></a>Refresh Token</h4><p>是一种延长 accesstoken 的方法，主要解决方法是：</p>
<ul>
<li>如果 accesstoken 没过期，就正常使用</li>
<li>如果 accesstoken 过期，但 Refresh Token 没过期，就可以获取到新的 Token</li>
<li>如果都过期就需要重新登录</li>
<li>Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证</li>
</ul>
<h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>JSON Web Token（简称 JWT）是目前最流行的<strong>跨域认证</strong>解决方案。是一种认证授权机制。<br>session 是保存在服务端的，而 jwt 是保存在客户端的。<br>原理图：<br><img src="https://i.loli.net/2021/12/02/chSBlOHZ9dDIQiJ.png" alt="JWT.png"><br>使用方式：</p>
<ul>
<li>跨域的时候，可以把 JWT 放在 POST 请求的数据体里。</li>
<li>通过 URL 传输，比如<code>http://www.example.com/user?token=xxx</code></li>
<li>放在 HTTP 请求头信息的 Authorization 字段里</li>
</ul>
<p>缺点：</p>
<ol>
<li>安全性不好，因为 jwt 是明文传输的，并且经常需要从客户端发向服务端，不安全</li>
<li>性能不佳，数据增大后经过编码之后导致 jwt 非常长。</li>
</ol>
<h3 id="OAuth"><a href="#OAuth" class="headerlink" title="OAuth"></a>OAuth</h3><p>OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。OAuth 在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。<br><img src="https://obohe.com/i/2021/12/03/sf3lt0.png"><br>流程如下:</p>
<ol>
<li>用户打开客户端以后，客户端要求用户给予授权。</li>
<li>用户同意给予客户端授权。</li>
<li>客户端使用上一步获得的授权，向认证服务器申请令牌。</li>
<li>认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</li>
<li>客户端使用令牌，向资源服务器申请获取资源。</li>
<li>资源服务器确认令牌无误，同意向客户端开放资源。</li>
</ol>
<h3 id="SSO"><a href="#SSO" class="headerlink" title="SSO"></a>SSO</h3><p>SSO(单点登录)指的是在多个应用系统中，只需登录一次，就可以访问其他相互信任的应用系统。<br>详细可以看这篇文章<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/35165725">https://www.zhihu.com/question/35165725</a></p>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>应用层的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。应用层协议是应用到应用的协议，相应的，传输层是进程到进程，网络层是主机到主机。<br>应用层主要协议：</p>
<ul>
<li>HTTP</li>
<li>SMTP</li>
<li>FTP</li>
<li>DNS，但是 DNS 更像是一个应用，服务于上面的协议。</li>
</ul>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>应用层的模型主要有两个：</p>
<ol>
<li>C/S 模型，即客户端/服务器模型；服务器总是启动，等待客户端的请求连接并发回响应。Web 和电子邮件都是这种</li>
<li>P2P 模式，每一个主机既是客户端又是服务器，资源在主机间交换。</li>
</ol>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h3><p>超文本传输协议（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。</p>
<ul>
<li>HTTP 基于 TCP，要建立 HTTP 连接的进程需要通过 TCP 传输，因此是可靠数据传输，并且拥有拥塞控制等优化手段。</li>
<li>HTTP 是无状态的协议，单靠 HTTP 的话，并不会记录之前的传输，如果再次请求将会再次发送（可以通过 HTTP 缓存解决）；同时也不会存储关于用户的任何信息</li>
<li>HTTP 客户端进程默认位于 80 端口</li>
<li>请求–应答方式，一发一收连接</li>
<li>灵活可扩展，传输数据自由不限制，并且语义比较自由</li>
</ul>
<h3 id="持续和非持续连接"><a href="#持续和非持续连接" class="headerlink" title="持续和非持续连接"></a>持续和非持续连接</h3><p>HTTP 默认采用持续连接，即客户端和服务器建立 TCP 连接后，会一直使用这条连接进行数据交互，直到没有数据传输或异常断开。在空闲期间，通常会使用<code>心跳数据包（Keep-Alive）</code>保持链路不断开。如果这条链接一段时间未使用，服务器就会关闭连接。在持续链接持续期间，不再需要额外的 TCP 握手、挥手，只需要进行数据传输；</p>
<p>可以采用非持续连接，每一次发送都需要建立和断开连接，具体步骤如下：</p>
<ol>
<li>HTTP 客户端在 80 端口向服务器发起一个 TCP 连接</li>
<li>三次握手连接建立后，通过 socket 向服务器发送 HTTP 请求报文</li>
<li>服务器接受报文，返回响应报文</li>
<li>服务器通知 TCP 断开连接</li>
<li>客户端收到响应报文，TCP 经过四次挥手关闭连接。</li>
</ol>
<p>持续链接实际上就是对第 3 步的扩充</p>
<h3 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP1.1</span><br><span class="line">Host:www.wrox.com</span><br><span class="line">User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)</span><br><span class="line">Content-Type:application/x-www-form-urlencoded</span><br><span class="line">Content-Length:40</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line">name=Professional%20Ajax&amp;publisher=Wiley</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/12/02/geW1ol4FckqY7ty.png" alt="request.png"></p>
<p>报文的第一行叫做请求行，后续叫做首部行（请求头）</p>
<ol>
<li>请求行，用来说明请求类型,要访问的资源以及所使用的 HTTP 版本。GET 说明请求类型为 GET,<code>/562f25980001b1b106000338.jpg</code>为要访问的资源，或者也可以是路由；最后一部分说明使用的是 HTTP1.1 版本。</li>
<li>请求头部（首部行），紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。</li>
<li>空行，请求头部后面的空行是必须的；即使第四部分的请求数据为空，也必须有空行。</li>
<li>请求数据，也叫实体体，可以添加任意的其他数据，GET 请求没有这部分。</li>
</ol>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Fri, 22 May 2009 06:07:21 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">      &lt;head&gt;&lt;/head&gt;</span><br><span class="line">      &lt;body&gt;</span><br><span class="line">            &lt;!--body goes here--&gt;</span><br><span class="line">      &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>状态行，由 HTTP 协议版本号、状态码、状态消息三部分组成。第一行为状态行，<code>HTTP/1.1</code>表明 HTTP 版本为 1.1 版本，状态码为 200，状态消息为（ok）</li>
<li>消息报头（首部行/响应头），用来说明客户端要使用的一些附加信息</li>
<li>空行，消息报头后面的空行是必须的</li>
<li>响应正文（实体体），服务器返回给客户端的文本信息。空行后面的 html 部分为响应正文。</li>
</ol>
<h3 id="HTTP-字段"><a href="#HTTP-字段" class="headerlink" title="HTTP 字段"></a>HTTP 字段</h3><p>http1.1 的字段主要有 47 个，按照分类主要有 4 类：</p>
<ol>
<li>通用首部字段，常见的有：</li>
</ol>
<ul>
<li><code>Connection</code> 连接管理、逐条首部</li>
<li><code>Upgrade</code> 升级为其他协议</li>
<li><code>Cache-Control</code> 缓存控制，即代替<code>Expires</code>字段的缓存控制字段</li>
</ul>
<ol start="2">
<li>请求首部字段，包括 Accept 系列字段，以及<code>User-Agent</code> 客户端程序信息等请求相关的字段</li>
<li>响应首部字段，响应时相关字段</li>
<li>实体首部字段，主要是 Content 相关字段，主要规定实体特征。实体首部字段在请求和响应中都可能有，只和请求体相关；如果请求没有请求体（GET/HEAD），则不会携带该字段</li>
</ol>
<p>HTTP 头会按照<code>请求/响应 - 通用 - 实体</code>顺序分别安排四种首部</p>
<p>全部字段见：<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903748196646920">https://juejin.cn/post/6844903748196646920</a></p>
<p>每个字段的用处，可以参考《图解 HTTP》</p>
<h4 id="HTTP-Request-Header-常见的请求头"><a href="#HTTP-Request-Header-常见的请求头" class="headerlink" title="HTTP Request Header 常见的请求头"></a><code>HTTP Request Header</code> 常见的请求头</h4><ul>
<li><code>Accept</code>:浏览器能够处理的内容类型，即 MIME type</li>
<li><code>Accept-Charset</code>:浏览器能够显示的字符集，优先选择该字符集发送</li>
<li><code>Accept-Encoding</code>：浏览器能够处理的压缩编码<ul>
<li>gzip: 当今最流行的压缩格式</li>
<li>deflate: 另外一种著名的压缩格式</li>
<li>br: 一种专门为 HTTP 发明的压缩算法</li>
</ul>
</li>
<li><code>Accept-Language</code>：浏览器当前设置的语言</li>
</ul>
<p>Accept 字段通常表示一种“优先选择”，即浏览器希望服务器发送一个希望的类型，并不是直接对发送的指示和标识。</p>
<ul>
<li><code>Authorization</code>: Web 认证信息，通常用于携带 jwt、token 等认证信息。</li>
<li><code>Connection</code>：浏览器与服务器之间连接的类型</li>
<li><code>Cookie</code>：当前页面设置的任何 Cookie</li>
<li><code>Host</code>：发出请求的页面所在的域</li>
<li><code>Referer</code>：发出请求的页面的 URL</li>
<li><code>User-Agent</code>：浏览器的用户代理字符串</li>
</ul>
<h4 id="HTTP-Responses-Header-常见的响应头"><a href="#HTTP-Responses-Header-常见的响应头" class="headerlink" title="HTTP Responses Header 常见的响应头"></a><code>HTTP Responses Header</code> 常见的响应头</h4><ul>
<li><code>Date</code>：表示消息发送的时间，时间的描述格式由 rfc822 定义</li>
<li><code>Server</code>:服务器名称</li>
<li><code>Connection</code>：浏览器与服务器之间连接的类型</li>
<li><code>Cache-Control</code>：控制 HTTP 缓存</li>
</ul>
<h4 id="常见的实体首部"><a href="#常见的实体首部" class="headerlink" title="常见的实体首部"></a>常见的实体首部</h4><ul>
<li><code>Content-Encoding</code> 实体主体适用的编码方式</li>
<li><code>Content-Language</code> 实体主体的自然语言</li>
<li><code>Content-Length</code> 实体主体的大小。一般用于设置定长包体的长度，实际请求体大于长度将会被截取，小于则会报错；</li>
<li><code>Content-Location</code> 替代对应资源的 URI</li>
<li><code>Content-MD5</code>实体主体的报文摘要</li>
<li><code>Content-Range</code> 实体主体的位置范围</li>
<li><code>Content-Type</code> 实体主体的媒体类型</li>
<li><code>Expires</code> 实体主体过期的日期时间</li>
<li><code>Last-Modified</code> 资源的最后修改日期时间</li>
</ul>
<p>常见的 <code>Content-Type</code> 属性值有以下四种：</p>
<ol>
<li><code>application/x-www-form-urlencoded</code>：浏览器的原生 <code>form</code> 表单，如果不设置 <code>enctype</code> 属性，那么最终就会以 <code>application/x-www-form-urlencoded </code>方式提交数据。该种方式提交的数据放在 body 里面，数据按照 <code>key1=val1&amp;key2=val2</code> 的方式进行编码，key 和 val 都进行了 URL 转码。</li>
<li><code>multipart/form-data</code>：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。</li>
<li><code>application/json</code>：服务器消息主体是序列化后的 JSON 字符串。</li>
<li><code>text/xml</code>：该种方式主要用来提交 XML 格式的数据。</li>
</ol>
<h3 id="HTTP-请求方法"><a href="#HTTP-请求方法" class="headerlink" title="HTTP 请求方法"></a>HTTP 请求方法</h3><ul>
<li><code>GET</code> <strong>请求</strong>指定的页面信息，并返回实体主体。</li>
<li><code>HEAD</code> 类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取<strong>报头</strong></li>
<li><code>POST</code> 向指定资源<strong>提交</strong>数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</li>
<li><code>PUT</code> 从客户端向服务器传送的数据<strong>取代</strong>指定的文档的内容。</li>
<li><code>DELETE</code> <strong>删除</strong></li>
<li><code>CONNECT</code> <strong>连接</strong>，比如 websocket 的最开始的请求方法就是 connect</li>
<li><code>OPTIONS</code> 用于<strong>检测</strong>服务器允许的 http 方法，一般是浏览器进行预检的时候自动发送的，跨域之前非简单请求就需要先发 options 获知服务端是否允许跨域</li>
<li><code>TRACE</code> 回显服务器收到的请求，主要用于<strong>测试</strong>或诊断。</li>
</ul>
<p>方法分类:</p>
<ul>
<li><code>Safe</code>:一定不会修改服务器上资源的请求，get、head、options</li>
<li><code>Idempotent</code>：幂等，除安全以外的请求，<strong>一个请求被执行一次和执行多次服务器状态一样，效果一样</strong></li>
</ul>
<h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><ul>
<li>1xx：指示信息–表示请求已接收，继续处理<ul>
<li>100：继续 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</li>
<li>101：切换协议 请求者已要求服务器切换协议，服务器已确认并准备切换.HTTP 升级为 WebSocket 的时候，如果服务器同意变更，就会发送状态码 101。</li>
</ul>
</li>
<li>2xx：成功–表示请求已被成功接收、理解、接受<ul>
<li>204：成功但没有 body</li>
</ul>
</li>
<li>3xx：重定向–要完成请求必须进行更进一步的操作；<ul>
<li>301：所请求的页面已经永久重定向至新的 URL</li>
<li>302：所请求的页面已经临时重定向至新的 URL</li>
<li>303：查看其它位置 表示对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。</li>
<li>304：缓存相关，表示资源未更改可以使用缓存</li>
<li>305：必须通过指定的代理才能访问</li>
</ul>
</li>
<li>4xx：客户端错误–请求有语法错误或请求无法实现<ul>
<li>400：Bad Request 请求错误，通常是域名未解析到正确的 IP，或解析后，服务器端未绑定此域名导致。</li>
<li>401：未授权 请求要求身份验证。对于需要登录的网页，服务器可能返回此响应</li>
<li>403：禁止 服务器拒绝请求</li>
<li>404：未找到 服务器找不到请求的网页</li>
<li>405：方法禁用 禁用请求中指定的方法</li>
<li>406 Not Acceptable: 资源无法满足客户端的条件。</li>
<li>408 Request Timeout: 服务器等待了太长时间。</li>
<li>409 Conflict: 多个请求发生了冲突。</li>
<li>413 Request Entity Too Large: 请求体的数据过大。</li>
<li>414 Request-URI Too Long: 请求行里的 URI 太大。</li>
<li>429 Too Many Request: 客户端发送的请求过多。</li>
<li>431 Request Header Fields Too Large 请求头的字段内容太大。</li>
</ul>
</li>
<li>5xx：服务器端错误–服务器未能实现合法的请求<ul>
<li>500：服务器内部错误 服务器遇到错误，无法完成请求</li>
<li>501：尚未实施 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码</li>
<li>502：错误网关 通常是服务器脚本语言端未启动或无响应，以及反向代理端无响应。一般表现为你自己写的应用层服务(Java/Go/PHP)挂了，网关层无法接收到响应</li>
<li>503：服务器不可用 服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态</li>
<li>504：超时 一般表现为应用层服务 (upstream) 超时</li>
<li>505：HTTP 版本不受支持 服务器不支持请求中所用的 HTTP 协议版本</li>
</ul>
</li>
</ul>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>cookie 的详细解释可以看这篇文章:<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904073934667790">https://juejin.cn/post/6844904073934667790</a></p>
<blockquote>
<p>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p>
</blockquote>
<p>因此 cookie 的主要工作方式是:在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</p>
<ul>
<li>创建方式</li>
</ul>
<p>服务器在响应头里添加<code>Set-Cookie</code>选项,比如这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br></pre></td></tr></table></figure>

<p>js 也可以直接通过<code>document.cookie</code>来读写 cookie</p>
<ul>
<li>cookie 属性<ul>
<li>名称:表示该 cookie 的名字,一般常用<code>_</code>开头表示一些身份信息或 id 等</li>
<li>值: 就是 cookie 的值,可以是任意字符</li>
<li>Domain: 限制访问域名,不设置就是都可以访问</li>
<li>Path: 主机下哪些路径可以访问,比如登录路径访问,就可以设置为<code>/login</code></li>
<li>SameSite:用于判断跨站时是否发送 cookie</li>
<li>Expires/Max-Age: 生命周期,定义 Cookie 的有效时间</li>
<li>HttpOnly:为避免跨域脚本 (XSS) 攻击，通过 JavaScript 的 Document.cookie API 无法访问带有 HttpOnly 标记的 Cookie，它们只应该发送给服务端。</li>
<li>Secure: 标记时只能通过 https 发给服务端</li>
</ul>
</li>
</ul>
<blockquote>
<p>cookie遵循同源，但是cookie的同源和CORS的同源不一样<br>cookie的”同源策略”只关注<strong>域名</strong>，也就是domain属性。</p>
</blockquote>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p><img src="https://pic.imgdb.cn/item/623400465baa1a80abe10fb0.jpg"></p>
<ul>
<li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 <code>TCP</code> 和 <code>HTTP</code> 应用层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。实际上 ssl 在应用层和传输层之间，更偏向属于应用层。</li>
<li>HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li>
<li>HTTPS 的端口号是 443。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ul>
<p><img src="https://i.loli.net/2021/12/02/Wlm3TKsZYBtc67H.png" alt="https.jpg"></p>
<h4 id="https-的安全依据"><a href="#https-的安全依据" class="headerlink" title="https 的安全依据"></a>https 的安全依据</h4><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021494676">https://segmentfault.com/a/1190000021494676</a></p>
<ol>
<li>对称和非对称混合加密（对称：加密和解密用的同一套密钥，非对称就是不同套密钥）</li>
</ol>
<blockquote>
<p>对称加密，顾名思义就是加密和解密都是使用同一个密钥，常见的对称加密算法有 DES、3DES 和 AES 等，其优缺点如下：<br>优点：算法公开、计算量小、加密速度快、加密效率高，适合加密比较大的数据。<br>缺点：<br>交易双方需要使用相同的密钥，也就无法避免密钥的传输，而密钥在传输过程中无法保证不被截获，因此对称加密的安全性得不到保证。每对用户每次使用对称加密算法时，都需要使用其他人不知道的惟一密钥，这会使得发收信双方所拥有的钥匙数量急剧增长，密钥管理成为双方的负担。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。</p>
</blockquote>
<blockquote>
<p>非对称加密，顾名思义，就是加密和解密需要使用两个不同的密钥：公钥（public key）和私钥（private key）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密；如果用私钥对数据进行加密，那么只有用对应的公钥才能解密。非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公钥对外公开；得到该公钥的乙方使用公钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的私钥对加密后的信息进行解密。<br><img src="https://pic.imgdb.cn/item/623413cf5baa1a80abeee528.png"></p>
</blockquote>
<ol start="2">
<li>摘要算法，简单来说就是客户端发送明文数据之前会通过摘要算法算出明文的“指纹”，然后服务器需要进行比较客户端携带的和自己存储的，如果一致就是安全的</li>
<li>数字证书</li>
</ol>
<ul>
<li>客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密</li>
<li>借助第三方权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</li>
</ul>
<h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p>概述：<br><img src="https://pic.imgdb.cn/item/623415d65baa1a80abf041be.jpg"></p>
<p>具体参数传递：<br><img src="https://pic.imgdb.cn/item/627b9fda0947543129f65d89.jpg"></p>
<ol>
<li><p>客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口，类似于 HTTP 的 80 端口)。客户端发送请求时会带上自己的一个随机码<code>client_random</code>以及 TLS 版本</p>
</li>
<li><p>采用 HTTPS 协议的服务器必须要有一套数字 CA (Certification Authority)证书，证书是需要申请的，并由专门的数字证书认证机构(CA)通过非常严格的审核之后颁发的电子证书。颁发证书的同时会产生一个<code>私钥</code>和<code>公钥</code>。<code>私钥</code>由服务端自己保存，不可泄漏。<code>公钥</code>则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。</p>
</li>
<li><p>服务器响应客户端请求，将证书传递给客户端，同时还会发送一个客户端生成的随机码<code>server_random</code>和<code>server_params</code>.</p>
</li>
<li><p>客户端解析证书并对其进行验证。如果证书没有问题，客户端就会从服务器证书中取出服务器的<code>公钥</code>。然后客户端还会再生成一个随机码<code>client_params</code>，将其用公钥加密后传输给服务端；然后用之前的<code>server_params</code>和自己的<code>client_params</code>一起生成一个<code>pre_random</code>，将这三个数通过一个伪随机数函数来计算出最终的 secret。</p>
</li>
<li><p>服务器在收到随机码 <code>client_params</code> 之后会使用<code>私钥</code>将其解密。这时服务端已经拥有了<code>client_params</code>和自己生成的<code>server_params</code>，服务端也类似的生成<code>pre_random</code>，接着用和客户端同样的伪随机数函数生成最后的 secret。</p>
</li>
<li><p>双方使用 secret 传输所有数据。</p>
</li>
</ol>
<blockquote>
<p>客户端只拥有公钥，服务端还额外拥有一个私钥，用于解密客户端用公钥加密后的数据。</p>
</blockquote>
<h4 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h4><p>SSL 和 TLS 协议可以为通信双方提供识别和认证通道，从而保证通信的机密性和数据完整性。TLS 协议是从 SSL 协议演变而来的，不过这两种协议并不兼容，SSL 已经逐渐被 TLS 取代，所以下文就以 TLS 指代安全层。<br>TLS 握手是启动 HTTPS 通信的过程，类似于 TCP 建立连接时的三次握手。 在 TLS 握手的过程中，通信双方交换消息以相互验证，相互确认，并确立它们所要使用的加密算法以及会话密钥 (用于对称加密的密钥)。可以说，TLS 握手是 HTTPS 通信的基础部分。</p>
<p>TLS 握手的主要过程其实就是 HTTPS 建立连接的基本流程，主要工作有：</p>
<ul>
<li>商定双方通信所使用的的 TLS 版本 (例如 TLS1.0, 1.2, 1.3 等等)；</li>
<li>确定双方所要使用的密码组合；</li>
<li>客户端通过服务器的公钥和数字证书 (上篇文章已有介绍)上的数字签名验证服务端的身份；</li>
<li>生成会话密钥，该密钥将用于握手结束后的对称加密。</li>
</ul>
<h3 id="HTTP1-1-HTTP2-0"><a href="#HTTP1-1-HTTP2-0" class="headerlink" title="HTTP1.1 HTTP2.0"></a>HTTP1.1 HTTP2.0</h3><h4 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h4><p>HTTP 1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求，类似于之前说过的非持续连接的 HTTP 请求。</p>
<p>http1.0 最大的两个问题是</p>
<ul>
<li>连接无法复用，会导致每次请求都经历三次握手和慢启动，即使带宽很大、文件很小，依然要耗费不少时间；</li>
<li>head of line blocking（队头阻塞）：致带宽无法被充分利用，以及后续健康请求被阻塞。</li>
</ul>
<blockquote>
<p>队头阻塞：<br>请求在客户端会形成队列，由于每次只能发送一个报文，并且在接受响应之前不会再次发送，因此队列里排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。</p>
</blockquote>
<h4 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h4><p>HTTP 1.1 支持持久连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。HTTP1.1 请求头中的<code>Connection</code>就是规定如何长连接的。<br>HTTP 1.1 通过增加更多的请求头和响应头来改进和扩充 HTTP 1.0 的功能。</p>
<p>HTTP1.1 和 HTTP1.0 主要区别有：</p>
<ul>
<li><p><strong>长连接</strong>，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。</p>
</li>
<li><p><strong>并发连接</strong>：允许客户端和服务端建立多个并发连接（Chrome 中是 6 个），减少队头阻塞。并发连接是建立多个 HTTP 连接，在每个连接上仍然一发一收进行，和 http2 的多路复用不一样。</p>
</li>
<li><p><strong>支持请求部分资源和断点续传</strong>，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 Range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>
</li>
<li><p><strong>缓存控制头增加</strong>，在 http1.0 中主要使用 header 里的 <code>If-Modified-Since</code>、<code>Expires</code> 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如<code>Etag</code>、<code>If-Unmodified-Since</code>、<code>If-Match</code>、<code>If-None-Match</code> 等更多可供选择的缓存头来控制缓存策略。</p>
</li>
<li><p><strong>HOST 字段的添加</strong>：http1.1 中新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。</p>
</li>
<li><p><strong>新增几个请求方法</strong>：http1.1 相对于 http1.0 还新增了很多请求方法，如 PUT、HEAD、OPTIONS 等。</p>
</li>
</ul>
<h4 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h4><p><img src="https://pic.imgdb.cn/item/627ba1480947543129fa0dc1.jpg"></p>
<p>HTTP2.0 相对于 HTTP1.1 的变化：</p>
<ul>
<li><strong>永久连接</strong>，没有 1.1 中的 keep-alive</li>
<li><strong>二进制协议</strong>：HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式；二进制是整个报文都是二进制，包括头部和实体，统称为”帧”</li>
<li><strong>多路复用</strong>：在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送</li>
<li><strong>优先级机制</strong>：每个请求都可以带一个优先值，0 表示最高优先级， 数值越大优先级越低，这样可以自行选择处理帧的方式。优先级和多路复用都解决了 HTTP 的老问题“<code>队头阻塞</code>”</li>
<li><strong>服务器推送 Server Push</strong>：服务器可以主动向用户<strong>推送</strong> js、css，而不是只能拿通过解析 html 获得<blockquote>
<p>server push 和 websocket 的区别：</p>
<ul>
<li>HTTP2 Server Push，一般用以服务器根据解析 index.html 同时推送 图片/JS/CSS 等资源，而免了服务器发送多次请求</li>
<li>websocket，用以服务器与客户端手动编写代码去推送进行数据通信</li>
</ul>
</blockquote>
</li>
<li><strong>头部压缩</strong>：<ul>
<li>头信息使用 gzip 或 compress 压缩后再发送</li>
<li>客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号。</li>
</ul>
</li>
</ul>
<blockquote>
<p>多路复用：<br>在 HTTP/1 中，每次请求都会建立一次 HTTP 连接，也就是我们常说的 3 次握手 4 次挥手，这个过程在一次请求过程中占用了相当长的时间，即使开启了 Keep-Alive ，解决了多次连接的问题，但是依然有两个效率上的问题：</p>
<ol>
<li>串行的文件传输。当请求 a 文件时，b 文件只能等待，等待 a 连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是 1 秒，那么 a 文件用时为 3 秒，b 文件传输完成用时为 6 秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）</li>
<li>连接数过多。我们假设 Apache 设置了最大并发数为 300，因为浏览器限制，浏览器发起的最大请求数为 6，也就是服务器能承载的最高并发为 50，当第 51 个人访问时，就需要等待前面某个请求处理完成。<br>HTTP/2 的多路复用就是为了解决上述的两个性能问题。<br>在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。</li>
</ol>
<ul>
<li>帧代表着最小的数据单位</li>
<li>通信双方都可以给对方发送二进制帧，这种二进制帧的<strong>双向传输的序列</strong>，也叫做流(Stream)。HTTP/2 用流来在一个 TCP 连接上来进行多个数据帧的通信<br>多路复用，就是<strong>在一个 TCP 连接中可以存在多条流</strong>。换句话说，也就是<strong>可以发送多个请求</strong>，对端可以通过<strong>帧中的标识知道属于哪个请求</strong>。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</li>
</ul>
</blockquote>
<blockquote>
<p>二进制帧<br><img src="https://pic.imgdb.cn/item/627ba15b0947543129fa3ad7.jpg"><br>每个帧分为帧头和帧体。先是三个字节的帧长度，这个长度表示的是帧体的长度。<br>然后是帧类型，大概可以分为数据帧和控制帧两种。数据帧用来存放 HTTP 报文，控制帧用来管理流的传输。</p>
</blockquote>
<h3 id="HTTP-代理"><a href="#HTTP-代理" class="headerlink" title="HTTP 代理"></a>HTTP 代理</h3><p>代理实际上是一个服务器，假设在服务器和客户端之间，作为一个中间人的身份；请求并不是直接发送给服务器，而是先经过代理服务器进行一些操作，然后再发给服务器；响应也是同理。<br>代理服务器主要功能有：</p>
<ul>
<li><strong>负载均衡</strong>。代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。</li>
<li><strong>保障安全</strong>。利用心跳机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作。</li>
<li><strong>缓存代理</strong>。将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得，也叫做 Web 缓存；从计算机网络的角度，这样的代理通常设置在区域 ISP 中。实际上 HTTP 缓存的实现就是依赖代理服务器，或者叫做缓存器。</li>
</ul>
<h4 id="代理字段"><a href="#代理字段" class="headerlink" title="代理字段"></a>代理字段</h4><ul>
<li><code>Via</code>：记录代理服务器。每经过一个代理服务器就向这个字段添加当前代理的身份，添加的顺序就是经过代理服务器的顺序。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Via: proxy_server1, proxy_server2</span><br></pre></td></tr></table></figure>

<ul>
<li><code>X-Forwarded-For</code>：字面意思就是为谁转发, 它记录的是请求方的 IP 地址</li>
<li><code>X-Real-IP</code>：是一种获取用户真实 IP 的字段，不管中间经过多少代理，这个字段始终记录最初的客户端的 IP`</li>
<li><code>Cache-Control</code>中的<code>s-maxage</code>字段：限定了缓存在代理服务器中可以存放多久，即相当于代理服务器中的<code>max-age</code>。</li>
</ul>
<h4 id="代理缓存"><a href="#代理缓存" class="headerlink" title="代理缓存"></a>代理缓存</h4><p>对于 HTTP 缓存来说，如果每次客户端缓存失效都要到源服务器获取，那给源服务器的压力是很大的。<br>由此引入了缓存代理的机制。让代理服务器接管一部分的服务端 HTTP 缓存，客户端缓存过期后就近到代理缓存中获取，代理缓存过期了才请求源服务器，这样流量巨大的时候能明显降低源服务器的压力。<br>缓存代理的控制分为两部分，一部分是源服务器端的控制，一部分是客户端的控制。</p>
<ol>
<li><strong>源服务器控制</strong>：主要通过<code>Cache-Contro</code>字段控制。</li>
</ol>
<ul>
<li><code>private</code>或者<code>public</code>表示是否允许代理服务器缓存，前者禁止，后者为允许。</li>
<li><code>must-revalidate</code>的意思是客户端缓存过期就去源服务器获取，而<code>proxy-revalidate</code>则表示代理服务器的缓存过期后到源服务器获取。</li>
<li><code>s-maxage</code>:限定了缓存在代理服务器中可以存放多久，即相当于代理服务器中的<code>max-age</code>。</li>
</ul>
<ol start="2">
<li><strong>客户端控制</strong>：通过向请求头中添加几个字段：</li>
</ol>
<ul>
<li><code>max-stale</code> 和 <code>min-fresh</code>：<code>max-stale</code>表示客户端到代理服务器上拿缓存的时候，即使代理缓存过期了也不要紧，只要过期时间在多长时间之内，还是可以从代理中获取的。<code>min-fresh</code>正相反，要求至少提前多长时间。</li>
</ul>
<h3 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h3><h4 id="缓存的分类"><a href="#缓存的分类" class="headerlink" title="缓存的分类"></a>缓存的分类</h4><p>缓存根据位置和使用的对象可以分成两类：</p>
<ul>
<li>web 缓存、<code>代理缓存</code>、共用缓存：以被多个用户使用，一般是架设在 ISP 的代理服务器，作为用户主机和外部的中介</li>
<li><code>http缓存</code>：即通过请求和响应头设置的缓存，一般存储在用户主机本地，只能服务于单独用户，并且常见的 http 缓存只能缓存 get 请求响应的资源；<br>http 缓存可以根据缓存存放的<strong>位置</strong>分为 3 类<ul>
<li><code>Service Worker</code>：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers">MDN-Service Worker</a>具体介绍了这个 api，实际上比较复杂，但是只需要知道它运行在 JavaScript 主线程之外，可以完成<strong>离线缓存</strong>、消息推送、网络代理等功能；若没有在 Service Worker 命中缓存，会根据缓存查找优先级去查找数据。</li>
<li><code>Memory Cache</code>：内存缓存，效率最高最快，但一旦关闭 Tab 页面就不再保存</li>
<li><code>Disk Cache</code>：存储在硬盘中的缓存，覆盖面基本是最大的，会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。</li>
<li><code>Push Cache</code>：HTTP/2 的缓存，以上三种都没有才会使用，并且生命周期和 session 一致</li>
</ul>
</li>
</ul>
<blockquote>
<p>尽量不要用浏览器缓存这个词，因为浏览器缓存主要指的是类似 cookie 的缓存，但实际上私有 http 缓存也是存在浏览器内部的</p>
</blockquote>
<h4 id="http-缓存"><a href="#http-缓存" class="headerlink" title="http 缓存"></a>http 缓存</h4><blockquote>
<p>HTTP 缓存主要是通过请求和响应报文头中的对应 Header 信息，来控制缓存的策略。响应头中相关字段为 <code>Expires</code>、<code>Cache-Control</code>、<code>Last-Modified</code>、<code>Etag</code>。<br>缓存两种类型: <strong>强缓存</strong> / <strong>协商缓存</strong><br>从物理上，http 缓存依靠代理服务器（又叫 Web 缓存器）存储缓存信息；Web 缓存器相当于一个中转站：</p>
<ul>
<li>当客户端请求时，<strong>将请求定向至缓存器</strong>，会先经过缓存器并检查是否存有副本，如果有会直接返回；如果没有则会向服务器发送请求</li>
<li>服务器响应请求给缓存器，缓存器将文件在本地保存，返回给客户端；当下一次客户端请求时会给予之前的副本而不是直接请求服务器</li>
</ul>
</blockquote>
<p>缓存类型有两种：</p>
<ul>
<li>强缓存: 如果缓存在缓存器缓存数据库中存在,就强制使用缓存而不是请求服务器; 如果没有缓存就请求服务器并取得缓存,下次使用缓存<br><img src="https://pic.imgdb.cn/item/623439926eeb7459a2832d75.jpg"></li>
<li>协商缓存/对比缓存: 无论有无缓存都会向服务器请求, 比较判断是否可以使用缓存。浏览器再次请求数据时，浏览器将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回 304 状态码，通知客户端比较成功，可以使用缓存数据。第二次的请求大小会比第一次小很多, 一般不包含静态资源缓存, 因此要快很多<br><img src="https://pic.imgdb.cn/item/623439f15baa1a80ab0c3519.jpg"></li>
</ul>
<blockquote>
<p>不存在缓存数据或者过期时会采用强缓存，获取之后在进行缓存；<br>一旦拥有缓存，即采用协商缓存<br>允许使用浏览器本地缓存的状态码是<code>304</code>，表示资源未改变，可以使用缓存<br>判断流程：<img src="https://pic.imgdb.cn/item/62343dc85baa1a80ab0e7589.jpg"></p>
<p>这张图从浏览器角度看更清晰：<img src="https://pic.imgdb.cn/item/6237f03627f86abb2af51f05.jpg"></p>
</blockquote>
<h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应 header 中。<br>在缓存数据未失效的情况下，浏览器会直接使用缓存数据；浏览器判断数据失效的依据是响应头部的缓存相关字段；如果失效，则会再次向服务器请求。</p>
<p>缓存相关字段如下：</p>
<ul>
<li><code>Expires</code>：服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。在 HTTP 1.1 的版本，Expires 被 Cache-Control 替代。</li>
<li><code>Cache-Control</code>：常见的取值有 private、public、no-cache、max-age，no-store，默认为 private。<ul>
<li><code>max-age=xxx</code>：用来设置资源（representations）可以被缓存多长时间，单位为秒；</li>
<li><code>public</code>：指示响应可被任何缓存区缓存；</li>
<li><code>private</code>：只能针对个人用户，而不能被代理服务器缓存；对前端来说这两个没什么太多区别</li>
<li><code>no-cache</code>：强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到请求，然后判断资源是否变更，是则返回新内容，否则返回 304，未变更。</li>
<li><code>no-store</code>：禁止一切缓存（这个才是响应不被缓存的意思）。</li>
<li><code>s-maxage</code>：限定了缓存在代理服务器中可以存放多久，和限制客户端缓存时间的 max-age 并不冲突。<code>s-maxage</code>出现时将无视 expires 字段。</li>
</ul>
</li>
</ul>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。<br>再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回 304 状态码，通知客户端比较成功，可以使用缓存数据。</p>
<blockquote>
<p>协商缓存的判断字段分为两组，第一组依据修改时间判断是否过期、是否需要重传；第二组通过唯一标识符判断；<br>两组内部的值其实相同，只是组内的前者是响应头内的，后者是请求头内的。<br><strong>第二组</strong>的优先级高一些；</p>
</blockquote>
<ul>
<li><code>Last-Modified</code> ：最后修改时间</li>
<li><code>If-Modified-Since</code>：再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。</li>
</ul>
<p>服务器收到请求后发现有头<code>If-Modified-Since</code> 则与被请求资源的最后修改时间进行比对。</p>
<ul>
<li>若资源的最后修改时间大于<code>If-Modified-Since</code>，说明资源又被改动过，则响应整片资源内容，返回状态码 200；</li>
<li>若资源的最后修改时间小于或等于<code>If-Modified-Since</code>，说明资源无新修改，则响应 HTTP 304，告知浏览器继续使用所保存的 cache。</li>
</ul>
<hr>
<ul>
<li><code>Etag</code>：服务器对资源的唯一标识</li>
<li><code>If-None-Match</code>：再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。</li>
</ul>
<p>服务器收到请求后发现有头<code>If-None-Match</code> 则与被请求资源的唯一标识（Etag）进行比对，</p>
<ul>
<li>不同，说明资源又被改动过，则响应整片资源内容，返回状态码 200；</li>
<li>相同，说明资源无新修改，则响应 HTTP 304，告知浏览器继续使用所保存的 cache。</li>
</ul>
<h4 id="条件-GET"><a href="#条件-GET" class="headerlink" title="条件 GET"></a>条件 GET</h4><p>浏览器通过条件 GET（也就是报文中首部行的<code>If-Modified-Since</code>）<strong>判断缓存器上的副本是否是最新的</strong>，具体步骤如下：</p>
<ol>
<li>代理缓存器第一次向服务器发送请求，服务器返回的报文首部行中有一个<code>Last-Modified</code>字段被一并保存；</li>
<li>一段时间后当客户端请求时，代理缓存器会发送一个 GET 请求，其中首部行带有<code>If-Modified-Since</code>字段，并且值就是之前的<code>Last-Modified</code>字段，表示上次请求的时间</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">HOST: www.xxx.com</span><br><span class="line">If-Modified-Since: Wed, 9 Sep 2020 09:23:24</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>服务器对条件 GET 做出响应：</li>
</ol>
<ul>
<li>状态码 304，说明可以继续使用缓存</li>
<li>其他情况，发送新的响应体，重新缓存</li>
</ul>
<ol start="4">
<li>将缓存响应给客户端</li>
</ol>
<h3 id="HTTP-其他功能"><a href="#HTTP-其他功能" class="headerlink" title="HTTP 其他功能"></a>HTTP 其他功能</h3><h4 id="大文件传输（分段传输）"><a href="#大文件传输（分段传输）" class="headerlink" title="大文件传输（分段传输）"></a>大文件传输（分段传输）</h4><p>HTTP 针对这一场景，采取了范围请求的解决方案，允许客户端仅仅请求一个资源的一部分。</p>
<p>要支持这个功能，就必须加上这样一个响应头:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure>

<p>而对于客户端而言，它需要指定请求哪一部分，通过 Range 这个请求头字段确定，格式为 bytes=x-y。<br>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 单段数据</span><br><span class="line">Range: bytes=0-9</span><br><span class="line">// 多段数据</span><br><span class="line">Range: bytes=0-9, 30-39</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Range 的书写格式:<br>0-499 表示从开始到第 499 个字节。<br>500- 表示从第 500 字节到文件终点。<br>-100 表示文件的最后 100 个字节。<br>服务器收到请求之后，首先验证范围是否合法，如果越界了那么返回<code>416</code>错误码;否则读取相应片段，返回<code>206</code>状态码。</p>
</blockquote>
<p>响应对于单端数据的处理和多段数据不同。</p>
<ol>
<li>单段数据：核心是<code>Content-Range</code>字段，表示响应的返回部分和总资源的大小。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Content-Length: 10</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Range: bytes 0-9/100</span><br><span class="line"></span><br><span class="line">i am xxxxx</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>多段数据：</li>
<li><code>Content-Type: multipart/byteranges; boundary=00000010101</code>这个字段表示响应体是一个多段数据，用 boundary 值为 00000010101 来分割。</li>
<li>每一段都会先用 boundary 分割，然后展示本段的类型（<code>Content-Type</code>）和范围（<code>Content-Range</code>），再在一个空行之后放入正常的响应体即可。</li>
<li>在最后的分隔末尾添上–表示结束。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Content-Type: multipart/byteranges; boundary=00000010101</span><br><span class="line">Content-Length: 189</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--00000010101</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Range: bytes 0-9/96</span><br><span class="line"></span><br><span class="line">i am xxxxx</span><br><span class="line">--00000010101</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Range: bytes 20-29/96</span><br><span class="line"></span><br><span class="line">eex jspy e</span><br><span class="line">--00000010101--</span><br></pre></td></tr></table></figure>

<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。</p>
<p>在定义上，DNS 既是一个由分层的 DNS 服务器实现的 DNS<strong>数据库</strong>，又是一个提供这项功能的应用层<strong>协议</strong>。</p>
<p>作用：将域名解析为 IP 地址，客户端向 DNS 服务器（DNS 服务器有自己的 IP 地址）发送域名查询请求，DNS 服务器告知客户机 Web 服务器的 IP 地址。</p>
<blockquote>
<p>DNS 用作域名解析时运行在 UDP 上，53 号端口<br>DNS 在区域传输时使用 TCP，即根服务器、权威服务器等之间的数据交换</p>
</blockquote>
<h3 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h3><p>DNS 采用分布式层次数据库的方式，使 IP 地址–域名的映射分布在所有 DNS 服务器上。这些服务器大致分为三类：</p>
<ul>
<li>根 DNS 服务器：提供顶级域（TLD）服务器的 IP 地址</li>
<li>TLD DNS 服务器：顶级域即类似<code>.com</code>、<code>.cn</code>这样的域名中的顶级域，这些顶级域提供权威 DNS 服务器的 IP</li>
<li>权威 DNS 服务器：真正存储映射的地方，维护一个区域的映射。</li>
<li>本地 DNS 服务器：虽然不属于分布式的一部分，但是和用户直接相连，用于向其他服务器发送；同时也带有 DHCP 服务器，供用户获取自己的 IP 地址。</li>
</ul>
<p>DNS 服务器解析域名的过程：</p>
<ol>
<li>首先会在<strong>浏览器的缓存</strong>中查找对应的 IP 地址，如果查找到直接返回，若找不到继续下一步</li>
<li>将请求发送给本地 DNS 服务器，在<strong>本地 DNS 服务器缓存</strong>中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步</li>
<li>本地 DNS 服务器向<strong>根域名服务器</strong>发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</li>
<li>本地 DNS 服务器向<strong>顶级域名服务器</strong>发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址</li>
<li>本地 DNS 服务器向<strong>权威域名服务器</strong>发送请求，域名服务器返回对应的结果</li>
<li>本地 DNS 服务器将返回结果保存在缓存中，便于下次使用</li>
<li>本地 DNS 服务器将返回结果返回给浏览器</li>
</ol>
<p>上面这种方式，本地 DNS 分别向三个层次发送请求，这种方式是<code>迭代查询</code>。<br>如果是<code>本地DNS-&gt;根DNS-&gt;TLD DNS-&gt;权威DNS-&gt;原路返回</code>这样的形式，就是<code>递归查询</code>。</p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>CDN（内容分发网络）：尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN 系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。<br>也就是说，cdn 可以尽可能把你连接到最近、最快的服务器</p>
<p>cdn 由一个 dns 服务器和几台缓存服务器组成，dns 服务器用作接入并返回合适的缓存服务器；缓存服务器存储真正的内容，会被分配到不同的用户。</p>
<ol>
<li>当用户点击网站页面上的内容 URL，经过本地 DNS 系统解析，并不会直接返回对应的 IP 地址，而是返回一个 CDN 服务器的域名（注意是域名不是 ip）</li>
<li>用户向返回的这个 CDN 服务器域名发起请求。</li>
<li>CDN 服务器根据用户 IP 地址，以及用户请求的内容 URL，选择一台用户所属区域的区域负载均衡设备，返回给这台设备的 IP 地址</li>
<li>用户通过本地 dns 向该 ip 发起连接。</li>
</ol>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>传输层建立在网络层之上和应用层之下，为运行在不同主机上的不同进程之间提供了逻辑通信。<br>传输层的主要功能：</p>
<ol>
<li>多路复用和多路分解：由于网络层只负责主机到主机的传输，具体到进程需要传输层控制。把进程和运输层之间不同的套接字中的数据块收集，并生成报文段的过程叫多路复用（封装数据）；把报文段的数据正确交付到对应的套接字叫做多路分解（解封和交付）</li>
<li>提供可靠数据传输，以及拥塞控制等功能（TCP）</li>
</ol>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP（用户数据报协议），和 TCP 协议一样用于处理数据包，是一种无连接的协议。通常适用于允许丢失、但对实时性要求很高的功能。</p>
<h3 id="UDP-特点"><a href="#UDP-特点" class="headerlink" title="UDP 特点"></a>UDP 特点</h3><ol>
<li><strong>无连接</strong><br>UDP 不需要和 TCP 一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。<br>具体来说就是：<ul>
<li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li>
<li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li>
</ul>
</li>
<li><strong>传输方式多样</strong><br>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</li>
<li><strong>面向报文</strong><br>发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</li>
<li><strong>不可靠性</strong><br>首先不可靠性体现在<strong>无连接</strong>，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。<br>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也<strong>不会确定对方是否已经正确接收到数据</strong>。<br>再者网络环境时好时坏，但是 UDP 因为<strong>没有拥塞控制</strong>，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。<br>这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</li>
<li><strong>高效</strong><br>UDP 头部包含了以下几个数据：</li>
</ol>
<ul>
<li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li>
<li>整个数据报文的长度</li>
<li>整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误</li>
</ul>
<blockquote>
<p>检验和：将所有的字相加，得到的字如果溢出就回卷（去掉几个开头的位），然后取其反码作为检验和。<br>在验证时用检验和和所有字的和相加，如果不全为1就说明有差错。</p>
</blockquote>
<p>  因此 UDP 的头部开销小，只有 8 字节，相比 TCP 的至少 20 字节要少得多，在传输数据报文时是很高效的。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP 的全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是面向连接的、可靠的流协议（流就是指不间断的数据结构）。<br>TCP 应用场景： 效率要求相对低，但对<strong>准确性</strong>要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有 UDP 高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录</p>
<h3 id="TCP-特点"><a href="#TCP-特点" class="headerlink" title="TCP 特点"></a>TCP 特点</h3><ol>
<li><strong>面向连接</strong><br>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</li>
<li><strong>仅支持单播传输</strong><br>每条 TCP 传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</li>
<li><strong>面向字节流</strong><br>TCP 不像 UDP 一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</li>
<li><strong>可靠传输</strong><br>对于可靠传输，判断丢包、误码靠的是 TCP 的段编号以及确认号。TCP 为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</li>
<li><strong>提供拥塞控制</strong><br>当网络出现拥塞的时候，TCP 能够减小向网络注入数据的速率和数量，缓解拥塞。</li>
<li><strong>提供全双工通信</strong><br>TCP 允许通信双方的应用程序在任何时候都能发送数据，因为 TCP 连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP 可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于 MSS）</li>
</ol>
<h3 id="TCP-报文段"><a href="#TCP-报文段" class="headerlink" title="TCP 报文段"></a>TCP 报文段</h3><p><img src="https://pic.imgdb.cn/item/62348f555baa1a80ab774d02.jpg"><br>TCP 报文结构如上所示：</p>
<ul>
<li>32 比特的序号（seq）和确认号（ack），这两个是报文中确定传输最重要的部分</li>
<li>16 比特的接收窗口，用于流量控制</li>
<li>标志字段，包括 ACK、SYN、FIN 等多个用于标识状态的字段。常用的标志位：<ul>
<li><code>SYN</code>(synchronous)： 发送/同步标志，用来建立连接，和下面的第二个标志位 ACK 搭配使用。连接开始时，SYN=1，ACK=0，代表连接开始但是未获得响应。当连接被响应的时候，标志位会发生变化，其中 ACK 会置为 1，代表确认收到连接请求，此时的标志位变成了 SYN=1，ACK=1。</li>
<li><code>ACK</code>(acknowledgement)：确认标志，表示确认收到请求。</li>
<li><code>PSH</code>(push) ：表示推送操作，就是指数据包到达接收端以后，不对其进行队列处理，而是尽可能的将数据交给应用程序处理；</li>
<li><code>FIN</code>(finish)：结束标志，用于结束一个 TCP 会话；</li>
<li><code>RST</code>(reset)：重置复位标志，用于复位对应的 TCP 连接。</li>
<li><code>URG</code>(urgent)：紧急标志，用于保证 TCP 连接不被中断，并且督促中间层设备尽快处理。</li>
</ul>
</li>
<li>首部字段，指示 TCP 首部长度（不包括数据），一般是 20 字节，但是可变；</li>
<li>数据字段，由于 MSS 的限制，数据字段一般不会大于<code>1500-20-20=1460</code>字节</li>
</ul>
<h4 id="序号和确认号"><a href="#序号和确认号" class="headerlink" title="序号和确认号"></a>序号和确认号</h4><p>TCP 把数据看作是一个无结构的、有序的字节流；因此序号标识的是数据的<strong>字节</strong>，而不是报文段。<br>报文中的序号（seq）通常是报文中数据段的段首字节位置；<br><img src="https://pic.imgdb.cn/item/623493275baa1a80ab80f873.jpg"></p>
<blockquote>
<p>比如有一个 500000 字节的文件，每个报文段数据为 1000 字节，那么 seq 就分别是 0、1000、2000 直到 499000</p>
</blockquote>
<p>确认号表示期望从对方主机收到的下一个字节序号。</p>
<blockquote>
<p>比如两个主机 A 和 B，主机 A 已经收到了来自主机 B 的编号为 0~535 的字节，因此主机 A 再次给主机 B 发送的 ack 就是 536，表示期望收到第 536 号字节之后的数据；<br>另外，如果主机 B 给主机 A 发送的不是 536 之后的，主机 A 仍会继续发送 ack=536，直到接收到 536 为止，再继续请求下一个最前面的字节序号；这也是后面 TCP 可靠数据传输的原理之一，即<code>累计确认</code></p>
</blockquote>
<h3 id="TCP-的可靠数据传输"><a href="#TCP-的可靠数据传输" class="headerlink" title="TCP 的可靠数据传输"></a>TCP 的可靠数据传输</h3><p>TCP 可靠数据传输主要通过重传机制实现；其中导致 TCP 进行重传的条件主要有两个：</p>
<ol>
<li>定时器超时（超时重传）</li>
<li>连续收到三个 ack（快速重传）</li>
</ol>
<h4 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h4><p>TCP 仅在刚发送第一个报文段时启动<strong>一个</strong>定时器，在定时器到期并且仍没有收到有效的 ACK 时，就会重新发送具有最小序号的报文段（即最早发送的那个）。<br>由于超时时间过长或过短都会导致传输数据出现异常（详见计网 P162），因此每一次重传都会将超时时间间隔设置为前一次的 2 倍；如果有新的重传事件发生（比如收到了 3 个冗余 ack），就会重新计算超时时间。</p>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>当发送方连续收到 3 个相同的 ack 时，将会在定时器到期之前就重传这个报文段。<br>收到冗余 ack 的原因是 TCP 会在不同的情况下发送可能不同于平常的 ack，规则如下：（都是指接收方）</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>动作</th>
</tr>
</thead>
<tbody><tr>
<td>收到正常顺序的数据，并且之前没有缺漏</td>
<td>延迟 500ms 发送 ack，即如果下一个报文段 500ms 内没有到达，就发送这个的 ack</td>
</tr>
<tr>
<td>收到比期望序号大的报文段，即<code>seq &gt; ack</code></td>
<td>说明中间有缺失，会继续发送缺失部分的 ack</td>
</tr>
<tr>
<td>收到填补缺失的报文段，填补之后前面都已经完整</td>
<td>从整个接收区的末尾字节继续发送 ack，即完全填充之后就又正常发送 ack</td>
</tr>
</tbody></table>
<p>因此，收到冗余 ack 的原因是<strong>报文段缺失</strong>。<br>一旦发送方收到连续 3 个相同的 ack，就会进行快速重传，即把缺失的报文段再发一次，以弥补接收方的缺失。</p>
<p>这部分的图可以参考 计网 P164</p>
<h3 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h3><p>TCP的双方都维护了一个缓冲区，作为临时存储数据；为了保证双方的缓冲区不溢出，需要有一个流量控制机制，保证发送端的发送速度不会超出接收端的处理速度。<br>流量控制的原理是接收方维护一个接收窗口，即之前报文段中的部分；接收窗口会给发送方一个指示，告诉自己剩余多少空间，发送方则会根据这个值调整自己的发送速度。<br>接收窗口的空闲区间大小用<code>rwnd</code>表示，表示缓存区中的<strong>空闲空间</strong>。<br>当接收方收到数据时，会把rwnd放在回复给发送方的报文段中。发送方收到接收方的rwnd之后，便可以通过这个值确定自己本次要发送多少数据，保证自己发送的数据量不会导致rwnd被充满。<br>发送方要保证发送的数据不会使得 rwnd 变为 0；同时如果 rwnd 变为 0 也并不是完全停止发送，而是会继续发送一个字节的报文段，用于获取新的 rwnd 值。<br>详见计网 P165</p>
<h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h3><p>TCP的拥塞控制实际上是一种端到端的拥塞控制，即，网络层没有提供任何关于拥塞的信息，拥塞与否主要依靠TCP自己判断，比如三次冗余ack等方式。</p>
<p>TCP 拥塞控制就是控制拥塞窗口<code>cwnd</code>，限制<strong>发送</strong>方在未确认时能发送的数据量。因此接受方中未被确认的数据量不会大于<code>min&#123;cwnd,rwnd&#125;</code>。其实也就是说发送方要发送的数据量不能大于这两个的最小值。</p>
<blockquote>
<p>注意rwnd和cwnd的区别：<br>rwnd：流量控制机制，由接收端的缓存空间剩余量决定，由接收端发送给发送端<br>cwnd：拥塞控制机制，由发送端跟踪并控制，可以由发送端直接改变</p>
</blockquote>
<p>TCP 的拥塞控制机制主要是以下三种机制：</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>快速恢复</li>
</ul>
<p>拥塞控制的特点：线性增加（拥塞避免或快速恢复的线性增加）、乘性减少（一旦有冗余 ack 就把阈值砍半）</p>
<blockquote>
<p>注意拥塞控制中的速度单位 MSS/RTT ，即一次收发时间内发送多少个最大报文段长度。</p>
</blockquote>
<h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>慢启动流程：</p>
<ol>
<li>TCP 连接刚开始时<code>cwnd</code>值通常被设为 1 个 MSS（最大报文段长度），然后每当收到一个确认时就指数增加，变成每次发送 2、4、8…..个 MSS；</li>
<li>慢启动的停止条件和情况有三种：</li>
<li>当出现一次<strong>超时重传</strong>时，就立即停止这种增长，取当前发送的 MSS 值的一半作为<code>ssthresh</code>值，即“阈值”（比如到一次发送 8 个 MSS 时出现超时，就设置 ssthresh = 4`），并且把cwnd重设为1，<strong>重新开始慢启动</strong>。</li>
<li>当已经设置了ssthresh值，并且慢启动又到达了这个值，就会进入<strong>拥塞避免</strong></li>
<li>当出现<strong>三个冗余ack</strong>时，进入快速恢复阶段。</li>
</ol>
<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>进入拥塞避免时，由上面可以知道此时cwnd应该是刚到达ssthresh，即阈值的一半。</p>
<ol>
<li>在拥塞避免阶段，增长变成线性，即从慢启动确定的阈值开始，一次只增加一个 MSS。</li>
<li>结束拥塞避免阶段也有两种情况：</li>
<li>当出现一次<strong>超时重传</strong>时，和慢启动一样，cwnd被重设为1，重新慢启动。</li>
<li>当出现一次<strong>快速重传</strong>时（即三个冗余 ack），就立即停止增长，并类似的设置阈值为当前值的一半。比如这次到 12MSS 时出现重传，就设置阈值为 6；然后进入快速恢复阶段</li>
</ol>
<h4 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h4><p>快速恢复启动的时候有两种情况：</p>
<ol>
<li>拥塞避免阶段结束，刚刚出现了一次快速重传</li>
<li>慢启动结束，刚刚出现了一次快速重传</li>
</ol>
<p>因此不管是哪种情况进入，都是因为快速重传的出现。快速恢复就是为了处理这种快速重传。</p>
<p>快速恢复不是一个必须项，并且快速恢复有两个版本：</p>
<ul>
<li>Tahoe，已废弃的版本，区别是拥塞避免出现冗余 ack 之后也会直接将 cwnd 设置为 1，即任何异常都会之间置为 1</li>
<li>Reno，就是当前采用的方法；出现冗余 ack 并不会直接置为 1，而是从<code>(ssthresh / 2) + 3</code>开始继续拥塞避免。上面的阈值设置为 6，就从 9MSS 开始进入拥塞避免阶段，即匀速增长。</li>
</ul>
<p>在快速恢复中如果再次出现超时的情况，就执行在上面两个中一样的步骤，即cwnd重置为1，并进入慢启动重新走一次流程。</p>
<h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><p><img src="https://pic.imgdb.cn/item/6234ab885baa1a80abb8eabe.png"></p>
<p>步骤：<br>0. 初始两端都处于 closed 状态。</p>
<ol>
<li>客户端向服务端发送一个不含有有效载荷的 TCP 报文段；标志位<code>SYN=1</code>，seq 设置一个随机的值作为初始序号（设为 x）；发送之后客户端进入<code>SYN-SENT</code>阶段，发送时服务端处于<code>LISTEN</code>阶段。</li>
<li>服务端收到该报文，分配缓存和变量，根据 seq 值确定自己要开始接收的序号（即 ack 值），然后给客户端告知自己的 seq 值，标志位<code>SYN=1, ACK=1</code>。同理服务端发送后也立即进入<code>SYN-RECEIVED</code>阶段；<br>注意服务器返回的<code>ack = x + 1</code>，是因为<code>SYN</code>会消耗一个序列号；<strong>凡是需要对端确认的，一定消耗 TCP 报文的序列号</strong>，下一个连接的 ack 为 y+1 也是这个原因。同时还会发送自己经过分配得到的 seq 值（设为 y）。这段报文同样没有有效载荷，被称为<code>SYNACK报文段</code></li>
<li>客户端收到，同样给连接分配缓存和变量；将自己的 seq 设置为<code>x+1</code>，即上一步服务器的 ack 值，表示自己从这里开始发送；随后令自己的<code>ack = y + 1</code>，即服务器的 seq 值下一个，标志位<code>ACK=1,SYN=0</code>。客户端发送后进入<code>ESTABLISHED</code>阶段，此时客户端已经准备好；服务端接收到之后也会进入<code>ESTABLISHED</code>阶段；当两者都进入，连接成功，开始发送数据。<br>另外这个请求可以携带有效载荷，同时因为连接已经建立，<code>SYN=0</code></li>
</ol>
<blockquote>
<p>一定要三次握手的原因：<br>为了确认双方的接收能力和发送能力都正常<br>如果是用两次握手，则会出现下面这种情况：<br>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p>
</blockquote>
<p>概括一下就是：</p>
<ol>
<li>第一次握手： 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 <code>SYN-SENT</code> 状态。</li>
<li>第二次握手： 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 <code>SYN-RECEIVED</code> 状态。</li>
<li>第三次握手： 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 <code>ESTABLISHED</code> 状态，服务端收到这个应答后也进入 <code>ESTABLISHED</code> 状态，此时连接建立成功。</li>
</ol>
<h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><p><img src="https://pic.imgdb.cn/item/6234b0a55baa1a80abc43d47.jpg"></p>
<ol>
<li><p>第一次挥手： 客户端会发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 <code>FIN_WAIT1</code> 状态。<br>即发出连接释放报文段（FIN=1），并停止再发送数据，主动关闭 TCP 连接，进入<code>FIN_WAIT1</code>（半关闭）状态，等待服务端的确认。</p>
</li>
<li><p>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT </code>状态。<br>即服务端收到连接释放报文段后即发出确认报文段（ACK=1），服务端进入<code>CLOSE_WAIT</code>（关闭等待）状态，此时的 TCP 处于半关闭状态，<strong>客户端到服务端的连接释放</strong>。<br>客户端收到服务端的确认后，进入<code>FIN_WAIT2</code>（终止等待 2）状态，等待服务端发出的连接释放报文段。</p>
</li>
<li><p>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK </code>的状态。<br>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1），服务端进入<code>LAST_ACK</code>（最后确认）状态，等待客户端的确认。</p>
</li>
<li><p>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 <code>TIME_WAIT</code> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 <code>CLOSED</code> 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 <code>CLOSED</code> 状态。<br>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1），客户端进入<code>TIME_WAIT</code>（时间等待）状态。<br>此时 TCP 未释放掉，<strong>需要经过时间等待计时器设置的时间 2MSL 后</strong>，客户端才进入 CLOSED 状态。（1MSL 大概是 2 分钟左右，实际时间可能更短）</p>
</li>
</ol>
<hr>
<p>那为什么需要四次挥手呢？</p>
<blockquote>
<p>因为当服务端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当服务端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉客户端，“你发的 FIN 报文我收到了”。<strong>只有等到我服务端所有的报文都发送完了</strong>，我才能发送 FIN 报文来确认关闭，因此不能一起发送，故需要四次挥手。</p>
</blockquote>
<hr>
<p>简单来说就是以下四步：</p>
<ol>
<li>第一次挥手： 若<strong>客户端认为数据发送完成</strong>，则它需要向服务端发送连接释放请求。</li>
<li>第二次挥手：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 <code>CLOSE_WAIT</code> 状态，此时表明客户端到服务端的连接已经释放，<strong>不再接收客户端发的数据</strong>了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。</li>
<li>第三次挥手：服务端如果此时<strong>还有没发完的数据</strong>会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 <code>LAST-ACK</code> 状态。</li>
<li>第四次挥手： 客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 <code>TIME-WAIT</code> 状态。该状态会持续 2MSL（<strong>最大段生存期</strong>，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 <code>CLOSED</code> 状态。当服务端收到确认应答后，也便进入 <code>CLOSED</code> 状态。</li>
</ol>
<p>TCP 使用四次挥手的原因是因为 TCP 的连接是<strong>全双工</strong>的，所以<strong>需要双方分别释放到对方的连接</strong>，单独一方的连接释放，只代表不能再向对方发送数据，连接处于的是半释放的状态。<br>最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了<strong>防止发送给服务器的确认报文段丢失或者出错</strong>，从而导致服务器端不能正常关闭。</p>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>网络层运行在传输层之下，从结构上分为数据平面（IP）和控制平面（SDN），其主要的功能有两个：</p>
<ul>
<li>转发，是数据平面的唯一功能，即主机和主机、主机和路由器、路由器和路由器之间转发分组；绝大部分的转发在路由器上完成</li>
<li>路由选择，控制平面的主要功能，即选择合适的路径、转发方式</li>
</ul>
<p>网络层中涉及众多的协议，其中包括最重要的协议，也是 TCP/IP 的核心协议——IP 协议。IP 协议非常简单，仅仅提供不可靠、无连接的传送服务。IP 协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。</p>
<h2 id="IP（IPv4）"><a href="#IP（IPv4）" class="headerlink" title="IP（IPv4）"></a>IP（IPv4）</h2><h3 id="IP-数据报"><a href="#IP-数据报" class="headerlink" title="IP 数据报"></a>IP 数据报</h3><p><img src="https://pic.imgdb.cn/item/623595a65baa1a80ab118e12.png"></p>
<ul>
<li>版本：指 IP 协议的版本，占 4 位，如 IPv4 和 IPv6；</li>
<li>首部位长度：表示 IP 首部长度，占 4 位，最大数值位 15；</li>
<li>总长度：表示 IP 数据报总长度，占 16 位，最大数值位 65535；</li>
<li>生存时间（TTL）：表示 IP 数据报文在网络中的寿命，占 8 位；</li>
<li>协议：表明 IP 数据所携带的具体数据是什么协议的，如 TCP、UDP。</li>
</ul>
<h3 id="IP-编址"><a href="#IP-编址" class="headerlink" title="IP 编址"></a>IP 编址</h3><p>IP 地址采用等分十进制编码，即把本来的四个二进制字节写作类似<code>xxx.xxx.xxx.xxx</code>的格式。</p>
<h4 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h4><p>网络中并不是所有的设备都分散在网络各处，而是会组成一个个的小块，互联这些小块中的主机接口和路由器接口的网络叫做<strong>子网</strong>。每个子网前面一部分的编址相同，只有后面一小部分的编址不同，用于区分子网内的主机；</p>
<p><img src="https://pic.imgdb.cn/item/62359a035baa1a80ab1bfec6.jpg"></p>
<p>通常写作<code>a.b.c.d/x</code>格式，其中<code>/x</code>称为<strong>子网掩码</strong>，用于说明前 x 位是子网中具有相同前缀的位数，也叫做<strong>前缀</strong>；</p>
<ul>
<li>前缀用来标识子网，也被叫做地址的网络部分；</li>
<li>前缀之后的部分用来标识子网中的主机</li>
</ul>
<p>外部连接子网时，并不需要直到每个确定的设备 IP，而是只需要知道前缀，将请求发给网关路由器即可。</p>
<h4 id="地址分类"><a href="#地址分类" class="headerlink" title="地址分类"></a>地址分类</h4><p>以前，IP 地址的网络部分的长度被限制只能是 8、16、24 比特的一种，即掩码只能是 8、16 或 24。因此，网络部分长度为 8/16/24 比特的网络分别被成为 A/B/C 类网络：</p>
<p><img src="https://pic.imgdb.cn/item/62359b5b5baa1a80ab1f39f1.png"><br><img src="https://pic.imgdb.cn/item/6235a03d5baa1a80ab2a302e.png"></p>
<p>IP 地址可根据主机号和网络号所占字节分为 ABCDE 类：</p>
<ul>
<li>A 类地址:网络号占 1 个字节。网络号的第一位固定为 0。</li>
<li>B 类地址：网络号占 2 个字节。网络号的前两位固定为 10。</li>
<li>C 类地址：网络号占 3 个字节。网络号的前三位固定位 110。</li>
<li>D 类地址：前四位是 1110，用于多播(multicast)，即一对多通信。</li>
<li>E 类地址：前四位是 1111，保留为以后使用。<br>其中，ABC 三类地址为单播地址（unicast),用于一对一通信，是最常用的。</li>
</ul>
<blockquote>
<p>CIDR 是无类别域间路由选择的简称，即可以任意划定主机部分和网络部分的长度，用子网掩码作为标识指示第一部分的比特数；通过 CIDR，就不会有对网络号的位数限制，即不再有 A/B/C 类网络的划分。</p>
</blockquote>
<p>不同类型的网络拥有不同数量的主机和网络数。比如 A 类网络部分长度为 8，即最多只能有<code>2^8 - 2 = 254</code>个网络（全 1 和全 0 有特殊用处），但每个子网却有<code>2^24</code>台主机；其他的同理：<br><img src="https://pic.imgdb.cn/item/62359c395baa1a80ab213a37.jpg"></p>
<blockquote>
<p>特殊的 IP 地址：</p>
<ul>
<li><code>127.0.0.1</code>：回环地址。该地址指电脑本身</li>
<li><code>10.x.x.x</code>、<code>172.16.x.x</code>～<code>172.31.x.x</code>、<code>192.168.x.x</code>：这些地址被用做内网中。用做私网地址，这些地址不与外网相连。</li>
<li><code>0.0.0.0</code>：这个 IP 地址在 IP 数据报中只能用作<strong>源</strong>IP 地址，这发生在当设备启动时但又不知道自己的 IP 地址情况下。</li>
<li><code>255.255.255.255</code>：广播地址，只能用作<strong>目标</strong>IP 地址，用于不知道自己 IP 的情况下寻找 DHCP 服务器时用</li>
<li>主机号全为 0（<code>xxx.0.0.0</code>）：标识本子网</li>
<li>主机号全为 1（<code>xxx.255.255.255</code>）：标识本子网下的全部主机</li>
</ul>
</blockquote>
<h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><h2 id="链路层寻址（MAC）"><a href="#链路层寻址（MAC）" class="headerlink" title="链路层寻址（MAC）"></a>链路层寻址（MAC）</h2><p>主机和路由器本身不具有链路层地址，是他们的网卡（网络适配器、网络接口）具有。链路层地址可以认为就是 MAC 地址。<br>MAC 地址为 6 字节，一旦被赋予就是<strong>永久</strong>的，一个 MAC 地址始终和网卡绑定，采用十六进制表示。<br><img src="https://i.loli.net/2021/12/02/G4P5bBIxHwOtup7.jpg" alt="MAC.jpg"></p>
<blockquote>
<p>MAC 地址只在子网内生效；如果想要发送到外部，则只需要网关路由器输入端口的 MAC 地址，再由网关路由器进行 ARP 查询和转发。</p>
</blockquote>
<h2 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h2><p>ARP 协议协议(Address Resolution Protocol)，地址解析协议，它是用于实现<strong>IP 地址到 MAC 地址的映射</strong>。<br>ARP 协议是自学习、零配置的，其能够通过反复把最新的映射添加到维护的 ARP 表中，实现自动配置。</p>
<blockquote>
<p>ARP 协议既是网络层又是链路层的协议，是一个介于两者之间的协议。</p>
</blockquote>
<p>ARP 协议流程如下：</p>
<ol>
<li><p>首先，每台主机、交换机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。</p>
</li>
<li><p>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己的 ARP 列表，是否存在该 IP 地址对应的 MAC 地址；如果有﹐就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的广播包，查询此目的主机对应的 MAC 地址。此 ARP 请求的数据包里，包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。</p>
</li>
<li><p>网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同，就会忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址。</p>
</li>
<li><p>源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</p>
</li>
</ol>
<h1 id="从浏览器输入-url-到显示的过程"><a href="#从浏览器输入-url-到显示的过程" class="headerlink" title="从浏览器输入 url 到显示的过程"></a>从浏览器输入 url 到显示的过程</h1><h3 id="0-连接网络"><a href="#0-连接网络" class="headerlink" title="0. 连接网络"></a>0. 连接网络</h3><ol>
<li>主机生成 DHCP 请求报文，被放在具有 IP 广播地址（255.255.255.255）和源 IP（0.0.0.0）的 IP 数据报中</li>
<li>将上一步的数据报放置在以太网帧，该帧具有<code>FF:FF:FF:FF:FF:FF</code>的广播 MAC 地址，然后广播出去</li>
<li>DHCP 服务器收到该广播，通过解封装抽取其 UDP 数据报，并给该主机分配一个 IP 地址，再次封装发回到主机的 MAC 地址（主机的 IP 位置但 MAC 已知且固定）</li>
<li>主机收到该帧，解封装得知自己的 IP 地址，该主机的 DHCP 客户端记录下该主机的 IP，此时已经相当于“连接上网络”</li>
</ol>
<h3 id="1-解析-URL"><a href="#1-解析-URL" class="headerlink" title="1. 解析 URL"></a>1. 解析 URL</h3><ol>
<li>首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。</li>
<li>浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。</li>
<li>主机生成 DNS 查询报文，获取到网关路由器的 IP 和 MAC 地址，准备向本地 DNS 服务器发送查询请求</li>
<li>判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有执行 DNS 查询，可能会有迭代查询和递归查询两种方式。</li>
<li>获取 MAC 地址： 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址；</li>
</ol>
<ul>
<li>如果对应的 ip 和主机在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址；</li>
<li>如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。（这一步其实在第 3 步已经完成）</li>
</ul>
<h3 id="2-TCP-和-HTTP-连接"><a href="#2-TCP-和-HTTP-连接" class="headerlink" title="2. TCP 和 HTTP 连接"></a>2. TCP 和 HTTP 连接</h3><ol>
<li>进行 TCP 三次握手</li>
<li>如果连接是 HTTPS，就还需要一个 HTTPS 握手：</li>
<li>首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。</li>
<li>服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的<strong>数字证书</strong>。</li>
<li>客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机码 key，并使用证书中的<strong>公钥</strong>对随机码 key 加密，然后发送给服务器端</li>
<li>服务器端接收后，使用自己的<strong>私钥</strong>对客户端发来的随机码 key 密，并使用该随机码 key 对传输数据进行加密并发送给客户端。客户端收到后会用自己的随机码 key 解密，完成加密过程。此后所有数据都通过该随机码加密之后传输。</li>
<li>发送 HTTP GET 请求，请求对应的 HTML 文档；</li>
<li>浏览器响应，返回该 HTML 文件，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。</li>
</ol>
<h3 id="3-浏览器显示网页"><a href="#3-浏览器显示网页" class="headerlink" title="3. 浏览器显示网页"></a>3. 浏览器显示网页</h3><ol>
<li>浏览器首先会根据 html 文件构建 DOM 树，对 HTML 中的标签进行词法解析。</li>
<li><strong>解析 css</strong>：并通过一些 css 选择器，确定每个 dom 节点的样式；即使没有 css，浏览器内部也有自己的样式. 这个过程中会想创建 dom 树一样创建 CSSOM, CSSOM 的特点如下:<ul>
<li>CSSOM 阻止任何东西渲染, 也就是说在 CSSOM 完全建立之前是不会展示界面的</li>
<li>CSSOM 在加载一个新页面时必须重新构建. 即使你的 CSS 文件被缓存了，也并不意味着这个已经构建好了的 CSSOM 可以应用到每一个页面。</li>
<li>CSSOM 是展示任何东西的必需品。在 CSSOM 构建之前，所有东西都不会展示，如果你阻塞了 CSSOM 的构建，CSSOM 的构建就会消耗更长的时间，这就意味着页面的渲染也需要更长的时间。</li>
</ul>
</li>
<li><strong>布局（Layout）</strong>，知道了每个节点的样式，还需要知道节点的位置：获取节点具体位置排版的过程叫做；主线程这时会通过像建立 dom 树一样的方式建立<strong>Layout Tree</strong>，每个节点上都记录元素的 xy 坐标、尺寸、边框等信息。layout 树是和展示在屏幕上的元素对应</li>
<li><strong>绘制（paint）</strong>：还需要知道一定的绘制顺序。主线程会遍历 Layout Tree 生成<strong>绘制记录表（Paint Record）</strong>，然后后续按照记录表顺序进行绘制。</li>
<li><strong>栅格化（Rastering）</strong>：把上面的 dom 树、绘制记录表、Layout Tree 等变成像素点展示在页面上<ul>
<li>这里介绍 chrome 栅格化方式的改进：现在采用的是合成方法，即对页面按一定规则分割成图层（Layer Tree），然后栅格化图层再进行拼接</li>
</ul>
</li>
</ol>
<p>这时主线程把信息传递给合成器线程，来把上面这些不同的表合成在一起</p>
<ol start="10">
<li><strong>分割图块（tiles）</strong>：把图层分割成图块，每个图块都有一个栅格进程进行栅格化</li>
<li><strong>合成器帧（Frame）</strong>：上一步栅格化之后，把每一部分存在 GPU 内存中；合成器线程收集（draw quads）的图块信息，拼接成合成器帧</li>
</ol>
<p>接下来会通过 ipc 传输给浏览器进程中的 UI 线程</p>
<ol start="12">
<li><strong>最后渲染</strong>：浏览器进程收到来自合成器帧拼接成的帧时，就会通过 GPU 渲染到屏幕上</li>
<li><strong>更新渲染</strong>：当页面变化，就会生成新的合成器帧，然后继续按照 11、12 步渲染到页面上</li>
</ol>
<p><img src="https://i.loli.net/2021/12/02/I2sC6cwBHkgYESK.png" alt="浏览器工作流程.png"></p>
<h1 id="网络安全相关"><a href="#网络安全相关" class="headerlink" title="网络安全相关"></a>网络安全相关</h1><h2 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h2><p>内容安全策略( CSP )是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等<br>CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。<br>启动 CSP 的方法有两种:</p>
<ul>
<li>通过 HTTP 头信息的 <code>Content-Security-Policy</code> 的字段</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: script-src &#x27;self&#x27;; object-src &#x27;none&#x27;;</span><br><span class="line">style-src cdn.example.org third-party.org; child-src https:;</span><br></pre></td></tr></table></figure>

<ul>
<li>另一种是通过网页的<meta>标签。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;script-src &#x27;self&#x27;; object-src &#x27;none&#x27;; style-src cdn.example.org ; child-src https:&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，CSP 做了如下配置:</p>
<ul>
<li>脚本：只信任当前域名</li>
<li><code>&lt;object&gt;</code>标签：不信任任何 URL，即不加载任何资源</li>
<li>样式表：只信任<a target="_blank" rel="noopener" href="http://cdn.example.org/">http://cdn.example.org</a></li>
<li>框架（frame）：必须使用 HTTPS 协议加载</li>
<li>其他资源：没有限制</li>
</ul>
<h2 id="XSS-攻击"><a href="#XSS-攻击" class="headerlink" title="XSS 攻击"></a>XSS 攻击</h2><p>XSS 即（<code>Cross Site Scripting</code>）中文名称为：跨站脚本攻击。<br>攻击者在网页插入一些 script 标签, 当用户浏览器加载到页面时会触发这段 script。攻击者会获取到比如 cookie 等信息，然后使用该信息来冒充合法用户<br>XSS 攻击最主要有如下分类：反射型、存储型、 DOM-based 型。</p>
<h3 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h3><p>反射型 XSS 指的是恶意脚本作为网络请求的一部分。<br>主要是通过恶意链接, 当用户点击恶意链接时, 会跳转到攻击者预先准备的界面然后会返回攻击者准备的 js 脚本，该 js 脚本就在浏览器中执行了<br>比如输入:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://sanyuan.com?q=&lt;script&gt;alert(&quot;你完蛋了&quot;)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在服务器端会拿到 q 参数,然后将内容返回给浏览器端，浏览器将这些内容作为 HTML 的一部分解析，发现是一个脚本，直接执行，这样就被攻击了。<br>之所以叫它反射型, 是因为恶意脚本是通过作为网络请求的参数，经过服务器，然后再反射到 HTML 文档中，执行解析。和存储型不一样的是，服务器并不会存储这些恶意脚本。</p>
<h3 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h3><p>主要是将恶意代码上传或存储到服务器中，下次只要受害者浏览包含此恶意代码的页面就会执行恶意代码。<br>因此存储型 XSS 的攻击步骤如下：</p>
<ol>
<li>攻击者将恶意代码提交到目标网站数据库中。</li>
<li>用户打开目标网站时，网站服务器将恶意代码从数据库中取出，然后拼接到 html 中返回给浏览器中。</li>
<li>用户浏览器接收到响应后解析执行，那么其中的恶意代码也会被执行。</li>
<li>那么恶意代码执行后，就能获取到用户数据，比如上面的 cookie 等信息，把该 cookie 发送到攻击者网站中，那么攻击者拿到该 cookie 然后会冒充该用户的行为，调用目标网站接口等违法操作。</li>
</ol>
<p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等</p>
<h3 id="DOM-based"><a href="#DOM-based" class="headerlink" title="DOM-based"></a>DOM-based</h3><p>DOM XSS 是基于文档对象模型的 XSS。一般情况下不需要经过服务端，是出现于前端的问题，比如直接将用户的输入通过<code>innerHTML</code>或者<code>document.write</code>打印在页面上，就有可能执行恶意代码。</p>
<p>恶意输入的来源可能有：</p>
<ul>
<li>用于输入的地方，比如 input、textarea</li>
<li>url 栏，js 脚本可能会检测 url 的变化并把其中的某些参数取出来直接插入 dom</li>
</ul>
<h3 id="XSS-的预防"><a href="#XSS-的预防" class="headerlink" title="XSS 的预防"></a>XSS 的预防</h3><p>详见<a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/09/27/fe-security.html">https://tech.meituan.com/2018/09/27/fe-security.html</a></p>
<p>XSS 主要是要预防恶意代码的执行，即：</p>
<ol>
<li><code>innerHTML</code>的使用<br>最主要的方式是对后端返回的数据，尤其是字符串进行转义。因为如果使用原本返回的字符，有可能导致被插入<code>&lt;script&gt;</code>脚本：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">&quot;/...&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> text = <span class="keyword">await</span> res.json(); <span class="comment">// 比如说这里的text是 `&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>).innerHTML = text;</span><br><span class="line"></span><br><span class="line"><span class="comment">// html</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="string">&#x27;xss&#x27;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>; <span class="comment">// 这里就会执行该段恶意代码</span></span><br></pre></td></tr></table></figure>

<p>比较好的方式是将发来的字符串转码，再插入 dom，但是转码之后可能导致显示异常，或者无法获取到正常的输出，应该尽量避免转码的方式。<br>或者根本就不使用<code>innerHTML</code>方法，在框架中表现为不使用<code>v-html/_dangerouslySetInnerHTML</code>直接转成 html 的方法，就可以有效避免。</p>
<ol start="2">
<li><p><code>&lt;a&gt;</code>标签的<code>href</code>属性，要注意不能携带<code>&#39;javascript:xxx&#39;</code>这样会导致直接执行 js 的 url；要禁止以 <code>javascript:</code> 开头的链接，或者直接选择白名单形式，只允许<code>http: https:</code>才可以作为 href 属性。</p>
</li>
<li><p>对于 js，要小心能直接运行字符串代码的函数，比如<code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code>，或者能直接在 html 属性中运行 js 代码的事件监听<code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等</p>
</li>
<li><p>过滤用户输入，即过滤用户在表单等地方输入的字符，不仅是前端要过滤非法字符，同时存储到数据库或者读取数据时也要过滤，或者采用第一种的转码方式。</p>
</li>
<li><p>对 cookie 添加<code>HttpOnly</code>字段，不允许 js 读取，直接从源头上防止。</p>
</li>
</ol>
<h2 id="CSRF-攻击"><a href="#CSRF-攻击" class="headerlink" title="CSRF 攻击"></a>CSRF 攻击</h2><h3 id="原理解释"><a href="#原理解释" class="headerlink" title="原理解释"></a>原理解释</h3><p>跨站请求伪造（Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 上执行非本意的操作的攻击方法。<br>简单来说，攻击者诱导你登录一个跟你想登录的网站很类似的网站, 该网站可以利用 form 表单或者其他方式，向具有你信息的网站发送请求，网站的接口请求格式一般很容易获取到，请求会自动携带上网站的 cookie 信息，即你的身份验证信息<br>举个栗子<br>比如原先你的操作是获取你有多少钱, 这里使用的是 GET 请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.mybank.com/userdata?toBankId=11&amp;money=1000</span><br></pre></td></tr></table></figure>

<p>危险网站 B，它里面有一段 HTML 的代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://www.mybank.com/userdata?toBankId=11&amp;money=1000&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>当你登录 A 的时候, 同时打开了 B 网站的这个链接, 你的浏览器会带上你的银行网站 A 的 Cookie 发出 Get 请求，去获取资源<code>http://www.mybank.com/userdata?toBankId=11&amp;money=1000</code>，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作</p>
<p>再举个栗子<br>比如银行使用 POST 方法更新数据<br>这时危险网站就可以通过表单提交的方式伪造数据</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">name</span>=<span class="string">&quot;transfer&quot;</span> <span class="attr">action</span>=<span class="string">&quot;http://www.myBank.com/userdata&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;toBankId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;11&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;money&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1000&quot;</span> /&gt;</span> 　　　　　　</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>cookie可以通过设置使得从一个页面跳转到的新页面仍然可以使用原页面的cookie（Samesite属性的lax值），可能会导致csrf攻击。如果把这个值设置成Strict，相当于完全不允许其他网站访问，能最大程度避免csrf攻击。</p>
</blockquote>
<h3 id="防范手段"><a href="#防范手段" class="headerlink" title="防范手段"></a>防范手段</h3><ul>
<li>Token<br>由服务端生成一个 token，返回给前端，在每次发送请求中，在参数中额外参加一个参数，例如 <code>csrf_token</code> , 服务端每次校验时对比 <code>csrf_token</code> 与服务端存储的值。</li>
<li>同源检测<br>根据 HTTP 协议，在 HTTP 头中有一个字段叫 <code>Referer</code>，记录了该 HTTP 请求的来源地址。可以借助来判断请求来源, 不是安全的就排除</li>
<li>设置 cookie 的 samesite，只有同源网站才可以访问。</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/">日常学习</a></div><div class="post_share"><div class="social-share" data-image="/img/web.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/04/blog28-bom/"><img class="prev-cover" src="/img/Chrome.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">BOM和ES6新Api</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/02/blog26-browser/"><img class="next-cover" src="/img/Chrome.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">浏览器知识学习总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/11/06/blog11-myReact/" title="react知识点汇总和使用小总结(一)"><img class="cover" src="/img/react.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-06</div><div class="title">react知识点汇总和使用小总结(一)</div></div></a></div><div><a href="/2021/10/27/blog10-react-router/" title="react-router的使用"><img class="cover" src="/img/reactrouter.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-27</div><div class="title">react-router的使用</div></div></a></div><div><a href="/2021/11/20/blog14-react-ts-basic/" title="typescript+react基础部分"><img class="cover" src="/img/typescript.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-20</div><div class="title">typescript+react基础部分</div></div></a></div><div><a href="/2021/11/22/blog17-react-pubsub-issues/" title="react+typescript使用pubsub时的一点小问题"><img class="cover" src="/img/pubsub.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-22</div><div class="title">react+typescript使用pubsub时的一点小问题</div></div></a></div><div><a href="/2021/11/20/blog16-react-ts-hooks-redux/" title="typescript+react:自定义hooks代替redux"><img class="cover" src="/img/typescript.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-20</div><div class="title">typescript+react:自定义hooks代替redux</div></div></a></div><div><a href="/2021/11/25/blog18-vue3ts-basic/" title="vue3+ts配置及简单使用注意"><img class="cover" src="/img/vue3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-25</div><div class="title">vue3+ts配置及简单使用注意</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/pinkstar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xing Ye</div><div class="author-info__description">a singleThreaded boy's blog</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/penghei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/penghei" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:632885485@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">A SingleThreaded Boy...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">网络基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E9%97%B4%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.</span> <span class="toc-text">协议间关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5-%E8%B6%85%E9%93%BE%E6%8E%A5"><span class="toc-number">1.2.</span> <span class="toc-text">链接&#x2F;超链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#URL"><span class="toc-number">1.3.</span> <span class="toc-text">URL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#URL-%E7%9A%84%E7%BC%96%E7%A0%81"><span class="toc-number">1.3.1.</span> <span class="toc-text">URL 的编码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D"><span class="toc-number">1.4.</span> <span class="toc-text">域名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MIME"><span class="toc-number">1.5.</span> <span class="toc-text">MIME</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F"><span class="toc-number">1.6.</span> <span class="toc-text">跨域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-number">1.6.1.</span> <span class="toc-text">同源策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CORS"><span class="toc-number">1.6.2.</span> <span class="toc-text">CORS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">简单请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">非简单请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSONP"><span class="toc-number">1.6.3.</span> <span class="toc-text">JSONP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">1.6.4.</span> <span class="toc-text">Nginx 反向代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-proxy-middleware"><span class="toc-number">1.6.5.</span> <span class="toc-text">http-proxy-middleware</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.7.</span> <span class="toc-text">网络模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%89%B4%E6%9D%83%E6%A0%A1%E9%AA%8C%E7%9B%B8%E5%85%B3"><span class="toc-number">1.8.</span> <span class="toc-text">鉴权校验相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Session"><span class="toc-number">1.8.1.</span> <span class="toc-text">Session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Token%EF%BC%88%E4%BB%A4%E7%89%8C%EF%BC%89"><span class="toc-number">1.8.2.</span> <span class="toc-text">Token（令牌）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Access-Token"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">Access Token</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Refresh-Token"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">Refresh Token</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JWT"><span class="toc-number">1.8.3.</span> <span class="toc-text">JWT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OAuth"><span class="toc-number">1.8.4.</span> <span class="toc-text">OAuth</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSO"><span class="toc-number">1.8.5.</span> <span class="toc-text">SSO</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text">应用层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-number">2.2.</span> <span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E7%82%B9"><span class="toc-number">2.2.1.</span> <span class="toc-text">基本特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E7%BB%AD%E5%92%8C%E9%9D%9E%E6%8C%81%E7%BB%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.2.2.</span> <span class="toc-text">持续和非持续连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E6%8A%A5%E6%96%87"><span class="toc-number">2.2.3.</span> <span class="toc-text">HTTP 报文</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">请求报文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">响应报文</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E5%AD%97%E6%AE%B5"><span class="toc-number">2.2.4.</span> <span class="toc-text">HTTP 字段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-Request-Header-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">HTTP Request Header 常见的请求头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-Responses-Header-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">HTTP Responses Header 常见的响应头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%9E%E4%BD%93%E9%A6%96%E9%83%A8"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">常见的实体首部</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.5.</span> <span class="toc-text">HTTP 请求方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">2.2.6.</span> <span class="toc-text">HTTP 状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie"><span class="toc-number">2.2.7.</span> <span class="toc-text">cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS"><span class="toc-number">2.2.8.</span> <span class="toc-text">HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#https-%E7%9A%84%E5%AE%89%E5%85%A8%E4%BE%9D%E6%8D%AE"><span class="toc-number">2.2.8.1.</span> <span class="toc-text">https 的安全依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.8.2.</span> <span class="toc-text">基本流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SSL-TLS"><span class="toc-number">2.2.8.3.</span> <span class="toc-text">SSL&#x2F;TLS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP1-1-HTTP2-0"><span class="toc-number">2.2.9.</span> <span class="toc-text">HTTP1.1 HTTP2.0</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP1-0"><span class="toc-number">2.2.9.1.</span> <span class="toc-text">HTTP1.0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP1-1"><span class="toc-number">2.2.9.2.</span> <span class="toc-text">HTTP1.1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP2-0"><span class="toc-number">2.2.9.3.</span> <span class="toc-text">HTTP2.0</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E4%BB%A3%E7%90%86"><span class="toc-number">2.2.10.</span> <span class="toc-text">HTTP 代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E5%AD%97%E6%AE%B5"><span class="toc-number">2.2.10.1.</span> <span class="toc-text">代理字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98"><span class="toc-number">2.2.10.2.</span> <span class="toc-text">代理缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E7%BC%93%E5%AD%98"><span class="toc-number">2.2.11.</span> <span class="toc-text">HTTP 缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.2.11.1.</span> <span class="toc-text">缓存的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#http-%E7%BC%93%E5%AD%98"><span class="toc-number">2.2.11.2.</span> <span class="toc-text">http 缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98"><span class="toc-number">2.2.11.3.</span> <span class="toc-text">强缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-number">2.2.11.4.</span> <span class="toc-text">协商缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6-GET"><span class="toc-number">2.2.11.5.</span> <span class="toc-text">条件 GET</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD"><span class="toc-number">2.2.12.</span> <span class="toc-text">HTTP 其他功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%EF%BC%88%E5%88%86%E6%AE%B5%E4%BC%A0%E8%BE%93%EF%BC%89"><span class="toc-number">2.2.12.1.</span> <span class="toc-text">大文件传输（分段传输）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS"><span class="toc-number">2.3.</span> <span class="toc-text">DNS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">查询过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CDN"><span class="toc-number">2.4.</span> <span class="toc-text">CDN</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text">传输层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP"><span class="toc-number">3.1.</span> <span class="toc-text">UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-%E7%89%B9%E7%82%B9"><span class="toc-number">3.1.1.</span> <span class="toc-text">UDP 特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP"><span class="toc-number">3.2.</span> <span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E7%89%B9%E7%82%B9"><span class="toc-number">3.2.1.</span> <span class="toc-text">TCP 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E6%8A%A5%E6%96%87%E6%AE%B5"><span class="toc-number">3.2.2.</span> <span class="toc-text">TCP 报文段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%8F%B7%E5%92%8C%E7%A1%AE%E8%AE%A4%E5%8F%B7"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">序号和确认号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-number">3.2.3.</span> <span class="toc-text">TCP 的可靠数据传输</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">超时重传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">快速重传</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">3.2.4.</span> <span class="toc-text">TCP 流量控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">3.2.5.</span> <span class="toc-text">TCP 拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="toc-number">3.2.5.1.</span> <span class="toc-text">慢启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D"><span class="toc-number">3.2.5.2.</span> <span class="toc-text">拥塞避免</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D"><span class="toc-number">3.2.5.3.</span> <span class="toc-text">快速恢复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">3.2.6.</span> <span class="toc-text">TCP 三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">3.2.7.</span> <span class="toc-text">TCP 四次挥手</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">4.</span> <span class="toc-text">网络层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IP%EF%BC%88IPv4%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">IP（IPv4）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IP-%E6%95%B0%E6%8D%AE%E6%8A%A5"><span class="toc-number">4.1.1.</span> <span class="toc-text">IP 数据报</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP-%E7%BC%96%E5%9D%80"><span class="toc-number">4.1.2.</span> <span class="toc-text">IP 编址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E7%BD%91"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">子网</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">地址分类</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-number">5.</span> <span class="toc-text">链路层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82%E5%AF%BB%E5%9D%80%EF%BC%88MAC%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">链路层寻址（MAC）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARP-%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.2.</span> <span class="toc-text">ARP 协议</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5-url-%E5%88%B0%E6%98%BE%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">从浏览器输入 url 到显示的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9C"><span class="toc-number">6.0.1.</span> <span class="toc-text">0. 连接网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%A7%A3%E6%9E%90-URL"><span class="toc-number">6.0.2.</span> <span class="toc-text">1. 解析 URL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-TCP-%E5%92%8C-HTTP-%E8%BF%9E%E6%8E%A5"><span class="toc-number">6.0.3.</span> <span class="toc-text">2. TCP 和 HTTP 连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E7%BD%91%E9%A1%B5"><span class="toc-number">6.0.4.</span> <span class="toc-text">3. 浏览器显示网页</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3"><span class="toc-number">7.</span> <span class="toc-text">网络安全相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CSP"><span class="toc-number">7.1.</span> <span class="toc-text">CSP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XSS-%E6%94%BB%E5%87%BB"><span class="toc-number">7.2.</span> <span class="toc-text">XSS 攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%9E%8B"><span class="toc-number">7.2.1.</span> <span class="toc-text">反射型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%9E%8B"><span class="toc-number">7.2.2.</span> <span class="toc-text">存储型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-based"><span class="toc-number">7.2.3.</span> <span class="toc-text">DOM-based</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS-%E7%9A%84%E9%A2%84%E9%98%B2"><span class="toc-number">7.2.4.</span> <span class="toc-text">XSS 的预防</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSRF-%E6%94%BB%E5%87%BB"><span class="toc-number">7.3.</span> <span class="toc-text">CSRF 攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A"><span class="toc-number">7.3.1.</span> <span class="toc-text">原理解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E8%8C%83%E6%89%8B%E6%AE%B5"><span class="toc-number">7.3.2.</span> <span class="toc-text">防范手段</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/05/18/projects/" title="无题"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/05/18/projects/" title="无题">无题</a><time datetime="2022-05-18T02:57:57.356Z" title="发表于 2022-05-18 10:57:57">2022-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/13/handwriting/" title="js题目"><img src="/img/JS.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="js题目"/></a><div class="content"><a class="title" href="/2022/05/13/handwriting/" title="js题目">js题目</a><time datetime="2022-05-13T04:21:10.000Z" title="发表于 2022-05-13 12:21:10">2022-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/12/OS/" title="操作系统知识点总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统知识点总结"/></a><div class="content"><a class="title" href="/2022/05/12/OS/" title="操作系统知识点总结">操作系统知识点总结</a><time datetime="2022-05-12T07:58:22.000Z" title="发表于 2022-05-12 15:58:22">2022-05-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/05/blog43-algorithms/" title="算法学习总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法学习总结"/></a><div class="content"><a class="title" href="/2022/04/05/blog43-algorithms/" title="算法学习总结">算法学习总结</a><time datetime="2022-04-05T08:01:22.000Z" title="发表于 2022-04-05 16:01:22">2022-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/05/blog44-optimization/" title="优化问题总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="优化问题总结"/></a><div class="content"><a class="title" href="/2022/04/05/blog44-optimization/" title="优化问题总结">优化问题总结</a><time datetime="2022-04-05T08:01:22.000Z" title="发表于 2022-04-05 16:01:22">2022-04-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Xing Ye</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hello stranger!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>