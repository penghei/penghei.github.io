<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>js更深入学习 | XingYeBlog</title><meta name="keywords" content="日常学习"><meta name="author" content="Xing Ye,632885485@qq.com"><meta name="copyright" content="Xing Ye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="对象深拷贝比如现在有一个对象： 12345678let obj1 &#x3D; &amp;#123;  name: &quot;zzx&quot;,  age: 19,  info: &amp;#123;    height: 175,    weight: 80,  &amp;#125;,&amp;#125;;  首先要了解,js 中普通的数据类型在复制时是复制值,而对象和数组等引用类型是复制地址所以当我们直接let obj2 &#x3D; ob">
<meta property="og:type" content="article">
<meta property="og:title" content="js更深入学习">
<meta property="og:url" content="http://example.com/2021/12/05/blog30-js-deeping/index.html">
<meta property="og:site_name" content="XingYeBlog">
<meta property="og:description" content="对象深拷贝比如现在有一个对象： 12345678let obj1 &#x3D; &amp;#123;  name: &quot;zzx&quot;,  age: 19,  info: &amp;#123;    height: 175,    weight: 80,  &amp;#125;,&amp;#125;;  首先要了解,js 中普通的数据类型在复制时是复制值,而对象和数组等引用类型是复制地址所以当我们直接let obj2 &#x3D; ob">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/JS.png">
<meta property="article:published_time" content="2021-12-05T13:21:10.000Z">
<meta property="article:modified_time" content="2021-12-09T18:29:51.396Z">
<meta property="article:author" content="Xing Ye">
<meta property="article:tag" content="日常学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/JS.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2021/12/05/blog30-js-deeping/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'js更深入学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-10 02:29:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/pinkstar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/JS.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XingYeBlog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">js更深入学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-05T13:21:10.000Z" title="发表于 2021-12-05 21:21:10">2021-12-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-09T18:29:51.396Z" title="更新于 2021-12-10 02:29:51">2021-12-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>51分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="js更深入学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="对象深拷贝"><a href="#对象深拷贝" class="headerlink" title="对象深拷贝"></a>对象深拷贝</h1><p>比如现在有一个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;zzx&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">19</span>,</span><br><span class="line">  <span class="attr">info</span>: &#123;</span><br><span class="line">    <span class="attr">height</span>: <span class="number">175</span>,</span><br><span class="line">    <span class="attr">weight</span>: <span class="number">80</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先要了解,js 中普通的数据类型在复制时是复制值,而对象和数组等引用类型是复制地址<br>所以当我们直接<code>let obj2 = obj1</code>并不能复制,只是复制了 obj1 的地址<br>所以我们需要有一个拷贝的方法,可以保证新对象与源对象不一样</p>
<ul>
<li>Object.assign</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br></pre></td></tr></table></figure>

<ul>
<li>展开运算符</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2 = &#123; ...obj1 &#125;;</span><br></pre></td></tr></table></figure>

<p>而如果数组/对象互相嵌套,就需要进行深拷贝,方法有:</p>
<ul>
<li>JSON<br>原理是 JSON.parse 转换的依据是 JSON.stringify 生成的字符串而不是原先的 obj</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* JSON先转字符串再转回来的方法可以实现 */</span></span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1));</span><br></pre></td></tr></table></figure>

<ul>
<li>递归</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepAssign</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newObj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      newObj[key] =</span><br><span class="line">        <span class="keyword">typeof</span> obj[key] === <span class="string">&quot;object&quot;</span> <span class="comment">//这一步是关键,如果属性是对象就递归,如果不是就赋值</span></span><br><span class="line">          ? deepAssign(obj[key])</span><br><span class="line">          : obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>lodash 库函数 cloneDeep</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2 = _.cloneDeep(obj1);</span><br></pre></td></tr></table></figure>

<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>Symbol 可以理解为一个对象的<strong>隐藏</strong>属性, 而在构造函数或者类中还可以作为方法使用, 在内建类中起到很重要作用<br>创建方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> userId = <span class="built_in">Symbol</span>(<span class="string">&quot;myId&quot;</span>); <span class="comment">//创建一个symbol, myId是userId的description,也是之后通过for方法引用的</span></span><br><span class="line">obj[userId] = <span class="string">&quot;0001&quot;</span>; <span class="comment">//使用创建symbol时的变量值引用</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[userId]);</span><br></pre></td></tr></table></figure>

<ul>
<li>Symbol 的参数是它的 description, 可以方便在后续使用(比如 for 方法)</li>
<li>Symbol 只能用方括号访问, 值是定义 Symbol 时的赋值而不是 description</li>
<li>也可以直接这样定义:(注意要先声明 Symbol)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userId = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xiaohong&quot;</span>,</span><br><span class="line">  [userId]: <span class="string">&quot;0002&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Symbol 的特点:</p>
<ol>
<li>不会被 forin/for 循环等遍历,用 Object.keys 也不会访问,即对外部方法不可见</li>
<li>任何两个 symbol 都不相等,即使 description 相同</li>
<li>可以被 Object.assign/展开运算符等浅拷贝复制</li>
<li>Symbol 提供了很多内置属性,用于在对象,构造函数,类等中使用,比如后面的 Symbol.iterator 迭代器对象,或者 Symbol.instance 用于更改 instanceof 访问对象</li>
</ol>
<p>Symbol 相关方法:</p>
<ul>
<li>Symbol.for():获取或创建一个<strong>全局的</strong>symbol 对象, 比如<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>.for(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> userId = <span class="built_in">Symbol</span>.for(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">id === userId;</span><br></pre></td></tr></table></figure>
他和直接 Symbol()的区别在于:<ul>
<li>会被登记在全局环境中供搜索</li>
<li>每次调用都会返回同一个 Symbol 值,但调用很多次 Symbol()会返回不同的值</li>
</ul>
</li>
<li>Symbol.keyFor():for 的反向调用, 参数是 Symbol 赋给的变量<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>.for(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(id);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="迭代器和可迭代"><a href="#迭代器和可迭代" class="headerlink" title="迭代器和可迭代"></a>迭代器和可迭代</h1><h2 id="forof-和-forin"><a href="#forof-和-forin" class="headerlink" title="forof 和 forin"></a>forof 和 forin</h2><ul>
<li>for…of 循环可以使用的范围包括<ul>
<li>数组</li>
<li>Set 和 Map</li>
<li>某些类似数组的对象（比如 arguments/DOM NodeList）</li>
<li>Generator</li>
<li>字符串</li>
</ul>
</li>
<li>for…in 以任意顺序遍历一个<strong>对象</strong>的除 Symbol 以外的可枚举属性<ul>
<li>常用于对象属性的遍历,比如<code>for(let key in obj)&#123;&#125;</code></li>
<li>属性特征值被设置不可枚举的不能被遍历</li>
<li>Symbol 不可以</li>
</ul>
</li>
</ul>
<h2 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h2><p>一般我们称可以被按一定顺序遍历的对象为可迭代对象, 更具体的概念是可以使用 for…of 的对象(注意不是 for…in)<br>可迭代对象主要有以下两类:</p>
<ul>
<li>数组等本身可遍历的对象</li>
<li>添加了迭代器的对象</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>正常来说, 对象是不能使用 forof 遍历的(不是可迭代对象), 但是我们可以手动添加一个迭代器<br>迭代器特点:</p>
<ul>
<li>在对象中是一个方法</li>
<li>以<code>[Symbol.iterator]</code>作为方法名</li>
<li>返回一个迭代器对象, 内部有:<ul>
<li>一些数据, 用于限制迭代次数(不是必须)</li>
<li>有一个 next()函数,每次迭代都会调用这个函数,这个函数将会返回 <code>&#123;done:.., value :...&#125;</code> 格式的对象(必须)</li>
</ul>
</li>
<li>另外, 可迭代对象也可以用展开运算符展开</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="attr">from</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">to</span>: <span class="number">5</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">range[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">current</span>: <span class="built_in">this</span>.from,</span><br><span class="line">    <span class="attr">last</span>: <span class="built_in">this</span>.to,</span><br><span class="line">    <span class="comment">//next() 在 for..of 的每一轮循环迭代中被调用</span></span><br><span class="line">    <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.current &lt;= <span class="built_in">this</span>.last) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="built_in">this</span>.current++ &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//效果:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> range) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125; <span class="comment">//12345</span></span><br><span class="line"><span class="built_in">console</span>.log([...range]);</span><br></pre></td></tr></table></figure>

<p>不止是对象, 对于一个<strong>返回迭代器对象</strong>的函数也可以迭代<br>比如封装一个 range 函数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRange</span>(<span class="params"><span class="keyword">from</span>, to</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">from</span>,</span><br><span class="line">    to,</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">current</span>: <span class="built_in">this</span>.from,</span><br><span class="line">        <span class="attr">last</span>: <span class="built_in">this</span>.to,</span><br><span class="line">        <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">this</span>.current &lt;= <span class="built_in">this</span>.last) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="built_in">this</span>.current++ &#125;;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> createRange(<span class="number">1</span>, <span class="number">10</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125; <span class="comment">//10遍hello world</span></span><br></pre></td></tr></table></figure>

<h2 id="arrayLike"><a href="#arrayLike" class="headerlink" title="arrayLike"></a>arrayLike</h2><p>对于一些像数组的对象, 我们可以通过<code>Array.from()</code>变成真正的数组<br>像数组的对象有以下特点:</p>
<ul>
<li>键名为数字, 或者数字型的字符(比如’1’)</li>
<li>有 length 属性</li>
<li>本身没有数组相关方法, 比如 push pop<br>举个栗子:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrLike = &#123;</span><br><span class="line">  <span class="comment">//声明一个类数组对象,特点是键名为数字,并且有length属性</span></span><br><span class="line">  <span class="comment">//可以是任意数字</span></span><br><span class="line">  <span class="number">2</span>: <span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&quot;bbb&quot;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span>, <span class="comment">//不声明长度将会是空</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arrFrom = <span class="built_in">Array</span>.from(arrLike); <span class="comment">//[undefined,&#x27;bbb&#x27;,&#x27;aaa&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>from 方法也可以用于可迭代对象的转化,结果就是迭代范围的一个数组</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrRange = <span class="built_in">Array</span>.from(range); <span class="comment">//[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>

<p>实际上,<strong>js 的数组就是一个键为序号数字,值为任意元素的对象</strong></p>
<h1 id="Map-和-Set"><a href="#Map-和-Set" class="headerlink" title="Map 和 Set"></a>Map 和 Set</h1><p>Map 和 Set 都是一种类对象的数据类型, 都是通过构造函数方法创建</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="Map-的特点"><a href="#Map-的特点" class="headerlink" title="Map 的特点"></a>Map 的特点</h3><ul>
<li>Map 是一种键可以为任意值的对象, 对象的键一般只能是字符串, map 的键可以是数字/布尔值等任何类型</li>
<li>本身可迭代</li>
<li>值和键只能通过 get 和 set 等方法获取, 不能像对象一样用<code>.</code>获取;<strong>注意 set 和 get 都返回 map 本身,所以可以链式调用</strong></li>
<li>创建 map 可以用一组每个为一个键值对的数组(如下)传入<br>比如:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="literal">true</span>, <span class="string">&quot;hello&quot;</span>).set(<span class="literal">false</span>, <span class="number">20</span>).set(<span class="number">12</span>, <span class="string">&quot;12&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="literal">true</span>)); <span class="comment">//&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">const</span> mapByArr = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;apple&quot;</span>, <span class="number">10</span>],</span><br><span class="line">  [<span class="literal">false</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="number">12</span>, <span class="string">&quot;12&quot;</span>],</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<h3 id="Map-迭代"><a href="#Map-迭代" class="headerlink" title="Map 迭代"></a>Map 迭代</h3><p>如果要在 map 里使用循环，可以使用以下三个方法：</p>
<ul>
<li>map.keys() —— 遍历并返回所有的键</li>
<li>map.values() —— 遍历并返回所有的值</li>
<li>map.entries() —— 遍历并返回所有的键值对</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> mapByArr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> mapByArr.keys()) &#123;</span><br><span class="line">  <span class="comment">//遍历map对象需要用keys()等方法,返回一个可迭代的包含键值信息的数组,</span></span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> mapByArr.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> mapByArr.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map-和对象相互转化"><a href="#Map-和对象相互转化" class="headerlink" title="Map 和对象相互转化"></a>Map 和对象相互转化</h3><ul>
<li>Object.entries 可以把已有对象转成 map 对象</li>
<li>Object.fromEntries<strong>给定一个 [key, value] 键值对的数组</strong>，它会根据给定数组创建一个对象. 注意不是一个直接的 Map 对象.这个创建方法和上面的 Map 构造函数参数很像</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> userMap = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(user)); <span class="comment">//这种方法可以把已有对象转成map对象</span></span><br><span class="line"><span class="keyword">const</span> objFromMap = <span class="built_in">Object</span>.fromEntries([</span><br><span class="line">  [<span class="string">&quot;banana&quot;</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="string">&quot;orange&quot;</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="string">&quot;meat&quot;</span>, <span class="number">4</span>],</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="Set-的特点"><a href="#Set-的特点" class="headerlink" title="Set 的特点"></a>Set 的特点</h3><ul>
<li>Set 只有值没有键, 并且不可重复</li>
<li>跟 Map 一样,可迭代,不可直接访问,要借助 Set 自带的方法</li>
</ul>
<h3 id="Set-的主要方法"><a href="#Set-的主要方法" class="headerlink" title="Set 的主要方法"></a>Set 的主要方法</h3><ul>
<li>new Set(iterable) : 创建一个 set，<strong>如果提供了一个 iterable 对象（通常是数组）,将会从数组里面复制值到 set 中</strong></li>
<li>set.add(value) : 添加值,也是返回 set 本身,可以链式调用. 创建 set 还可以使用一个数组</li>
<li>set.delete(value) : 删除值</li>
<li>set.has(value):是否存在值</li>
<li>set.clear():清空</li>
<li>set.size:返回元素个数。<br>set 也有像 map 一样的 keys()/values()/entries()方法, <em>虽然没有键</em></li>
<li>set.keys() —— 遍历并返回所有的值（returns an iterable object for values），</li>
<li>set.values() —— 与 set.keys() 作用相同，这是为了兼容 Map，</li>
<li>set.entries() —— 遍历并返回所有的实体（returns an iterable object for entries）[value, value]，它的存在也是为了兼容 Map。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">let</span> xiaoming = &#123; <span class="attr">name</span>: <span class="string">&quot;xiaoming&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> xiaohong = &#123; <span class="attr">name</span>: <span class="string">&quot;xiaohong&quot;</span> &#125;;</span><br><span class="line">set.add(xiaoming).add(xiaoming).add(xiaohong);</span><br><span class="line"><span class="built_in">console</span>.log(set.size); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>这里添加了两次 xiaoming,但是因为重复所以值加入了一个<br>注意,<strong>当添加的是引用对象时不会自动去重</strong>,比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">set</span><br><span class="line">  .add(&#123; <span class="attr">name</span>: <span class="string">&quot;xiaoming&quot;</span> &#125;)</span><br><span class="line">  .add(&#123; <span class="attr">name</span>: <span class="string">&quot;xiaoming&quot;</span> &#125;)</span><br><span class="line">  .add(&#123; <span class="attr">name</span>: <span class="string">&quot;xiaohong&quot;</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(set.size); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>原因是引用对象的两个<code>&#123;name:&#39;xiaoming&#39;&#125;</code>本质上不算一个值(两种地址), 所以不会被去重;上面一个例子的两个 xiaoming 是同一个地址,所以会被去重</p>
<h3 id="Set-迭代"><a href="#Set-迭代" class="headerlink" title="Set 迭代"></a>Set 迭代</h3><p>可以使用 for..of 或 forEach 来遍历 Set：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setFromArr = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="number">100</span>, <span class="literal">true</span>]);</span><br><span class="line">setFromArr.forEach(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(val));</span><br></pre></td></tr></table></figure>

<p>或者用 set.keys/set.values/set.entries 等方法</p>
<h3 id="Set-的转换"><a href="#Set-的转换" class="headerlink" title="Set 的转换"></a>Set 的转换</h3><p>set 在类型上更像数组而不是对象, 所以 Set 可以用 Array.from 生成一个数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(arr); <span class="comment">//生成set</span></span><br><span class="line"><span class="keyword">const</span> arr1 = <span class="built_in">Array</span>.from(set); <span class="comment">//返回数组</span></span><br></pre></td></tr></table></figure>

<h3 id="Set-用于数组去重"><a href="#Set-用于数组去重" class="headerlink" title="Set 用于数组去重"></a>Set 用于数组去重</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrRepeated = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> setNoRepeat = <span class="keyword">new</span> <span class="built_in">Set</span>(arrRepeated);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(setNoRepeat));</span><br></pre></td></tr></table></figure>

<h1 id="对象属性配置"><a href="#对象属性配置" class="headerlink" title="对象属性配置"></a>对象属性配置</h1><h2 id="对象的默认属性"><a href="#对象的默认属性" class="headerlink" title="对象的默认属性"></a>对象的默认属性</h2><p>对象的每个属性都有对应的四个默认属性,分别为</p>
<ul>
<li>value: 本身的值</li>
<li>writable:默认 true, false 为只读</li>
<li>enumerable: 是否可枚举,false 即不会出现在 forin/object.keys 这种遍历中,直接打印也不会出现</li>
<li>configurable: 是否可配置,即不可删除/覆盖,也不能修改只读属性等,<strong>但是可以改属性值</strong><br>设置或更改属性的属性值使用 Object.defineProperty 方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;xiaohong&quot;</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>, <span class="comment">//只读</span></span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">//不可枚举,即不会出现在forin/object.keys这种遍历中,直接打印也不会出现</span></span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">//不可配置,即不可删除/覆盖,也不能修改只读属性等,但是可以改属性值</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>获取属性可以用 getOwnPropertyDescriptor 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(user, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">/* 属性描述符：</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &quot;value&quot;: &quot;xiaoming&quot;,</span></span><br><span class="line"><span class="comment">  &quot;writable&quot;: true,</span></span><br><span class="line"><span class="comment">  &quot;enumerable&quot;: true,</span></span><br><span class="line"><span class="comment">  &quot;configurable&quot;: true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="getter-和-setter"><a href="#getter-和-setter" class="headerlink" title="getter 和 setter"></a>getter 和 setter</h2><blockquote>
<p>getter 和 setter 是对象的访问器属性。它们本质上是用于获取和设置值的<strong>函数</strong>，但<strong>从外部代码来看就像常规属性</strong></p>
</blockquote>
<p>意思就是, getter 和 setter 定义为函数, 但访问是用属性的方式访问<br>getter 和 setter 的主要特点为:</p>
<ul>
<li>getter 和 setter 是属性不是方法,得用属性的形式访问</li>
<li>定义一个 getter 的方法是 <code>get funcname()&#123;&#125;</code>,相当于 get 后面一个正常的方法, get 只是一个修饰符;</li>
<li>setter 需要一个参数, 作为设置的值;getter 不设返回值就无法获取访问结果(下面的 student.name 会是 undefined)</li>
</ul>
<p>比如这个例子中,get 和 set 是属性不是方法,得用属性的形式访问而不是 name(‘xx’)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> student = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val.length &lt; <span class="number">3</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//长度短不予设置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">this</span>._name = val;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//注意,</span></span><br><span class="line">student.name = <span class="string">&quot;aa&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(student.name); <span class="comment">//undefined</span></span><br><span class="line">student.name = <span class="string">&quot;xiaoming&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(student.name); <span class="comment">//设置成功</span></span><br></pre></td></tr></table></figure>

<p>同理我们也可以用 defineProperty 给对象加 getter 和 setter</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">&quot;birthday&quot;</span>, &#123;</span><br><span class="line">  <span class="comment">//通过define给对象加属性</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">return</span> date.getFullYear() - <span class="built_in">this</span>.age;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="built_in">this</span>.age = date.getFullYear() - val;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">user.birthday = <span class="number">2002</span>; <span class="comment">//触发set,改动了age</span></span><br><span class="line"><span class="built_in">console</span>.log(user.birthday, user.age); <span class="comment">//birthday的访问通过get</span></span><br></pre></td></tr></table></figure>

<p>这里有一个 this 指向的问题, 也适用于后面的类和构造函数:<br><strong>this 的指向始终只和.之前的值有关,跟内部引用和定义没关系</strong><br>另外, 类和构造函数也可以加 getter, 在其实例的访问时会调用该 getter</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">birthday</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.birthday = birthday;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, <span class="string">&quot;age&quot;</span>, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> todayYear = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">      <span class="keyword">return</span> todayYear - <span class="built_in">this</span>.birthday.getFullYear();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> john = <span class="keyword">new</span> User(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2002</span>, <span class="number">6</span>, <span class="number">1</span>));</span><br><span class="line">join.age; <span class="comment">//触发getter, 返回计算值19</span></span><br></pre></td></tr></table></figure>

<h1 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h1><p>在 js 中, 函数本质也是个对象, 因此函数也有对象的一些属性<br>一个空函数:<br><img src="https://pic.imgdb.cn/item/61b0c2282ab3f51d915ba4b5.png"></p>
<ul>
<li>prototype 是函数固有的原型对象(原型链会讲到)</li>
<li>name:函数名</li>
<li>length:函数参数数量</li>
<li>arguemnts:函数参数(返回一个数组)<br>以及一些方法</li>
</ul>
<h2 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h2><p>因为函数本质也是个对象, 所以我们可以给函数本身添加一些属性,比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">  sayHello.counter++; <span class="comment">//使用函数名自定义属性</span></span><br><span class="line">&#125;</span><br><span class="line">sayHello.counter = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>每调用一次 sayHello, 内部的 counter 就会加一.注意这里 counter 相当于一个全局存储的变量, 通过函数对象直接访问,并存储在全局</p>
<h2 id="IFE"><a href="#IFE" class="headerlink" title="IFE"></a>IFE</h2><p>定义式的函数可以额外拥有一个内部的名字, 该函数名可以用于递归, 外部不可见</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sayHi = <span class="function"><span class="keyword">function</span> <span class="title">_sayHi</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (who) &#123;</span><br><span class="line">    alert(<span class="string">`Hello, <span class="subst">$&#123;who&#125;</span>`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _sayHi(<span class="string">&quot;Guest&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><h2 id="Prototype-和proto"><a href="#Prototype-和proto" class="headerlink" title="[[Prototype]]和proto"></a>[[Prototype]]和<strong>proto</strong></h2><blockquote>
<p>JavaScript 中，对象有一个特殊的隐藏属性 [[Prototype]],它要么为 null，要么就是对另一个对象的引用。该对象被称为“原型”<br>当我们从 object 中读取一个缺失的属性时，JavaScript 会自动从原型中获取该属性。在编程中，这种行为被称为“原型继承”</p>
</blockquote>
<p>[[Prototype]]和<strong>proto</strong>:</p>
<ul>
<li>[[Prototype]]不等于<strong>proto</strong>;</li>
<li><strong>proto</strong>是访问[[Prototype]]的一种方法, 也就是[[Prototype]]的 getter 和 setter</li>
<li><strong>proto</strong>是一种”旧时的访问方法”,应该用一些新方法代替</li>
</ul>
<h2 id="对象原型"><a href="#对象原型" class="headerlink" title="对象原型"></a>对象原型</h2><p>接下来的数据类型几乎都是以对象为例<br>一个对象内部可以设置其<strong>proto</strong>,或者在外部访问来设置这个对象的原型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animal = &#123;</span><br><span class="line">  <span class="attr">eats</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="function"><span class="title">walk</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`i can walk`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> rabbit = &#123;</span><br><span class="line">  <span class="attr">jump</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">__proto__</span>: animal, <span class="comment">//__proto__是[[Prototype]]的getter/setter,真正访问的是[[Prototype]]</span></span><br><span class="line">&#125;;</span><br><span class="line">rabbit.walk(); <span class="comment">//i can walk</span></span><br></pre></td></tr></table></figure>

<p>这里我们就说 rabbit 继承了 animal,或者说 animal 是 rabbit 的原型<br><img src="https://pic.imgdb.cn/item/61b0c20c2ab3f51d915b97ba.png"><br>如果再继承一个对象,就会像上面两个一样形成原型关系<br>继承的属性有几个特点:</p>
<ul>
<li>继承来的会被当做是”自己的”, 也就是说 forin 属性可以遍历到</li>
<li>如果父类有 getter/setter, 子类会继承并维护自己独立的 getter 值,即触发子类的 setter 不会影响父类</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">Name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = value;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">Name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> admin = &#123;</span><br><span class="line">  <span class="attr">__proto__</span>: user,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">admin.fullName; <span class="comment">//John</span></span><br><span class="line">admin.fullName = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line">admin.fullName; <span class="comment">//Jack</span></span><br><span class="line">user.fullName; <span class="comment">// John</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果想分辨哪些是自己的属性, 可以使用 hasOwnProperty</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> rabbit) <span class="built_in">console</span>.log(key); <span class="comment">//可以迭代到上一层的属性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> rabbit) &#123;</span><br><span class="line">  <span class="keyword">if</span> (rabbit.hasOwnProperty(key)) &#123;</span><br><span class="line">    <span class="comment">//可以用来排除非本身的属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`myKeys:<span class="subst">$&#123;key&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数原型属性-prototype"><a href="#函数原型属性-prototype" class="headerlink" title="函数原型属性 prototype"></a>函数原型属性 prototype</h2><p>prototype 是函数的一个固有属性,通过 function.prototype 读写<br>根据函数的不同分为两种情况:</p>
<ul>
<li>构造函数的 prototype 指向对象之后, new 出来的实例的[[Prototype]]会指向该对象.这个很重要,这也就是 Array()/Object()这种构造函数的原理<br>比如:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animal = &#123;</span><br><span class="line">  <span class="attr">eat</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rabbit</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Rabbit.prototype = animal;</span><br><span class="line"><span class="comment">//不是把函数挂到animal,而是把new的实例的[[Prototype]]指向animal</span></span><br><span class="line"><span class="comment">//效果就是,rabbit.__proto__ = Rabbit.prototype</span></span><br></pre></td></tr></table></figure>

<ul>
<li>一般函数的 prototype 是一个只有属性 constructor 的对象，属性 constructor 指向函数自身。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rabbit</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Rabbit.prototype === &#123; <span class="attr">constructor</span>: Rabbit &#125;;</span><br></pre></td></tr></table></figure>

<p>但是 constructor 有时候会丢失指向<br>如果替换了函数的 prototype ,就会丢失指向,所以需要重定向 constructor.这个在组合继承中很重要</p>
<h2 id="用来代替proto的函数"><a href="#用来代替proto的函数" class="headerlink" title="用来代替proto的函数"></a>用来代替<strong>proto</strong>的函数</h2><ul>
<li>Object.create():参数是父类,还可以有一个额外参数用于给返回对象添加属性;返回一个原型指向参数的子对象</li>
<li>getPrototypeOf()/setPrototypeOf():参数都是对象,用于获取/设置对象的原型</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animal = &#123;</span><br><span class="line">  <span class="attr">eats</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="function"><span class="title">walk</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`i can walk`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> snake = <span class="built_in">Object</span>.create(animal, &#123;</span><br><span class="line">  <span class="attr">slide</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;); <span class="comment">//创建以animal为原型的对象,第二个参数是这个对象的额外属性</span></span><br><span class="line">snake.walk();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(snake)); <span class="comment">//获取原型</span></span><br><span class="line"><span class="keyword">let</span> bear = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(bear, animal); <span class="comment">//设置原型</span></span><br><span class="line">bear.walk();</span><br></pre></td></tr></table></figure>

<h1 id="js-的继承-很高级的语法"><a href="#js-的继承-很高级的语法" class="headerlink" title="js 的继承(很高级的语法)"></a>js 的继承(很高级的语法)</h1><h2 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h2><p>原理是通过原型链把子构造函数的原型(f.prototype)指向父构造函数的实例, 这样子构造函数创建的实例就有父类的方法<br>几个注意点:</p>
<ul>
<li>不同的子实例共享父类属性, 比如下面的 stu1 更改 play 数组,stu2 的数组也会改变</li>
<li>子类可以调用父类的原型上的方法, 换句话说就是可以多层继承</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;i am 20 years old&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">grade</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person(<span class="string">&quot;zzx&quot;</span>); <span class="comment">//子类的原型指向父类实例</span></span><br><span class="line"><span class="keyword">let</span> stu1 = <span class="keyword">new</span> Student(<span class="number">100</span>); <span class="comment">//stu1上有Person的方法</span></span><br><span class="line"><span class="keyword">let</span> stu2 = <span class="keyword">new</span> Student(<span class="number">90</span>);</span><br><span class="line"><span class="comment">//父类Person上有一个引用数据类型(数组)play, 如果更改stu1继承的数组会导致stu2的也改变</span></span><br><span class="line"><span class="comment">//就说明不同实例实际上共同共享了父类(原型)的属性,对于引用对象来说地址也是相同的</span></span><br><span class="line">stu1.play.push(<span class="number">4</span>);</span><br><span class="line">stu1.setAge(); <span class="comment">//子类可以调用父类的原型的方法</span></span><br><span class="line"><span class="built_in">console</span>.log(stu2.play);</span><br></pre></td></tr></table></figure>

<h2 id="2-构造函数继承"><a href="#2-构造函数继承" class="headerlink" title="2. 构造函数继承"></a>2. 构造函数继承</h2><p>原理是在子构造函数中调用 call(),使得父的实例被转移到子构造函数中</p>
<ul>
<li><code>Person.call(this, name);</code> 相当于<code>this.Person(name)</code>,由于调用了 call,Person 的 this 指向 stu3,也就相当于 stu3.Person(‘xiaohong’) .又因为 Person 本身是个构造函数,这里就相当于<code>stu3 = new Person(&#39;xiaohong&#39;)</code>,加上外面的 new,等于 stu3 同时有父类的属性</li>
<li>子类不能调用父类原型上的方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">unction <span class="function"><span class="title">Person</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//父类原型的方法</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;i am 20 years old&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">grade, name</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="built_in">this</span>, name); <span class="comment">//相当于this.Person(name)</span></span><br><span class="line">  <span class="built_in">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stu3 = <span class="keyword">new</span> Student(<span class="number">100</span>, <span class="string">&quot;xiaohong&quot;</span>);</span><br><span class="line"><span class="comment">//由于调用了call,Person的this指向stu3,也就相当于stu3.Person(&#x27;xiaohong&#x27;)</span></span><br><span class="line"><span class="comment">//又因为Person本身是个构造函数,这里就相当于stu3 = new Person(&#x27;xiaohong&#x27;),加上外面的new,等于stu3同时有父类的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(stu3);</span><br></pre></td></tr></table></figure>

<h2 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3. 组合继承"></a>3. 组合继承</h2><p>就是上面两种方法的结合</p>
<ul>
<li>由于改变了子类原型, 需要修复构造器指向</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//父类原型的方法</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;i am 20 years old&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">grade, name</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相比于构造函数继承加上了原型链指向和修复构造器,这样就可以访问到父类的原型上的方法setAge</span></span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//修复构造器指向,因为正常情况下构造器应该是指向自己的,这里设置了student的原型需要修复回来,不然就会指向Person</span></span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu4 = <span class="keyword">new</span> Student(<span class="number">120</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> stu5 = <span class="keyword">new</span> Student(<span class="number">80</span>, <span class="string">&quot;mike&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="4-组合寄生继承-构造函数中最好的继承方法"><a href="#4-组合寄生继承-构造函数中最好的继承方法" class="headerlink" title="4. 组合寄生继承(构造函数中最好的继承方法)"></a>4. 组合寄生继承(构造函数中最好的继承方法)</h2><p>用 Object.create 代替直接指向的 prototype,并且是以父类的 prototype 作为原型,而不是上面几种方法用到的父类实例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//父类原型的方法</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;i am 20 years old&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">grade, name</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Object.create返回一个以参数为原型的新对象,相当于Student.__proto__ = Person</span></span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"><span class="comment">//所以new出来的实例,__proto__会指向Person实例,继而相当于完整的原型链</span></span><br><span class="line"><span class="keyword">let</span> stu6 = <span class="keyword">new</span> Student(<span class="number">120</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> stu7 = <span class="keyword">new</span> Student(<span class="number">80</span>, <span class="string">&quot;mike&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(stu6, stu7);</span><br></pre></td></tr></table></figure>

<h2 id="5-类继承"><a href="#5-类继承" class="headerlink" title="5. 类继承"></a>5. 类继承</h2><p>利用 es6 类的特性完成比较完整的继承</p>
<ul>
<li>构造函数中向构造函数原型上添加方法的方式相当于在类中直接声明</li>
<li>子类需要 constructor 使用 super 方法实现父类的构造,也就是说子类 new 的时候如果也想传入姓名, 就需要 super.(具体在类中解释)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//注意在构造函数中向构造函数原型上添加方法的方式相当于在类中直接声明</span></span><br><span class="line">  <span class="function"><span class="title">setAge</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;i am 20 years old&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">grade, name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">    <span class="built_in">this</span>.grade = grade;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stu8 = <span class="keyword">new</span> Student(<span class="number">150</span>, <span class="string">&quot;zzx&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(stu8);</span><br></pre></td></tr></table></figure>

<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>关于 js 基本类的操作和写法就不再赘述了,这里讲一些之前没用到的知识点</p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><h3 id="super-的使用"><a href="#super-的使用" class="headerlink" title="super 的使用"></a>super 的使用</h3><ul>
<li>直接用<code>super.</code>可以在子类 constructor 外部使用父类的方法</li>
<li>在 constructor 使用 super 接受参数用于构造实例(重写 constructor)</li>
<li>在 constructor 使用父类属性需要<code>super.</code>,不然不能访问到</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Benz</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, maxSpeed</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.maxSpeed = maxSpeed;</span><br><span class="line">  &#125;</span><br><span class="line">  run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> run with speed <span class="subst">$&#123;<span class="built_in">this</span>.maxSpeed&#125;</span>`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Track</span> <span class="keyword">extends</span> <span class="title">Benz</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.maxSpeed = <span class="built_in">super</span>.maxSpeed - <span class="number">100</span>; <span class="comment">//在constructor中使用super调用父类属性</span></span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">  &#125;</span><br><span class="line">  stop = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.stop(); <span class="comment">//使用super调用父类函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>.maxSpeed);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherTrack</span> <span class="keyword">extends</span> <span class="title">Benz</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">type, ...args</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(...args); <span class="comment">//如果要重写constructor构造的属性(比如子类实例也想设置name),就需要调用super函数</span></span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> anotherTrack = <span class="keyword">new</span> AnotherTrack(<span class="string">&quot;AnotherTrack&quot;</span>, <span class="string">&quot;myAnotherTrack&quot;</span>); <span class="comment">//这里重写了父类的constructor构造的属性name和maxSpeed</span></span><br></pre></td></tr></table></figure>

<h3 id="super-的实现原理"><a href="#super-的实现原理" class="headerlink" title="super 的实现原理"></a>super 的实现原理</h3><p>super 使用了类中函数的一个[[HomeObject]]属性(当然每个函数都有),<br>当一个函数被定义为类或者对象方法时，它的 [[HomeObject]] 属性就成为了该对象或类(也就是一种绑定)<br>因为这个原理, super 可以准确沿着原型链找到父类上的方法和属性</p>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p><code>a instanceof B</code>返回 a 是否是 B 的实例,返回一个 boolean 值</p>
<ul>
<li>instanceof 会先检查类中的[Symbol.hasInstance]静态方法,如果有会根据方法返回</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance](obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.type === <span class="string">&quot;fruit&quot;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> apple = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;fruit&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">apple <span class="keyword">instanceof</span> Fruit; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><blockquote>
<p>Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
</blockquote>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Promise 对象有以下两个特点。</p>
<ul>
<li>Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。</li>
</ul>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>通过 new Promise()生成 Promise 实例,参数是一个 executor 函数(执行函数)<br>特点:</p>
<ul>
<li>executor 函数被创建会<strong>立即执行</strong>(不是一个异步任务)</li>
<li>executor 函数中只能调用一个 resolve 或 reject(条件判断算一个),多个的后面会被无视<ul>
<li>resolve:将 <strong>Promise 对象的状态</strong>从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将<strong>异步操作的结果</strong>，作为<strong>参数</strong>传递出去；</li>
<li>reject:将 Promise 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。<br>这两个方法都是向外传递一个变量,后续的 then 需要参数来接受</li>
</ul>
</li>
<li>使用 resolve 之后,就不应该再在 promise 中操作了,剩下的操作应该在 then 中完成</li>
<li>then 函数有<strong>两个参数</strong>,第二个函数将在 promise rejected 后运行并接收 error。</li>
<li>还有一个 finally ,和 trycatch 中的 finally 类似</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&quot;done&quot;</span>), <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>通常使用都需要封装在一个函数中, 函数会返回一个 promise 对象<br>比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">    script.src = src;</span><br><span class="line">    script.onload = <span class="function">() =&gt;</span> resolve(script);</span><br><span class="line">    script.onerror = <span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Script load error for <span class="subst">$&#123;src&#125;</span>`</span>));</span><br><span class="line">    <span class="built_in">document</span>.head.append(script);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">loadScript(<span class="string">&quot;/src&quot;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.err(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Promise-链"><a href="#Promise-链" class="headerlink" title="Promise 链"></a>Promise 链</h2><p>每个 then 还可以有一个返回值,会被下一个 then 接收到作为参数<br>举个例子,axios 的连续调用<br>当下一次请求需要上一次的返回值时,不需要写在上一次的回调中;可以返回请求 Promise 对象再进行一次 then<br>注意:</p>
<ul>
<li>链必须始终是同一个 Promise 对象下的, 给多个 promise 分开 then 不是链</li>
<li>即使不刻意返回 Promise 对象,then 也会默认返回一个<strong>新的</strong>Promise 对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">axios</span><br><span class="line">  .get(<span class="string">&quot;/api&quot;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> axios.get(<span class="string">`/api/<span class="subst">$&#123;res&#125;</span>`</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> axios.get(<span class="string">`/api/<span class="subst">$&#123;res&#125;</span>`</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><p>并行执行多个 promise，并等待所有 promise 都准备就绪后再执行一个 then<br>参数是一个数组或可迭代对象,每个元素都是 promise 对象,返回是一个每个 promise 结果组成的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(<span class="string">&#x27;/post/&#x27;</span> + id + <span class="string">&quot;.json&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.all(promises)</span><br><span class="line">  .then((posts) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).catch((err)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h2><p>用于处理 Promise 程序的函数是一个微任务<br>也就是说, 每个.then/.catch/.finally 内的函数都是一个微任务</p>
<ul>
<li>微任务队列会在上一个宏任务完成后,下一个宏任务开始前调用<strong>微任务队列中的所有的微任务</strong>完成(所以 promise2 会和 promise1 一起先后一起完成)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;timeout&quot;</span>));</span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;clg&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这一段代码会返回这样一个结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clg</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure>

<h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>async 在函数前面时会创建一个特殊的函数,这个函数默认返回 Promise 对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getNum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> num = <span class="number">2</span>;</span><br><span class="line">num.then(<span class="function">(<span class="params">res</span>) =&gt;</span> clg(res));</span><br></pre></td></tr></table></figure>

<p>这个例子中 num 实际上是这样:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当然也可以显示返回一个 Promise 对象</p>
<p>await 是一个执行比较复杂的语句, 按照 await 的原理,可以把 await 的语句看成是一个 Promise</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUrl</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> text = <span class="keyword">await</span> fetch(<span class="string">`/<span class="subst">$&#123;url&#125;</span>`</span>);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">getUrl();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>最终顺序为:0 1 3 2<br>原理:</p>
<ul>
<li>0 同步执行;然后进入 getUrl 函数直接执行 1</li>
<li>await 看成这样:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(fetch(<span class="string">&quot;/&quot;</span>));</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> text = res;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
因此 await 是:<ul>
<li>把 await 紧挨其后的表达式当做 Promise 对象</li>
<li>把 await 语句之后的都当成下一个 then 内的语句</li>
<li>如果下面还有一个 await,就看做再下一个 then<br>所以它还可以链式调用:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUrl</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> text = <span class="keyword">await</span> fetch(<span class="string">`/<span class="subst">$&#123;url&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">let</span> text2 = <span class="keyword">await</span> fetch(<span class="string">`/<span class="subst">$&#123;text&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其中<code>fetch(</code>/${text}<code>)</code>会在 text 获取之后调用(就像 then 的工作方式)</li>
</ul>
</li>
<li>由于 await 把后面任务变成了 promise 微任务,所以会先调用 3,然后在 3 的末尾调用 2</li>
</ul>
<p>另外,如果需要处理错误,就需要在 async 函数调用的外部加上 catch,或者直接在 await 附近加 trycatch</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">getUrl().catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>await 还可以用于 Promise.all</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">  fetch(url1),</span><br><span class="line">  fetch(url2),</span><br><span class="line">  ...</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="模块类型"><a href="#模块类型" class="headerlink" title="模块类型"></a>模块类型</h2><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>一种适用于 node 的模块化,主要特点:</p>
<ul>
<li>使用 module、exports、require、global 为基本操作;其中 module 为模块内部的一个对象,常用属性有<ul>
<li>module.id 模块的识别符，通常是带有绝对路径的模块文件名。</li>
<li>module.filename 模块的文件名，带有绝对路径。</li>
<li>module.loaded 返回一个布尔值，表示模块是否已经完成加载。</li>
<li>module.parent 返回一个对象，表示调用该模块的模块。</li>
<li>module.children 返回一个数组，表示该模块要用到的其他模块。</li>
<li>module.exports 表示模块对外输出的值。</li>
</ul>
</li>
<li>同步导入导出, 适合服务端</li>
<li>导入对象实际上是导出的浅拷贝</li>
</ul>
<h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>异步版的 Commonjs,依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行<br>AMD 常采用 require.js 实现,用 require.config()指定引用路径等，用 define()定义模块，用 require()加载模块<br>主要步骤为:</p>
<ol>
<li>在 main 中用 require.config 指定各模块路径, 参数是一个有基本路径和具体路径构成的模块整体路径,比如下面的<code>&quot;add&quot;: &quot;add.js&quot;,</code>,”add”是模块名,后面是相对路径;</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">  <span class="attr">baseUrl</span>: <span class="string">&quot;js/&quot;</span>,</span><br><span class="line">  <span class="attr">paths</span>: &#123;</span><br><span class="line">    <span class="attr">add</span>: <span class="string">&quot;add.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>引用模块, 参数是一个模块名的数组和一个回调函数,异步的关键</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">&quot;add&quot;</span>, <span class="string">&quot;minus&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">add, minus</span>) </span>&#123;</span><br><span class="line">  add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  minus(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>定义一个模块用 define</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">add</span>: add,</span><br><span class="line">    <span class="attr">basicNum</span>: basicNum,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>一种 AMD 的变体;AMD 推崇依赖前置、提前执行，CMD 推崇依赖就近、延迟执行;<br>意思就是,AMD 会使导入的模块全部执行(即使没有调用); 而 CMD 是一种按需调用<br>CMD 也常和 sea.js 一同使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&quot;./a&quot;</span>);</span><br><span class="line">  a.doSomething();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&quot;./b&quot;</span>);</span><br><span class="line">  b.doSomething();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** sea.js **/</span></span><br><span class="line"><span class="comment">// 定义模块 math.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">&quot;jquery.js&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">exports</span>.add = add;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.use([<span class="string">&quot;math.js&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = math.add(<span class="number">1</span> + <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h3><blockquote>
<p>它可以通过运行时或者编译时让同一个代码模块在使用 CommonJs、CMD 甚至是 AMD 的项目中运行。</p>
</blockquote>
<p>意思就是, 他可以根据导出类型的不同实现不同的导入方法,比如上下文是 AMD 的方式,就可以用 AMD 导入导出<br>简单 UMD:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">(<span class="params"><span class="built_in">global</span>, factory</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//如果 当前的上下文有define函数，并且AMD  说明处于AMD 环境下</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&quot;function&quot;</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">    define([<span class="string">&quot;moduleA&quot;</span>], factory);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">//commonjs</span></span><br><span class="line">    <span class="keyword">let</span> moduleA = <span class="built_in">require</span>(<span class="string">&quot;moduleA&quot;</span>);</span><br><span class="line">    modules.exports = factory(moduleA);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">global</span>.moduleA = factory(<span class="built_in">global</span>.moduleA); <span class="comment">//直接挂载成 windows 全局变量</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="built_in">this</span>, <span class="function">(<span class="params">moduleA</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//本模块的定义</span></span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h3><p>使用 import/export 作为导入导出的方法(下面会详细叙述)<br><strong>模块只通过 HTTP(s) 工作，在本地文件则不行</strong></p>
<h2 id="ES6-Module-1"><a href="#ES6-Module-1" class="headerlink" title="ES6 Module"></a>ES6 Module</h2><p>一个模块实际上就是一个文件,特点如下:</p>
<ul>
<li>模块内部 js 始终使用”use strict”</li>
<li>模块代码仅在第一次导入时被解析,生成导出，然后它被分享给所有对其的导入,也就是说:<ul>
<li>导入时模块中的代码就已经被解析,如果有错误会在此时报出;</li>
<li>只解析一次,同一个模块在其他文件中再次导入不会再解析</li>
<li>如果导出一个引用类型的值(对象/数组),则一处数据更改也会影响另一处的导入的数据,但是不会影响源文件.所以尽量不要更改模块,而是只读或者使用拷贝</li>
</ul>
</li>
<li><code>&lt;script type=&quot;module&quot;&gt;</code>下的 this 是 undefined 而不是 window(这个跟严格模式有关系)</li>
<li><code>&lt;script type=&quot;module&quot;&gt;</code>的脚本是异步的,会等待 html 完全就绪才会运行</li>
</ul>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>import * as xxx 将所有内容导入为一个对象,相当于所有的导入都在 xxx 这个对象里</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> say <span class="keyword">from</span> <span class="string">&quot;./say.js&quot;</span>;</span><br><span class="line">say.sayHi(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">say.sayBye(<span class="string">&quot;John&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>另外,借助 import(module) 表达式可以实现动态导入<br>import(module) 表达式加载模块并返回一个 promise，该 promise resolve 为一个包含其所有导出的模块对象。比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./test.js&#x27;</span>)</span><br><span class="line">.then(<span class="function"><span class="params">obj</span>=&gt;</span><span class="built_in">console</span>.log(obj))</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">getImport</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./test.js&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>resolve 的 obj 就是模块的导出对象;可以对对象使用其 default 属性来访问默认导出<br>注意这种导入就不能使用<code>type=&quot;module&quot;</code>了,而是看做一个正常的表达式</p>
<h1 id="Proxy-和-Reflect"><a href="#Proxy-和-Reflect" class="headerlink" title="Proxy 和 Reflect"></a>Proxy 和 Reflect</h1><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>一个 Proxy 对象包装另一个对象并拦截诸如读取/写入属性和其他操作，可以选择自行处理它们，或者透明地允许该对象处理它们。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>

<ul>
<li>target 是要代理的对象, handler 是”捕捉器”,是一个包含 getter/setter 等属性的对象</li>
<li>直接对 Proxy 的实例读写相当于对代理对象读写(假设没有 handler),也可以迭代</li>
<li>Proxy 本身没有任何属性</li>
<li>常见的 handler 方法:<table>
<thead>
<tr>
<th>内部方法</th>
<th>Handler 方法</th>
<th>何时触发</th>
</tr>
</thead>
<tbody><tr>
<td>[[Get]]</td>
<td>get</td>
<td>读取属性</td>
</tr>
<tr>
<td>[[Set]]</td>
<td>set</td>
<td>写入属性</td>
</tr>
<tr>
<td>[[HasProperty]]</td>
<td>has</td>
<td>in 操作符</td>
</tr>
<tr>
<td>[[Delete]]</td>
<td>deleteProperty</td>
<td>delete 操作符</td>
</tr>
<tr>
<td>[[Call]]</td>
<td>apply</td>
<td>函数调用</td>
</tr>
<tr>
<td>[[Construct]]</td>
<td>construct</td>
<td>new 操作符</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>注意,这些 handler 方法都是访问代理对象而不是源对象时触发的</strong>.比如直接访问源对象属性并不会触发代理的拦截,这点和 defineProperty 加上 getter/setter 不同<br>所以为了可以直接访问对象代理,可以把代理对象赋给源对象</p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>get 方法一般如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numDict = &#123;</span><br><span class="line">  <span class="attr">zero</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">one</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">two</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(numDict, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, property, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (property <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[property];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> property;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>参数:</p>
<ul>
<li>target:就是代理的对象,参数第一个</li>
<li>property :访问的属性名，比如访问<code>proxy.xxx</code>,prop 就是 xxx</li>
<li>receiver :如果目标属性是一个 getter 访问器属性，则 receiver 就是本次读取属性所在的 this 对象。一般都是 Proxy 实例</li>
</ul>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set 方法如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [];</span><br><span class="line">numbers = <span class="keyword">new</span> <span class="built_in">Proxy</span>(numbers, &#123;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, prop, val</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> val == <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      target[prop] = val;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">numbers.push(<span class="number">1</span>); <span class="comment">// 添加成功</span></span><br><span class="line">numbers.push(<span class="number">2</span>); <span class="comment">// 添加成功</span></span><br><span class="line">numbers.push(<span class="string">&quot;test&quot;</span>); <span class="comment">// TypeError（proxy 的 &#x27;set&#x27; 返回 false）</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数:<ul>
<li>target: 代理对象</li>
<li>property: 访问属性名，</li>
<li>value: 设置的属性的值，比如<code>proxy.xxx = aaa</code>,value 就是 aaa</li>
<li>receiver: 与 get 捕捉器类似，仅与 setter 访问器属性相关。</li>
</ul>
</li>
<li>set 必须返回 true 或者 false</li>
<li>对于数组对象等的内建方法(比如 push/shift/pop),也会触发 setter,因此也可以作为内建方法的监听</li>
</ul>
<h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys"></a>ownKeys</h3><p>对于<code>forin</code>和<code>Object.keys/entries/values</code>等遍历属性方法都会用到[[OwnPropertyKeys]]方法,通过 ownKeys 捕捉器拦截<br>参数只有 target 作为代理对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">_password</span>: <span class="string">&quot;***&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">  <span class="function"><span class="title">ownKeys</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(target).filter(<span class="function">(<span class="params">key</span>) =&gt;</span> !key.startsWith(<span class="string">&quot;_&quot;</span>));</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> user) alert(key); <span class="comment">// name age</span></span><br></pre></td></tr></table></figure>

<p>注意:ownKeys 返回的键<strong>只少不多</strong>;也就是说这些键只能是原本就有的,不能返回原对象没有的键;同理,也不会返回不可枚举的键</p>
<h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty"></a>deleteProperty</h3><p>用于对删除进行拦截<br>参数和 get 相同</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">_password</span>: <span class="string">&quot;***&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">user = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">  <span class="function"><span class="title">deleteProperty</span>(<span class="params">tar, prop</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop.startsWith(<span class="string">&quot;_&quot;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">delete</span> tar[prop];</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="has"><a href="#has" class="headerlink" title="has"></a>has</h3><p>has 会拦截<code>in</code>,比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="attr">from</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">to</span>: <span class="number">10</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(range, &#123;</span><br><span class="line">  <span class="function"><span class="title">has</span>(<span class="params">tar, prop</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> prop &gt;= tar.from &amp;&amp; prop &lt;= tar.to ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> <span class="keyword">in</span> proxy); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>其他一些方法和上面类似,列举如下:<br>|方法|参数|返回|效果|<br>|—|—|—|—|<br>|construct (target, args, newTarget) |args 是创建实例时传入的参数数组;newTarget 是 new 命令作用的构造函数|必须是个对象,用于设置属性|用于拦截 new 命令|<br>|defineProperty (target, key, descriptor)|key 和 descriptor 都是 Object.defineProperty()传入的参数|true/false|拦截了 Object.defineProperty()操作|<br>|getPrototypeOf(target)/setPrototypeOf (target, proto)|proto 是设置的父原型|返回 proto/true 或 false|拦截获取/设置原型|</p>
<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><blockquote>
<p>Reflect 是一个内建对象，可简化 Proxy 的创建。</p>
</blockquote>
<p>也就是说, reflect 是一种”映射”,可以把我们对 reflect 对象的操作”映射到”源对象上<br>每个 Proxy 对应的方法都是 reflect 对应的, 比如 get 中使用的应该是 Reflect.get(),has 使用 Reflect.has(),以此类推<br>举个栗子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, prop, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`GET <span class="subst">$&#123;prop&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, prop, val, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`SET <span class="subst">$&#123;prop&#125;</span>=<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, prop, val, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里的 Reflect 代替的直接的读取, <strong>成功返回 true,失败返回 false</strong><br>注意这里用到了之前没用到的 receiver;这个属性的作用与 this 相关,比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">_name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hello,<span class="subst">$&#123;<span class="built_in">this</span>._name&#125;</span>!`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, prop, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`GET <span class="subst">$&#123;prop&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, prop, val, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`SET <span class="subst">$&#123;prop&#125;</span>=<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(...arguments);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu = &#123;</span><br><span class="line">  <span class="attr">__proto__</span>: proxy,</span><br><span class="line">  <span class="attr">_name</span>: <span class="string">&quot;Mike&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">stu.sayHi();</span><br></pre></td></tr></table></figure>

<p>这个例子中希望 stu 的调用 this 能指向 stu 而不是 user,就需要 reflect<br>如果没有 reflect:</p>
<ul>
<li>stu 访问 name, 在原型 proxy 上寻找</li>
<li>proxy 通过 get 拦截, 并默认把上下文看做 target,调用 user 的 getter,返回一个 user 上下文</li>
<li>产生的是”John”<br>如果有 reflect ,就可以把正常的上下文”receiver”保留,从而使得 this 的指向依旧是”点前面的对象”</li>
</ul>
<h1 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h1><blockquote>
<p>柯里化是一种函数的转换，它是指将一个函数从可调用的 f(a, b, c) 转换为可调用的 f(a)(b)(c)。</p>
</blockquote>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>举个栗子,两个参数的柯里化:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> f(a, b);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> add = curry(sum);</span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>一步步分析原理:</p>
<ol>
<li>首先调用 curry(sum),会返回第一层函数,即 add 函数</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(a, b);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然后 add(1),触发第一层,相当于参数 a = 1;进入第二层</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add(<span class="number">1</span>) = <span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(<span class="number">1</span>,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>再调用 add(1)(2),到最后一层,把参数 b 传入</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add(<span class="number">1</span>)(<span class="number">2</span>) = f(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>最后返回 sum(1,2)的值 3</li>
</ol>
<p>因此柯里化的过程实际上就是拆分参数的过程;把多个参数按照一定分组分开调用;</p>
<h3 id="真正实现"><a href="#真正实现" class="headerlink" title="真正实现"></a>真正实现</h3><p>还有更高级的写法,比如递归:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= func.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> func(args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curried(...args, ...args2);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> add = curry(sum);</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>同样原理如下:(以 add(1)(2,3)为例)</p>
<ol>
<li>因为 curry 的返回给了 add,add 函数相当于这个:</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (args.length &gt;= func.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> func(args);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> curried(...args, ...args2);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然后产生 add(1),相当于参数…args = [1];因为参数数量少于函数最大参数数量,所以进入 else,即 add(1)又是这个函数:</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> curried(<span class="number">1</span>, ...args2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>调用 add(1)(2,3),后面的(2,3)相当于 add(1)这个函数的参数,被传入…args2 中</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"><span class="number">2</span>,<span class="number">3</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> curried(<span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>递归,再次进入 1 中的函数;但是这次参数为三个,所以直接调用 sum(1,2,3)</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>) === sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>多个参数同理,这就是柯里化的根本原理</li>
</ol>
<p>另外,lodash 库中有_.curry 可以用做柯里化一个函数,其源码如下:(增加了 this 的绑定)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= func.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curried.apply(<span class="built_in">this</span>, args.concat(args2));</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>柯里化可以适用于函数多个参数的分开调用/延时执行等地方,并且可以创建偏函数(即原函数中只有一个参数的新函数)<br>比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">method, url, type</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以把它柯里化,然后转成一个固定 method 的偏函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getData = _.curry(getData)</span><br><span class="line"><span class="keyword">let</span> getDataByPost = getData(<span class="string">&quot;POST&quot;</span>)</span><br><span class="line">getDataByPost(<span class="string">&quot;/...&quot;</span>,...)</span><br></pre></td></tr></table></figure>

<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="词法环境-Lexical-Environments"><a href="#词法环境-Lexical-Environments" class="headerlink" title="词法环境(Lexical Environments)"></a>词法环境(Lexical Environments)</h3><p>在介绍 js 编译原理的时候,我们说过 js 的每一个函数/代码块和全局都会有一个”执行上下文”,里边还有变量环境和词法环境两部分<br><img src="https://static001.geekbang.org/resource/image/06/13/0655d18ec347a95dfbf843969a921a13.png"><br>这里重点讲一下词法环境</p>
<ul>
<li>词法环境是一个用于”登记”执行上下文中的变量/函数等的结构</li>
<li>词法环境创建的 5 种类型:<ul>
<li>函数</li>
<li>with 代码块</li>
<li>catch 代码块(注意不是 try)</li>
<li>全局</li>
<li>eval<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/3/1677429807aea76d~tplv-t2oaga2asx-watermark.awebp"></li>
</ul>
</li>
<li>词法环境对象由两部分组成：<ul>
<li>环境记录(Environment Records) :一个存储<strong>所有局部变量</strong>作为其属性（包括一些其他信息，例如 this 的值）的对象。就是登记环境内部变量的地方</li>
<li>外部引用(outer):对外部词法环境的<strong>引用</strong>，与外部代码相关联。就是包含本自己词法环境的父外部词法环境,是作用域链连起来的根本</li>
</ul>
</li>
<li>词法环境在 js 解析代码之前就已经创建了,也就是说在词法环境内的变量都会被先创建,但是不能引用;必须等待 let/const/函数声明来”登记”了之后才可以</li>
<li>我们常说的变量只是环境记录的一个属性</li>
<li>词法环境是嵌套的。内部的词法环境会通过 outer 和外部词法环境相连;当代码要访问一个变量时 —— 首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。<br>举个例子,比如下面这段代码:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> counter = makeCounter();</span><br></pre></td></tr></table></figure>

<p>会创建这样的嵌套词法环境:<br><img src="https://pic.imgdb.cn/item/61b1d3072ab3f51d91da2eb8.png"><br>当我们调用 counter 函数,</p>
<ol>
<li>counter 创建自己的词法环境</li>
<li>counter 函数查找自己词法环境内部的 count 变量;</li>
<li>上一步没找到,就会根据 outer 到外部词法环境,也就是 makeCounter 函数的词法环境查找;</li>
<li>如果再找不到就会到全局,在哪找到就会在哪修改<br>这是执行之后的:<br><img src="https://pic.imgdb.cn/item/61b1d4162ab3f51d91dac8ca.png"></li>
</ol>
<h3 id="变量环境-VariableEnvironment"><a href="#变量环境-VariableEnvironment" class="headerlink" title="变量环境(VariableEnvironment)"></a>变量环境(VariableEnvironment)</h3><p>相对于词法环境:</p>
<ul>
<li>两者本质上差不多,变量环境是一种特殊的词法环境</li>
<li>变量环境用来存储 var 声明和函数声明</li>
<li>词法环境存储 let/const 以及各种块声明</li>
</ul>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>先看这样一段代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(myName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myName = <span class="string">&quot;BBB&quot;</span>;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">&quot;AAA&quot;</span>;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>这个代码最终打印的是 AAA 而不是 BBB<br>作用域链实际上就是上面所说的词法环境中的 outer 连续指向形成的链.在上面这段代码中,bar 和 foo 的 outer 都指向全局,所以没有的变量去全局查找,因此最终 bar 中的 myName 应该是 AAA<br>因此作用域链,或者说一个函数的 outer 只和定义时的位置相关,跟怎么调用无关<br>如果是这样,就可以打印 BBB 了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myName = <span class="string">&quot;BBB&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(myName);</span><br><span class="line">  &#125;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">&quot;AAA&quot;</span>;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/61b1d8f42ab3f51d91dda91b.png"><br>所以可以总结相关几点:</p>
<ul>
<li>作用域链通过执行上下文中词法环境的 outer 属性设置</li>
<li>通常一个执行上下文的 outer 指向它声明的时候的直接外部执行上下文</li>
<li>一个函数的 outer 只和定义时的位置相关,跟怎么调用无关</li>
</ul>
<h3 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包"></a>闭包</h3><p>根据上面作用域链的相关概念,可以更清楚了解闭包:<br>先看一段代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myName = <span class="string">&quot; AAA &quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> test1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> test2 = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> innerBar = &#123;</span><br><span class="line">    <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(test1);</span><br><span class="line">      <span class="keyword">return</span> myName;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">setName</span>(<span class="params">newName</span>)</span> &#123;</span><br><span class="line">      myName = newName;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> innerBar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo();</span><br><span class="line">bar.setName(<span class="string">&quot; BBB &quot;</span>);</span><br><span class="line">bar.getName();</span><br><span class="line"><span class="built_in">console</span>.log(bar.getName());</span><br></pre></td></tr></table></figure>

<ol>
<li>首先调用执行 foo 函数, 这个过程中会创建全局执行上下文和 foo 函数的执行上下文;在 foo 函数的执行上下文中有 myName,test1,test2,innerBar 这些变量的词法环境</li>
<li>这时候函数继续执行到 return 为止, 赋值给 bar;bar 调用 setName,这时候虽然 foo 已经返回,但是因为 setName 函数中引用了 foo 函数的 myName 变量,因此就会导致 foo 函数的执行上下文出栈,但还留着一个”小包”,里边就是 myName 和 test1 变量.</li>
<li>bar 函数在全局作用域下调用,这时候这个小包直接在全局上下文上,全局执行上下文走到哪都会带着这个”背包”,我们把这个背包叫<strong>闭包</strong><br><img src="https://pic.imgdb.cn/item/61b1deab2ab3f51d91e09e76.png"><br>所以接下来就可以给闭包一个正式定义:<br>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。<br>这句话有几个关键点:</li>
</ol>
<ul>
<li>词法作用域的规则:就是我们上面一直讲的作用域链;一个变量查找不到就会到其上级的词法环境查找</li>
<li>外部函数已经执行结束:这也是 js 闭包的特点,在函数 return 之后依然可以使用这个函数里边的值</li>
<li>这些变量的集合称为闭包:闭包实际上是个变量的集合</li>
</ul>
<p>这里还有一个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">  <span class="attr">myName</span>: <span class="string">&quot;CCC&quot;</span>,</span><br><span class="line">  <span class="attr">printName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(myName);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> myName = <span class="string">&quot; BBB &quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> bar.printName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot; AAA &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> _printName = foo();</span><br><span class="line">_printName();</span><br><span class="line">bar.printName();</span><br></pre></td></tr></table></figure>

<p>结果是两次都打印 AAA<br>原理也很简单,不管 bar 这个对象如何,printName 始终只相当于一个单独的函数,根据函数在哪定义在哪确定上下文的原理,printName 始终用的是全局的 myName AAA 而不是其他</p>
<h1 id="手写万物"><a href="#手写万物" class="headerlink" title="手写万物"></a>手写万物</h1><h2 id="手写-new"><a href="#手写-new" class="headerlink" title="手写 new"></a>手写 new</h2><p>原理:</p>
<ul>
<li><code>let obj = Object.create(fn.prototype)</code>相当于<code>let obj; obj.__proto__ = fn.prototype</code></li>
<li>第二行调用构造函数并绑定 this 到 obj 上</li>
<li>第三行返回调用结果, 如果上一步传参等原因导致返回 null, 会返回 obj</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">  <span class="keyword">const</span> ret = fn.apply(obj, args);</span><br><span class="line">  <span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = _new(Animal, <span class="string">&quot;Puppy&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>或者还有一种更朴实的写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> targetObj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> [<span class="title">constructor</span>, ...<span class="title">args</span>] = [...<span class="title">arguments</span>];</span><br><span class="line">  targetObj.__proto__ = <span class="title">constructor</span>.<span class="title">prototype</span>;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="title">constructor</span>.<span class="title">apply</span>(<span class="params">targetObj, args</span>);</span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : targetObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写数组去重"><a href="#手写数组去重" class="headerlink" title="手写数组去重"></a>手写数组去重</h2><p>原理:</p>
<ul>
<li>filter 会在返回为 false 时去除该元素</li>
<li>indexOf 会返回第一个找到的该元素的索引; 如果有重复元素则显然 indexOf 只返回第一个该元素, 不会等于当前 index,就会返回 false 从而筛掉</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = arr.filter(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> array.indexOf(item) === index;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写数组扁平"><a href="#手写数组扁平" class="headerlink" title="手写数组扁平"></a>手写数组扁平</h2><p>原理:</p>
<ul>
<li>arr.some 方法, 参数传递一个测试函数, 对每个元素测试, 如果至少一个通过测试就会返回 true; 也就是判断这个数组中是否至少还有一个数组(至少还有一维没有展平)</li>
<li>Array.isArray 判断是否是一个数组</li>
<li>核心方法是 concat ,这个方法会抹平二维数组, 所以只需要递归/循环就行(<code>[].concat(1,[2]) = [1,2]</code>)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (arr.some(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">    arr = [].concat(...arr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[].concat(1,[2]) = [1,2]</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<h2 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h2><p>原理:</p>
<ul>
<li>typeof 一个数组也是 object</li>
<li><code>typeof obj[key] === &#39;object&#39;</code>会判断当前是否还有一层, 如果当前这项不是基本数据而是对象或数组, 就递归再调用一次, 直到复制完内部所有的属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">var</span> newObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObj[key] =</span><br><span class="line">        <span class="keyword">typeof</span> obj[key] === <span class="string">&quot;object&quot;</span> ? deepClone(obj[key]) : obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写防抖-节流"><a href="#手写防抖-节流" class="headerlink" title="手写防抖/节流"></a>手写防抖/节流</h2><ul>
<li>防抖</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      func.apply(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>节流</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context, args;</span><br><span class="line">  <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    context = <span class="built_in">this</span>;</span><br><span class="line">    args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">      func.apply(context, args);</span><br><span class="line">      previous = now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写柯里化"><a href="#手写柯里化" class="headerlink" title="手写柯里化"></a>手写柯里化</h2><p>具体解析见上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= func.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> func(args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curried(...args, ...args2);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写-Promise"><a href="#手写-Promise" class="headerlink" title="手写 Promise"></a>手写 Promise</h2><p>原理:<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903625769091079">具体原理可以看这里</a></p>
<ul>
<li>首先构造一个类, promise 对象是需要传一个函数的，这里直接作为 constructor 的参数；在 constructor 中做如下配置：<ul>
<li>设置状态 state，有三种情况：pending、fulfilled、rejected</li>
<li>设置 value 用于维持一个值，在后面 resolve 到 then 中，then 也需要这个 value</li>
<li>设置 resolve 函数，原理就是：<ol>
<li>调用时更改 state 状态</li>
<li>存储调用时传入的值</li>
</ol>
</li>
<li>设置 rejected，原理是：<ol>
<li>更改 state 为 rejected</li>
<li>设置错误原因</li>
</ol>
</li>
<li>设置完上面之后通过传入的 executor 传入 resolve 和 rejected；在外部使用 resolve 和 rejected 都会直接触发类中的这两个函数</li>
</ul>
</li>
<li>设计 then；then 实际上是类的一个方法，参数为 onFulfilled 和 onRejected，分别表示成功回调和失败回调<ul>
<li>调用时先判断 state；如果为 fulfilled，就调用外部自定义的 onFulfilled 函数，参数为 this.value，也就相当于我们常写的”res”；如果为 rejected 同理</li>
</ul>
</li>
<li>添加定时器异步<ul>
<li>首先在构造函数添加成功存放的数组和失败存放的数组，这两个存的分别是后续外部定义的 onFulfilled 函数和 onRejected 函数，在“完成的时刻”再从数组中取出调用他们。使用数组的原因是多个 then（不是 then 链，还没实现）</li>
<li>在 resolve 和 rejected 函数中添加调用上面两个数组中所有函数；这步最为关键，也就是说必须直到状态改变，后续的 then 中函数才会被调用，是一种异步效果</li>
<li>在 then 中设置 pending 状态的操作：如果在 pending 状态说明 executor 函数中有延时执行的任务，这时候就把所有的回调放在成功/失败数组中，等待完成后执行</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化state为等待态</span></span><br><span class="line">    <span class="built_in">this</span>.state = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line">    <span class="comment">// 成功的值</span></span><br><span class="line">    <span class="built_in">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 失败的原因</span></span><br><span class="line">    <span class="built_in">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 成功存放的数组</span></span><br><span class="line">    <span class="built_in">this</span>.onResolvedCallbacks = [];</span><br><span class="line">    <span class="comment">// 失败存放法数组</span></span><br><span class="line">    <span class="built_in">this</span>.onRejectedCallbacks = [];</span><br><span class="line">    <span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// state改变,resolve调用就会失败</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// resolve调用后，state转化为成功态</span></span><br><span class="line">        <span class="built_in">this</span>.state = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line">        <span class="comment">// 储存成功的值</span></span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="comment">// 一旦resolve执行，调用成功数组的函数</span></span><br><span class="line">        <span class="built_in">this</span>.onResolvedCallbacks.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// state改变,reject调用就会失败</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// reject调用后，state转化为失败态</span></span><br><span class="line">        <span class="built_in">this</span>.state = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">        <span class="comment">// 储存失败的原因</span></span><br><span class="line">        <span class="built_in">this</span>.reason = reason;</span><br><span class="line">        <span class="comment">// 一旦reject执行，调用失败数组的函数</span></span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 如果executor执行报错，直接执行reject</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 状态为fulfilled，执行onFulfilled，传入成功的值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line">      onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态为rejected，执行onRejected，传入失败的原因</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">      onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当状态state为pending时</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// onFulfilled传入到成功数组</span></span><br><span class="line">      <span class="built_in">this</span>.onResolvedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// onRejected传入到失败数组</span></span><br><span class="line">      <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写"><a href="#手写" class="headerlink" title="手写"></a>手写</h2></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/">日常学习</a></div><div class="post_share"><div class="social-share" data-image="/img/JS.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/09/blog31-es6+/"><img class="prev-cover" src="/img/ES6.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">es6一些疏漏的知识点</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/05/blog29-h5&amp;c3/"><img class="next-cover" src="/img/Chrome.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">前端知识深入--HTML5和CSS3深入</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/12/01/blog0-knowledge-graph/" title="未知知识图谱(接下来要学习的)"><img class="cover" src="/img/knowledges.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-01</div><div class="title">未知知识图谱(接下来要学习的)</div></div></a></div><div><a href="/2021/10/27/blog10-react-router/" title="react-router的使用"><img class="cover" src="/img/reactrouter.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-27</div><div class="title">react-router的使用</div></div></a></div><div><a href="/2021/11/06/blog11-myReact/" title="react知识点汇总和使用小总结(一)"><img class="cover" src="/img/react.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-06</div><div class="title">react知识点汇总和使用小总结(一)</div></div></a></div><div><a href="/2021/11/20/blog14-react-ts-basic/" title="typescript+react基础部分"><img class="cover" src="/img/typescript.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-20</div><div class="title">typescript+react基础部分</div></div></a></div><div><a href="/2021/11/20/blog15-react-ts-router/" title="typescript+react:react-routerv6和旧版v5的使用"><img class="cover" src="/img/typescript.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-20</div><div class="title">typescript+react:react-routerv6和旧版v5的使用</div></div></a></div><div><a href="/2021/11/20/blog16-react-ts-hooks-redux/" title="typescript+react:自定义hooks代替redux"><img class="cover" src="/img/typescript.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-20</div><div class="title">typescript+react:自定义hooks代替redux</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/pinkstar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xing Ye</div><div class="author-info__description">a singleThreaded boy's blog</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/penghei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/penghei" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:632885485@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">A SingleThreaded Boy...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.</span> <span class="toc-text">对象深拷贝</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Symbol"><span class="toc-number">2.</span> <span class="toc-text">Symbol</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E5%8F%AF%E8%BF%AD%E4%BB%A3"><span class="toc-number">3.</span> <span class="toc-text">迭代器和可迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#forof-%E5%92%8C-forin"><span class="toc-number">3.1.</span> <span class="toc-text">forof 和 forin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.2.</span> <span class="toc-text">可迭代对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arrayLike"><span class="toc-number">3.4.</span> <span class="toc-text">arrayLike</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Map-%E5%92%8C-Set"><span class="toc-number">4.</span> <span class="toc-text">Map 和 Set</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Map"><span class="toc-number">4.1.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Map-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.1.1.</span> <span class="toc-text">Map 的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map-%E8%BF%AD%E4%BB%A3"><span class="toc-number">4.1.2.</span> <span class="toc-text">Map 迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map-%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96"><span class="toc-number">4.1.3.</span> <span class="toc-text">Map 和对象相互转化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set"><span class="toc-number">4.2.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.2.1.</span> <span class="toc-text">Set 的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.2.</span> <span class="toc-text">Set 的主要方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-%E8%BF%AD%E4%BB%A3"><span class="toc-number">4.2.3.</span> <span class="toc-text">Set 迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.2.4.</span> <span class="toc-text">Set 的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-%E7%94%A8%E4%BA%8E%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-number">4.2.5.</span> <span class="toc-text">Set 用于数组去重</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE"><span class="toc-number">5.</span> <span class="toc-text">对象属性配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%BB%98%E8%AE%A4%E5%B1%9E%E6%80%A7"><span class="toc-number">5.1.</span> <span class="toc-text">对象的默认属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getter-%E5%92%8C-setter"><span class="toc-number">5.2.</span> <span class="toc-text">getter 和 setter</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.</span> <span class="toc-text">函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7"><span class="toc-number">6.1.</span> <span class="toc-text">函数属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IFE"><span class="toc-number">6.2.</span> <span class="toc-text">IFE</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">7.</span> <span class="toc-text">原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Prototype-%E5%92%8Cproto"><span class="toc-number">7.1.</span> <span class="toc-text">[[Prototype]]和proto</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B"><span class="toc-number">7.2.</span> <span class="toc-text">对象原型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%B1%9E%E6%80%A7-prototype"><span class="toc-number">7.3.</span> <span class="toc-text">函数原型属性 prototype</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%9D%A5%E4%BB%A3%E6%9B%BFproto%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">7.4.</span> <span class="toc-text">用来代替proto的函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#js-%E7%9A%84%E7%BB%A7%E6%89%BF-%E5%BE%88%E9%AB%98%E7%BA%A7%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">js 的继承(很高级的语法)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-number">8.1.</span> <span class="toc-text">1. 原型链继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">8.2.</span> <span class="toc-text">2. 构造函数继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-number">8.3.</span> <span class="toc-text">3. 组合继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BB%84%E5%90%88%E5%AF%84%E7%94%9F%E7%BB%A7%E6%89%BF-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E6%9C%80%E5%A5%BD%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95"><span class="toc-number">8.4.</span> <span class="toc-text">4. 组合寄生继承(构造函数中最好的继承方法)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="toc-number">8.5.</span> <span class="toc-text">5. 类继承</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">9.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#super"><span class="toc-number">9.1.</span> <span class="toc-text">super</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#super-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">9.1.1.</span> <span class="toc-text">super 的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">9.1.2.</span> <span class="toc-text">super 的实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof"><span class="toc-number">9.2.</span> <span class="toc-text">instanceof</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise"><span class="toc-number">10.</span> <span class="toc-text">Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">10.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">10.2.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-%E9%93%BE"><span class="toc-number">10.3.</span> <span class="toc-text">Promise 链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-all"><span class="toc-number">10.4.</span> <span class="toc-text">Promise.all</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-number">10.5.</span> <span class="toc-text">微任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async-await"><span class="toc-number">10.6.</span> <span class="toc-text">async&#x2F;await</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97"><span class="toc-number">11.</span> <span class="toc-text">模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.1.</span> <span class="toc-text">模块类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CommonJS"><span class="toc-number">11.1.1.</span> <span class="toc-text">CommonJS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AMD"><span class="toc-number">11.1.2.</span> <span class="toc-text">AMD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMD"><span class="toc-number">11.1.3.</span> <span class="toc-text">CMD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UMD"><span class="toc-number">11.1.4.</span> <span class="toc-text">UMD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6-Module"><span class="toc-number">11.1.5.</span> <span class="toc-text">ES6 Module</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6-Module-1"><span class="toc-number">11.2.</span> <span class="toc-text">ES6 Module</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#import"><span class="toc-number">11.2.1.</span> <span class="toc-text">import</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Proxy-%E5%92%8C-Reflect"><span class="toc-number">12.</span> <span class="toc-text">Proxy 和 Reflect</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Proxy"><span class="toc-number">12.1.</span> <span class="toc-text">Proxy</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#get"><span class="toc-number">12.1.1.</span> <span class="toc-text">get</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set"><span class="toc-number">12.1.2.</span> <span class="toc-text">set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ownKeys"><span class="toc-number">12.1.3.</span> <span class="toc-text">ownKeys</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deleteProperty"><span class="toc-number">12.1.4.</span> <span class="toc-text">deleteProperty</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#has"><span class="toc-number">12.1.5.</span> <span class="toc-text">has</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">12.1.6.</span> <span class="toc-text">其他方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reflect"><span class="toc-number">12.2.</span> <span class="toc-text">Reflect</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-number">13.</span> <span class="toc-text">函数柯里化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">13.1.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">13.1.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%9F%E6%AD%A3%E5%AE%9E%E7%8E%B0"><span class="toc-number">13.1.2.</span> <span class="toc-text">真正实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">13.2.</span> <span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">14.</span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">14.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83-Lexical-Environments"><span class="toc-number">14.1.1.</span> <span class="toc-text">词法环境(Lexical Environments)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%8E%AF%E5%A2%83-VariableEnvironment"><span class="toc-number">14.1.2.</span> <span class="toc-text">变量环境(VariableEnvironment)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">14.1.3.</span> <span class="toc-text">作用域链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85-1"><span class="toc-number">14.1.4.</span> <span class="toc-text">闭包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E4%B8%87%E7%89%A9"><span class="toc-number">15.</span> <span class="toc-text">手写万物</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-new"><span class="toc-number">15.1.</span> <span class="toc-text">手写 new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-number">15.2.</span> <span class="toc-text">手写数组去重</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3"><span class="toc-number">15.3.</span> <span class="toc-text">手写数组扁平</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">15.4.</span> <span class="toc-text">手写深拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E9%98%B2%E6%8A%96-%E8%8A%82%E6%B5%81"><span class="toc-number">15.5.</span> <span class="toc-text">手写防抖&#x2F;节流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-number">15.6.</span> <span class="toc-text">手写柯里化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-Promise"><span class="toc-number">15.7.</span> <span class="toc-text">手写 Promise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99"><span class="toc-number">15.8.</span> <span class="toc-text">手写</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/09/blog31-es6+/" title="es6一些疏漏的知识点"><img src="/img/ES6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="es6一些疏漏的知识点"/></a><div class="content"><a class="title" href="/2021/12/09/blog31-es6+/" title="es6一些疏漏的知识点">es6一些疏漏的知识点</a><time datetime="2021-12-09T10:57:20.000Z" title="发表于 2021-12-09 18:57:20">2021-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/05/blog30-js-deeping/" title="js更深入学习"><img src="/img/JS.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="js更深入学习"/></a><div class="content"><a class="title" href="/2021/12/05/blog30-js-deeping/" title="js更深入学习">js更深入学习</a><time datetime="2021-12-05T13:21:10.000Z" title="发表于 2021-12-05 21:21:10">2021-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/05/blog29-h5&amp;c3/" title="前端知识深入--HTML5和CSS3深入"><img src="/img/Chrome.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端知识深入--HTML5和CSS3深入"/></a><div class="content"><a class="title" href="/2021/12/05/blog29-h5&amp;c3/" title="前端知识深入--HTML5和CSS3深入">前端知识深入--HTML5和CSS3深入</a><time datetime="2021-12-05T04:53:28.000Z" title="发表于 2021-12-05 12:53:28">2021-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/04/blog28-webAPI/" title="前端知识深入--WebAPI深入"><img src="/img/Chrome.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端知识深入--WebAPI深入"/></a><div class="content"><a class="title" href="/2021/12/04/blog28-webAPI/" title="前端知识深入--WebAPI深入">前端知识深入--WebAPI深入</a><time datetime="2021-12-04T06:39:28.000Z" title="发表于 2021-12-04 14:39:28">2021-12-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/02/blog27-browser/" title="前端知识深入--浏览器深入"><img src="/img/Chrome.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端知识深入--浏览器深入"/></a><div class="content"><a class="title" href="/2021/12/02/blog27-browser/" title="前端知识深入--浏览器深入">前端知识深入--浏览器深入</a><time datetime="2021-12-02T04:21:26.000Z" title="发表于 2021-12-02 12:21:26">2021-12-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Xing Ye</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hello stranger!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>