<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JavaScript学习总结 | XingYeBlog</title><meta name="keywords" content="日常学习"><meta name="author" content="Xing Ye,632885485@qq.com"><meta name="copyright" content="Xing Ye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="js 数据类型数据类型概览js 只有 8 种基本数据类型  number bigint string boolean null undefined symbol object   没有专门的数组类型，数组实际上是一种键为有序数字的对象；对象的键如果是数字或者可以转化为有效数字的字符（比如’1’ ‘2’），也会有相应的顺序变化，像数组一样。   其中 Symbol 和 BigInt 是 ES6 中新">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript学习总结">
<meta property="og:url" content="http://example.com/2021/12/05/blog30-js-deeping/index.html">
<meta property="og:site_name" content="XingYeBlog">
<meta property="og:description" content="js 数据类型数据类型概览js 只有 8 种基本数据类型  number bigint string boolean null undefined symbol object   没有专门的数组类型，数组实际上是一种键为有序数字的对象；对象的键如果是数字或者可以转化为有效数字的字符（比如’1’ ‘2’），也会有相应的顺序变化，像数组一样。   其中 Symbol 和 BigInt 是 ES6 中新">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/JS.png">
<meta property="article:published_time" content="2021-12-05T13:21:10.000Z">
<meta property="article:modified_time" content="2022-06-05T16:40:48.504Z">
<meta property="article:author" content="Xing Ye">
<meta property="article:tag" content="日常学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/JS.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2021/12/05/blog30-js-deeping/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaScript学习总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-06 00:40:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/pinkstar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/JS.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XingYeBlog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JavaScript学习总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-05T13:21:10.000Z" title="发表于 2021-12-05 21:21:10">2021-12-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-05T16:40:48.504Z" title="更新于 2022-06-06 00:40:48">2022-06-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaScript/">JavaScript</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">47.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>177分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JavaScript学习总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="js-数据类型"><a href="#js-数据类型" class="headerlink" title="js 数据类型"></a>js 数据类型</h1><h2 id="数据类型概览"><a href="#数据类型概览" class="headerlink" title="数据类型概览"></a>数据类型概览</h2><p>js 只有 8 种基本数据类型</p>
<ul>
<li>number</li>
<li>bigint</li>
<li>string</li>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>symbol</li>
<li>object</li>
</ul>
<blockquote>
<p>没有专门的数组类型，数组实际上是一种键为有序数字的对象；<br>对象的键如果是数字或者可以转化为有效数字的字符（比如’1’ ‘2’），也会有相应的顺序变化，像数组一样。</p>
</blockquote>
<p><img src="http://blog.poetries.top/img-repo/2019/11/3.png"></p>
<p>其中 Symbol 和 BigInt 是 ES6 中新增的数据类型：</p>
<ul>
<li>Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</li>
<li>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。创建一个 bigint 需要在数字后面加上 n：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bigInt = <span class="number">1234567890123456789012345678901234567890n</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>bigint 不能和正常的 number 类型做加减乘除<br>bigint 只能和自己运算，结果也是自己，并且只可能是正整数<br>bigint 可以通过<code>Number()</code>和 number 互相转化，但是不支持<code>+bigint</code>这样转换。</p>
</blockquote>
<h2 id="0-1-0-2-0-3"><a href="#0-1-0-2-0-3" class="headerlink" title="0.1 + 0.2 !== 0.3"></a><code>0.1 + 0.2 !== 0.3</code></h2><p>js 中的数字是 IEEE754 标准下的 64 位双精度浮点数：</p>
<ul>
<li>1 位数符</li>
<li>11 位阶码，是移码，相当于原数+1023</li>
<li>52 位尾数<br><img src="https://pic.imgdb.cn/item/622f1c815baa1a80abcfa2fe.jpg"></li>
</ul>
<p>该数字能表达的最大的数：<code>2^53 - 1</code>，使用<code>Number.MAX_SAFE_INTEGER</code>可以获取<br>同理最小数就是改变数符，即<code>-(2^53 - 1)</code>，用<code>Number.MIN_SAFE_INTEGER</code>获取<br>超过最大数的数都会被视为相等：<br><img src="https://pic.imgdb.cn/item/622f1dd45baa1a80abd014a0.jpg"></p>
<p>0.1 和 0.2 的 IEEE754 表示为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 01111111100 0.1100110011001100110011001100110011001100110011001101</span><br><span class="line">0 01111111100 1.1001100110011001100110011001100110011001100110011010</span><br></pre></td></tr></table></figure>

<p>相加得</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 01111111100 10.0110011001100110011001100110011001100110011001100111</span><br></pre></td></tr></table></figure>

<p>小数点向左移动一位，阶码加 1，尾数超出的部分则 0 舍 1 入<br>结果就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 01111111101 0011001100110011001100110011001100110011001100110100</span><br></pre></td></tr></table></figure>

<p>这个值和 0.3 的表示有差距。其核心原因是上一步的舍去使得相加出现了精度问题。</p>
<h3 id="避免方法"><a href="#避免方法" class="headerlink" title="避免方法"></a>避免方法</h3><p>使用 <code>Number.EPSILON</code> 误差范围。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEqual</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(a - b) &lt; <span class="built_in">Number</span>.EPSILON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isEqual(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>Number.EPSILON</code>的实质是一个可以接受的最小误差范围，一般来说为 <code>Math.pow(2, -52)</code> 。<br>​<br>如果不追求精度，使用<code>toFixed(2)</code>保留两位小数即可。</p>
<h2 id="值的比较"><a href="#值的比较" class="headerlink" title="值的比较"></a>值的比较</h2><p>js 比较两个变量的符号通常有<code>&gt;</code>、<code>&lt;</code>、<code>!=</code>、<code>==</code>、<code>===</code>、<code>!==</code>。</p>
<p>除了<code>===</code>和<code>!==</code>，其他比较方式都会适当转换两个值；如果两个值类型不同，则会转换成相同类型再比较。</p>
<blockquote>
<p><code>==</code> 和其他比较大小的几个运算符转换的方式并不相同，因此很多时候会出现<code>&gt;=</code>成立但是<code>==</code>不成立的情况。</p>
</blockquote>
<h3 id="的转换规则"><a href="#的转换规则" class="headerlink" title="==的转换规则"></a><code>==</code>的转换规则</h3><p>判断流程：</p>
<ol>
<li>首先会判断两者类型是否相同，相同的话就比较两者的大小；类型不相同的话，就会进行类型转换；</li>
<li>会先判断是否在对比 null 和 undefined，是的话就会返回 true</li>
<li>判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number</li>
<li>判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断</li>
<li>判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断。<br>比如<code>&#39;1&#39; == &#123;&#125;</code>，相当于<code>&#39;1&#39; == &#39;[object Object]&#39;</code></li>
</ol>
<p>流程图：</p>
<p><img src="https://pic.imgdb.cn/item/6231cd8d5baa1a80ab1b76e2.jpg"></p>
<p>因此大多数情况下，都是将不同类型转换为 number 再进行比较。</p>
<h3 id="相同类型比较"><a href="#相同类型比较" class="headerlink" title="相同类型比较"></a>相同类型比较</h3><ul>
<li><p><code>boolean</code>：<br><img src="https://pic.imgdb.cn/item/62272d635baa1a80ab510506.jpg"></p>
</li>
<li><p><code>string</code><br>字符串比较默认按照字典序和 Unicode 编码顺序综合排序，序号在前面的比较小，因此小于序号在后面的字符；多个字符按照字典序规则比较。</p>
</li>
</ul>
<blockquote>
<p>注意，只有不同类型比较才会把字符串转为数字；<br><code>&#39;2&#39; &gt; &#39;12&#39;</code>结果为 true，因为两个都是字符串，直接按照字符串的比较方式比较。</p>
</blockquote>
<ul>
<li><p><code>object</code><br>对象永不相等，但是<code>&#123;&#125; &gt;= or &lt;= &#123;&#125;</code>结果为 true</p>
</li>
<li><p><code>number</code>和<code>bigint</code>都是正常比较大小</p>
</li>
<li><p><code>null</code>和自己不同</p>
</li>
<li><p><code>undefined</code>和自己<code>==</code>为 true</p>
</li>
</ul>
<h3 id="不同类型比较"><a href="#不同类型比较" class="headerlink" title="不同类型比较"></a>不同类型比较</h3><p><img src="https://pic.imgdb.cn/item/627b447c09475431290e3f9e.jpg"></p>
<h4 id="其他值到数字的转换规则"><a href="#其他值到数字的转换规则" class="headerlink" title="其他值到数字的转换规则"></a>其他值到数字的转换规则</h4><ul>
<li><code>Undefined</code> 类型的值转换为 NaN。</li>
<li><code>Null</code> 类型的值转换为 0。</li>
<li><code>Boolean</code> 类型的值，<code>true</code> 转换为 1，<code>false</code> 转换为 0。</li>
<li><code>String</code> 类型的值转换如同使用 <code>Number()</code> 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。</li>
<li><code>Symbol</code> 类型的值不能转换为数字，会报错。</li>
<li>对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。</li>
</ul>
<p>为了将值转换为相应的基本类型值，抽象操作 <code>ToPrimitive</code> 会首先（通过内部操作 <code>DefaultValue</code>）检查该值是否有<code>valueOf()</code>方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 <code>toString()</code> 的返回值（如果存在）来进行强制类型转换。<br>如果 <code>valueOf()</code> 和 <code>toString()</code> 均不返回基本类型值，会产生 <code>TypeError</code> 错误。</p>
<blockquote>
<p>如何让 if(a == 1 &amp;&amp; a == 2)条件成立？<br>其实就是 valueOf 的应用，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">valueOf</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="其他值到布尔类型的值的转换规则"><a href="#其他值到布尔类型的值的转换规则" class="headerlink" title="其他值到布尔类型的值的转换规则"></a>其他值到布尔类型的值的转换规则</h4><p>以下这些是假值：</p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>false</code></li>
<li>+0、-0</li>
<li><code>NaN</code></li>
<li><code>&quot;&quot;</code></li>
</ul>
<p>假值的布尔强制类型转换结果为 false。<br>假值列表以外的都是真值。</p>
<h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a><code>Object.is()</code></h4><p>是一种更精确的判断方式.<br>使用 <code>Object.is</code> 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。</p>
<h2 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h2><ol>
<li><code>==</code>比较时结果为 true，也就是<code>null == undefinded</code>；</li>
<li><code>null/undefined</code> 会被转化为数字：<code>null</code> 被转化为 0，<code>undefined</code> 被转化为 NaN。<br><img src="https://pic.imgdb.cn/item/622731015baa1a80ab543ae7.jpg"></li>
</ol>
<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p>null 代表的含义是空对象，并不是指一个值完全不存在；主要用于赋值给一些可能会返回对象的变量，作为初始化。<br>null 和其他值比较时相当于 0，但是和 0 比较时只有<code>&gt;=</code>和<code>&lt;=</code>成立。这是因为相等性检查<code>==</code>和普通比较符 <code>&gt; &lt; &gt;= &lt;=</code> 的代码逻辑是相互独立的。进行值的比较时，null 会被转化为数字，因此它被转化为了 0</p>
<blockquote>
<p>null 只和 undefined 非严格相等</p>
</blockquote>
<p><img src="https://pic.imgdb.cn/item/622731855baa1a80ab54998c.jpg"></p>
<hr>
<p><code>typeof null</code> 的结果是<code>&#39;object&#39;</code>，和<code>typeof Object</code>的结果一样</p>
<h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><p>undefined 代表的含义是未定义，一般变量声明了但还没有定义的时候会返回 undefined</p>
<p>undefined 不应该被与其他有效值进行比较，因为它并不会和任何值相等；唯一特例是与 null 和自己非严格相等：<br><img src="https://pic.imgdb.cn/item/6227334b5baa1a80ab55ba5d.jpg"></p>
<h2 id="NaN-和-Infinity"><a href="#NaN-和-Infinity" class="headerlink" title="NaN 和 Infinity"></a>NaN 和 Infinity</h2><p>NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>; <span class="comment">//number</span></span><br><span class="line"><span class="literal">NaN</span> !== <span class="literal">NaN</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>NaN 是一个特殊值，它和自身不相等，是唯一一个非自反的值。即<code>NaN !== NaN</code> 为 true。</p>
<hr>
<p>Infinity 表示“无穷”，是一个数值。当一个数过大超出 js 最大数值很多时，也会被认作 infinity，不一定是数学上的无穷</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">Infinity</span>; <span class="comment">//&#x27;number&#x27;</span></span><br><span class="line"><span class="literal">Infinity</span> === <span class="literal">Infinity</span>; <span class="comment">//true</span></span><br><span class="line"><span class="literal">Infinity</span> &gt; <span class="number">1</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="isNaN-和-isFinite"><a href="#isNaN-和-isFinite" class="headerlink" title="isNaN 和 isFinite"></a>isNaN 和 isFinite</h3><p>NaN 的判断主要是是通过<code>isNaN</code>方法。当一个变量类型转换出错或者计算出错时就会出现 NaN，这时可以用 isNaN 判断</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Number</span>(<span class="string">&quot;a&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">1</span> / <span class="number">0</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;a&quot;</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><code>isNaN</code>在参数为 NaN 的时候会返回 true。它会先<strong>尝试将参数转化为<code>Number</code>类型</strong>，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断（即，不是 NaN 但也不是数字类型时仍会返回 true）<br>更好的方法是使用<code>Number.isNaN</code>，相对于 isNaN 增加了对于数字的判断，只有是 Number 类型才会判断</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">&quot;a&quot;</span>); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<hr>
<p>infinity 的判定通过<code>isFinite</code>方法，但是注意这是判断“是有限的”，即正常数值会返回 true，无穷会返回 false。<br>和 isNaN 一样，参数会先被转为 Number 类型，然后进行判断；因此有时候会出现一些奇怪的判断结果<br><img src="https://pic.imgdb.cn/item/6231ccc75baa1a80ab19f546.jpg"><br>同理也有它的<code>Number.isFinite</code>版本，也是类似的更加准确。</p>
<h2 id="对象转化原始数据类型"><a href="#对象转化原始数据类型" class="headerlink" title="对象转化原始数据类型"></a>对象转化原始数据类型</h2><p>一个变量类型为对象的变量可以通过一些类型转换的方式变为原始数据类型的变量；<br>主要有三种转换，类型转换有三种变体（variant），发生在各种情况下，被称为 <code>hint</code>（这个词找不到具体含义，大概意思是对象的转化目标）</p>
<h3 id="1-转化为-string"><a href="#1-转化为-string" class="headerlink" title="1. 转化为 string"></a>1. 转化为 string</h3><p>通过 alert 或者其他方式可以让对象变成字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对象作为属性键</span></span><br><span class="line">anotherObj[obj] = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>这种方式隐式调用了<code>Object.prototype.toString</code>方法.<br>直接调用对象本身的 toString()方法也可以；<br><img src="https://pic.imgdb.cn/item/6226ec605baa1a80ab1488be.jpg"></p>
<h3 id="2-转化为-number"><a href="#2-转化为-number" class="headerlink" title="2. 转化为 number"></a>2. 转化为 number</h3><p>绝大多数对象或者实例转化为数字相关是都会变成 NaN，对象间的相加减也是。<br><img src="https://pic.imgdb.cn/item/6226ed4a5baa1a80ab153c99.jpg"></p>
<p>但是有几个特例，比如 Date 对象的实例是可以相加减的。<br><img src="https://pic.imgdb.cn/item/6226edca5baa1a80ab159013.jpg"><br>date 实例直接运算相当于是时间戳的运算。</p>
<h3 id="3-default"><a href="#3-default" class="headerlink" title="3. default"></a>3. <code>default</code></h3><p>当运算符“不确定”期望值的类型时，会把对象转化为<code>default</code>类型。<br>比如，二元加法 + 可用于字符串（连接），也可以用于数字（相加），所以字符串和数字这两种类型都可以。因此，当二元加法得到对象类型的参数时，它将依据 <code>&quot;default&quot; hint</code> 来对其进行转换。<br>此外，如果对象被用于与字符串、数字或 <code>symbol</code> 进行<code>==</code>比较，这时到底应该进行哪种转换也不是很明确，因此使用<code>&quot;default&quot; hint</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二元加法使用默认 hint</span></span><br><span class="line"><span class="keyword">let</span> total = obj1 + obj2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj == number 使用默认 hint</span></span><br><span class="line"><span class="keyword">if</span> (user == <span class="number">1</span>) &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="转化方法"><a href="#转化方法" class="headerlink" title="转化方法"></a>转化方法</h3><p>在对象进行类型转换时，JavaScript 尝试查找并调用三个对象方法，每一个不存在则调用下一个方法：</p>
<ol>
<li>调用 <code>obj[Symbol.toPrimitive](hint)</code>，即自定义的 <code>Symbol.toPrimitive</code>方法；</li>
<li>如果 hint 是 <code>&quot;string&quot;</code> ，优先调用 <code>obj.toString()</code> ，如果不存在则调用 <code>obj.valueOf()</code></li>
<li>如果 hint 是 <code>&quot;number&quot;</code> 或 <code>&quot;default&quot;</code> ，优先调用 <code>obj.valueOf()</code> 如果不存在则调用 <code>obj.toString()</code>。</li>
</ol>
<h3 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a><code>Symbol.toPrimitive</code></h3><p>因此可以手动实现一个<code>Symbol.toPrimitive</code>方法，从而达到自定义转化的效果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line"></span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`target: <span class="subst">$&#123;hint&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> hint === <span class="string">&quot;string&quot;</span> ? <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span> : <span class="built_in">this</span>.age;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(user); <span class="comment">//aaa</span></span><br><span class="line"><span class="built_in">console</span>.log(+user); <span class="comment">//18</span></span><br></pre></td></tr></table></figure>

<h3 id="toString-valueOf"><a href="#toString-valueOf" class="headerlink" title="toString/valueOf"></a><code>toString/valueOf</code></h3><p>默认情况下，普通对象具有 toString 和 valueOf 方法：</p>
<ul>
<li><code>toString</code> 方法返回一个字符串 <code>&quot;[object Object]&quot;</code>。</li>
<li><code>valueOf</code> 方法返回对象自身</li>
</ul>
<p>同样的，可以自定义这两个函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">money</span>: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于 hint=&quot;string&quot;</span></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`name: &quot;<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>&quot;`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于 hint=&quot;number&quot; 或 &quot;default&quot;</span></span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.money;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">alert(user); <span class="comment">// &quot;name: John&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(+user); <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>

<h2 id="原始数据类型和引用数据类型"><a href="#原始数据类型和引用数据类型" class="headerlink" title="原始数据类型和引用数据类型"></a>原始数据类型和引用数据类型</h2><h3 id="对象包装器"><a href="#对象包装器" class="headerlink" title="对象包装器"></a>对象包装器</h3><p>js 中的数据可以分为<strong>原始数据类型</strong>和<strong>引用数据类型</strong>。<br>有 7 种原始类型：<code>string</code>，<code>number</code>，<code>bigint</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code> ，<code>undefined</code>。<br>JavaScript 允许访问这些原始类型的方法和属性，但是理论上原始类型并没有办法提供任何方法和属性。<br>因此 js 会创建提供额外功能的特殊“<strong>对象包装器</strong>”，使用后即被销毁。<br>“对象包装器”对于每种原始类型都是不同的，有 String、Number、Boolean、Symbol 和 BigInt，各自提供了不同的方法。</p>
<blockquote>
<p>null/undefined 没有任何方法，没有对应的“对象包装器”</p>
</blockquote>
<p>因为包装器即用即毁的特征，我们不能向原始数据类型上添加任何自定义的方法和属性，不能存储额外的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;str&quot;</span>;</span><br><span class="line">str.test = <span class="number">1</span>;</span><br><span class="line">clg(str.test); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><ul>
<li>栈：原始数据类型（Undefined、Null、Boolean、Number、String、Symbol）。这个栈实际上就是 js 的调用栈，变量存储在函数的执行上下文中</li>
<li>堆：引用数据类型（对象、数组和函数）</li>
</ul>
<p>两种类型的区别在于存储位置的不同：</p>
<ul>
<li>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li>
<li>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。<strong>如果存储在栈中，将会影响程序运行的性能</strong>；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li>
</ul>
<p>堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：</p>
<ul>
<li>在数据结构中，栈中数据的存取方式为先进后出。</li>
<li>堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。</li>
</ul>
<p>在操作系统中，内存被分为栈区和堆区：</p>
<ul>
<li>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li>
<li>堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。</li>
</ul>
<blockquote>
<p>闭包保存的变量是存在堆中的</p>
</blockquote>
<h2 id="检测数据类型的方法"><a href="#检测数据类型的方法" class="headerlink" title="检测数据类型的方法"></a>检测数据类型的方法</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">2</span>); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&quot;str&quot;</span>); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;); <span class="comment">// function</span></span><br><span class="line"><span class="comment">//这些都是object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<p>typeof 的结果是一个全小写<strong>字符串</strong>；null 和 array 类型会被判断为 object，其他的正常；因此数组和 null 类型还需要其他方法区分</p>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><blockquote>
<p>instanceof 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。<br>说人话就是：用来判断一个构造函数是否是某个对象的原型，或者说这个对象的原型链上有没有这个构造函数。当然根据原型链的相关知识就知道，对象原型链上的不应该是构造函数本身，应该是构造函数的 prototype</p>
</blockquote>
<p><code>instanceof</code>本来适用于判断一个实例的原型；由于数据类型实际上就是其对应构造函数的实例，因此也可以借此来判断类型；但是只能用于引用类型的判断，基础类型不可以。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;str&quot;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面例子中的 Number、Boolean 等实际上是一个构造函数<br><img src="https://pic.imgdb.cn/item/62260d3e5baa1a80ab8d563f.jpg"></p>
<blockquote>
<p>原始数据类型是由这些构造函数构造出来的，但是这些并不是对象，<strong>如果我们试图访问它们的属性，那么临时包装器对象将会通过内建的构造器 String、Number 和 Boolean 被创建。它们提供给我们操作字符串、数字和布尔值的方法然后消失。</strong>这些对象的方法也驻留在它们的 <code>prototype</code> 中，可以通过 <code>String.prototype</code>、<code>Number.prototype</code> 和 <code>Boolean.prototype</code> 进行获取。<br>控制台输出可以看到，数组是有对应的构造函数<code>Array()</code>的<code>prototype</code>；原始数据类型的构造函数 prototype 不能被显式查看，但是依旧可以访问。<br><img src="https://pic.imgdb.cn/item/62260e895baa1a80ab8e2745.jpg"><br>另外，null 和 undefined 是特例，不能访问其构造函数的 prototype。</p>
</blockquote>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><blockquote>
<p>constructor 有两个作用，一是判断数据的类型，二是对象实例通过 constrcutor 对象访问它的构造函数。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">2</span>).constructor === <span class="built_in">Number</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span>.constructor === <span class="built_in">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;str&quot;</span>.constructor === <span class="built_in">String</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log([].constructor === <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;.constructor === <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125;.constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面说过原始数据类型不能通过原型链判断，但是可以通过<code>constrcutor</code>找到其对应的构造函数。<br>但是相应的，如果手动改变一个对象的原型，在使用判断就会出错</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">num = <span class="built_in">Object</span>.create(<span class="keyword">new</span> <span class="built_in">Array</span>());</span><br><span class="line"><span class="built_in">console</span>.log(num.constructor); <span class="comment">//[Function: Array]</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a><code>Object.prototype.toString</code></h3><p>调用 Object 对象的原型方法 <code>toString()</code>可以让每种数据类型有不同的表现：</p>
<p><img src="https://pic.imgdb.cn/item/622612555baa1a80ab907a7a.jpg"></p>
<blockquote>
<p>每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中 type 是对象的类型。</p>
</blockquote>
<p>一些操作中会隐式调用<code>Object.prototype.toString.call()</code>，使得本来正常的输出变成这种形式。常见的就是 alert 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">alert(obj); <span class="comment">//[object Object]</span></span><br></pre></td></tr></table></figure>

<p><code>Object.prototype.toString.call()</code> 使用 Object 对象的原型方法 toString 来判断数据类型。</p>
<blockquote>
<p>注意不能直接调用<code>toString()</code>并在括号中传入参数，应当使用 call 或者 apply 方法调用。<br>因为这个函数内部含有 this，应当使用 call 明确指定 this，否则可能是 undefined</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="literal">true</span>));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="string">&quot;str&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(a.call([]));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(&#123;&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="literal">undefined</span>));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[object Number]</span></span><br><span class="line"><span class="comment">[object Boolean]</span></span><br><span class="line"><span class="comment">[object String]</span></span><br><span class="line"><span class="comment">[object Array]</span></span><br><span class="line"><span class="comment">[object Function]</span></span><br><span class="line"><span class="comment">[object Object]</span></span><br><span class="line"><span class="comment">[object Undefined]</span></span><br><span class="line"><span class="comment">[object Null]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<p><code>obj.toString()</code>的结果和<code>Object.prototype.toString.call(obj)</code>的结果不一样，是因为 toString 是 Object 的原型方法，而 Array、function 等类型作为 Object 的实例，都重写了 toString 方法。不同的对象类型调用 toString 方法时，根据原型链的知识，调用的是对应的重写之后的 toString 方法（function 类型返回内容为函数体的字符串，Array 类型返回元素组成的字符串…），而不会去调用 Object 上原型 toString 方法（返回对象的具体类型），所以采用 obj.toString()不能得到其对象类型，只能将 obj 转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用 Object 原型上的 toString 方法。</p>
<p>同理，如果重写一个变量原型上的 <code>toString()</code>方法，也可以更改输出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">arr.__proto__.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">this</span>).slice(<span class="number">8</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(arr.toString()); <span class="comment">//&#x27;Array&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog();</span><br><span class="line">dog.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(dog.toString()); <span class="comment">//&#x27;taddy&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="判断数组的方法"><a href="#判断数组的方法" class="headerlink" title="判断数组的方法"></a>判断数组的方法</h3><ol>
<li>通过 <code>Object.prototype.toString.call()</code>做判断</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&quot;Array&quot;</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过原型链做判断</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.__proto__ === <span class="built_in">Array</span>.prototype;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通过 ES6 的 <code>Array.isArray()</code>做判断</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray(obj);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>通过 <code>instanceof</code> 做判断</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>通过 <code>Array.prototype.isPrototypeOf</code></li>
</ol>
<p>这个属性实际上是 <code>Object.prototype</code> 上的，通过原型链访问到</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.isPrototypeOf(obj);</span><br></pre></td></tr></table></figure>

<h1 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h1><p>比如现在有一个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;zzx&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">19</span>,</span><br><span class="line">  <span class="attr">info</span>: &#123;</span><br><span class="line">    <span class="attr">height</span>: <span class="number">175</span>,</span><br><span class="line">    <span class="attr">weight</span>: <span class="number">80</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先要了解,js 中普通的数据类型在复制时是复制值,而对象和数组等引用类型是复制地址<br>所以当我们直接<code>let obj2 = obj1</code>并不能复制,只是复制了 obj1 的引用<br>所以我们需要有一个拷贝的方法,可以保证新对象与源对象不一样</p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a><code>Object.assign</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br></pre></td></tr></table></figure>
<p><code>Object.assign</code>实际上是把一个对象所有的可枚举属性和自有属性(hasOwnProperty)复制到另一个对象中去，并返回复制的新对象。<br>如果通过difineProperty设置了属性不可枚举（不可遍历），则不能复制。<br>同时只会复制对象自己身上的属性，不会复制原型链上的属性。</p>
<h3 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2 = &#123; ...obj1 &#125;;</span><br></pre></td></tr></table></figure>

<p>而如果数组/对象互相嵌套,就需要进行深拷贝,方法有:</p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>原理是 <code>JSON.parse</code> 转换的对象是 <code>JSON.stringify</code> 生成的字符串，而不是原先的 obj</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* JSON先转字符串再转回来的方法可以实现 */</span></span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1));</span><br></pre></td></tr></table></figure>
<p>这个方法有很大的问题。比如如果某个值是一个函数，json就会忽略掉，这样再转回来的时候就会缺少属性</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>详见下方手写深拷贝</p>
<h3 id="lodash-库函数-cloneDeep"><a href="#lodash-库函数-cloneDeep" class="headerlink" title="lodash 库函数 cloneDeep"></a>lodash 库函数 cloneDeep</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2 = _.cloneDeep(obj1);</span><br></pre></td></tr></table></figure>

<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>Symbol 可以理解为一个对象的<strong>隐藏</strong>属性, 而在构造函数或者类中还可以作为方法使用, 在内建类中起到很重要作用。</p>
<h2 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> userId = <span class="built_in">Symbol</span>(<span class="string">&quot;myId&quot;</span>); <span class="comment">//创建一个symbol, myId是userId的description</span></span><br><span class="line">obj[userId] = <span class="string">&quot;0001&quot;</span>; <span class="comment">//使用创建symbol时的变量值引用</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[userId]);</span><br></pre></td></tr></table></figure>

<ul>
<li>Symbol() 的参数是它的 description, 可以方便在后续使用。</li>
<li>Symbol 只能用方括号访问, 访问的结果值是定义 Symbol 时的赋值，而不是 description（即不是调用 Symbol 方法传入的参数，而是具体用中括号放入对象时赋的值，比如上面的<code>userId</code>）</li>
</ul>
<p>也可以通过对象字面量的方式直接定义：(注意要先声明 Symbol)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userId = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xiaohong&quot;</span>,</span><br><span class="line">  [userId]: <span class="string">&quot;0002&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Symbol-的特点"><a href="#Symbol-的特点" class="headerlink" title="Symbol 的特点"></a>Symbol 的特点</h2><ol>
<li>不会被 <code>forin</code>/<code>for</code> 循环等遍历,用 <code>Object.keys</code> 也不会访问,即对外部方法不可见。</li>
</ol>
<blockquote>
<p>但是其实 Symbol 并不是完全隐形的，有一个内建方法 <code>Object.getOwnPropertySymbols(obj)</code> 允许获取所有的 Symbol。还有一个名为 <code>Reflect.ownKeys(obj)</code> 的方法可以返回一个对象的<strong>所有</strong>键，包括 Symbol。<br>同时，<code>Object.assign</code> 会同时复制字符串和 symbol 属性，通过展开运算符等拷贝方式（深浅拷贝都会）也会复制 Symbol 属性；但是继承的对象并不能访问到父原型的 Symbol</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> id = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> userObj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">userObj[id] = <span class="string">&quot;001&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(userObj));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherUserObj = &#123; ...userObj &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(anotherUserObj));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> childUserObj = <span class="built_in">Object</span>.create(userObj);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(childUserObj));</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/6226e4795baa1a80ab0f181d.jpg"></p>
</blockquote>
<ol start="2">
<li><p>任何两个 symbol 都不相等,即使 description 相同。<br>但是<code>Symbol.for()</code>可以创建一个被全局识别的 Symbol。也就是说由<code>Symbol.for()</code>创建的 Symbol 是全局唯一的，相同 description 的 symbol 会被判定为相同 Symbol。<br>这个全局 Symbol 并不是某个对象的隐藏属性，而是一个<strong>全局变量</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>.for(<span class="string">&quot;id&quot;</span>); <span class="comment">// 如果该 Symbol 不存在，则创建它</span></span><br><span class="line"><span class="comment">// 再次读取（可能是在代码中的另一个位置）</span></span><br><span class="line"><span class="keyword">let</span> idAgain = <span class="built_in">Symbol</span>.for(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="comment">// 相同的 Symbol</span></span><br><span class="line">clg(id === idAgain); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><p>JavaScript 使用了许多系统 Symbol，比如后面的 <code>Symbol.iterator</code> 迭代器对象、 <code>Symbol.hasInstance</code> 用于更改 instanceof 访问对象等等。这些系统 Symbol 并不是某个对象的属性，更像 Symbol 原型上的一些属性和方法，通过在对象或类中添加并合适赋值，可以改变一些对象的性质，供一些内置方法使用。</p>
</li>
<li><p>Symbol 不能被默认字符串化，也就是不能调用<code>Object.prototype.toString.call(Symbol)</code>；因此 alert 一个 Symbol 会报错。显示一个 Symbol 可以直接调用<code>toString()</code>方法</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> id = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> userObj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">userObj[id] = <span class="string">&quot;001&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(id.toString()); <span class="comment">//&#x27;Symbol(id)&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="Symbol-相关方法"><a href="#Symbol-相关方法" class="headerlink" title="Symbol 相关方法"></a>Symbol 相关方法</h2><p><code>Symbol.for()</code>:获取或创建一个<strong>全局的</strong>symbol 对象, 比如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>.for(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> userId = <span class="built_in">Symbol</span>.for(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">id === userId; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>他和直接 <code>Symbol()</code>的区别在于:</p>
<ul>
<li>会被登记在全局环境中供搜索，也就是相当于声明了一个全局变量，可以被<code>Symbol.keyFor()</code>获取到。</li>
<li>可以确保每次访问相同名字的 Symbol 时，返回的都是相同的 Symbol。</li>
</ul>
<hr>
<p><code>Symbol.keyFor()</code>：<code>Symbol.for()</code>的反向调用, 参数是定义<strong>全局 Symbol</strong> 时的<code>description</code>，返回这个全局 Symbol 对象。不适用于非全局 Symbol，如果 Symbol 不是全局的会返回 undefined。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> symid = <span class="built_in">Symbol</span>.for(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(id); <span class="comment">//symid</span></span><br></pre></td></tr></table></figure>

<h1 id="迭代器和可迭代"><a href="#迭代器和可迭代" class="headerlink" title="迭代器和可迭代"></a>迭代器和可迭代</h1><h2 id="forof-和-forin"><a href="#forof-和-forin" class="headerlink" title="forof 和 forin"></a>forof 和 forin</h2><ul>
<li><code>for...of</code> 循环可以使用的范围包括<ul>
<li>数组</li>
<li>Set 和 Map</li>
<li>某些类似数组的对象（比如 arguments/DOM NodeList）</li>
<li>Generator</li>
<li>字符串</li>
</ul>
</li>
<li><code>for...in</code> 以任意顺序遍历一个<strong>对象</strong>的除 Symbol 以外的可枚举<strong>属性</strong><ul>
<li>常用于对象属性的遍历,比如<code>for(let key in obj)&#123;&#125;</code></li>
<li>属性特征值被设置不可枚举的不能被遍历</li>
<li><strong>会遍历对象的整个原型链</strong>，性能非常差不推荐使用</li>
<li>Symbol 不能被遍历到</li>
</ul>
</li>
</ul>
<h2 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h2><p>一般我们称可以被按一定顺序遍历的对象为可迭代对象, 更具体的概念是可以使用 for…of 的对象(注意不是 for…in)<br>可迭代对象主要有以下两类:</p>
<ul>
<li>数组等本身可遍历的对象</li>
<li>添加了迭代器的对象</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>正常来说, 对象是不能使用 forof 遍历的(不是可迭代对象), 但是我们可以手动添加一个迭代器<br>迭代器特点:</p>
<ul>
<li>以<code>[Symbol.iterator]</code>作为方法名</li>
<li>返回一个迭代器对象, 内部有:<ul>
<li>一些数据, 用于限制迭代次数(不是必须)</li>
<li>有一个 <code>next()</code>函数,每次迭代都会调用这个函数,这个函数将会返回 <code>&#123;done:.., value :...&#125;</code> 格式的对象(必须)</li>
</ul>
</li>
<li>另外, 可迭代对象也可以用展开运算符展开</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="attr">from</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">to</span>: <span class="number">5</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">range[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">current</span>: <span class="built_in">this</span>.from,</span><br><span class="line">    <span class="attr">last</span>: <span class="built_in">this</span>.to,</span><br><span class="line">    <span class="comment">//next() 在 for..of 的每一轮循环迭代中被调用</span></span><br><span class="line">    <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.current &lt;= <span class="built_in">this</span>.last) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="built_in">this</span>.current++ &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//效果:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> range) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125; <span class="comment">//12345</span></span><br><span class="line"><span class="built_in">console</span>.log([...range]);</span><br></pre></td></tr></table></figure>

<p>不止是对象, 对于一个<strong>返回迭代器对象</strong>的函数也可以迭代<br>比如封装一个 range 函数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRange</span>(<span class="params"><span class="keyword">from</span>, to</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">from</span>,</span><br><span class="line">    to,</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">current</span>: <span class="built_in">this</span>.from,</span><br><span class="line">        <span class="attr">last</span>: <span class="built_in">this</span>.to,</span><br><span class="line">        <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">this</span>.current &lt;= <span class="built_in">this</span>.last) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="built_in">this</span>.current++ &#125;;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> createRange(<span class="number">1</span>, <span class="number">10</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125; <span class="comment">//10遍hello world</span></span><br></pre></td></tr></table></figure>

<h2 id="arrayLike"><a href="#arrayLike" class="headerlink" title="arrayLike"></a>arrayLike</h2><p>对于一些像数组的对象, 我们可以通过<code>Array.from()</code>变成真正的数组<br>像数组的对象有以下特点:</p>
<ul>
<li>键名为数字, 或者数字型的字符(比如’1’)</li>
<li>有 length 属性</li>
<li>本身没有数组相关方法, 比如 push pop</li>
</ul>
<blockquote>
<p>对于Array.from()的参数来说，只有一个要求，就是必须有length属性即可。</p>
</blockquote>
<p>举个栗子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrLike = &#123;</span><br><span class="line">  <span class="comment">//声明一个类数组对象,特点是键名为数字,并且有length属性</span></span><br><span class="line">  <span class="comment">//可以是任意数字</span></span><br><span class="line">  <span class="number">2</span>: <span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&quot;bbb&quot;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span>, <span class="comment">//不声明长度将会是空</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arrFrom = <span class="built_in">Array</span>.from(arrLike); <span class="comment">//[undefined,&#x27;bbb&#x27;,&#x27;aaa&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>from 方法也可以用于可迭代对象的转化,结果就是迭代范围的一个数组</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrRange = <span class="built_in">Array</span>.from(range); <span class="comment">//[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>

<p>除了<code>Array.from</code>，还有其他方式也可以把类数组转化为数组：</p>
<ol>
<li>展开运算符</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arrArgs = [...arguments];</span><br><span class="line">  arrArgs.forEach(<span class="function">(<span class="params">a</span>) =&gt;</span> <span class="built_in">console</span>.log(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>slice(arr)</code>/<code>splice(arr,0)</code>/<code>concat([],arr)</code><br>这三个方法都不能直接调用，因为不是一个数组；<br>需要通过<code>Array.prototype.xxx.call()</code>的方式调用，相当于借用了 Array 上的方法</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.concat.apply([], arrayLike); <span class="comment">//和一个空数组合并</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(arrayLike); <span class="comment">//不切割数组，返回一个原本完整的</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.splice.call(arrayLike, <span class="number">0</span>); <span class="comment">//从第0个开始，但不删除也不插入元素</span></span><br></pre></td></tr></table></figure>

<h1 id="Map-和-Set"><a href="#Map-和-Set" class="headerlink" title="Map 和 Set"></a>Map 和 Set</h1><p>Map 和 Set 都是一种类对象的数据类型, 都是通过构造函数方法创建</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="Map-的特点"><a href="#Map-的特点" class="headerlink" title="Map 的特点"></a>Map 的特点</h3><ul>
<li>Map 是一种键可以为任意值的对象, 对象的键一般只能是字符串, map 的键可以是数字/布尔值等任何类型</li>
<li>本身可迭代</li>
<li>值和键只能通过 get 和 set 等方法获取, 不能像对象一样用<code>.</code>获取;<strong>注意 set 和 get 都返回 map 本身,所以可以链式调用</strong></li>
<li>创建 map 可以用一组每个为一个键值对的数组(如下)传入</li>
</ul>
<p>比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="literal">true</span>, <span class="string">&quot;hello&quot;</span>).set(<span class="literal">false</span>, <span class="number">20</span>).set(<span class="number">12</span>, <span class="string">&quot;12&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="literal">true</span>)); <span class="comment">//&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="comment">//实际上map就是这样的数据形式，即一个二维数组</span></span><br><span class="line"><span class="keyword">const</span> mapByArr = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;apple&quot;</span>, <span class="number">10</span>],</span><br><span class="line">  [<span class="literal">false</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="number">12</span>, <span class="string">&quot;12&quot;</span>],</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<h3 id="Map-迭代"><a href="#Map-迭代" class="headerlink" title="Map 迭代"></a>Map 迭代</h3><p>如果要在 map 里使用循环，可以使用以下三个方法：</p>
<ul>
<li><code>map.keys()</code> —— 遍历并返回所有的键</li>
<li><code>map.values()</code> —— 遍历并返回所有的值</li>
<li><code>map.entries()</code> —— 遍历并返回所有的键值对</li>
<li><code>map.forEach((value,key,map)=&gt;&#123;&#125;)</code>：Map 中也有类似数组的 forEach 方法，操作基本一致。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> mapByArr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> mapByArr.keys()) &#123;</span><br><span class="line">  <span class="comment">//遍历map对象需要用keys()等方法,返回一个可迭代的包含键值信息的数组,</span></span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> mapByArr.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> mapByArr.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map-和对象相互转化"><a href="#Map-和对象相互转化" class="headerlink" title="Map 和对象相互转化"></a>Map 和对象相互转化</h3><ul>
<li><code>Object.entries()</code> 可以把已有对象转成 map 对象</li>
<li><code>Object.fromEntries()</code><strong>给定一个 [key, value] 键值对的数组</strong>，它会根据给定数组创建一个对象. 注意不是一个直接的 Map 对象.这个创建方法和上面的 Map 构造函数参数很像</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> userMap = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(user)); <span class="comment">//这种方法可以把已有对象转成map对象</span></span><br><span class="line"><span class="keyword">const</span> objFromMap = <span class="built_in">Object</span>.fromEntries([</span><br><span class="line">  [<span class="string">&quot;banana&quot;</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="string">&quot;orange&quot;</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="string">&quot;meat&quot;</span>, <span class="number">4</span>],</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="Set-的特点"><a href="#Set-的特点" class="headerlink" title="Set 的特点"></a>Set 的特点</h3><ul>
<li>Set 只有值没有键, 并且不可重复</li>
<li>跟 Map 一样,可迭代,不可直接访问,要借助 Set 自带的方法</li>
</ul>
<h3 id="Set-的主要方法"><a href="#Set-的主要方法" class="headerlink" title="Set 的主要方法"></a>Set 的主要方法</h3><ul>
<li><code>new Set(iterable)</code> : 创建一个 set，<strong>如果提供了一个 iterable 对象（通常是数组）,将会从数组里面复制值到 set 中</strong></li>
<li><code>set.add(value)</code> : 添加值,也是返回 set 本身,可以链式调用. 创建 set 还可以使用一个数组</li>
<li><code>set.delete(value)</code> : 删除值</li>
<li><code>set.has(value)</code>:是否存在值</li>
<li><code>set.clear()</code>:清空</li>
<li><code>set.size</code>:返回元素个数。</li>
</ul>
<p>set 也有像 map 一样的 keys()/values()/entries()方法, <strong>虽然没有键</strong></p>
<ul>
<li><code>set.keys()</code> —— 遍历并返回所有的值</li>
<li><code>set.values()</code> —— 与 <code>set.keys()</code>作用相同，这是为了兼容 Map，</li>
<li><code>set.entries()</code> —— 遍历并返回所有的实体[value, value]，它的存在也是为了兼容 Map。</li>
<li><code>set.forEach((value,value,set)=&gt;&#123;&#125;)</code>：set 上的 foEach 方法，前两个参数相同都是当前值，是为了兼容 Map 所以重复两次。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">let</span> xiaoming = &#123; <span class="attr">name</span>: <span class="string">&quot;xiaoming&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> xiaohong = &#123; <span class="attr">name</span>: <span class="string">&quot;xiaohong&quot;</span> &#125;;</span><br><span class="line">set.add(xiaoming).add(xiaoming).add(xiaohong);</span><br><span class="line"><span class="built_in">console</span>.log(set.size); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>这里添加了两次 xiaoming，但是因为重复所以值加入了一个。<br>注意,<strong>当添加的是引用对象时不会自动去重</strong>,比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">set</span><br><span class="line">  .add(&#123; <span class="attr">name</span>: <span class="string">&quot;xiaoming&quot;</span> &#125;)</span><br><span class="line">  .add(&#123; <span class="attr">name</span>: <span class="string">&quot;xiaoming&quot;</span> &#125;)</span><br><span class="line">  .add(&#123; <span class="attr">name</span>: <span class="string">&quot;xiaohong&quot;</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(set.size); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>原因是引用对象的两个<code>&#123;name:&#39;xiaoming&#39;&#125;</code>本质上不算一个值(两种地址), 所以不会被去重；上面一个例子的两个 xiaoming 是同一个地址，所以会被去重</p>
<h3 id="Set-迭代"><a href="#Set-迭代" class="headerlink" title="Set 迭代"></a>Set 迭代</h3><p>可以使用 for..of 或 forEach 来遍历 Set：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setFromArr = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="number">100</span>, <span class="literal">true</span>]);</span><br><span class="line">setFromArr.forEach(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(val));</span><br></pre></td></tr></table></figure>

<p>或者用 set.keys/set.values/set.entries 等方法</p>
<h3 id="Set-的转换"><a href="#Set-的转换" class="headerlink" title="Set 的转换"></a>Set 的转换</h3><p>set 在类型上更像数组而不是对象, 所以 Set 可以用 Array.from 生成一个数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(arr); <span class="comment">//生成set</span></span><br><span class="line"><span class="keyword">const</span> arr1 = <span class="built_in">Array</span>.from(set); <span class="comment">//返回数组</span></span><br></pre></td></tr></table></figure>

<h3 id="Set-用于数组去重"><a href="#Set-用于数组去重" class="headerlink" title="Set 用于数组去重"></a>Set 用于数组去重</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrRepeated = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> setNoRepeat = <span class="keyword">new</span> <span class="built_in">Set</span>(arrRepeated);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(setNoRepeat));</span><br></pre></td></tr></table></figure>

<h2 id="WeakMap-和-WeakSet"><a href="#WeakMap-和-WeakSet" class="headerlink" title="WeakMap 和 WeakSet"></a>WeakMap 和 WeakSet</h2><p>这两者的出现都是为了解决 Map 和 Set 的垃圾回收问题。<br>由 js 的垃圾回收机制可以直到，如果一个对象的索引被置为 null，这个对象就相当于不可访问，因此就会被垃圾回收机制回收；<br>但是如果对象作为 Map 的键，那么当 Map 存在时，该对象也将存在。它会占用内存，并且应该不会被（垃圾回收机制）回收。<br>WeakMap 在这方面有着根本上的不同。它不会阻止垃圾回收机制对作为键的对象的回收。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>WeakMap 的键必须是对象，其他的都不可以</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> weakMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">weakMap.set(obj, <span class="string">&quot;ok&quot;</span>); <span class="comment">// 正常工作（以对象作为键）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能使用字符串作为键</span></span><br><span class="line">weakMap.set(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;Whoops&quot;</span>); <span class="comment">// Error，因为 &quot;test&quot; 不是一个对象</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>WeakMap 没有任何迭代方法，只有基础的四个方法：</li>
</ol>
<ul>
<li><code>weakMap.get(key)</code></li>
<li><code>weakMap.set(key, value)</code></li>
<li><code>weakMap.delete(key)</code></li>
<li><code>weakMap.has(key)</code></li>
</ul>
<ol start="3">
<li><p>WeakSet 和 WeakMap 类似，只能向 WeakSet 添加对象；并且也不能迭代只有基础的四个方法。</p>
</li>
<li><p>WeakMap 中，如果一个作为键的对象的索引被置 null，这个键和值也会被垃圾回收；WeakSet 同理。</p>
</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>WeakMap 的主要应用场景是 <strong>额外数据的存储</strong>，可以理解为缓存或者用于存储一些核心之外的边角数据。这些数据就应该与主要的对象共存亡，当对象被清除，这些数据不应该被保留。</li>
<li>WeakSet 可以作为额外的存储空间。但并非针对任意数据，而是针对“是/否”的事实。WeakSet 的元素可能代表着有关该对象的某些信息。WeakSet 更多执行一个<code>has</code>的操作，只用判断是否“有过”</li>
</ul>
<h1 id="对象属性配置"><a href="#对象属性配置" class="headerlink" title="对象属性配置"></a>对象属性配置</h1><h2 id="对象的默认属性"><a href="#对象的默认属性" class="headerlink" title="对象的默认属性"></a>对象的默认属性</h2><p>对象的每个属性都有对应的四个默认属性,分别为</p>
<ul>
<li><code>value</code>: 本身的值</li>
<li><code>writable</code>:默认 true, false 为只读</li>
<li><code>enumerable</code>: 是否可枚举,false 即不会出现在 forin/object.keys 这种遍历中,直接打印也不会出现</li>
<li><code>configurable</code>: 是否可配置,即不可删除/覆盖,也不能修改只读属性等,<strong>但是可以改属性值</strong></li>
</ul>
<p>设置或更改属性的属性值使用 <code>Object.defineProperty</code> 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;xiaohong&quot;</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>, <span class="comment">//只读</span></span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">//不可枚举,即不会出现在forin/object.keys这种遍历中,直接打印也不会出现</span></span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">//不可配置,即不可删除/覆盖,也不能修改只读属性等,但是可以改属性值</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>获取属性可以用 getOwnPropertyDescriptor 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(user, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">/* 属性描述符：</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &quot;value&quot;: &quot;xiaoming&quot;,</span></span><br><span class="line"><span class="comment">  &quot;writable&quot;: true,</span></span><br><span class="line"><span class="comment">  &quot;enumerable&quot;: true,</span></span><br><span class="line"><span class="comment">  &quot;configurable&quot;: true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="getter-和-setter"><a href="#getter-和-setter" class="headerlink" title="getter 和 setter"></a>getter 和 setter</h2><blockquote>
<p>getter 和 setter 是对象的访问器属性。它们本质上是用于获取和设置值的<strong>函数</strong>，但<strong>从外部代码来看就像常规属性</strong></p>
</blockquote>
<p>意思就是, getter 和 setter 定义为函数, 但访问是用属性的方式访问<br>getter 和 setter 的主要特点为:</p>
<ul>
<li>getter 和 setter 是属性不是方法,得用属性的形式访问</li>
<li>定义一个 getter 的方法是 <code>get funcname()&#123;&#125;</code>,相当于 get 后面一个正常的方法, get 只是一个修饰符;</li>
<li>setter 需要一个参数, 作为设置的值;getter 不设返回值就无法获取访问结果(下面的 student.name 会是 undefined)</li>
</ul>
<p>比如这个例子中,get 和 set 是属性不是方法,得用属性的形式访问而不是 name(‘xx’)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> student = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val.length &lt; <span class="number">3</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//长度短不予设置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">this</span>._name = val;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//注意,</span></span><br><span class="line">student.name = <span class="string">&quot;aa&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(student.name); <span class="comment">//undefined</span></span><br><span class="line">student.name = <span class="string">&quot;xiaoming&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(student.name); <span class="comment">//设置成功</span></span><br></pre></td></tr></table></figure>

<p>同理我们也可以用 <code>defineProperty</code> 给对象加 getter 和 setter</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">&quot;birthday&quot;</span>, &#123;</span><br><span class="line">  <span class="comment">//通过define给对象加属性</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">return</span> date.getFullYear() - <span class="built_in">this</span>.age;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="built_in">this</span>.age = date.getFullYear() - val;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">user.birthday = <span class="number">2002</span>; <span class="comment">//触发set,改动了age</span></span><br><span class="line"><span class="built_in">console</span>.log(user.birthday, user.age); <span class="comment">//birthday的访问通过get</span></span><br></pre></td></tr></table></figure>

<p>这里有一个 this 指向的问题, 也适用于后面的类和构造函数:<br><strong>this 的指向始终只和<code>.</code>之前的值有关,跟内部引用和定义没关系</strong><br>另外, 类和构造函数也可以加 getter, 在其实例的访问时会调用该 getter</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">birthday</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.birthday = birthday;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, <span class="string">&quot;age&quot;</span>, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> todayYear = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">      <span class="keyword">return</span> todayYear - <span class="built_in">this</span>.birthday.getFullYear();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> john = <span class="keyword">new</span> User(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2002</span>, <span class="number">6</span>, <span class="number">1</span>));</span><br><span class="line">join.age; <span class="comment">//触发getter, 返回计算值19</span></span><br></pre></td></tr></table></figure>

<h1 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h1><p>函数有两种创建方式：函数声明和函数表达式。<br>无论函数是如何创建的，函数都是一个值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数表达式*/</span></span><br><span class="line"><span class="keyword">let</span> hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>函数声明和函数表达式的区别在于：JavaScript 引擎会在 <strong>什么时候</strong> 创建函数。</p>
<ul>
<li>函数表达式是在代码执行到达时被创建，并且仅从那一刻起可用；</li>
<li>函数声明被定义之前，它就可以被调用，无论声明被写在何处；</li>
</ul>
<p>并且，当一个函数声明在一个<strong>代码块内</strong>时，它在该代码块内的任何位置都是可见的。但在代码块外不可见。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">welcome</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">welcome</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;Greetings!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">welcome(); <span class="comment">// Error: welcome is not defined</span></span><br></pre></td></tr></table></figure>

<h1 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h1><p>在 js 中, 函数本质也是个对象, 因此函数也有对象的一些属性<br>一个空函数:<br><img src="https://pic.imgdb.cn/item/61b0c2282ab3f51d915ba4b5.png"></p>
<ul>
<li>prototype 是函数固有的原型对象(原型链会讲到)</li>
<li>name:函数名</li>
<li>length:函数参数数量</li>
<li>arguments:函数参数(返回一个数组，注意结尾的 s)</li>
</ul>
<p>以及一些方法</p>
<h2 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h2><p>因为函数本质也是个对象, 所以我们可以给函数本身添加一些属性,比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">  sayHello.counter++; <span class="comment">//使用函数名自定义属性</span></span><br><span class="line">&#125;</span><br><span class="line">sayHello.counter = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>每调用一次 sayHello, 内部的 counter 就会加一.注意这里 counter 相当于一个全局存储的变量, 通过函数对象直接访问,并存储在全局。</p>
<blockquote>
<p>函数属性可以用于在一些情况下替代闭包，同时这个闭包可以直接在外部访问</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> counter.count++;</span><br><span class="line">  &#125;</span><br><span class="line">  counter.count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = makeCounter();</span><br><span class="line">counter.count = <span class="number">10</span>;</span><br><span class="line">alert(counter()); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>不仅是属性，方法也可以</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count++;</span><br><span class="line">  &#125;</span><br><span class="line">  counter.set = <span class="function">(<span class="params">value</span>) =&gt;</span> (count = value);</span><br><span class="line">  counter.decrease = <span class="function">() =&gt;</span> count--;</span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="IFE"><a href="#IFE" class="headerlink" title="IFE"></a>IFE</h2><p>定义式的函数可以额外拥有一个内部的名字, 该函数名可以用于递归, 外部不可见</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sayHi = <span class="function"><span class="keyword">function</span> <span class="title">_sayHi</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (who) &#123;</span><br><span class="line">    alert(<span class="string">`Hello, <span class="subst">$&#123;who&#125;</span>`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _sayHi(<span class="string">&quot;Guest&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h1><blockquote>
<p>柯里化是一种函数的转换，它是指将一个函数从可调用的 f(a, b, c) 转换为可调用的 f(a)(b)(c)。</p>
</blockquote>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>举个栗子,两个参数的柯里化:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> f(a, b);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> add = curry(sum);</span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>一步步分析原理:</p>
<ol>
<li>首先调用 curry(sum),会返回第一层函数,即 add 函数</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(a, b);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然后 add(1),触发第一层,相当于参数 a = 1;进入第二层</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>) = <span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(<span class="number">1</span>,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>再调用 add(1)(2),到最后一层,把参数 b 传入</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>) = f(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>最后返回 sum(1,2)的值 3</li>
</ol>
<p>因此柯里化的过程实际上就是拆分参数的过程;把多个参数按照一定分组分开调用;</p>
<h3 id="真正实现"><a href="#真正实现" class="headerlink" title="真正实现"></a>真正实现</h3><p>还有更高级的写法,比如递归:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= func.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> func(args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curried(...args, ...args2);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> add = curry(sum);</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>同样原理如下:(以 <code>add(1)(2,3)</code>为例)</p>
<ol>
<li>add 函数相当于这个:</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (args.length &gt;= func.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> func(args);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> curried(...args, ...args2);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然后产生 add(1),即<code>args = [1]</code>;因为参数数量少于函数最大参数数量,所以进入 else,即 add(1)又是这个函数:</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> curried(<span class="number">1</span>, ...args2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>调用 add(1)(2,3),后面的(2,3)相当于 add(1)这个函数的参数,被传入…args2 中</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"><span class="number">2</span>,<span class="number">3</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> curried(<span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>递归,再次进入 1 中的函数;但是这次参数为三个,所以直接调用 sum(1,2,3)</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>) === sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>多个参数同理,这就是柯里化的根本原理</li>
</ol>
<p>另外,lodash 库中有<code>_.curry</code> 可以用做柯里化一个函数,其源码如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= func.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curried.apply(<span class="built_in">this</span>, args.concat(args2));</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>柯里化可以适用于函数多个参数的分开调用/延时执行等地方,并且可以创建偏函数(即原函数中只有一个参数的新函数)<br>比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">method, url, type</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以把它柯里化,然后转成一个固定 method 的偏函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getData = _.curry(getData)</span><br><span class="line"><span class="keyword">let</span> getDataByPost = getData(<span class="string">&quot;POST&quot;</span>)</span><br><span class="line">getDataByPost(<span class="string">&quot;/...&quot;</span>,...)</span><br></pre></td></tr></table></figure>

<p>（当然这个更方便的实现是通过 bind</p>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>JavaScript 的精髓在于创建一个函数并将其传递到某个地方。在诸如<code>forEach</code>、<code>map</code>这样的函数中，通常不想离开当前上下文。这就是箭头函数的主战场。</p>
<p>箭头函数的主要特点如下：</p>
<h3 id="没有-this"><a href="#没有-this" class="headerlink" title="没有 this"></a>没有 this</h3><p>箭头函数内部的 this，实际上是其外层执行上下文的 this。之前说 this 实际上就是函数<strong>执行上下文</strong>的指代，因此也可以理解为箭头函数的 this 指代的仍是其外层的。<br>注意这个外层是<strong>调用</strong>时的外层，就像执行上下文只有在执行时才能确定；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">  <span class="attr">sayName</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.sayName(); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>这个例子中，sayName 是一个箭头函数，自身代码中的 this 实际上是调用时的外层<code>window</code>，因此不存在该属性。<br>如果是一个正常的函数，前面有对象和点访问符的情况，this 将会指向该对象，而不是直接指向外层。</p>
<p>从 Babel 翻译 this 也可以看出来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">getArrow</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span> === obj);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">getArrow</span>: <span class="function"><span class="keyword">function</span> <span class="title">getArrow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(_this === obj);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到箭头函数的 this 实际上是外层 this 的一个闭包。</p>
<h3 id="不存在-prototype"><a href="#不存在-prototype" class="headerlink" title="不存在 prototype"></a>不存在 prototype</h3><p>箭头函数不存在自己的 prototype</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrow = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">arrow.prototype; <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>因此箭头函数也不会拥有普通函数中的一些属性和方法，同样也不能访问函数对象，给函数本身添加属性</p>
<h3 id="没有-arguments-属性"><a href="#没有-arguments-属性" class="headerlink" title="没有 arguments 属性"></a>没有 arguments 属性</h3><p>但是仍可以这样访问参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrow = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是在一些函数包装器中就不合适，因此函数装饰器返回的函数尽量采用普通函数。</p>
<blockquote>
<p>箭头函数仍有<code>name</code>和<code>length</code>属性。</p>
</blockquote>
<h3 id="不能-new"><a href="#不能-new" class="headerlink" title="不能 new"></a>不能 new</h3><p>由于没有自己的 this 和 prototype，箭头函数也不能作为构造函数去 new</p>
<h3 id="没有-super"><a href="#没有-super" class="headerlink" title="没有 super"></a>没有 super</h3><p>在类中的箭头函数上调用 super 会和 this 一样的效果，即从外层访问</p>
<h3 id="call-、apply-、bind-等方法不能改变箭头函数中-this-的指向"><a href="#call-、apply-、bind-等方法不能改变箭头函数中-this-的指向" class="headerlink" title="call()、apply()、bind()等方法不能改变箭头函数中 this 的指向"></a><code>call()</code>、<code>apply()</code>、<code>bind()</code>等方法不能改变箭头函数中 this 的指向</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&quot;Global&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> fun1 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">&#125;;</span><br><span class="line">fun1(); <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.call(&#123; <span class="attr">id</span>: <span class="string">&quot;Obj&quot;</span> &#125;); <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.apply(&#123; <span class="attr">id</span>: <span class="string">&quot;Obj&quot;</span> &#125;); <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.bind(&#123; <span class="attr">id</span>: <span class="string">&quot;Obj&quot;</span> &#125;)(); <span class="comment">// &#x27;Global&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>参考：<a target="_blank" rel="noopener" href="https://blog.poetries.top/browser-working-principle/guide/part2/lesson07.html">https://blog.poetries.top/browser-working-principle/guide/part2/lesson07.html</a></p>
<p>执行上下文，里边有变量环境、词法环境、outer 和 this 四部分<br><img src="http://blog.poetries.top/img-repo/2019/11/1.png"><br><img src="https://static001.geekbang.org/resource/image/06/13/0655d18ec347a95dfbf843969a921a13.png"></p>
<h4 id="执行上下文的伪代码表示"><a href="#执行上下文的伪代码表示" class="headerlink" title="执行上下文的伪代码表示"></a>执行上下文的伪代码表示</h4><p>词法环境的伪代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GlobalExectionContext = &#123;  <span class="comment">// 全局执行上下文</span></span><br><span class="line">  <span class="attr">LexicalEnvironment</span>: &#123;       <span class="comment">// 词法环境</span></span><br><span class="line">    <span class="attr">EnvironmentRecord</span>: &#123;     <span class="comment">// 环境记录</span></span><br><span class="line">      <span class="attr">Type</span>: <span class="string">&quot;Object&quot;</span>,           <span class="comment">// 全局环境</span></span><br><span class="line">      <span class="comment">// 变量绑定在这里</span></span><br><span class="line">      <span class="attr">outer</span>: &lt;<span class="literal">null</span>&gt;           <span class="comment">// 对外部环境的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">FunctionExectionContext</span>: &#123; <span class="comment">// 函数执行上下文</span></span><br><span class="line">    <span class="attr">LexicalEnvironment</span>: &#123;     <span class="comment">// 词法环境</span></span><br><span class="line">      <span class="attr">EnvironmentRecord</span>: &#123;    <span class="comment">// 环境记录</span></span><br><span class="line">        <span class="attr">Type</span>: <span class="string">&quot;Declarative&quot;</span>,      <span class="comment">// 函数环境</span></span><br><span class="line">        <span class="comment">// 变量绑定在这里      // 对外部环境的引用</span></span><br><span class="line">        <span class="attr">outer</span>: <span class="xml"><span class="tag">&lt;<span class="name">Global</span> <span class="attr">or</span> <span class="attr">outer</span> <span class="attr">function</span> <span class="attr">environment</span> <span class="attr">reference</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>

<p>变量环境是存储 var 定义的变量的另一个词法环境</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> VariableEnvironment: &#123;  <span class="comment">// 变量环境</span></span><br><span class="line">    <span class="attr">EnvironmentRecord</span>: &#123;</span><br><span class="line">      <span class="attr">Type</span>: <span class="string">&quot;Object&quot;</span>,</span><br><span class="line">      <span class="comment">// 标识符绑定在这里</span></span><br><span class="line">      <span class="attr">c</span>: <span class="literal">undefined</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">outer</span>: &lt;<span class="literal">null</span>&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>举一个实际的例子，比如下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">e, f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> g = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">return</span> e * f * g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = multiply(<span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>对应的伪代码执行上下文如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">GlobalExectionContext = &#123;<span class="comment">//全局上下文，包裹着全局定义的函数、变量</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">ThisBinding</span>: &lt;Global Object&gt;,// this的绑定，这里是全局上下文中的this，即全局对象(window)</span><br><span class="line"></span><br><span class="line">  LexicalEnvironment: &#123;  // 词法环境</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      // 标识符绑定在这里</span><br><span class="line">      a: &lt; uninitialized &gt;,  // a被定义但是未被初始化，只有执行到特定的行才会被初始化，并且这一行之前也不能使用</span><br><span class="line">      b: &lt; uninitialized &gt;,</span><br><span class="line">      multiply: &lt; func &gt;  // 函数被定义但未被初始化</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  VariableEnvironment: &#123;  // 变量环境</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      // 标识符绑定在这里</span><br><span class="line">      c: undefined,  // var定义的变量会被初始化为undefined，可以使用但是没有意义</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FunctionExectionContext = &#123;  // 函数的执行上下文</span><br><span class="line"></span><br><span class="line">  ThisBinding: &lt;Global Object&gt;,// 函数内部的this</span><br><span class="line"></span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      // 标识符绑定在这里</span><br><span class="line">      Arguments: &#123;0: 20, 1: 30, length: 2&#125;,  // 参数被保存在词法环境，可以看到参数实际上是一个单独的块作用域</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;  // 函数的outer指向全局</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  VariableEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      // 标识符绑定在这里</span><br><span class="line">      g: undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当形成这样的执行上下文后，就会放入 js 调用栈中执行。当 Javascript 引擎开始执行第一行脚本代码的时候，它就会创建一个全局执行上下文然后将它压到执行栈中；每当引擎碰到一个函数的时候，它就会创建一个函数执行上下文，然后将这个执行上下文压到执行栈中。也就是说，执行上下文是在开始执行的时候创建的，创建后立即被压入执行栈<br>执行过程会进行赋值、代码执行等操作，执行完成后会回收出栈的执行上下文并销毁。</p>
<h4 id="词法环境-Lexical-Environments"><a href="#词法环境-Lexical-Environments" class="headerlink" title="词法环境(Lexical Environments)"></a>词法环境(Lexical Environments)</h4><ul>
<li>词法环境是一个用于”登记”执行上下文中的变量/函数等的结构</li>
<li>词法环境创建的 5 种类型:<ul>
<li>函数</li>
<li>with 代码块</li>
<li>catch 代码块(注意不是 try)</li>
<li>全局</li>
<li>eval<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/3/1677429807aea76d~tplv-t2oaga2asx-watermark.awebp"></li>
</ul>
</li>
<li>词法环境对象由两部分组成：<ul>
<li>环境记录(<code>Environment Records</code>) :一个存储<strong>所有局部变量</strong>作为其属性（包括一些其他信息，例如 this 的值）的对象。就是登记环境内部变量的地方</li>
<li>外部引用(<code>outer</code>):对外部词法环境的<strong>引用</strong>，与外部代码相关联。就是包含本自己词法环境的父外部词法环境,是作用域链连起来的根本</li>
</ul>
</li>
<li>词法环境在 js 解析代码之前就已经创建了,也就是说在词法环境内的变量都会被先创建,但是不能引用;必须等待 let/const/函数声明来”登记”了之后才可以</li>
<li>我们常说的变量只是环境记录的一个属性</li>
<li>词法环境是嵌套的。内部的词法环境会通过 outer 和外部词法环境相连;当代码要访问一个变量时 —— 首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。</li>
</ul>
<p>举个例子,比如下面这段代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> counter = makeCounter();</span><br></pre></td></tr></table></figure>

<p>会创建这样的嵌套词法环境:<br><img src="https://pic.imgdb.cn/item/61b1d3072ab3f51d91da2eb8.png"><br>当我们调用 counter 函数,</p>
<ol>
<li>counter 创建自己的词法环境</li>
<li>counter 函数查找自己词法环境内部的 count 变量;</li>
<li>上一步没找到,就会根据 outer 到外部词法环境,也就是 makeCounter 函数的词法环境查找;</li>
<li>如果再找不到就会到全局,在哪找到就会在哪修改</li>
</ol>
<p>这是执行之后的:<br><img src="https://pic.imgdb.cn/item/61b1d4162ab3f51d91dac8ca.png"></p>
<h4 id="变量环境-Variable-Environment"><a href="#变量环境-Variable-Environment" class="headerlink" title="变量环境(Variable Environment)"></a>变量环境(Variable Environment)</h4><p>相对于词法环境:</p>
<ul>
<li>两者本质上差不多,变量环境是一种特殊的词法环境</li>
<li>变量环境用来存储 var 声明和函数声明</li>
<li>词法环境存储 let/const 以及各种块声明</li>
</ul>
<h4 id="执行上下文中的-this"><a href="#执行上下文中的-this" class="headerlink" title="执行上下文中的 this"></a>执行上下文中的 this</h4><p><a target="_blank" rel="noopener" href="https://blog.poetries.top/browser-working-principle/guide/part2/lesson11.html">https://blog.poetries.top/browser-working-principle/guide/part2/lesson11.html</a></p>
<h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><ul>
<li>作用域：规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。换句话说，作用域决定了代码区块中变量和其他资源的可见性。（全局作用域、函数作用域、块级作用域）</li>
<li>作用域链：从当前作用域开始一层层往上找某个变量，如果找到全局作用域还没找到，就放弃寻找 。这种层级关系就是作用域链。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903797135769614">https://juejin.cn/post/6844903797135769614</a></p>
<blockquote>
<p>对于 for 循环的块级作用域问题也是常考点。比如这个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个的输出分别为：</p>
<ul>
<li>1 秒后同时输出 3 个 3，因为 var 不具有块级作用域，每次循环都会重新赋值，最终值为 3</li>
<li>1 秒后同时输出 0 1 2</li>
</ul>
<p>其实只要这样看待就很好理解：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">3</span>; <span class="comment">//每次赋值都会覆盖上面的，因此最终是向延迟队列中放入3个3</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">3</span>; <span class="comment">//每个i不一样</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>先看这样一段代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(myName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myName = <span class="string">&quot;BBB&quot;</span>;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">&quot;AAA&quot;</span>;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>这个代码最终打印的是 AAA 而不是 BBB<br>作用域链实际上就是上面所说的词法环境中的 outer 连续指向形成的链。在上面这段代码中，<code>bar</code> 和 <code>foo</code> 的 <code>outer</code> 都指向全局，所以没有的变量去全局查找，因此最终 <code>bar</code> 中的 <code>myName</code> 应该是 AAA<br>因此作用域链，或者说一个函数的 <code>outer</code> <strong>只和定义时的位置相关</strong>，跟怎么调用无关<br>如果是这样，就可以打印 BBB 了，因为<code>myName</code>是<code>bar</code>函数的一个闭包</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myName = <span class="string">&quot;BBB&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(myName);</span><br><span class="line">  &#125;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">&quot;AAA&quot;</span>;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/61b1d8f42ab3f51d91dda91b.png"><br>所以可以总结相关几点:</p>
<ul>
<li>作用域链通过执行上下文中词法环境的 outer 属性设置</li>
<li>通常一个执行上下文的 outer 指向它声明的时候的直接外部执行上下文</li>
<li>一个函数的 outer 只和定义时的位置相关，跟怎么调用无关</li>
</ul>
<h3 id="作用域和执行上下文"><a href="#作用域和执行上下文" class="headerlink" title="作用域和执行上下文"></a>作用域和执行上下文</h3><p>JavaScript 属于解释型语言，JavaScript 的执行分为解释和执行两个阶段,这两个阶段所做的事并不一样：</p>
<p><strong>解释阶段</strong>：</p>
<ul>
<li>词法分析</li>
<li>语法分析</li>
<li>作用域规则确定</li>
</ul>
<p><strong>执行阶段</strong>：</p>
<ul>
<li>创建执行上下文，并创建词法环境、变量环境、变量初始化为 undefined，函数确定但不执行</li>
<li>执行函数代码</li>
<li>垃圾回收</li>
</ul>
<p>JavaScript 解释阶段便会确定作用域规则，因此<strong>作用域在函数定义时就已经确定了</strong>，而不是在函数调用时确定。但是<strong>执行上下文是解释之后、执行之前创建的</strong>。执行上下文最明显的就是 this 的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。</p>
<p>作用域和执行上下文之间最大的区别是：<br><strong>执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。</strong>这也就是上面说的，一个作用域的 outer 只和定义时的位置相关，和调用的位置无关。</p>
<p>一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。</p>
<h2 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包"></a>闭包</h2><p>根据上面作用域链的相关概念,可以更清楚了解闭包:<br>先看一段代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myName = <span class="string">&quot; AAA &quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> test1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> test2 = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> innerBar = &#123;</span><br><span class="line">    <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(test1);</span><br><span class="line">      <span class="keyword">return</span> myName;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">setName</span>(<span class="params">newName</span>)</span> &#123;</span><br><span class="line">      myName = newName;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> innerBar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo();</span><br><span class="line">bar.setName(<span class="string">&quot; BBB &quot;</span>);</span><br><span class="line">bar.getName();</span><br><span class="line"><span class="built_in">console</span>.log(bar.getName());</span><br></pre></td></tr></table></figure>

<ol>
<li>首先调用执行 foo 函数, 这个过程中会创建全局执行上下文和 foo 函数的执行上下文;在 foo 函数的执行上下文中有 myName,test1,test2,innerBar 这些变量的词法环境</li>
<li>这时候函数继续执行到 return 为止, 赋值给 bar;bar 调用 setName,这时候虽然 foo 已经返回,但是因为 setName 函数中引用了 foo 函数的 myName 变量,因此就会导致 foo 函数的执行上下文出栈,但还留着一个”小包”,里边就是 myName 和 test1 变量.</li>
<li>bar 函数在全局作用域下调用,这时候这个小包直接在全局上下文上,全局执行上下文走到哪都会带着这个”背包”,我们把这个背包叫<strong>闭包</strong><br><img src="https://pic.imgdb.cn/item/61b1deab2ab3f51d91e09e76.png"></li>
</ol>
<p>所以接下来就可以给闭包一个正式定义:<br><strong>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。</strong></p>
<p>这句话有几个关键点:</p>
<ul>
<li>词法作用域的规则:就是我们上面一直讲的作用域链;一个变量查找不到就会到其上级的词法环境查找</li>
<li>外部函数已经执行结束:这也是 js 闭包的特点,在函数 return 之后依然可以使用这个函数里边的值</li>
<li>这些变量的集合称为闭包:闭包实际上是个变量的集合</li>
</ul>
<p>这里还有一个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">  <span class="attr">myName</span>: <span class="string">&quot;CCC&quot;</span>,</span><br><span class="line">  <span class="attr">printName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(myName);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> myName = <span class="string">&quot; BBB &quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> bar.printName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot; AAA &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> _printName = foo();</span><br><span class="line">_printName();</span><br><span class="line">bar.printName();</span><br></pre></td></tr></table></figure>

<p>结果是两次都打印 AAA。<br>解析：</p>
<ol>
<li>对象和其他类型的数据一样，只是一种映射关系而已，并不会单独创建一个上下文；访问对象的某个属性或方法，就是确定的那个属性或方法，和对象中的其他任何都没有关系（除非使用 this）<br>所以上面这段代码调用<code>foo()</code>时相当于拿到了 bar 对象中的<code>printName</code>方法的索引（还没有编译和调用）；然后 foo 函数返回，即使<code>printName</code>内部有一个同名变量，但它还没有执行，自然不会有任何 foo 函数的闭包在它身上。</li>
<li>调用<code>_printName()</code>时才为<code>printName</code>函数创建一个上下文；其中的 myName 变量按照 <code>词法环境 -&gt; 变量环境 -&gt; outer -&gt; 全局变量环境 -&gt; 全局词法环境</code>的顺序搜索,找到了全局下的 myName 并打印。因此，没有涉及到 bar 中的任何内容，最终结果只能是全局的。</li>
</ol>
<p>从函数“在哪定义在哪确定 outer 关系”的角度说，<code>printName</code>只在全局环境下调用了一次，因此它的 outer 只指向全局上下文。如果在 foo 函数内部就已经调用，那么结果就会是<code>BBB</code>。</p>
<hr>
<p>从名词角度上来说，<strong>一个函数和对其周围状态（词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）</strong><br>也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。<br>每当创建一个函数，闭包就会在函数创建的同时被创建出来，作为函数内部与外部连接起来的一座桥梁。</p>
<h3 id="闭包和内存泄漏"><a href="#闭包和内存泄漏" class="headerlink" title="闭包和内存泄漏"></a>闭包和内存泄漏</h3><p>不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。 内存泄漏是指程序执行时，一些变量没有及时释放，一直占用着内存 而这种占用内存的行为就叫做内存泄漏。</p>
<p>js 中常见的内存泄漏有三种情况：</p>
<ol>
<li>全局变量；由于非严格模式下全局变量会被挂载到 window 上，因此全局变量一直不使用但不清除就会造成这种问题。另外在非严格模式下未声明直接使用和 this 调用也会出现这种问题</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  say = <span class="string">&quot;hehe&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;hehe&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定时器；当一个节点被删除或者被销毁时，其上挂载的定时器没有被清除，可能会导致定时器仍在运作</li>
<li>引用但已经被销毁的 dom 元素；即引用一个 dom，但这个 dom 被从 dom 树中移除了：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> refA = <span class="built_in">document</span>.getElementById(<span class="string">&quot;refA&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.body.removeChild(refA); <span class="comment">// dom删除了</span></span><br><span class="line"><span class="built_in">console</span>.log(refA, <span class="string">&quot;refA&quot;</span>); <span class="comment">// 但是还存在引用能console出整个div 没有被回收</span></span><br><span class="line">refA = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(refA, <span class="string">&quot;refA&quot;</span>); <span class="comment">// 解除引用</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>闭包；即一个函数引用的数据成为一个闭包后，后面如果再次调用可能还会生成一个新闭包，这样累计就会造成极大的问题：</li>
</ol>
<p>比如下面这段代码，每秒钟都会创建一个新的<code>Array(1000000)</code>，并用于<code>innerFunc</code>函数的闭包一直被保留，只要这个函数还在被引用，产生的闭包就不会被回收。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bigArray = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> scope = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> temp = bigArray;</span><br><span class="line">  bigArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">innerFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (temp) <span class="built_in">console</span>.log(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(scope(), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>如果不是某些特定任务需要使用闭包，尽量避免在函数中创建函数，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。<br>比如构造函数的方法应该挂载到构造函数的<code>prototype</code>上，而不是构造函数内部。ES6 的类就是这样做的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数中的两个方法会引起闭包，每一次构造都会导致方法被改变（重新赋值）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params">name, message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name.toString();</span><br><span class="line">  <span class="built_in">this</span>.message = message.toString();</span><br><span class="line">  <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.getMessage = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.message;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应该是</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params">name, message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name.toString();</span><br><span class="line">  <span class="built_in">this</span>.message = message.toString();</span><br><span class="line">&#125;</span><br><span class="line">MyObject.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line">MyObject.prototype.getMessage = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.message;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="闭包的出现场景"><a href="#闭包的出现场景" class="headerlink" title="闭包的出现场景"></a>闭包的出现场景</h3><ol>
<li>嵌套函数<br>最基本的出现场景，不再赘述</li>
<li>回调函数；在定时器、事件监听、Ajax 请求、跨窗口通信、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。<br>作为回调的函数闭包保存了 window 对象，以及其可能引用的其他值。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时器</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timeHandler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;111&#x27;</span>);</span><br><span class="line">&#125;，<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件监听</span></span><br><span class="line">$(<span class="string">&#x27;#app&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;DOM Listener&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>IIFE。严格来说当 IIFE 返回一个值时才算闭包：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunc = (<span class="function"><span class="keyword">function</span> <span class="title">makeFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;Mozilla&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> displayName;</span><br><span class="line">&#125;)();</span><br><span class="line">myFunc();</span><br></pre></td></tr></table></figure>

<h3 id="闭包的使用场景"><a href="#闭包的使用场景" class="headerlink" title="闭包的使用场景"></a>闭包的使用场景</h3><p>闭包的作用主要作用体现在两个方面：保存和保护。</p>
<p>保存：保存闭包引用的外部变量。通过闭包可以实现很多高阶函数。</p>
<p>保护：保护私有变量；即函数内部定义一个变量，然后通过闭包访问并返回，但并不能直接修改该变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">private</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> times = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 一些操作</span></span><br><span class="line">    <span class="keyword">return</span> times;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">times; <span class="comment">//未定义</span></span><br><span class="line"><span class="keyword">const</span> timesVal = private()();</span><br></pre></td></tr></table></figure>

<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>接受一个函数，并返回包含新功能的函数被称为装饰器。装饰器可以给一个基本功能的函数添加一些“装饰”，但是不在函数本身做改变，而是在装饰器函数中做一些工作。<br>比如一个简单的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`hello <span class="subst">$&#123;user&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以外包一个装饰器，让这个函数可以记录每次 hello 的参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloMemory</span>(<span class="params">f, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    arr.push(...arguments);</span><br><span class="line">    f.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> users = [];</span><br><span class="line">hellos = helloMemory(hello, users);</span><br><span class="line">hellos(<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line">hellos(<span class="string">&quot;xiaohong&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>装饰器利用了函数的闭包以及函数作为对象时的 arguments 属性。由于 js 中函数可以像变量一样任意传递，因此提供了极大的灵活性。</p>
<h2 id="方法借用"><a href="#方法借用" class="headerlink" title="方法借用"></a>方法借用</h2><p>当被装饰的函数参数&gt;1 时，可以考虑使用<code>arguments</code>来取到所有的参数；<br>但是实际上，arguments 对象既是可迭代对象又是类数组对象，并不是真正的数组，因此如果对 arguments 调用 join、push 等方法都会出错。<br>因此我们可以从数组对象中“借用”这些方法，然后用 call 或 apply 的方式调用到 arguments 上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hash</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [].join.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">//或</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">//相当于 arguments.join()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hash(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>类似的方法还有很多，js 中许多内置方法并不是针对完全的数组或字符串，实际上只要相似的可迭代对象或<code>ArrayLike</code>就可以应用。<br>数组的大多数方法都可以借用。</p>
<h2 id="apply-和-call-的使用"><a href="#apply-和-call-的使用" class="headerlink" title="apply 和 call 的使用"></a>apply 和 call 的使用</h2><p>注意到装饰器中调用作为参数的函数都是通过<code>call</code>或者<code>apply</code>的方式，主要原因是保证 this 指向的正确性。<br>在一个正常函数中不会有影响，但是如果函数是某个对象内部的一个方法，如果直接调用而不是用<code>.</code>访问符调用（在装饰器函数内部），this 可能会缺失指向，这时候需要手动指定 this</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> worker = &#123;</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="function"><span class="title">slow</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cachingDecorator</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.has(x)) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache.get(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = func(x); <span class="comment">//这个地方直接调用worker中的slow方法，前面没有点访问符，this没有指向</span></span><br><span class="line">    cache.set(x, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">worker.slow(<span class="number">1</span>); <span class="comment">// 原始方法有效</span></span><br><span class="line"></span><br><span class="line">worker.slow = cachingDecorator(worker.slow);</span><br><span class="line">worker.slow(<span class="number">2</span>); <span class="comment">//由于上面的原因，执行中this为undefined，会报错</span></span><br></pre></td></tr></table></figure>

<p>所以装饰器内部调用原函数一定要使用 call 或 apply。<br>这里 apply 参数的 this 就是后续<code>*</code>行的 worker</p>
<blockquote>
<p><code>worker.slow</code> 现在是包装器 <code>function (x) &#123; ... &#125;</code>，这是一个普通函数，它的 this 来自外部点访问符指明的对象（即<code>worker</code>）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cachingDecorator</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.has(x)) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache.get(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    cache.set(x, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">worker.slow = cachingDecorator(worker.slow);</span><br><span class="line">worker.slow(<span class="number">2</span>); <span class="comment">//（*）</span></span><br></pre></td></tr></table></figure>

<h2 id="常见的装饰器"><a href="#常见的装饰器" class="headerlink" title="常见的装饰器"></a>常见的装饰器</h2><h3 id="延时"><a href="#延时" class="headerlink" title="延时"></a>延时</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">f, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      f.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, ms);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h3><p>参考下面的防抖和节流</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">caching</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.has(arg)) <span class="keyword">return</span> cache.get(arg);</span><br><span class="line">    <span class="keyword">let</span> res = f.call(<span class="built_in">this</span>, arg);</span><br><span class="line">    cache.set(arg, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>原型链参考图：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f1 = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">let</span> f2 = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a61ca07672a45d3aecf382100cc9719~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"></p>
<p>分析如下：</p>
<p>每个对象的<code>__proto__</code>都是指向它的构造函数的原型对象 prototype 的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person1.__proto__ === Person.prototype;</span><br></pre></td></tr></table></figure>

<p>构造函数是一个函数对象，是通过 Function 构造器产生的。<br>实际上任何一个函数的<code>__proto__</code>都指向<code>Function.prototype</code>对象，包括<code>Object()</code>和<code>Function()</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.__proto__ === <span class="built_in">Function</span>.prototype;</span><br></pre></td></tr></table></figure>

<p>原型对象本身是一个普通对象，而普通对象的构造函数都是 Object</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype;</span><br></pre></td></tr></table></figure>

<p>刚刚上面说了，所有的构造器都是函数对象，函数对象都是 Function 构造产生的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype;</span><br></pre></td></tr></table></figure>

<p>Object 的原型对象也有<code>__proto__</code>属性指向 null，null 是原型链的顶端</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>一切对象都是继承自<code>Object</code>对象，<code>Object</code> 对象直接继承根源对象 <code>null</code></li>
<li>一切的函数对象（包括 <code>Object</code> 对象），都是继承自 <code>Function</code> 对象</li>
<li><code>Object</code> 对象直接继承自 <code>Function</code> 对象</li>
<li><code>Function</code>对象的<code>__proto__</code>会指向自己的原型对象，最终还是继承自<code>Object</code>对象</li>
</ul>
<h2 id="Prototype-和-proto"><a href="#Prototype-和-proto" class="headerlink" title="[[Prototype]]和__proto__"></a><code>[[Prototype]]</code>和<code>__proto__</code></h2><blockquote>
<p>JavaScript 中，对象有一个特殊的隐藏<strong>属性</strong> ：<code>[[Prototype]]</code>。它要么为 null，要么就是对另一个对象的引用。该对象被称为“原型”<br>当我们从 object 中读取一个缺失的属性时，JavaScript 会自动从原型中获取该属性。在编程中，这种行为被称为“原型继承”</p>
</blockquote>
<p><code>[[Prototype]]</code>和<code>__proto__</code>:</p>
<ul>
<li><code>[[Prototype]]</code>不等于<code>__proto__</code>;</li>
<li><code>__proto__</code>是访问<code>[[Prototype]]</code>的一种方法, 也就是<code>[[Prototype]]</code>的 getter 和 setter</li>
<li><code>__proto__</code>是一种”旧时的访问方法”,应该用一些新方法代替</li>
</ul>
<h2 id="对象原型"><a href="#对象原型" class="headerlink" title="对象原型"></a>对象原型</h2><h3 id="原型和继承"><a href="#原型和继承" class="headerlink" title="原型和继承"></a>原型和继承</h3><p>接下来的数据类型几乎都是以对象为例<br>一个对象内部可以设置其<code>__proto__</code>,或者在外部访问来设置这个对象的原型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animal = &#123;</span><br><span class="line">  <span class="attr">eats</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="function"><span class="title">walk</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`i can walk`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> rabbit = &#123;</span><br><span class="line">  <span class="attr">jump</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">__proto__</span>: animal, <span class="comment">//__proto__是[[Prototype]]的getter/setter,真正访问的是[[Prototype]]</span></span><br><span class="line">&#125;;</span><br><span class="line">rabbit.walk(); <span class="comment">//i can walk</span></span><br></pre></td></tr></table></figure>

<p>这里我们就说 rabbit 继承了 animal,或者说 animal 是 rabbit 的原型<br><img src="https://pic.imgdb.cn/item/61b0c20c2ab3f51d915b97ba.png"><br>如果再继承一个对象,就会像上面两个一样形成原型关系<br>继承的属性有几个特点:</p>
<ul>
<li><p>继承来的会被当做是”自己的”, 也就是说用 forin 可以遍历到（但<code>Object.keys</code> 只返回自己的 key）。如果想分辨哪些是自己本身的属性, 可以使用 <code>hasOwnProperty</code></p>
</li>
<li><p>原型仅用于读取属性；对于写入/删除操作直接在对象上进行，并不会影响其原型；但是 getter 和 setter 例外。因为写一个 setter 相当于是调用原型上的 setter 函数，而不是修改一般属性。</p>
</li>
<li><p>如果父类有 getter/setter, 子类会继承并维护自己独立的 getter 值,即触发子类的 setter 不会影响父类</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">surname</span>: <span class="string">&quot;Smith&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title">fullName</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    [<span class="built_in">this</span>.name, <span class="built_in">this</span>.surname] = value.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">fullName</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.surname&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> admin = &#123;</span><br><span class="line">  <span class="attr">__proto__</span>: user,</span><br><span class="line">  <span class="attr">isAdmin</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(admin.fullName); <span class="comment">// John Smith</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// setter triggers!</span></span><br><span class="line">admin.fullName = <span class="string">&quot;Alice Cooper&quot;</span>;</span><br><span class="line"></span><br><span class="line">alert(admin.fullName); <span class="comment">// Alice Cooper，admin 的内容被修改了</span></span><br><span class="line">alert(user.fullName); <span class="comment">// John Smith，user 的内容被保护了</span></span><br></pre></td></tr></table></figure>

<h3 id="原型链的限制："><a href="#原型链的限制：" class="headerlink" title="原型链的限制："></a>原型链的限制：</h3><ol>
<li>引用不能形成闭环，即原型链不能开头指向结尾</li>
<li><code>__proto__</code>值只能是对象或 null</li>
<li>一个对象不能从其他两个对象获得继承，一个对象只有一个原型。</li>
</ol>
<h3 id="原型和-this"><a href="#原型和-this" class="headerlink" title="原型和 this"></a>原型和 this</h3><p>另外，原型链上的对象中的 this 根本不受原型的影响。this 始终是<code>.</code>前面的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">  <span class="function"><span class="title">walk</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isSleeping) &#123;</span><br><span class="line">      alert(<span class="string">`I wake`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">sleep</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.isSleeping = <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;White Rabbit&quot;</span>,</span><br><span class="line">  <span class="attr">__proto__</span>: animal,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 rabbit.isSleeping</span></span><br><span class="line">rabbit.sleep();</span><br><span class="line"></span><br><span class="line">alert(rabbit.isSleeping); <span class="comment">// true，说明sleep方法中的this指的是rabbit而不是animal</span></span><br><span class="line">alert(animal.isSleeping); <span class="comment">// undefined（animal中没有此属性）</span></span><br></pre></td></tr></table></figure>

<h2 id="函数属性-prototype"><a href="#函数属性-prototype" class="headerlink" title="函数属性 prototype"></a>函数属性 prototype</h2><p>prototype 是<strong>函数</strong>的一个固有属性，通过 <code>function.prototype</code> 读写；它被理解为一个名为 “prototype” 的常规属性，但是它表达的意思是函数的原型。</p>
<h3 id="prototype-在函数上的表现"><a href="#prototype-在函数上的表现" class="headerlink" title="prototype 在函数上的表现"></a>prototype 在函数上的表现</h3><blockquote>
<p>如果函数是一个构造函数，那么他构造出的实例的<strong>proto</strong>属性将会指向该函数的 prototype 属性。注意实例并不是直接指向该构造函数的。</p>
</blockquote>
<p>把<strong>构造函数</strong>的 prototype 指向某个原型, 则其 new 出来的实例的<code>[[Prototype]]</code>也会指向该对象.<br><code>F.prototype</code> 属性<strong>仅</strong>在 <code>new F</code> 被调用时使用，它为新对象的 <code>[[Prototype]]</code> 赋值</p>
<p>比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animal = &#123;</span><br><span class="line">  <span class="attr">eat</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rabbit</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Rabbit.prototype = animal;</span><br><span class="line"><span class="comment">//不是把函数挂到animal,而是把new的实例的[[Prototype]]指向animal</span></span><br><span class="line"><span class="comment">//效果就是 rabbit.__proto__ === Rabbit.prototype</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/622620495baa1a80ab998667.jpg"></p>
<blockquote>
<p>每个函数都有 “prototype” 属性</p>
</blockquote>
<p>一般函数的 prototype 是一个只有属性 constructor 的对象，属性 constructor 指向函数自身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rabbit</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Rabbit.prototype === &#123; <span class="attr">constructor</span>: Rabbit &#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/622625515baa1a80ab9cbc98.jpg"></p>
<p>但是 constructor 有时候会丢失指向<br>如果替换了函数的 prototype ,就会丢失指向,所以需要重定向 constructor.这个在组合继承中很重要</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rabbit</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Rabbit.prototype = &#123;</span><br><span class="line">  <span class="attr">jumps</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> Rabbit();</span><br><span class="line">alert(rabbit.constructor === Rabbit); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<hr>
<p>扩展：</p>
<ol>
<li>如果创建一个构造函数的实例，在它之后修改这个函数的 prototype 属性不会影响当前实例，但是会影响之后的实例</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rabbit</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Rabbit.prototype = &#123;</span><br><span class="line">  <span class="attr">eats</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> Rabbit();</span><br><span class="line">Rabbit.prototype = &#123;&#125;;</span><br><span class="line">clg(rabbit.eats); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit2 = <span class="keyword">new</span> Rabbit();</span><br><span class="line">clg(rabbit.eats); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>由于每个函数的 prototype 上都有<code>constructor</code>属性，它们的实例也可以访问这个属性，因此可以通过实例上调用<code>constructor</code>访问到自己的构造函数。<br>这也是可以通过 constructor 属性判断变量类型的原理。<br>但是这种方法不可取，因为 constructor 可能随着 prototype 的改变直接丢失或者改变，即它是不可信的。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> SomeObject();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="keyword">new</span> obj.constructor();</span><br></pre></td></tr></table></figure>

<h2 id="用来代替-proto-的函数"><a href="#用来代替-proto-的函数" class="headerlink" title="用来代替__proto__的函数"></a>用来代替<code>__proto__</code>的函数</h2><ul>
<li><code>Object.create()</code>：参数是父类，还可以有一个额外参数用于给返回对象添加属性；返回一个原型指向参数的子对象</li>
<li><code>getPrototypeOf()</code>/<code>setPrototypeOf()</code>：参数都是对象，用于获取/设置对象的原型</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animal = &#123;</span><br><span class="line">  <span class="attr">eats</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="function"><span class="title">walk</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`i can walk`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> snake = <span class="built_in">Object</span>.create(animal, &#123;</span><br><span class="line">  <span class="attr">slide</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;); <span class="comment">//创建以animal为原型的对象,第二个参数是这个对象的额外属性</span></span><br><span class="line">snake.walk();</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(snake)); <span class="comment">//获取原型</span></span><br><span class="line"><span class="keyword">let</span> bear = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(bear, animal); <span class="comment">//设置原型</span></span><br><span class="line">bear.walk();</span><br></pre></td></tr></table></figure>

<h1 id="js-五种继承方式"><a href="#js-五种继承方式" class="headerlink" title="js 五种继承方式"></a>js 五种继承方式</h1><p>这里的继承是指一个构造函数继承另一个构造函数，使得 new 出来的实例拥有父构造函数的方法。<br>简单来说就是要达到这个目的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">grade</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">child.age; <span class="comment">//18</span></span><br></pre></td></tr></table></figure>

<p>由构造函数的<code>prototype</code>属性原理可知，如果我们把构造函数的<code>prototype</code>指向另一个对象，就可以继承这个对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">eats</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.eats = eats;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> animal = <span class="keyword">new</span> Animal(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">/* 上面这段相当于生成了下面这个对象：</span></span><br><span class="line"><span class="comment">let animal = &#123;</span></span><br><span class="line"><span class="comment">  eats: true</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rabbit</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Rabbit.prototype = animal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> Rabbit(<span class="string">&quot;White Rabbit&quot;</span>); <span class="comment">//  rabbit.__proto__ == animal</span></span><br><span class="line">rabbit.eats; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这就是一切的基础（其实就是第一种原型链继承），后面几个方法都是对此的改进。</p>
<h2 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h2><p>原理是通过原型链把子构造函数的原型(f.prototype)指向父构造函数的实例, 这样子构造函数创建的实例就有父类的方法。<br>原理参考：<a target="_blank" rel="noopener" href="https://zh.javascript.info/function-prototype">https://zh.javascript.info/function-prototype</a> 的第一个例子<br>即改变构造函数的<code>prototype</code>相当于改变了其构造出来的实例的<code>__proto__</code>；如果我们把构造函数的<code>prototype</code>指向另一个构造函数的实例（实际上就是个拥有父构造函数属性的对象而已），就相当于子构造函数继承了父构造函数。</p>
<p>几个注意点:</p>
<ul>
<li>不同的子实例共享父类属性, 比如下面的 stu1 更改 play 数组,stu2 的数组也会改变</li>
<li>子类可以调用父类的原型上的方法, 换句话说就是可以多层继承</li>
</ul>
<p>缺点：</p>
<ul>
<li>多个子实例共享一个父实例，并不是单独的</li>
<li>创建子类实例时，无法向父类构造函数传参</li>
<li>子类添加方法，必须要在<code>Student.prototype = new Person() </code>之后执行（因为这句会覆盖前面添加方法），不能放到构造器中</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;i am 20 years old&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">grade</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person(<span class="string">&quot;zzx&quot;</span>); <span class="comment">//子类的原型指向父类实例</span></span><br><span class="line"><span class="keyword">let</span> stu1 = <span class="keyword">new</span> Student(<span class="number">100</span>); <span class="comment">//stu1上有Person的方法</span></span><br><span class="line"><span class="keyword">let</span> stu2 = <span class="keyword">new</span> Student(<span class="number">90</span>);</span><br><span class="line"><span class="comment">//父类Person上有一个引用数据类型(数组)play, 如果更改stu1继承的数组会导致stu2的也改变</span></span><br><span class="line"><span class="comment">//就说明不同实例实际上共同共享了父类(原型)的属性,对于引用对象来说地址也是相同的</span></span><br><span class="line">stu1.play.push(<span class="number">4</span>);</span><br><span class="line">stu1.setAge(); <span class="comment">//子类可以调用父类的原型的方法</span></span><br><span class="line"><span class="built_in">console</span>.log(stu2.play);</span><br></pre></td></tr></table></figure>

<h2 id="2-构造函数继承"><a href="#2-构造函数继承" class="headerlink" title="2. 构造函数继承"></a>2. 构造函数继承</h2><p>原理是在子构造函数中用 call 调用父构造函数 ,使得父的实例被转移到子构造函数中</p>
<ul>
<li><code>Person.call(this, name);</code> 相当于<code>this.Person(name)</code>，显然这里的 this 是 Student 即将指向实例的，相当于把 Person 中的构造部分移到了 Student 中；但是由于只是把 person 构造了一遍，只拥有了 Person 内部的构造效果，本质上并没有继承 Person 原型。</li>
</ul>
<p>缺点：</p>
<ul>
<li>只能继承父类的实例属性和方法，不能继承原型属性和方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//父类原型的方法</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;i am 20 years old&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">grade, name</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="built_in">this</span>, name); <span class="comment">//相当于this.Person(name)</span></span><br><span class="line">  <span class="built_in">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stu3 = <span class="keyword">new</span> Student(<span class="number">100</span>, <span class="string">&quot;xiaohong&quot;</span>);</span><br><span class="line"><span class="comment">//由于调用了call,Person的this指向stu3,也就相当于stu3.Person(&#x27;xiaohong&#x27;)</span></span><br><span class="line"><span class="comment">//又因为Person本身是个构造函数,这里就相当于stu3 = new Person(&#x27;xiaohong&#x27;),加上外面的new,等于stu3同时有父类的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(stu3);</span><br></pre></td></tr></table></figure>

<h2 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3. 组合继承"></a>3. 组合继承</h2><p>就是上面两种方法的结合；由于改变了子类原型, 需要修复构造器指向。<br>相比于上面两种方法，组合继承的特点是：</p>
<ul>
<li>可以向父构造函数传参，这点源于构造函数继承方法</li>
<li>子类可以继承完整的父类，这点源于基本的原型链继承方法</li>
<li>因为每个实例都相当于单独调用了一次父构造函数，所以不同实例之间也不会共享父元素数据，不会冲突。</li>
</ul>
<p>缺点：</p>
<ul>
<li>调用了两次父类构造函数，生成了两份实例（下一个的优化就是只调用一次构造函数）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//父类原型的方法</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;i am 20 years old&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">grade, name</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*相比于构造函数继承加上了原型链指向和修复构造器,这样就可以访问到父类的原型上的方法setAge*/</span></span><br><span class="line"></span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person(); <span class="comment">//这里有没有参数都可以，最终参数来自于Student构造函数的调用</span></span><br><span class="line"><span class="comment">//修复构造器指向,因为正常情况下构造器应该是指向自己的,这里设置了student的原型需要修复回来,不然就会指向Person</span></span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu4 = <span class="keyword">new</span> Student(<span class="number">120</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> stu5 = <span class="keyword">new</span> Student(<span class="number">80</span>, <span class="string">&quot;mike&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<p>既然为了避免调用两次父构造函数，可以让子构造函数的 prototype 和父构造函数的 prototype 相等，比如这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">Student.prototype = Person.prototype;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>但是显然这不是个最好的方案，因为这样实际上两者的实例就没有区别了，new 的时候实例的<code>__proto__</code>都指向相同，无法分辨</p>
<h2 id="4-组合寄生继承-构造函数中最好的继承方法"><a href="#4-组合寄生继承-构造函数中最好的继承方法" class="headerlink" title="4. 组合寄生继承(构造函数中最好的继承方法)"></a>4. 组合寄生继承(构造函数中最好的继承方法)</h2><p>用 <code>Object.create</code> 代替<code>new Person() </code>，解决了调用两次父类的问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//父类原型的方法</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;i am 20 years old&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">grade, name</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Object.create返回一个以参数为原型的新对象,相当于 stu.__proto__ = Person.prototype</span></span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line"><span class="comment">//恢复constructor指向</span></span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"><span class="comment">//所以new出来的实例,__proto__会指向Person.prototype,继而相当于完整的原型链</span></span><br><span class="line"><span class="keyword">let</span> stu6 = <span class="keyword">new</span> Student(<span class="number">120</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> stu7 = <span class="keyword">new</span> Student(<span class="number">80</span>, <span class="string">&quot;mike&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(stu6, stu7);</span><br></pre></td></tr></table></figure>

<h2 id="5-类继承"><a href="#5-类继承" class="headerlink" title="5. 类继承"></a>5. 类继承</h2><p>利用 es6 类的特性完成比较完整的继承</p>
<ul>
<li>构造函数中向构造函数原型上添加方法的方式相当于在类中直接声明</li>
<li>子类需要 constructor 使用 super 方法实现父类的构造,也就是说子类 new 的时候如果也想传入姓名, 就需要 super.(具体在类中解释)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//注意在构造函数中向构造函数原型上添加方法的方式相当于在类中直接声明</span></span><br><span class="line">  <span class="function"><span class="title">setAge</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;i am 20 years old&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">grade, name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name); <span class="comment">//super(...)相当于 Person.call(this,...arguments)</span></span><br><span class="line">    <span class="built_in">this</span>.grade = grade;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stu8 = <span class="keyword">new</span> Student(<span class="number">150</span>, <span class="string">&quot;zzx&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(stu8);</span><br></pre></td></tr></table></figure>

<p>从这里其实也能看出来 js 中类实际上就是构造函数。</p>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>关于 js 基本类的操作和写法就不再赘述了,这里讲一些之前没用到的知识点</p>
<h2 id="类、构造函数、this"><a href="#类、构造函数、this" class="headerlink" title="类、构造函数、this"></a>类、构造函数、this</h2><p>js 中的类其实就是一种构造函数。<br>下面这两段代码效果是相同的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;zzx&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, <span class="built_in">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;zzx&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, <span class="built_in">this</span>.age);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-类和类字段"><a href="#1-类和类字段" class="headerlink" title="1. 类和类字段"></a>1. 类和类字段</h3><p>如果直接写<strong>类字段</strong>，则是类字段方法/属性。类字段方法/属性会被直接放在类本身，而不是类的<code>prototype</code>上。<br>我们把前两种函数定义方法也可以称为<strong>类字段</strong>，第三个函数才是类真正的方法，安插在构造函数的<code>prototype</code>上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  name = <span class="string">&quot;zzx&quot;</span>;</span><br><span class="line">  getName = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  getAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">getAll</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, <span class="built_in">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="number">19</span>);</span><br><span class="line">person.name; <span class="comment">//zzx</span></span><br><span class="line">Person.prototype.name; <span class="comment">//undefined</span></span><br><span class="line">person.getName(); <span class="comment">//zzx</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/622883965baa1a80ab3295ae.jpg"></p>
<h3 id="2-类和-this"><a href="#2-类和-this" class="headerlink" title="2. 类和 this"></a>2. 类和 this</h3><p>关于类中方法的 this，正常使用指向应该是<strong>实例</strong>，不管是哪种方式定义的函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  name = <span class="string">&quot;zzx&quot;</span>;</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, <span class="built_in">this</span>.age); <span class="comment">//这里的this是下面的person</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br><span class="line">person.getName() === person.__proto__.getName();</span><br></pre></td></tr></table></figure>

<p>但是类内部按照类字段定义的<strong>箭头函数</strong>，会携带类的闭包，相当于绑定了类作为 this。<br>比如下面这段箭头函数输出不会丢失 this：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  sayAge = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom = <span class="keyword">new</span> Animal(<span class="string">&quot;tom&quot;</span>, <span class="number">19</span>);</span><br><span class="line"><span class="keyword">let</span> [sayName, sayAge] = [tom.sayName, tom.sayAge];</span><br><span class="line">sayAge(); <span class="comment">// 正常输出19</span></span><br><span class="line">sayName(); <span class="comment">// this为undefined</span></span><br></pre></td></tr></table></figure>

<p>原理是这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Animal = <span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="built_in">this</span>; <span class="comment">//_this会作为闭包</span></span><br><span class="line"></span><br><span class="line">  _classCallCheck(<span class="built_in">this</span>, Animal);</span><br><span class="line"></span><br><span class="line">  _defineProperty(<span class="built_in">this</span>, <span class="string">&quot;sayName&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  _defineProperty(<span class="built_in">this</span>, <span class="string">&quot;sayAge&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(_this.age);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意两个<code>_defineProperty</code> 的回调函数内对于 this 的使用方式。一个是直接用了 this，一个用了构造实例的闭包，所以一个 this 会丢失（成为 undefined），而另一个不会。<br>所以：<strong>类中的箭头函数会携带类的闭包，从而对外展现出不会丢失 this 指向的效果。</strong><br>详细可以参看这个 issue：<a target="_blank" rel="noopener" href="https://github.com/dwqs/blog/issues/67">https://github.com/dwqs/blog/issues/67</a></p>
<hr>
<p>所以这也是在 React 的类组件中，方法要么写成箭头函数，要么明确绑定 this 的原因。<br>如果我们把上面代码的<code>sayName</code>bind 一下，同样也不会丢失 this 了（绑定的 this 显然应当是该类的实例，或者说是类本身）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.getAge = <span class="built_in">this</span>.getAge.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  sayAge = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h2><p>类使用 extends 关键词继承。<br>类的继承相当于原型链的延伸，extends 执行的动作就是将子类的<code>prototype</code>和父类的<code>prototype</code>用<code>[[Prototype]]</code>连接起来：<br><img src="https://pic.imgdb.cn/item/6228c7da5baa1a80ab8ab1b2.jpg"></p>
<p>类继承和 ES5 继承方式的区别：</p>
<p>子类可以直接通过 <code>__proto__</code>寻址到父类。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Sub();</span><br><span class="line"></span><br><span class="line">Sub.__proto__ === <span class="built_in">Function</span>.prototype;</span><br></pre></td></tr></table></figure>

<p>而通过 ES5 的方式，<code>Sub.__proto__ === Function.prototype</code></p>
<h3 id="super-的使用"><a href="#super-的使用" class="headerlink" title="super 的使用"></a>super 的使用</h3><p>从前面的继承可以看出来，<code>super(...)</code>实际上就是<code>ParentClass.call(this,...)</code>，而 super 对象本身就相当于<code>Parent.prototype</code></p>
<ul>
<li>直接用<code>super.</code>可以在子类 <code>constructor</code> 外部使用父类的方法</li>
<li>在 <code>constructor</code> 使用 <code>super</code> 接受参数用于重写 <code>constructor</code></li>
<li>在 <code>constructor</code> 使用父类属性需要<code>super.</code>,不然不能访问到</li>
<li><strong>继承类的 <code>constructor</code> 必须调用<code> super(...)</code>，并且一定要在使用 <code>this</code> 之前调用。</strong>原因是继承的 <code>constructor</code> 执行时，它不会执行此操作。它期望父类的 <code>constructor</code> 来完成这项工作。</li>
<li><strong>如果继承类没有<code>constructor</code>，相当于只有 <code>super(...args)</code> 的空构造器，会执行一次父类<code>constructor</code></strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Benz</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, maxSpeed</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.maxSpeed = maxSpeed;</span><br><span class="line">  &#125;</span><br><span class="line">  run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> run with speed <span class="subst">$&#123;<span class="built_in">this</span>.maxSpeed&#125;</span>`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Track</span> <span class="keyword">extends</span> <span class="title">Benz</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.maxSpeed = <span class="built_in">super</span>.maxSpeed - <span class="number">100</span>; <span class="comment">//在constructor中使用super调用父类属性</span></span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">  &#125;</span><br><span class="line">  stop = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.stop(); <span class="comment">//使用super调用父类函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>.maxSpeed);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherTrack</span> <span class="keyword">extends</span> <span class="title">Benz</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">type, ...args</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(...args); <span class="comment">//如果要重写constructor构造的属性(比如子类实例也想设置name),就需要调用super函数</span></span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> anotherTrack = <span class="keyword">new</span> AnotherTrack(<span class="string">&quot;AnotherTrack&quot;</span>, <span class="string">&quot;myAnotherTrack&quot;</span>); <span class="comment">//这里重写了父类的constructor构造的属性name和maxSpeed</span></span><br></pre></td></tr></table></figure>

<h3 id="super-的实现原理"><a href="#super-的实现原理" class="headerlink" title="super 的实现原理"></a>super 的实现原理</h3><p>super 使用了类中函数的一个<code>[[HomeObject]]</code>属性(当然每个函数都有),<br>当一个函数被定义为类或者对象方法时，它的 <code>[[HomeObject]]</code> 属性就成为了该对象或类(也就是一种绑定)<br>因为这个原理, super 可以准确沿着原型链找到父类上的方法和属性</p>
<h2 id="instanceof-1"><a href="#instanceof-1" class="headerlink" title="instanceof"></a>instanceof</h2><p><code>a instanceof B</code>返回 a 是否是 B 的实例,返回一个 boolean 值</p>
<p>instanceof 会先检查类中的<code>[Symbol.hasInstance]</code>静态方法,如果有会根据方法返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance](obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.type === <span class="string">&quot;fruit&quot;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> apple = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;fruit&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">apple <span class="keyword">instanceof</span> Fruit; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>如果没有 <code>Symbol.hasInstance</code>，会使用<code> obj instanceOf Class</code> 检查 <code>Class.prototype</code> 是否等于 <code>obj</code> 的原型链中的原型之一。<br>也就是一种遍历的方式一个一个比较：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">obj.__proto__ === Class.prototype?</span><br><span class="line">obj.__proto__.__proto__ === Class.prototype?</span><br><span class="line">obj.__proto__.__proto__.__proto__ === Class.prototype?</span><br><span class="line">...</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">Class.prototype.isPrototypeOf(obj)</span><br><span class="line">Class.prototype.prototype.isPrototypeOf(obj)</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<h2 id="类字段"><a href="#类字段" class="headerlink" title="类字段"></a>类字段</h2><p>直接在类中不声明而赋值的属性或者方法被称为类字段。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  name = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">  getName = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类字段本身直接保存在实例中而不是构造函数的 prototype 上。</p>
<h3 id="重写类字段"><a href="#重写类字段" class="headerlink" title="重写类字段"></a>重写类字段</h3><p>不仅可以重写方法，还可以重写类字段。<br>但是：<strong>父类构造器总是会使用它自己字段的值，而不是被重写的那一个。</strong><br>举个栗子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  name = <span class="string">&quot;animal&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    隐式调用一次：</span></span><br><span class="line"><span class="comment">    alert(this.name)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  name = <span class="string">&quot;rabbit&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Animal(); <span class="comment">// animal</span></span><br><span class="line"><span class="keyword">new</span> Rabbit(); <span class="comment">// animal</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>new Rabbit()</code>会 alert aminal 是因为没有构造器的子类会隐式调用一次父类的构造器。</p>
</blockquote>
<p>这个例子很能说明问题，按理来说第二个输出应该是 rabbit 才对。<br>原因如下：</p>
<ul>
<li>对于基类（还未继承任何东西的那种），在构造函数调用前初始化。</li>
<li>对于派生类，在 <code>super()</code> 后立刻初始化。</li>
</ul>
<p>所以，<code>new Rabbit()</code> 调用了 <code>super()</code>，因此它执行了父类构造器，并且（根据派生类规则）只有在此之后，它的类字段才被初始化。在父类构造器被执行的时候，**<code>Rabbit</code> 还没有自己的类字段**，所以只能使用父类中的类字段。</p>
<h2 id="扩展内建类"><a href="#扩展内建类" class="headerlink" title="扩展内建类"></a>扩展内建类</h2><p>之前有过向内建对象的构造函数的 prototype 上添加属性和方法的方式添加自己的属性。实际上类也可以，而且更简单：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.length === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(arr.isEmpty());</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面和下面相同</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.length === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">50</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr.isEmpty());</span><br></pre></td></tr></table></figure>

<p>原理肥肠简单，前面说过类的方法实际上是放在类的 prototype 上的，这里<code>MyArray</code>继承了 Array 的所有方法和属性，并给自己添加了一个方法。</p>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><blockquote>
<p>Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
</blockquote>
<h2 id="Promise-解决的问题"><a href="#Promise-解决的问题" class="headerlink" title="Promise 解决的问题"></a>Promise 解决的问题</h2><p>Promise 的出现主要是为了解决回调地狱问题，即一个回调需要上一个回调的结果才能执行，就会依次嵌套，最后导致代码向右延伸，称为回调地狱。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ajax(url, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 处理逻辑</span></span><br><span class="line">  ajax(url1, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">    ajax(url2, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 处理逻辑</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Promise 采用以下三个方式解决这个问题：</p>
<ol>
<li>Promise 实现了回调函数的<strong>延时绑定</strong>。回调函数的延时绑定在代码上体现就是先创建 Promise ，通过 Promise 的构造函数 executor 来执行业务逻辑；创建好 Promise 对象 ，再使用 <code>.then</code> 来设置回调函数。也就是说相对于直接绑定回调，Promise 把主要执行逻辑和回调用 executor 和 then 分离了。</li>
<li>回调函数 <code>resolve</code> 的<strong>返回值穿透</strong>到最外层，也就是说 executor 内部执行 resolve 可以在外部访问；而一个 then 又可以继续返回一个 Promise，因此实现垂直的链式调用<br><img src="http://blog.poetries.top/img-repo/2019/11/45.png"></li>
<li><strong>错误冒泡</strong>，即 Promise 中任何一个地方的冒泡都会向下，直到找到第一个 catch 或 reject 为止。</li>
</ol>
<h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><p>Promise 对象有以下两个特点。</p>
<ul>
<li>Promise 对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和 <code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。</li>
</ul>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>通过 new Promise()生成 Promise 实例,参数是一个 executor 函数(执行函数)<br>特点:</p>
<ul>
<li>executor 函数被创建会<strong>立即执行</strong>(不是一个异步任务)</li>
<li>executor 函数中只能调用一个 resolve 或 reject(条件判断算一个),多个的后面会被无视<ul>
<li>resolve:将 <strong>Promise 对象的状态</strong>从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将<strong>异步操作的结果</strong>，作为<strong>参数</strong>传递出去；</li>
<li>reject:将 Promise 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li>
</ul>
</li>
</ul>
<p>这两个方法都是向外传递一个变量,后续的 then 需要参数来接受</p>
<ul>
<li>使用 resolve 之后,就不应该再在 promise 中操作了,剩下的操作应该在 then 中完成</li>
<li>then 函数有<strong>两个参数</strong>,第二个函数将在 promise rejected 后运行并接收 error。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>还有一个 <code>finally</code> ,和 <code>trycatch</code> 中的 <code>finally</code> 类似<ul>
<li><code>.finally(f)</code> 调用与 <code>.then(f, f)</code> 类似，在某种意义上，<code>f</code> 总是在 <code>promise</code> 被 <code>settled</code> 时运行：即 <code>promise</code> 被 <code>resolve</code> 或 <code>reject</code>。</li>
<li><code>finally</code> 没有参数。在 <code>finally</code> 中不知道 <code>promise</code> 是否成功，但无论是否成功都会向下传递</li>
<li><code>finally</code> 处理程序将结果和 <code>error</code> 传递给下一个处理程序。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&quot;done&quot;</span>), <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .finally(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;Promise ready&quot;</span>))</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>通常使用都需要封装在一个函数中, 函数会返回一个 promise 对象<br>比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">    script.src = src;</span><br><span class="line"></span><br><span class="line">    script.onload = <span class="function">() =&gt;</span> resolve(script);</span><br><span class="line">    script.onerror = <span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Script load error for <span class="subst">$&#123;src&#125;</span>`</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.head.append(script);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">loadScript(<span class="string">&quot;/src&quot;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.err(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Promise-链"><a href="#Promise-链" class="headerlink" title="Promise 链"></a>Promise 链</h2><p>每个 then 还可以有一个返回值,会被下一个 then 接收到作为参数<br>举个例子,axios 的连续调用<br>当下一次请求需要上一次的返回值时,不需要写在上一次的回调中;可以返回请求 Promise 对象再进行一次 then。<br>实际上，每个对 <code>.then</code> 的调用都会返回了一个新的 promise，因此我们可以在其之上调用下一个 <code>.then</code>。</p>
<p>注意:</p>
<ul>
<li>链必须始终是同一个 Promise 对象下的, 给多个 promise 分开 then 不是链，这种就不是：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  alert(result); <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  alert(result); <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>即使不刻意返回 Promise 对象,then 也会默认返回一个<strong>新的</strong>Promise 对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">axios</span><br><span class="line">  .get(<span class="string">&quot;/api&quot;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> axios.get(<span class="string">`/api/<span class="subst">$&#123;res&#125;</span>`</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> axios.get(<span class="string">`/api/<span class="subst">$&#123;res&#125;</span>`</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Promise-Api"><a href="#Promise-Api" class="headerlink" title="Promise Api"></a>Promise Api</h2><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a><code>Promise.all</code></h3><p>并行执行多个 promise，并等待所有 promise 都准备就绪后再执行一个 then<br>参数是一个数组或可迭代对象,每个元素都是 promise 对象,返回是一个每个 promise 结果组成的数组</p>
<blockquote>
<p>如果任意一个 promise 被 reject，由 <code>Promise.all</code> 返回的 promise 就会立即 reject，并且带有的就是这个 error。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>].map(<span class="function">(<span class="params">id</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(<span class="string">`/.../<span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.all(promises)</span><br><span class="line">  .then((posts) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).catch((err)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如何让 Promise.all 在抛出异常后依然有效？<br>其实原理很简单，就是给每个 Promise 单独设置 catch 即可；因为自己拥有自己的 catch 方法时，即使报错也会被捕获，并不会继续抛出错误让<code>promise.all</code>的 catch 去捕获从而导致 reject。</p>
</blockquote>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a><code>Promise.race</code></h3><p>与 <code>Promise.all</code> 类似，但只等待第一个 <code>settled</code> 的 <code>promise</code> 并获取其结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race([</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">2</span>), <span class="number">2000</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">3</span>), <span class="number">3000</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">]).then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res));</span><br></pre></td></tr></table></figure>

<p>上面这段代码第一个 Promise 会首先<code>settled </code>，因此只返回第一个的结果，剩余不再返回。</p>
<p>如果有一个promise在其他promise resolve之前就reject，则会只返回这个reject结果。<br>为了避免这种情况，有一个<code>Promise.any()</code> api，不会因为某个 Promise 变成rejected状态而结束，必须等到所有参数 Promise 变成rejected状态才会结束。</p>
<h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a><code>Promise.allSettled</code></h3><p>和 all 类似，但是会保证每个 promise 任务全都被处理完成，不管是 fulfilled 还是 rejected。<br>返回一个对象数组，数组的每一项包含对应序号的 promise 状态和结果</p>
<ul>
<li>如果 resolve，返回 value 属性，值是 resolve 的值</li>
<li>如果 reject，返回 reason 属性，值的抛出的错误</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(reject, <span class="number">100</span>, <span class="string">&quot;foo&quot;</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> promises = [promise1, promise2];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.allSettled(promises).then(<span class="function">(<span class="params">results</span>) =&gt;</span></span><br><span class="line">  results.forEach(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; status: &quot;fulfilled&quot;, value: 3 &#125;</span></span><br><span class="line"><span class="comment">// &#123; status: &quot;rejected&quot;, reason: &quot;foo&quot; &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h2><p>用于处理 Promise 程序的函数是一个微任务<br>也就是说, 每个<code>.then/.catch/.finally</code> 内的函数都是一个微任务</p>
<ul>
<li>微任务队列会在上一个宏任务完成后,下一个宏任务开始前调用<strong>微任务队列中的所有的微任务</strong>完成(所以 promise2 会和 promise1 一起先后一起完成)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;timeout&quot;</span>));</span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;clg&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这一段代码会返回这样一个结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clg</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure>

<p>Promise 中微任务的主要体现在于上面说的“回调函数延时绑定”：<br>下面这段代码中，设置<code>this.then</code>就是绑定回调函数的过程。</p>
<ul>
<li>首先有一个内部的<code>onFulFilled_</code>方法，即 then 内的回调函数，没有确定 then 之前为 null</li>
<li><code>onFulFilled</code>是<code>onFulFilled_</code>在 then 中的参数，在 then 中调用前者相当于调用后者。</li>
</ul>
<p>但是这里有个问题：在调用到<code>onFulFilled_</code>函数的时候，<code>Bromise.then</code> 还没有执行，因此<code>onFulFilled_</code>实际上仍然是 null；<br>因此我们需要让执行在绑定之后，让 resolve 延迟调用 <code>onFulFilled_</code>。方法就是把<code>onFulFilled_</code>添加到微任务去，保证绑定的完成才去执行回调。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> onFulFilled_ = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 模拟实现 resolve 和 then</span></span><br><span class="line">  <span class="built_in">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulFilled</span>) </span>&#123;</span><br><span class="line">    onFulFilled_ = onFulFilled;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//setTimeout(()=&gt;&#123;</span></span><br><span class="line">    onFulFilled_(value);</span><br><span class="line">    <span class="comment">// &#125;,0)</span></span><br><span class="line">  &#125;</span><br><span class="line">  executor(resolve, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promisify"><a href="#Promisify" class="headerlink" title="Promisify"></a>Promisify</h2><p>这个单词指可以将一些函数 promisify 的函数，也就是一个装饰器。<br>举个栗子，图片转 base64 的基本代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">imgToBase</span>(<span class="params">img, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fr = <span class="keyword">new</span> FileReader();</span><br><span class="line">  fr.readAsDataURL(img);</span><br><span class="line">  fr.onload = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    callback(e.target.result);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 onload 实际上是一个回调形式的异步过程。我们可以把这个函数放到 executor 中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisifyImgToBase</span>(<span class="params">img</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fr = <span class="keyword">new</span> FileReader();</span><br><span class="line">    fr.readAsDataURL(img);</span><br><span class="line">    fr.onload = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(e.target.result);</span><br><span class="line">    &#125;;</span><br><span class="line">    fr.onerror = <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">promisifyImgToBase(file).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><h3 id="async-和-await-的原理"><a href="#async-和-await-的原理" class="headerlink" title="async 和 await 的原理"></a>async 和 await 的原理</h3><p>async 在函数前面时会创建一个特殊的函数,这个函数默认返回 Promise 对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getNum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> num = getNum();</span><br><span class="line">num.then(<span class="function">(<span class="params">res</span>) =&gt;</span> clg(res));</span><br></pre></td></tr></table></figure>

<p>这个例子中 num 实际上是这样:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//简写</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>当然也可以显式返回一个 Promise 对象。<br>所以实际上 async 相当于一个 promisify，把一般的函数变成返回 promise 的函数。<br>因此，如果在一个地方需要拿到 async 函数的返回值，把它当作返回 promise 的函数就行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>reslove(<span class="number">1</span>),<span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getResult</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  wait().then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;...&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>await 是一个执行比较复杂的语句, 按照 await 的原理,可以把 await 的语句看成是一个 Promise<br>先看一个例子，下面的输出顺序应该是什么？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUrl</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> text = <span class="keyword">await</span> fetch(<span class="string">`/<span class="subst">$&#123;url&#125;</span>`</span>);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">getUrl();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>最终顺序为:<code>0 1 3 2</code><br>原理:</p>
<ol>
<li>0 同步执行;然后进入 getUrl 函数直接执行 1</li>
<li>await 看成这样:</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(fetch(<span class="string">&quot;/&quot;</span>));</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> text = res;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>因此 await 是:</p>
<ul>
<li>把 await 紧挨其后的表达式当做 Promise 对象</li>
<li>把 await 语句<strong>之后的</strong>都当成下一个 then 内的语句</li>
<li>如果下面还有一个 await,就看做再下一个 then</li>
</ul>
<blockquote>
<p>await 会导致函数暂停执行，直到被 await 等待的 Promise 状态变为 settled 才会继续。但是由于 await 执行在微任务队列，因此并不会阻塞主线程，但会阻塞后续微任务的执行。await 暂停的原理就是 Generator 函数中的 yield</p>
</blockquote>
<p>所以它还可以链式调用:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUrl</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> text = <span class="keyword">await</span> fetch(<span class="string">`/<span class="subst">$&#123;url&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">let</span> text2 = <span class="keyword">await</span> fetch(<span class="string">`/<span class="subst">$&#123;text&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">let</span> text, text2;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  fetch(<span class="string">`/<span class="subst">$&#123;url&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    text = res;</span><br><span class="line">    <span class="keyword">return</span> fetch(<span class="string">`/<span class="subst">$&#123;text&#125;</span>`</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    text2 = res;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>其中<code>fetch(</code>/${text}<code>)</code>会在 text 获取之后调用(就像 then 的工作方式) 3. 由于 await 把后面任务变成了 promise 微任务,所以会先输出 3,然后在 3 的末尾调用 promise 微任务输出 2。</p>
<blockquote>
<p>关于具体实现细节，可以参考 <a target="_blank" rel="noopener" href="https://blog.poetries.top/browser-working-principle/guide/part4/lesson20.html#%E7%94%9F%E6%88%90%E5%99%A8-vs-%E5%8D%8F%E7%A8%8B">https://blog.poetries.top/browser-working-principle/guide/part4/lesson20.html#%E7%94%9F%E6%88%90%E5%99%A8-vs-%E5%8D%8F%E7%A8%8B</a></p>
</blockquote>
<h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><p>await 处理的 Promise 语句如果被 reject，将 throw 这个 error。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Whoops!&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Whoops!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此如果需要处理错误,就需要在 async 函数调用的外部加上 catch,或者直接在 await 附近加 trycatch</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">getUrl().catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="keyword">await</span> ...</span><br><span class="line">&#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>await 还可以用于 Promise.all</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">  fetch(url1),</span><br><span class="line">  fetch(url2),</span><br><span class="line">  ...</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<h3 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h3><ol>
<li><code>forEach</code>中不能使用 await，因为<code>forEach</code> 只是简单的执行了下回调函数而已，并不会去处理异步的情况。因此如果要遍历数组执行，可以考虑<code>for of</code>或者<code>Promise.all/Promise.allSettled/Promise.race</code>等</li>
</ol>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>详细参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903744518389768">https://juejin.cn/post/6844903744518389768</a></p>
<h2 id="模块的发展历程"><a href="#模块的发展历程" class="headerlink" title="模块的发展历程"></a>模块的发展历程</h2><ol>
<li><p>全局函数调用形式<br>将不同的功能封装成不同的全局函数<br>问题: 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系</p>
</li>
<li><p>namespace：将一组变量和函数封装在一个对象。<br>外部可以直接修改模块内部的数据，不安全</p>
</li>
<li><p>立即调用函数IIFE：数据是私有的, 外部只能通过暴露的方法操作<br>但是如果当前这个模块依赖另一个模块就没办法处理<br>多个模块需要引入多个script，增大加载时间</p>
</li>
<li><p>AMD:主要应用于浏览器端；因为浏览器端不应该同步加载所有模块，因此AMD支持异步加载，通过回调的形式在加载完成后才执行代码。<br>AMD依赖于require.js，基本思想是通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载。</p>
</li>
<li><p>commonjs，详见下</p>
</li>
<li><p>CMD：整合了commonjs和amd，模块的加载是异步的，模块使用时才会加载执行。CMD的实现是sea.js</p>
</li>
<li><p>UMD：可以根据导出类型的不同实现不同的导入方法，可以通过运行时或者编译时让同一个代码模块在使用 Commonjs、CMD 甚至是 AMD 的项目中运行</p>
</li>
<li><p>ES6 Moudle：设计思想是尽量的<strong>静态</strong>化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。<br>ES6 模块输出的是值的引用。因此修改原文件中的值也会影响导入的值，但是导出的值不能在被导入的文件中修改<br>ES6 模块不是对象，它的对外接口只是一种静态定义，不像commonjs一样导入的是一个对象</p>
</li>
</ol>
<h2 id="模块类型"><a href="#模块类型" class="headerlink" title="模块类型"></a>模块类型</h2><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>一种适用于 node 的模块化,主要特点:</p>
<ul>
<li>每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</li>
<li>在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。</li>
<li>导入对象实际上是导出的<strong>浅拷贝</strong></li>
<li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li>
<li>使用 module、exports、require、global 为基本操作;其中 module 为模块内部的一个对象,常用属性有<ul>
<li><code>module.id</code> 模块的识别符，通常是带有绝对路径的模块文件名。</li>
<li><code>module.filename</code> 模块的文件名，带有绝对路径。</li>
<li><code>module.loaded</code> 返回一个布尔值，表示模块是否已经完成加载。</li>
<li><code>module.parent</code> 返回一个对象，表示调用该模块的模块。</li>
<li><code>module.children</code> 返回一个数组，表示该模块要用到的其他模块。</li>
<li><code>module.exports</code> 表示模块对外输出的值。</li>
</ul>
</li>
</ul>
<blockquote>
<p>浏览器不兼容 CommonJS 的根本原因，在于缺少四个 Node.js 环境的全局变量。</p>
<ul>
<li><code>module</code></li>
<li><code>exports</code></li>
<li><code>require</code></li>
<li><code>global</code><br>只要能够提供这四个变量，浏览器就能加载 CommonJS 模块。</li>
</ul>
</blockquote>
<p>这四个全局变量的主要功能如下：</p>
<h4 id="1-module"><a href="#1-module" class="headerlink" title="1. module"></a>1. module</h4><p>module 是定义在每个模块中的对象；module 的常用属性上面已经列举过。<br>其中最核心的是<code>module.exports</code>对象，用于存储导出的变量，以便 require 读取。</p>
<h4 id="2-exports"><a href="#2-exports" class="headerlink" title="2. exports"></a>2. exports</h4><p>为了方便，Node 为每个模块提供一个 exports 变量，指向 module.exports。这等同在每个模块头部，有一行这样的命令：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">exports</span> = <span class="built_in">module</span>.exports;（commonJS隐式做了这个赋值）、</span><br></pre></td></tr></table></figure>

<p>这样就可以通过<code>exports.xxx = xxx</code>来导出变量。</p>
<h4 id="3-require"><a href="#3-require" class="headerlink" title="3. require"></a>3. require</h4><p>require 命令的基本功能是，读入并执行一个 JavaScript 文件，然后返回该模块的 exports 对象。如果没有发现指定模块，会报错。(说白了就是将另一个文件中暴露的值，引用到本文件中。)</p>
<p>根据参数的不同格式，require 命令去不同路径寻找模块文件:</p>
<ol>
<li>缓存的模块优先级最高</li>
<li>如果是内置模块，则直接返回，优先级仅次缓存的模块；</li>
<li>如果是绝对路径 / 开头，则从根目录找</li>
<li>如果是相对路径 ./开头，则从当前 require 文件相对位置找</li>
<li>如果文件没有携带后缀，先从 js、json、node 按顺序查找</li>
<li>如果是目录，则根据 <code>package.json</code>的 main 属性值决定目录下入口文件，默认情况为 index.js</li>
<li>如果文件为第三方模块，则会引入 <code>node_modules</code> 文件，如果不在当前仓库文件中，则自动从上级递归查找，直到根目录</li>
</ol>
<blockquote>
<p>最后一步的查找优先级：<br>如果在<code>/home/ry/projects/foo.js</code>文件里调用了 <code>require(&#39;bar.js&#39;)</code>，则 Node.js 会按以下顺序查找：</p>
<ol>
<li><code>/home/ry/projects/node_modules/bar.js</code></li>
<li><code>/home/ry/node_modules/bar.js</code></li>
<li><code>/home/node_modules/bar.js</code></li>
<li><code>/home/node_modules/bar/index.js</code>；（如果上面不存在，说明可能是模块名错误，就会从默认按照 index.js 查找）</li>
<li><code>/node_modules/bar.js</code>，即总根目录下的模块</li>
</ol>
</blockquote>
<h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>异步版的 Commonjs,依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行<br>AMD 常采用 require.js 实现,用 <code>require.config()</code>指定引用路径等，用 <code>define()</code>定义模块，用 <code>require()</code>加载模块<br>主要步骤为:</p>
<ol>
<li>在 main 中用 <code>require.config</code> 指定各模块路径, 参数是一个有基本路径和具体路径构成的模块整体路径,比如下面的<code>add: &quot;add.js&quot;,</code>,”add”是模块名,后面是相对路径;</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">  <span class="attr">baseUrl</span>: <span class="string">&quot;js/&quot;</span>,</span><br><span class="line">  <span class="attr">paths</span>: &#123;</span><br><span class="line">    <span class="attr">add</span>: <span class="string">&quot;add.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>引用模块, 参数是一个模块名的数组和一个回调函数,异步的关键</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">&quot;add&quot;</span>, <span class="string">&quot;minus&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">add, minus</span>) </span>&#123;</span><br><span class="line">  add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  minus(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>定义一个模块用 define</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    add,</span><br><span class="line">    basicNum,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>一种 AMD 的变体;<br>AMD 推崇依赖前置、提前执行，CMD 推崇依赖就近、延迟执行;<br>意思就是,AMD 会使导入的模块全部执行(即使没有调用); 而 CMD 是一种按需调用<br>CMD 也常和 sea.js 一同使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&quot;./a&quot;</span>);</span><br><span class="line">  a.doSomething();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&quot;./b&quot;</span>);</span><br><span class="line">  b.doSomething();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** sea.js **/</span></span><br><span class="line"><span class="comment">// 定义模块 math.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">&quot;jquery.js&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">exports</span>.add = add;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.use([<span class="string">&quot;math.js&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = math.add(<span class="number">1</span> + <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h3><blockquote>
<p>它可以通过运行时或者编译时让同一个代码模块在使用 CommonJs、CMD 甚至是 AMD 的项目中运行。</p>
</blockquote>
<p>意思就是, 他可以根据导出类型的不同实现不同的导入方法,比如上下文是 AMD 的方式,就可以用 AMD 导入导出<br>简单 UMD:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">(<span class="params"><span class="built_in">global</span>, factory</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//如果 当前的上下文有define函数，并且AMD  说明处于AMD 环境下</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&quot;function&quot;</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">    define([<span class="string">&quot;moduleA&quot;</span>], factory);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">//commonjs</span></span><br><span class="line">    <span class="keyword">let</span> moduleA = <span class="built_in">require</span>(<span class="string">&quot;moduleA&quot;</span>);</span><br><span class="line">    modules.exports = factory(moduleA);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">global</span>.moduleA = factory(<span class="built_in">global</span>.moduleA); <span class="comment">//直接挂载成 windows 全局变量</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="built_in">this</span>, <span class="function">(<span class="params">moduleA</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//本模块的定义</span></span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h3><p>使用 import/export 作为导入导出的方法(下面会详细叙述)<br><strong>模块只通过 HTTP(s) 工作，在本地文件则不行</strong></p>
<h3 id="ES6-Module-与-CommonJS-异同"><a href="#ES6-Module-与-CommonJS-异同" class="headerlink" title="ES6 Module 与 CommonJS 异同"></a>ES6 Module 与 CommonJS 异同</h3><p>ES6 Module 和 CommonJS 模块的区别：</p>
<ul>
<li>CommonJS 是对模块的<strong>浅拷⻉</strong>，ES6 Module 是对模块的引⽤，即 ES6 Module 只存只读，不能改变其值，也就是指针指向不能变，类似 const；</li>
<li>import 的接⼝是 read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向。可以对 commonJS 对重新赋值（改变指针指向），但是对 ES6 Module 赋值会编译报错。</li>
</ul>
<p>ES6 Module 和 CommonJS 模块的共同点：</p>
<ul>
<li>CommonJS 和 ES6 Module 都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。</li>
</ul>
<h2 id="ES6-Module-1"><a href="#ES6-Module-1" class="headerlink" title="ES6 Module"></a>ES6 Module</h2><p>一个模块实际上就是一个文件,特点如下:</p>
<ul>
<li>模块内部 js 始终使用”use strict”</li>
<li>模块代码<strong>仅在第一次导入时被解析</strong>,生成导出，然后它被复制给所有对其的导入,也就是说:<ul>
<li>导入时模块中的代码就已经被解析,如果有错误会在此时报出;</li>
<li><strong>只解析一次</strong>,同一个模块在其他文件中再次导入不会再解析</li>
<li>如果导出一个引用类型的值(对象/数组),则一处数据更改也会影响另一处的导入的数据,但是不会影响源文件.所以尽量不要更改模块,而是只读或者使用拷贝</li>
</ul>
</li>
<li><code>&lt;script type=&quot;module&quot;&gt;</code>下的 this 是 undefined 而不是 window(这个跟严格模式有关系)</li>
<li><code>&lt;script type=&quot;module&quot;&gt;</code>的脚本是异步的,会等待 html 完全就绪才会运行</li>
</ul>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p><code>import * as xxx from path</code>将所有内容导入为一个对象,相当于所有的导入都在 xxx 这个对象里</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> say <span class="keyword">from</span> <span class="string">&quot;./say.js&quot;</span>;</span><br><span class="line">say.sayHi(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">say.sayBye(<span class="string">&quot;John&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>另外,借助 import(module) 表达式可以实现动态导入<br>import(module) 表达式加载模块并返回一个 promise，该 promise resolve 为一个包含其所有导出的模块对象。比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./test.js&#x27;</span>)</span><br><span class="line">.then(<span class="function"><span class="params">obj</span>=&gt;</span><span class="built_in">console</span>.log(obj))</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">getImport</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./test.js&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>resolve 的 obj 就是模块的导出对象;可以对对象使用其 default 属性来访问默认导出<br>注意这种导入就不能使用<code>type=&quot;module&quot;</code>了,而是看做一个正常的表达式</p>
<h1 id="Proxy-和-Reflect"><a href="#Proxy-和-Reflect" class="headerlink" title="Proxy 和 Reflect"></a>Proxy 和 Reflect</h1><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>一个 Proxy 对象包装另一个对象并拦截诸如读取/写入属性和其他操作，可以选择自行处理它们，或者透明地允许该对象处理它们。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;aaa&quot;</span> &#125;, &#123;&#125;);</span><br><span class="line">proxy.age = <span class="number">19</span>;</span><br><span class="line"><span class="built_in">console</span>.log(proxy.name);</span><br></pre></td></tr></table></figure>

<ul>
<li>target 是要代理的对象, handler 是”捕捉器”,是一个包含 getter/setter 等属性的对象</li>
<li>直接对 Proxy 的实例读写相当于对代理对象读写(假设没有 handler),也可以迭代</li>
<li>Proxy 本身没有任何属性</li>
<li>常见的 handler 方法:<table>
<thead>
<tr>
<th>内部方法</th>
<th>Handler 方法</th>
<th>何时触发</th>
</tr>
</thead>
<tbody><tr>
<td><code>[[Get]]</code></td>
<td>get</td>
<td>读取属性</td>
</tr>
<tr>
<td><code>[[Set]]</code></td>
<td>set</td>
<td>写入属性</td>
</tr>
<tr>
<td><code>[[HasProperty]]</code></td>
<td>has</td>
<td>in 操作符</td>
</tr>
<tr>
<td><code>[[Delete]]</code></td>
<td>deleteProperty</td>
<td>delete 操作符</td>
</tr>
<tr>
<td><code>[[Call]]</code></td>
<td>apply</td>
<td>函数调用</td>
</tr>
<tr>
<td><code>[[Construct]]</code></td>
<td>construct</td>
<td>new 操作符</td>
</tr>
</tbody></table>
</li>
</ul>
<p>handler 的使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line">proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, prop</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, prop, value</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">deleteProperty</span>(<span class="params">target, prop</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.xxx; <span class="comment">//get</span></span><br><span class="line">proxy.xxx = yyy; <span class="comment">//set</span></span><br><span class="line"><span class="keyword">delete</span> proxy.xxx; <span class="comment">//deleteProperty</span></span><br></pre></td></tr></table></figure>

<p><strong>注意,这些 handler 方法都是访问代理对象而不是源对象时触发的</strong>。<br>直接访问源对象属性并不会触发代理的拦截,这点和 <code>defineProperty</code> 加上 getter/setter 不同<br>所以为了可以直接访问对象代理,可以把代理对象赋给源对象</p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>get 方法一般如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numDict = &#123;</span><br><span class="line">  <span class="attr">zero</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">one</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">two</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(numDict, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, property, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (property <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[property];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> property;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>参数:</p>
<ul>
<li>target:就是代理的对象,参数第一个</li>
<li>property :访问的属性名，比如访问<code>proxy.xxx</code>,prop 就是 xxx</li>
<li>receiver :如果目标属性是一个 getter 访问器属性，则 receiver 就是本次读取属性所在的 this 对象。<strong>一般都是 Proxy 实例</strong></li>
</ul>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set 方法如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [];</span><br><span class="line">numbers = <span class="keyword">new</span> <span class="built_in">Proxy</span>(numbers, &#123;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, prop, val</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> val == <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      target[prop] = val;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">numbers.push(<span class="number">1</span>); <span class="comment">// 添加成功</span></span><br><span class="line">numbers.push(<span class="number">2</span>); <span class="comment">// 添加成功</span></span><br><span class="line">numbers.push(<span class="string">&quot;test&quot;</span>); <span class="comment">// TypeError（proxy 的 &#x27;set&#x27; 返回 false）</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数:<ul>
<li>target: 代理对象</li>
<li>property: 访问属性名，</li>
<li>value: 设置的属性的值，比如<code>proxy.xxx = aaa</code>,value 就是 aaa</li>
<li>receiver: 与 get 捕捉器类似，仅与 setter 访问器属性相关。</li>
</ul>
</li>
<li>set 必须返回 true 或者 false</li>
<li>对于数组对象等的内建方法(比如 push/shift/pop),也会触发 setter,因此也可以作为内建方法的监听</li>
</ul>
<h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys"></a>ownKeys</h3><p>对于<code>forin</code>和<code>Object.keys/entries/values</code>等遍历属性方法都会用到<code>[[OwnPropertyKeys]]</code>方法,通过 ownKeys 捕捉器拦截<br>参数只有 target 作为代理对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">_password</span>: <span class="string">&quot;***&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">  <span class="function"><span class="title">ownKeys</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(target).filter(<span class="function">(<span class="params">key</span>) =&gt;</span> !key.startsWith(<span class="string">&quot;_&quot;</span>));</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> user) alert(key); <span class="comment">// name age</span></span><br></pre></td></tr></table></figure>

<p>注意:ownKeys 返回的键<strong>只少不多</strong>;也就是说这些键只能是原本就有的,不能返回原对象没有的键;同理,也不会返回不可枚举的键</p>
<h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty"></a>deleteProperty</h3><p>用于对删除进行拦截<br>参数和 get 相同</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">_password</span>: <span class="string">&quot;***&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">user = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">  <span class="function"><span class="title">deleteProperty</span>(<span class="params">tar, prop</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop.startsWith(<span class="string">&quot;_&quot;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">delete</span> tar[prop];</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="has"><a href="#has" class="headerlink" title="has"></a>has</h3><p>has 会拦截<code>in</code>,比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="attr">from</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">to</span>: <span class="number">10</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(range, &#123;</span><br><span class="line">  <span class="function"><span class="title">has</span>(<span class="params">tar, prop</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> prop &gt;= tar.from &amp;&amp; prop &lt;= tar.to ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> <span class="keyword">in</span> proxy); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>其他一些方法和上面类似,列举如下:<br>|方法|参数|返回|效果|<br>|—|—|—|—|<br>|<code>construct (target, args, newTarget)</code> |<code>args</code> 是创建实例时传入的参数数组;<code>newTarget</code> 是 new 命令作用的构造函数|必须是个对象,用于设置属性|用于拦截 new 命令|<br>|<code>defineProperty (target, key, descriptor)</code>|<code>key</code> 和 <code>descriptor</code> 都是 <code>Object.defineProperty()</code>传入的参数|true/false|拦截了 <code>Object.defineProperty()</code>操作|<br>|<code>getPrototypeOf(target)</code>/<code>setPrototypeOf (target, proto)</code>|<code>proto</code> 是设置的父原型|返回 proto/true 或 false|拦截获取/设置原型|</p>
<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><blockquote>
<p>Reflect 是一个内建对象，可简化 Proxy 的创建。</p>
</blockquote>
<p>也就是说, reflect 是一种”映射”,可以把我们对 reflect 对象的操作”映射到”源对象上<br>每个 Proxy 对应的方法都是 reflect 对应的, 比如 get 中使用的应该是 <code>Reflect.get()</code>,has 使用 <code>Reflect.has()</code>,以此类推<br>举个栗子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, prop, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`GET <span class="subst">$&#123;prop&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, prop, val, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`SET <span class="subst">$&#123;prop&#125;</span>=<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, prop, val, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里的 Reflect 代替的直接的读取, <strong>成功返回 true,失败返回 false</strong><br>注意这里用到了之前没用到的 receiver;这个属性的作用与 this 相关,比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">_name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hello,<span class="subst">$&#123;<span class="built_in">this</span>._name&#125;</span>!`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, prop, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`GET <span class="subst">$&#123;prop&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, prop, val, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`SET <span class="subst">$&#123;prop&#125;</span>=<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(...arguments);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu = &#123;</span><br><span class="line">  <span class="attr">__proto__</span>: proxy,</span><br><span class="line">  <span class="attr">_name</span>: <span class="string">&quot;Mike&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">stu.sayHi();</span><br></pre></td></tr></table></figure>

<p>这个例子中希望 stu 的调用 this 能指向 stu 而不是 user,就需要 reflect<br>如果没有 reflect:</p>
<ul>
<li>stu 访问 name, 在原型 proxy 上寻找</li>
<li>proxy 通过 get 拦截, 并默认把上下文看做 target,调用 user 的 getter,返回一个 user 上下文</li>
<li>产生的是”John”<br>如果有 reflect ,就可以把正常的上下文”receiver”保留,从而使得 this 的指向依旧是”点前面的对象”</li>
</ul>
<h1 id="事件循环、消息队列、同步异步、宏任务微任务、调用栈、垃圾回收等各种原理性杂项"><a href="#事件循环、消息队列、同步异步、宏任务微任务、调用栈、垃圾回收等各种原理性杂项" class="headerlink" title="事件循环、消息队列、同步异步、宏任务微任务、调用栈、垃圾回收等各种原理性杂项"></a>事件循环、消息队列、同步异步、宏任务微任务、调用栈、垃圾回收等各种原理性杂项</h1><p><a target="_blank" rel="noopener" href="https://blog.poetries.top/browser-working-principle/">https://blog.poetries.top/browser-working-principle/</a></p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>对于 JavaScript 来说，会在创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放内存，这个自动释放内存的过程称为垃圾回收。<br>JS 环境中分配的内存有如下声明周期：</p>
<ol>
<li>内存分配：当我们申明变量、函数、对象的时候，系统会自动为他们分配内存</li>
<li>内存使用：即读写内存，也就是使用变量、函数等</li>
<li>内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存</li>
</ol>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>js 的垃圾回收分为新生代和老生代两个部分。</p>
<p>对于新生代，通常采用 Scavenge 算法。</p>
<p>即 将空间一分为二，From 部分表示正在使用的内存，To 是目前闲置的内存。当进行垃圾回收时，V8 将 From 部分的对象检查一遍，如果是存活对象那么复制到 To 内存中（复制期间即进行内存整理），如果是非存活对象直接回收即可。</p>
<p>当所有的 From 中的存活对象按照顺序进入到 To 内存之后，From 和 To 两者的角色对调，From 现在被闲置，To 为正在使用，如此循环。</p>
<p>当新生代的某部分内存经过好几次回收仍存在，就会晋升到老生代中。</p>
<p>老生代的回收方法主要是以下两种（老生代才是标记清除）：</p>
<h3 id="引用计数垃圾收集"><a href="#引用计数垃圾收集" class="headerlink" title="引用计数垃圾收集"></a>引用计数垃圾收集</h3><p>这是最初级的垃圾回收算法。引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。 如果没有其他对象指向它了，说明该对象已经不再需了。</p>
<p>但是如果两个对象相互引用，尽管他们已不再使用，垃圾回收不会进行回收，导致内存泄露。<br>比如这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line">  obj1.a = obj2;</span><br><span class="line">  obj2.a = obj1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure>

<p>为了解决循环引用造成的问题，现代浏览器通过使用标记清除算法来实现垃圾回收。</p>
<h3 id="标记–清除"><a href="#标记–清除" class="headerlink" title="标记–清除"></a>标记–清除</h3><p>标记清除算法将“不再使用的对象”定义为“无法达到的对象”。 简单来说，就是从根部（在 JS 中就是全局对象）出发定时扫描内存中的对象。 凡是能从根部到达的对象，都是还需要使用的。 那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。</p>
<p>实际上标记清除算法也包括了上面的引用计数方法；当一个对象不能被标记搜查到时，自然也就不能被引用。</p>
<p>工作流程：</p>
<ol>
<li>垃圾收集器会在运行的时候会给存储在内存中的所有变量都加上标记。</li>
<li>从根部出发将能触及到的对象的标记清除。</li>
<li>那些还存在标记的变量被视为准备删除的变量。</li>
<li>最后垃圾收集器会执行最后一步内存清除的工作，销毁那些带标记的值并回收它们所占用的内存空间。</li>
</ol>
<h1 id="event-loop"><a href="#event-loop" class="headerlink" title="event loop"></a>event loop</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e15fc609aa84eac973c5b8ff163c11c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"></p>
<p>详细讲解可以看这个视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1oV411k7XY/?spm_id_from=333.788.recommend_more_video.-1">https://www.bilibili.com/video/BV1oV411k7XY/?spm_id_from=333.788.recommend_more_video.-1</a><br>从 12 分钟开始看</p>
<p>纠正几个误区： </p>
<ol start="0">
<li>整个结构主要有三个部分：</li>
</ol>
<ul>
<li>js 调用栈，即所有同步任务直接进入的地方，所有任务要执行必须经过调用栈</li>
<li>webapis，或者可以是浏览器其他线程（对 js 来说就是一些 api），执行诸如定时器、网络请求等；当条件合适，会把回调放到任务队列中</li>
<li>task queue，即任务队列，上一步完成后会把回调放入在此处排队，等待 eventloop 依次取任务执行。</li>
</ul>
<ol>
<li>event loop 并不是一直在工作，它的作用是把任务队列（消息队列）中的任务（消息）依次给 js 调用栈，让 js 执行这些任务；如果一段代码全部都是同步任务，或者异步任务还没有触发任何回调，event loop 就不工作。</li>
<li>event loop 只有在<strong>调用栈为空</strong>的时候才会从 task queue 中取任务放到调用栈中执行。</li>
<li>不是所有任务都会经过 task queue，或者叫做消息队列；只有异步回调会经过，其他任务直接在 js 调用栈中运行！</li>
<li>上面视频最后讲到了渲染，实际上渲染是在和 task queue 争夺调用栈，同样只有栈空才能渲染；这也是不建议让大量代码堆积阻塞的原因。</li>
</ol>
<h1 id="宏任务微任务"><a href="#宏任务微任务" class="headerlink" title="宏任务微任务"></a>宏任务微任务</h1><p>宏任务：<code>setTimeout</code>，<code>setInterval</code>，<code>Ajax</code>，DOM 事件，同步代码算作一整个宏任务<br>微任务：<code>Promise.then/.catch/.finally</code>，<code>async/await</code>，<code>MutationObserver</code>。<br>两者区别：</p>
<ul>
<li>宏任务：DOM 渲染后触发</li>
<li>微任务：DOM 渲染前触发</li>
</ul>
<p>纠正误区：</p>
<ol>
<li>宏任务和微任务是在两个队列中的，并不是微任务在宏任务中；</li>
<li>同步代码算作一整个宏任务，因此同步代码执行完后会先调用微任务，然后才是剩下的异步宏任务。因此在表现上就是微任务先执行；实际上微任务一定是在宏任务之后执行。</li>
<li><code>new Promise</code>本身是同步任务，包括其内部的<code>executor</code>都是同步的，只有<code>.then/.catch/.finally</code>或者 await 才是异步微任务</li>
<li>对于上面的 api，一个函数就是一个宏任务；比如一个<code>setTimeout</code>就是一个宏任务，这个<strong>宏任务执行完后会立刻把微任务队列中的所有微任务都执行</strong>，才会进入下一个宏任务（下一个 setTimeout）</li>
</ol>
<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>DOM 是文档对象模型，实际上是一种规范；根据这个规范，文档（document）中的标签、文本、属性、注释等都是对象，js 都可以访问他们并操作他们。</p>
<h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>DOM 的最小组成单位叫做节点（node），节点的类型有七种。</p>
<ul>
<li><code>Document</code>：整个文档树的顶层节点</li>
<li><code>DocumentType</code>：doctype 标签（比如<code>&lt;!DOCTYPE html&gt;</code>）</li>
<li><code>Element</code>：网页的各种 HTML 标签（比如<code>&lt;body&gt;</code>、<code>&lt;a&gt;</code>等）</li>
<li><code>Attr</code>：网页元素的属性（比如<code>class=&quot;right&quot;</code>）</li>
<li><code>Text</code>：标签之间或标签包含的文本</li>
<li><code>Comment</code>：注释</li>
<li><code>DocumentFragment</code>：文档的片段</li>
</ul>
<h3 id="DOM-Tree"><a href="#DOM-Tree" class="headerlink" title="DOM Tree"></a>DOM Tree</h3><p>一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 DOM 树。它有一个顶层节点，下一层都是顶层节点的子节点，然后子节点又有自己的子节点，就这样层层衍生出一个金字塔结构，又像一棵树。</p>
<p>最根本的对象是<code>document</code>，代表整个文档对象；对于文档所有节点的操作都要在它之下。</p>
<h2 id="遍历-DOM"><a href="#遍历-DOM" class="headerlink" title="遍历 DOM"></a>遍历 DOM</h2><p>DOM 主要关系图：<br><img src="https://pic.imgdb.cn/item/622ac3fd5baa1a80abadacdf.jpg"></p>
<h3 id="顶层节点"><a href="#顶层节点" class="headerlink" title="顶层节点"></a>顶层节点</h3><p>关于具体节点的 DOM 不再赘述，主要看看这几个顶层节点：</p>
<ul>
<li><code>&lt;html&gt;</code> = <code>document.documentElement</code><br>最顶层的 document 节点是 <code>document.documentElement</code>。这是对应 <code>&lt;html&gt;</code> 标签的 DOM 节点。html 标签是一个可以完全可操控的对象，常见的比如操作<code>scrollTop</code>属性用于滚动。</li>
<li><code>&lt;body&gt;</code> = <code>document.body</code><br>另一个被广泛使用的 DOM 节点是 <code>&lt;body&gt;</code> 元素 — <code>document.body</code>。</li>
<li><code>&lt;head&gt;</code> = <code>document.head</code><br><code>&lt;head&gt;</code> 标签可以通过 <code>document.head</code> 访问。</li>
</ul>
<h3 id="关系节点"><a href="#关系节点" class="headerlink" title="关系节点"></a>关系节点</h3><p>给定一个 DOM 节点，我们可以使用导航（navigation）属性访问其直接的邻居。</p>
<p>这些属性主要分为两组：</p>
<ul>
<li><p>对于所有节点：<code>parentNode</code>，<code>childNodes</code>，<code>firstChild</code>，<code>lastChild</code>，<code>previousSibling</code>，<code>nextSibling</code>。<br>所有节点是指包括文本、元素、注释等全部节点（上面说的 7 个节点）<br><img src="https://pic.imgdb.cn/item/622ac5c15baa1a80abaed0a6.jpg"></p>
</li>
<li><p>仅对于元素节点：<code>parentElement</code>，<code>children</code>，<code>firstElementChild</code>，<code>lastElementChild</code>，<code>previousElementSibling</code>，<code>nextElementSibling</code>。<br>这里父、子节点都是单数，因为默认指向都是直接父元素和直接子元素。<br><img src="https://pic.imgdb.cn/item/622ac5b05baa1a80abaec72e.jpg"></p>
</li>
</ul>
<h2 id="getElement-和querySelector"><a href="#getElement-和querySelector" class="headerlink" title="getElement*和querySelector*"></a><code>getElement*</code>和<code>querySelector*</code></h2><p>区别：</p>
<ul>
<li>前者只能选择特定的选择器，比如<code>getElementById</code>只能选择 id；但是后者可以选择任意 css 选择器（字符串形式），直接的标签名当然也可以，还可以是伪类</li>
<li><code>getElementsBy*</code>方法都会返回一个 实时的集合，当 dom 变动时会相应变化；但是后者是<strong>静态的</strong>。</li>
</ul>
<h2 id="DOM-节点类"><a href="#DOM-节点类" class="headerlink" title="DOM 节点类"></a>DOM 节点类</h2><p>每个 DOM 节点都属于相应的内建类；所谓内建类，即包含元素特有属性和方法的类，比如<code>HTMLInputElement</code>是<code>&lt;input&gt;</code>元素的内建类，其上有输入相关的属性。</p>
<p>内建类之间的大致关系如下：<br><img src="https://pic.imgdb.cn/item/622acfaa5baa1a80abb50e82.jpg"></p>
<p>类如下所示：</p>
<ul>
<li><code>EventTarget</code> — 是根的<strong>抽象类</strong>。该类的对象从未被创建（没有实例）。它作为一个基础，以便让所有 DOM 节点都支持所谓的“事件（event）”</li>
<li><code>Node</code> — 也是一个抽象类，充当 DOM 节点的基础。它提供了树的核心功能：parentNode，nextSibling，childNodes 等（它们都是 getter）。Node 类的对象从未被创建。但是有一些继承自它的具体的节点类，例如：文本节点的 Text，元素节点的 Element 等。</li>
<li><code>Element</code> — 是 DOM 元素的基本类。它提供了元素级的导航（navigation），例如 nextElementSibling，children，以及像 getElementsByTagName 和 querySelector 这样的搜索方法。浏览器中不仅有 HTML，还会有 XML 和 SVG。Element 类充当更多特定类的基本类：SVGElement，XMLElement 和 HTMLElement。<ul>
<li><code>HTMLElement</code> — 最终是所有 HTML 元素的基本类。各种 HTML 元素均继承自它：</li>
<li><code>HTMLInputElement</code> — <code>&lt;input&gt;</code> 元素的类，</li>
<li><code>HTMLBodyElement</code> — <code>&lt;body&gt;</code> 元素的类，</li>
<li><code>HTMLAnchorElement</code> — <code>&lt;a&gt;</code> 元素的类，</li>
<li>h5 新增的一些语义化块级元素很多没有特定属性，都直接属于<code>HTMLElement</code></li>
</ul>
</li>
</ul>
<p>当获取某个元素上的方法或属性时，会按照如上的层次顺序依次查找：<br>例如 <code>&lt;input&gt;</code> 元素的 DOM 对象。它属于 <code>HTMLInputElement</code> 类。</p>
<p>它获取属性和方法，并将其作为下列类（按继承顺序列出）的叠加：</p>
<ol>
<li><code>HTMLInputElement</code> — 该类提供特定于输入的属性，</li>
<li><code>HTMLElement</code> — 它提供了通用的 HTML 元素方法</li>
<li><code>Element</code> — 提供通用元素方法，</li>
<li><code>Node</code> — 提供通用 DOM 节点属性，</li>
<li><code>EventTarget</code> — 为事件（包括事件本身）提供支持，</li>
<li><code>Object</code>，因为 <code>hasOwnProperty</code> 这样的“普通对象”方法也是可用的。</li>
</ol>
<p>因此 input 元素继承了上面每个父类的属性和方法，并自己重写了一部分。</p>
<blockquote>
<p>可以通过<code>console.dir(elem)</code> 将元素显示为 DOM 对象在控制台查看</p>
</blockquote>
<h3 id="元素属性"><a href="#元素属性" class="headerlink" title="元素属性"></a>元素属性</h3><p>下面这些属性是基本每个元素通用的、常用的属性：</p>
<h4 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a><code>innerHTML</code></h4><p>输出该元素<strong>内部</strong>的 HTML（即子元素），以字符串形式输出；注意不会输出该元素本身，会把其下各级子元素都输出<br><img src="https://pic.imgdb.cn/item/622ad4c95baa1a80abb87d46.jpg"><br>可以被写入，直接赋值相当于完全替换；可以使用<code>elem.innerHTML += &quot;...&quot;;</code>添加 HTML 元素</p>
<blockquote>
<p><code>innerHTML</code>和<code>innerText</code>区别：后者只会输出各级子元素中的文本节点值，包括换行符等特殊字符；前者输出的是 HTML</p>
</blockquote>
<h4 id="nodeValue-data-textContent"><a href="#nodeValue-data-textContent" class="headerlink" title="nodeValue/data/textContent"></a><code>nodeValue</code>/<code>data</code>/<code>textContent</code></h4><p>文本节点内容，即上面所说 7 种节点类型之一的文本节点。<br>前提是访问的必须是文本节点，甚至不可以是包含文本节点的元素节点（比如<code>&lt;p&gt;</code>元素内部包含的文本不能通过对<code>&lt;p&gt;</code>本身获取，结果只能是 null）</p>
<hr>
<p>更好的方式是使用<code>textContent</code>，会返回当前元素下所有文本节点的文本（不管嵌套多深）</p>
<h2 id="Attributes-amp-properties"><a href="#Attributes-amp-properties" class="headerlink" title="Attributes &amp; properties"></a><code>Attributes</code> &amp; <code>properties</code></h2><h3 id="特性attributes"><a href="#特性attributes" class="headerlink" title="特性attributes"></a>特性<code>attributes</code></h3><p><code>attributes</code>指 html 标签上注明的属性，比如 class/id/style/name 等等</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main-block&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>attributes</code>会在浏览器解析时作为<code>properties</code>插入到元素对象中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">class</span>: <span class="string">&quot;main-block&quot;</span>,</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>只有符合标准的<code>attributes</code>才会被添加，比如特定的几个 id/name/class 等；其余的并不会；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">something</span>=<span class="string">&quot;no-standard&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.body.id); <span class="comment">// test</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 非标准的特性没有获得对应的属性</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.body.something); <span class="comment">// undefined</span></span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>自定义<code>attributes</code>可通过<code>data-</code>的形式添加<br>所有以 <code>data-</code> 开头的特性均被保留，可在 dataset 属性中使用，通过 dataset 对象可以获取：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">data-about-me</span>=<span class="string">&quot;Elephants&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.body.dataset.aboutMe); <span class="comment">// Elephants</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//注意连字符形式转为小驼峰获取</span></span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>所有属性（包括不标准的）都可以通过以下方法进行访问：</p>
<ul>
<li><code>elem.hasAttribute(name)</code> — 检查特性是否存在。</li>
<li><code>elem.getAttribute(name)</code> — 获取这个特性值。</li>
<li><code>elem.setAttribute(name, value)</code> — 设置这个特性值。</li>
<li><code>elem.removeAttribute(name)</code> — 移除这个特性。</li>
</ul>
<p>HTML 特性有以下几个特征：</p>
<ul>
<li>名字是大小写不敏感的（id 与 ID 相同）。</li>
<li>值总是字符串类型的。</li>
</ul>
<h3 id="属性properties"><a href="#属性properties" class="headerlink" title="属性properties"></a>属性<code>properties</code></h3><p>由于元素本质上是一个 DOM 对象，因此可以向这个对象添加属性或方法，甚至向原型上添加：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.sayTagName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.tagName);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Element.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">`Hello, I&#x27;m <span class="subst">$&#123;<span class="built_in">this</span>.tagName&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.documentElement.sayHi(); <span class="comment">// Hello, I&#x27;m HTML</span></span><br><span class="line"><span class="built_in">document</span>.body.sayHi(); <span class="comment">// Hello, I&#x27;m BODY</span></span><br></pre></td></tr></table></figure>

<p>不同于<code>attributes</code>，而<code>properties</code>是多类型的；比如 style 是一个对象。<br>实际上<code>properties</code>就是相当于对象上的属性，其性质和操作等都可以直接认为是对象上的属性。</p>
<h2 id="classList和style"><a href="#classList和style" class="headerlink" title="classList和style"></a><code>classList</code>和<code>style</code></h2><p>通常修改样式的方法不应该是直接操作 style 属性，而是添加或删除一个 class</p>
<ul>
<li><code>className</code>会替换整个 class 字符串</li>
<li><code>classList</code> 的方法：<ul>
<li><code>elem.classList.add/remove(class)</code> — 添加/移除类。</li>
<li><code>elem.classList.toggle(class)</code> — 如果类不存在就添加类，存在就移除它。</li>
<li><code>elem.classList.contains(class)</code> — 检查给定类，返回 true/false。</li>
</ul>
</li>
</ul>
<hr>
<p>直接操作 style 相当于操作元素的 style <code>attributes</code>，因此不能通过 style 属性获取元素的样式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  The red text</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    alert(<span class="built_in">document</span>.body.style.color); <span class="comment">// 空的</span></span></span><br><span class="line"><span class="javascript">    alert(<span class="built_in">document</span>.body.style.marginTop); <span class="comment">// 空的</span></span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是可以通过<code>getComputedStyle</code>获取，参数第一个是元素 dom 对象，第二个是伪元素（可以选择该元素的<code>::after</code>等伪元素）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getComputedStyle(element, [pseudo]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> computedStyle = getComputedStyle(<span class="built_in">document</span>.body);</span><br><span class="line"><span class="built_in">console</span>.log(computedStyle.marginTop); <span class="comment">// 5px</span></span><br><span class="line"><span class="built_in">console</span>.log(computedStyle.color); <span class="comment">// rgb(255, 0, 0)</span></span><br></pre></td></tr></table></figure>

<p>getComputedStyle 实际上返回的是属性的解析值（resolved）：</p>
<ul>
<li>计算值：即确切的 css 属性值</li>
<li>解析值：把相对单位解析为确切数值的绝对单位值</li>
</ul>
<blockquote>
<p>尽量不要从<code>getComputedStyle</code>中获取元素宽高；因为这样获取的是 css 中设定的值，如果 css 中并没有显式指定宽高就有可能是 auto。<br>宽高等具体尺寸最好用<code>clientWidth/clientHeight</code>等获取；这部分的详解在 css 中。</p>
</blockquote>
<h2 id="Window-大小和滚动"><a href="#Window-大小和滚动" class="headerlink" title="Window 大小和滚动"></a>Window 大小和滚动</h2><p>为了获取窗口（window）的宽度和高度，我们可以使用 <code>document.documentElement.clientWidth/clientHeight</code></p>
<blockquote>
<p><code>window.innerWidth/innerHeight</code> 包括了滚动条，如果有滚动条的情况下实际上的可视空间会偏小。尽量使用 client</p>
</blockquote>
<h3 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h3><p>DOM 元素的当前滚动状态在其 scrollLeft/scrollTop 属性中；<br>但是对于整个 html 页面，通常使用这两个 api：（只读）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.pageYOffset); <span class="comment">//表示当前可视区域顶部到整个文档顶部的距离，相当于整个html元素的scrollTop</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.pageXOffset);</span><br></pre></td></tr></table></figure>

<p>如果要更改，可以使用 api 手动滚动：</p>
<ul>
<li><code>window.scrollBy(x,y)</code>：移动相对距离</li>
<li><code>window.scrollTo(pageX,pageY)</code>：移动到绝对位置，单位是像素值，值可以从<code>window.pageYOffset</code>获取</li>
<li><code>elem.scrollIntoView(true/false)</code>：移动到当前元素，参数 true 为使 elem 出现在窗口顶部。元素的上边缘将与窗口顶部对齐；false 则为底部。</li>
</ul>
<blockquote>
<p>要使文档不可滚动，只需要设置 <code>document.body.style.overflow = &quot;hidden&quot;</code>。该页面将“冻结”在其当前滚动位置上。<br>再设置一次空值则可以取消</p>
</blockquote>
<h2 id="Mutation-Observer-API"><a href="#Mutation-Observer-API" class="headerlink" title="Mutation Observer API"></a><code>Mutation Observer API</code></h2><p><code>Mutation Observer API</code> 用来监视 DOM 变动。DOM 的任何变动，比如节点的增减、属性的变动、文本内容的变动，这个 API 都可以得到通知。<br><code>Mutation Observer</code>是一个典型的<strong>微任务</strong>，通过这个 api 插入的处理程序会在当前所有 dom 变动之后执行。<br>详见：<br><a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/dom/mutationobserver.html">https://wangdoc.com/javascript/dom/mutationobserver.html</a></p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="EventTarget"><a href="#EventTarget" class="headerlink" title="EventTarget"></a><code>EventTarget</code></h2><p>事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 节点的事件操作（监听和触发），都定义在<code>EventTarget</code>接口。<br>所有节点对象都部署了这个接口，<code>Element</code>/<code>document</code>/<code>window</code> 是最常见的 <code>event targets</code>，这些 targets 可以被安插监听事件，可以被触发事件，也支持通过 <code>onevent</code> 设置事件处理程序。<br>该接口主要提供三个实例方法。</p>
<ul>
<li><code>addEventListener()</code>：绑定事件的监听函数</li>
<li><code>removeEventListener()</code>：移除事件的监听函数</li>
<li><code>dispatchEvent()</code>：触发事件</li>
</ul>
<p>从结构上来说，<code>EventTarget</code>实际上是一个维护各种监听处理回调、并按照事件类型分类的对象，通过<code>addEventListener()</code>等方法向上面添加、移除或者触发回调。<br>简单实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventTarget</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.listeners = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addEventListener</span>(<span class="params">type, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(type <span class="keyword">in</span> <span class="built_in">this</span>.listeners)) &#123;</span><br><span class="line">      <span class="comment">//如果之前没有这个类型的事件就初始化为空数组</span></span><br><span class="line">      <span class="built_in">this</span>.listeners[type] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.listeners[type].push(callback);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">removeEventListener</span>(<span class="params">type, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(type <span class="keyword">in</span> <span class="built_in">this</span>.listeners)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">this</span>.listeners = <span class="built_in">this</span>.listeners.filter(<span class="function">(<span class="params">list</span>) =&gt;</span> list !== callback);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">dispatchEvent</span>(<span class="params">event</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(type <span class="keyword">in</span> <span class="built_in">this</span>.listeners)) <span class="keyword">return</span>;</span><br><span class="line">    event.target = <span class="built_in">this</span>; <span class="comment">//绑定e.target为当前EventTarget</span></span><br><span class="line">    <span class="built_in">this</span>.listeners[event.type].forEach(<span class="function">(<span class="params">list</span>) =&gt;</span> &#123;</span><br><span class="line">      list.call(<span class="built_in">this</span>, event); <span class="comment">//依次触发该事件类型对应的每个事件</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件的异步和同步"><a href="#事件的异步和同步" class="headerlink" title="事件的异步和同步"></a>事件的异步和同步</h2><p>因此关于事件的监听、触发的顺序大致是这样：</p>
<ol>
<li>解析到 js 代码中有<code>addEventListener()</code>部分，将对应的处理程序或监听安插在该<code>EventTarget</code>上，但并不会执行</li>
<li>用户触发事件，这个过程可能由浏览器进程捕捉到，通过 IO 线程发送消息；</li>
<li>该<code>EventTarget</code>维护一个事件池（事件侦听器列表），收到事件触发的消息后，将处理程序封装成消息，放入消息队列中，后续执行。</li>
</ol>
<p>因此对于原生事件来说，可以理解为：</p>
<ul>
<li>事件的触发是异步（随时可能触发）</li>
<li>事件的处理是同步（一触发立即放入消息队列）</li>
</ul>
<h3 id="嵌套事件的立即触发"><a href="#嵌套事件的立即触发" class="headerlink" title="嵌套事件的立即触发"></a>嵌套事件的立即触发</h3><blockquote>
<p>通常事件是在队列中处理的。也就是说：如果浏览器正在处理 <code>onclick</code>，这时发生了一个新的事件，例如鼠标移动了，那么它的处理程序会被排入队列，相应的 <code>mousemove</code> 处理程序将在 <code>onclick</code> 事件处理完成后被调用。</p>
</blockquote>
<p>上面的引用说到，如果一个事件处理中触发了另一个事件，不会打断当前事件回调的执行，而是会放在当前事件之后执行。因为事件的触发是异步的，只有触发时事件对象才能知道已经触发，并把事件处理程序插入到消息队列中。</p>
<hr>
<p>但是特殊情况在于嵌套触发事件，会使得处理程序被“立即触发”，相当于同步触发。<br>比如下面这个例子，在一个事件的处理程序中触发了另一个事件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>clickme<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn2&quot;</span>&gt;</span>clickme2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  btn.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;btn1 has toggled&quot;</span>);</span></span><br><span class="line"><span class="javascript">    btn2.click();</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;btn1 finished&quot;</span>);</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript">  btn2.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;btn2 has toggled&quot;</span>);</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>点击 btn1 时的输出顺序：<br><img src="https://pic.imgdb.cn/item/622cb2a85baa1a80abc02079.jpg"><br>可以看到先去执行了另一个事件的处理程序，然后才返回继续执行自己的。<br>因此<strong>嵌套事件的传播和处理先被完成，然后处理过程才会返回到外部代码</strong>；但通常事件都会<strong>依次执行</strong>，并不会在一个处理程序中插入另一个。</p>
<h2 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a><code>addEventListener</code></h2><blockquote>
<p><code>addEventListener()</code>的工作原理是将实现<code>EventListener</code>的函数或对象添加到调用它的<code>EventTarget</code>上的指定事件类型的事件侦听器列表中。</p>
</blockquote>
<p>使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(event, handler, &#123; options &#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>event</code>：事件名，例如：”click”。</li>
<li><code>handler</code>处理程序。handler 不一定是函数，可以是一个对象或者一个类，比如这样：</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;elem&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">handleEvent</span>(<span class="params">event</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// mousedown -&gt; onMousedown</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> method = <span class="string">&quot;on&quot;</span> + event.type[<span class="number">0</span>].toUpperCase() + event.type.slice(<span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>[method](event);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">onMousedown</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      elem.innerHTML = <span class="string">&quot;Mouse button pressed&quot;</span>;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">onMouseup</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      elem.innerHTML += <span class="string">&quot;...and released.&quot;</span>;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> menu = <span class="keyword">new</span> Menu();</span></span><br><span class="line"><span class="javascript">  elem.addEventListener(<span class="string">&quot;mousedown&quot;</span>, menu);</span></span><br><span class="line"><span class="javascript">  elem.addEventListener(<span class="string">&quot;mouseup&quot;</span>, menu);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>options</code>:一个对象，属性有这三种：<ul>
<li><code>once</code>：如果为 true，事件只触发一次；</li>
<li><code>capture</code>：表示是否在事件捕获阶段触发。即“事件捕获”，从外向内触发事件；为 false 就是默认的“事件冒泡”</li>
<li><code>passive</code>：如果为 true，处理程序将不会调用 <code>preventDefault()</code></li>
</ul>
</li>
</ul>
<h2 id="事件对象event"><a href="#事件对象event" class="headerlink" title="事件对象event"></a>事件对象<code>event</code></h2><blockquote>
<p>当事件发生时，浏览器会创建一个 event 对象，将详细信息放入其中，并将其作为参数传递给处理程序。</p>
</blockquote>
<h3 id="event-target-和-event-currentTarget-和-this"><a href="#event-target-和-event-currentTarget-和-this" class="headerlink" title="event.target 和 event.currentTarget 和 this"></a><code>event.target</code> 和 <code>event.currentTarget</code> 和 <code>this</code></h3><p><code>this=event.currentTarget</code>;<br>这两个和 target 的区别在于:target 是指具体触发的元素,this 是指事件被插入的位置那个元素<br>比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;main&quot;</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span>clickme<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;;</span><br><span class="line"><span class="comment">//js</span></span><br><span class="line"><span class="comment">//如果点击的是inner</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;main&quot;</span>)[<span class="number">0</span>].addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  clg(event.target.className); <span class="comment">//inner</span></span><br><span class="line">  clg(<span class="built_in">this</span>.className); <span class="comment">//main</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个时候如果点击里边的 inner,this 就还是 main,而 target 则是点击的具体元素:inner</p>
<h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><blockquote>
<p>当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序。</p>
</blockquote>
<p>也就是说,触发一个元素的事件会从下向上连着触发它父元素和祖元素的事件。<br>注意这里是连续触发<strong>事件</strong>，而不是单纯的向上传递事件处理对象。<br>比如在子元素 input 点击一下，会触发 focus 事件，同时会触发其父元素的 click 事件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span> <span class="attr">onclick</span>=<span class="string">&quot;handleClick()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;my-input&quot;</span> <span class="attr">onfocus</span>=<span class="string">&quot;handleFocus()&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h3><p>冒泡事件从目标元素开始向上冒泡。通常，它会一直上升到 <code>&lt;html&gt;</code>，然后再到 document 对象，有些事件甚至会到达 window，它们会调用路径上所有的处理程序。<br>阻止传播有两个方法：（注意不只是阻止冒泡，捕获也会被阻止）</p>
<ul>
<li><code>event.stopPropagation()</code>可以阻止冒泡和捕获；安插在任意想要阻止冒泡的处理函数上，但并不会阻止当前元素的事件触发，只会阻止向上的。</li>
<li><code>event.stopImmediatePropagation()</code>阻止冒泡和捕获，并顺便阻止当前元素事件的执行</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>clickme<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.querySelector(<span class="string">&quot;main&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(e); <span class="comment">//不会触发，因为下面冒泡被拦截了</span></span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(e);</span></span><br><span class="line"><span class="javascript">    e.stopPropagation();</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h2><p>DOM 事件标准描述了事件传播的 3 个阶段：</p>
<ul>
<li>捕获阶段（Capturing phase）—— 事件（从 Window）向下走近元素。</li>
<li>目标阶段（Target phase）—— 事件到达目标元素。</li>
<li>冒泡阶段（Bubbling phase）—— 事件从元素上开始冒泡。</li>
</ul>
<p>事件首先通过祖先链向下到达元素（捕获阶段），然后到达目标（目标阶段），最后上升（冒泡阶段），<strong>在途中调用处理程序</strong>。<br><img src="https://pic.imgdb.cn/item/622afec75baa1a80abd69535.jpg"></p>
<p>上面说的<code>addEventListener</code>如果设置了参数 capture 为 true，则事件会在捕获阶段被触发。</p>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><blockquote>
<p>如果我们有许多以类似方式处理的元素，那么就不必为每个元素分配一个处理程序 —— 而是将单个处理程序放在它们的共同祖先上。</p>
</blockquote>
<p>举个栗子:比如说现在有一个 3*3 的单元格,现在想实现点击哪个单元格就让哪个变色</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> table = <span class="built_in">document</span>.getElementById(<span class="string">&quot;tab&quot;</span>);</span><br><span class="line">table.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.target.tagName !== <span class="string">&quot;td&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  e.target.style.backgroundColor = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>另外，更高级的写法是通过一个类或对象创建一组事件处理，然后传入事件后在内部匹配并触发：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;menu&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-action</span>=<span class="string">&quot;save&quot;</span>&gt;</span>Save<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-action</span>=<span class="string">&quot;load&quot;</span>&gt;</span>Load<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-action</span>=<span class="string">&quot;search&quot;</span>&gt;</span>Search<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">constructor</span>(<span class="params">elem</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>._elem = elem;</span></span><br><span class="line"><span class="javascript">      elem.onclick = <span class="built_in">this</span>.onClick; <span class="comment">//插入事件</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">save</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;saving&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">load</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;loading&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">search</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;searching&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    onClick = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> action = event.target.dataset.action;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (action) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>[action]();</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">new</span> Menu(<span class="built_in">document</span>.getElementById(<span class="string">&quot;menu&quot;</span>)); <span class="comment">//只需要new即可，在constructor中会插入事件。</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="浏览器默认事件"><a href="#浏览器默认事件" class="headerlink" title="浏览器默认事件"></a>浏览器默认事件</h2><p>浏览器主要的默认行为有:</p>
<ul>
<li>点击<code>&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;</code>会自动跳转,也就是改变 location 的 Url 信息</li>
<li>form 表单的<code>submit</code>事件会触发服务器提交,路径会带上 form 的信息跳转到新页面</li>
<li>在文本上按下鼠标按钮并移动会选中文本</li>
<li>在 <code>&lt;input type=&quot;checkbox&quot;&gt;</code> 上的 click 会选中/取消选中的 input</li>
</ul>
<p>想阻止默认事件有这几种方法:</p>
<ul>
<li>在事件的 event 对象使用<code>e.preventDefault()</code>方法</li>
<li><code>return false</code>,但是只能用于<code>onxxx</code>事件</li>
<li><code>addEventListener</code> 的可选项 <code>passive: true</code></li>
</ul>
<h3 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h3><p>阻止默认行为的两个方法：</p>
<ol>
<li>如果通过<code>on&lt;event&gt;</code>的形式触发，通过 return false 可以阻止。</li>
</ol>
<blockquote>
<p>React 中的事件虽然也是这种形式，但是并不相同，只能通过<code>e.preventDefault()</code>来阻止。</p>
</blockquote>
<p>注意这里 return 不是调用函数中在内部 return，而是直接在属性上 return<br>这样是无效的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">onsubmit</span>=<span class="string">&quot;handleSubmit()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">handleSubmit</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>无效的原因是，浏览器会根据其内容创建对应的处理程序，也就是说绑定的这个函数实际上外面又包了一层：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//onclick=&quot;handleSubmit()&quot;其实是</span></span><br><span class="line">elem.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  handleSubmit();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同时也可以看到，安插在 html 元素上的 event 应该写完整，只写一个<code>e</code>或者不写都不行。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onsubmit</span>=<span class="string">&quot;handleSubmit(event)&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;form onsubmit=&quot;handleSubmit(e)&quot;&gt; 不可以--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>应该这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return handleSubmit()&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者直接：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者这样也可：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.querySelector(<span class="string">&quot;form&quot;</span>).onsubmit = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">  &#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>addEventListener</code>只要拿到 event 对象，可以通过<code>e.preventDefault()</code>来阻止，而返回 false 无效。</li>
</ol>
<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p><a target="_blank" rel="noopener" href="https://zh.javascript.info/dispatch-events">https://zh.javascript.info/dispatch-events</a></p>
<h1 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h1><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><blockquote>
<p>fetch 不是 ajax 的进一步封装，而是原生 js，没有使用 XMLHttpRequest 对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = fetch(url, [options]);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>url</code> —— 要访问的 URL。</li>
<li><code>options</code> —— 可选参数，是一个对象：method，header 等。</li>
</ul>
<p><code>options</code>是 fetch 的主要配置选项，用于设置请求方法、放置请求体、设置请求头等<br>比如：</p>
<ul>
<li>设置 headers：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> response = fetch(protectedUrl, &#123;</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="attr">Authentication</span>: <span class="string">&quot;secret&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>设置 Post</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&quot;/article/fetch/post/user&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json;charset=utf-8&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(user),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>浏览器立即启动请求，并返回一个该调用代码应该用来获取结果的 promise；获取响应通常需要经过两个阶段：</p>
<ol>
<li><strong>服务器发送了响应头，fetch 返回的 promise 就使用内建的 <code>Response class</code> 对象来对响应头进行解析</strong>。</li>
</ol>
<p>fetch 会返回一个 promise 对象，resolve 值是一个 response，主要属性有：</p>
<ul>
<li><code>status</code>：HTTP 状态码，例如 200。</li>
<li><code>ok</code>：布尔值，如果 HTTP 状态码为 200-299，则为 true。</li>
<li><code>headers</code>：一个类似 Map 的 header 对象，可以迭代和使用 get 方法获取值：</li>
<li><code>body</code>：一个 <code>ReadableStream</code>，是一个读取流，可以用于访问读取进度</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> fetch(</span><br><span class="line">  <span class="string">&quot;https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个 header</span></span><br><span class="line">alert(response.headers.get(<span class="string">&quot;Content-Type&quot;</span>)); <span class="comment">// application/json; charset=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代所有 header</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> response.headers) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> = <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果请求失败，会 reject 一个异常状态码以及错误信息</p>
<ol start="2">
<li><strong>使用对 response 的处理方法获取<code>response.body</code></strong></li>
</ol>
<p>主要方法有：</p>
<ul>
<li><code>response.text()</code> : 读取 response，并以文本形式返回 response，</li>
<li><code>response.json()</code> : 将 response 解析为 JSON</li>
<li><code>response.formData()</code> : 以 FormData 对象的形式返回 response，</li>
<li><code>response.blob()</code> : 以 Blob 形式返回 response，</li>
<li><code>response.arrayBuffer()</code> : 以 ArrayBuffer 形式返回 response，</li>
</ul>
<p>这些方法都不会直接返回结果，而是返回一个 Promise 对象；因此仍然需要 await 或 then 调用获取结果。<br>方法只能调用一次，一次处理之后后续再解析也无效。</p>
<hr>
<p>fetch 等常见的请求方法都会返回一个 Promise 对象等待后续处理。因此如果针对“<strong>一组</strong>”请求，更好的方式是使用<code>Promise.all</code>。<br>比如，一个请求一组用户信息的函数，可以这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> infos = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">of</span> names) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">await</span> fetch(<span class="string">`/api/<span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">let</span> parse = <span class="keyword">await</span> res.json();</span><br><span class="line">  infos.push(parse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法相当于对每个 name 依次执行一个请求，当一个 name 的请求完成之前下一个请求并不会开始（上一个还在 await）。这样会导致请求速度很慢；<br>更高级的方式是把 fetch 请求的返回值放在一个数组中，然后对这个数组调用<code>Promise.all</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> infos = [];</span><br><span class="line">names.forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> info = fetch(<span class="string">`/api/<span class="subst">$&#123;name&#125;</span>`</span>).then(</span><br><span class="line">    <span class="function">(<span class="params">success</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> success.status === <span class="number">200</span> ? success.json() : <span class="literal">null</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">fail</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">  infos.push(info);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(infos);</span><br></pre></td></tr></table></figure>

<p>通过将 <code>.json() </code>直接添加到每个 fetch 中，就能确保每个 fetch 在收到响应时都会立即开始以 JSON 格式读取数据，而不会彼此等待。<br>不仅是 fetch，其他方法也是同理。</p>
<h3 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h3><p>之前讲过用 FormData 对象捕获表单数据的方法。fetch 可以接受一个 FormData 对象作为 body，会自动设置<code>Content-Type: multipart/form-data</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> form = <span class="built_in">document</span>.forms[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">  form.addEventListener(<span class="string">&quot;submit&quot;</span>, <span class="keyword">async</span> (e) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">    e.preventDefault();</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> formData = <span class="keyword">new</span> FormData(form);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> res = <span class="keyword">await</span> fetch(<span class="string">&quot;&quot;</span>, &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">body</span>: formData,</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>formData 不能被显式查看，但可以通过一些迭代方法访问，详见 BOM 章。</p>
<h2 id="XHR"><a href="#XHR" class="headerlink" title="XHR"></a>XHR</h2><p><a target="_blank" rel="noopener" href="https://zh.javascript.info/xmlhttprequest">https://zh.javascript.info/xmlhttprequest</a></p>
<p>常用的封装 xhr：</p>
<ol>
<li>xhr 需要先通过<code>open()</code>传入方法和 url</li>
<li>xhr 需要指定<code>responseType</code>和<code>setRequestHeader</code>，即指明响应格式和请求头</li>
<li>准备好后通过 send 发送请求</li>
<li>不需要<code>onreadystatechange</code>监听，因为现在已经拥有 onload 方法了</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url, method = <span class="string">&quot;GET&quot;</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    xhr.open(method, url);</span><br><span class="line">    xhr.responseType = <span class="string">&quot;JSON&quot;</span>;</span><br><span class="line">    xhr.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    xhr.send();</span><br><span class="line">    xhr.onload = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(xhr.response);</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.onerror = <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><blockquote>
<p>WebSockets 是一种先进的技术。它可以在用户的浏览器和服务器之间打开交互式通信会话。使用此 API 可以向服务器发送消息并接收事件驱动的响应，而无需通过轮询服务器的方式以获得响应。</p>
</blockquote>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>首先创建一个 WebSocket：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://xxx&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这个过程会尝试和该 url 建立连接，并返回一个 socket 对象。<br>一共有 4 个事件：</p>
<ul>
<li><code>socket.onopen</code>：连接已建立，</li>
<li><code>socket.onmessage</code>：接收到数据，</li>
<li><code>socket.onerror</code>：WebSocket 错误，</li>
<li><code>socket.onclose</code>：连接已关闭。</li>
</ul>
<p>使用<code>socket.send()</code>发送消息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(</span><br><span class="line">  <span class="string">&quot;wss://javascript.info/article/websocket/demo/hello&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">socket.onopen = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  socket.send(<span class="string">&quot;My name is John&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.onmessage = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`[message] Data received from server: <span class="subst">$&#123;event.data&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.onclose = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.wasClean) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">`[close] Connection closed cleanly, code=<span class="subst">$&#123;event.code&#125;</span> reason=<span class="subst">$&#123;event.reason&#125;</span>`</span></span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 例如服务器进程被杀死或网络中断</span></span><br><span class="line">    <span class="comment">// 在这种情况下，event.code 通常为 1006</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[close] Connection died&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.onerror = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`[error] <span class="subst">$&#123;error.message&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="WebSocket-连接"><a href="#WebSocket-连接" class="headerlink" title="WebSocket 连接"></a>WebSocket 连接</h3><p>当 <code>new WebSocket(url)</code> 被创建后，它将立即开始连接。<br>首先会先发起一个 http 请求，确知服务器支持 ws 后会建立 ws 连接：<br><img src="https://pic.imgdb.cn/item/622dce4d5baa1a80ab4ab5b7.jpg"></p>
<h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p>WebSocket 通信由 “frames”（即数据片段，帧）组成，可以从任何一方发送，并且有以下几种类型：</p>
<ul>
<li><code>text frames</code> —— 包含各方发送给彼此的文本数据。</li>
<li><code>binary data frames</code> —— 包含各方发送给彼此的二进制数据。</li>
<li><code>ping/pong frames</code> 被用于检查从服务器发送的连接，浏览器会自动响应它们。</li>
<li><code>connection close frame</code> 以及其他服务 frames</li>
</ul>
<p>send 方法不用设置数据类型，文本或二进制文件都可以</p>
<blockquote>
<p>当我们收到数据时，文本总是以字符串形式呈现。而对于二进制数据，我们可以在 Blob 和 ArrayBuffer 格式之间进行选择。<br><code>socket.binaryType</code> 属性可以设置，默认为 blob，可以设置为<code>&quot;arraybuffer&quot;</code></p>
</blockquote>
<h1 id="其他-js-基本知识点"><a href="#其他-js-基本知识点" class="headerlink" title="其他 js 基本知识点"></a>其他 js 基本知识点</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>JavaScript 的变量命名有两个限制：</p>
<ul>
<li>变量名称必须仅包含字母，数字，符号 <code>$</code> 和 <code>_</code>。</li>
<li>首字符必须非数字。</li>
</ul>
<p>单独的一个<code>$</code>或<code>_</code>也可以作为变量名。</p>
<hr>
<p>js 中的变量可以被任意互相赋值，变量间的赋值是一种拷贝；简单数据类型直接复制值，对象等复杂数据类型则复制引用</p>
<h2 id="和-amp-amp-和"><a href="#和-amp-amp-和" class="headerlink" title="||和&amp;&amp;和??"></a><code>||</code>和<code>&amp;&amp;</code>和<code>??</code></h2><ul>
<li><code>||</code> 可以在一排中找到第一个真值:<code>a || b</code> 表示 a 为假则判断 b;a 为真则直接用 a;</li>
<li><code>&amp;&amp;</code>可以找到第一个假值:<code>a &amp;&amp; b</code> 表示 a 为假则返回 a,a 为真则返回 b;都为真返回最后一个;</li>
<li><code>??</code>和<code>||</code>差不多,但是<code>||</code>是判断真值,<code>??</code>是判断已定义的值，即 null 或 undefined;比如 0 虽然为假但是已定义就可以正常返回</li>
</ul>
<p>三者的优先级：<code>&amp;&amp;</code> &gt; <code>||</code> = <code>??</code><br>但是 js 禁止同时使用<code>??</code>和另外两个，除非明确带上括号</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span> &amp;&amp; <span class="number">2</span> ?? <span class="number">3</span>; <span class="comment">//error</span></span><br><span class="line"><span class="keyword">let</span> x = (<span class="number">1</span> &amp;&amp; <span class="number">2</span>) ?? <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="this-原理"><a href="#this-原理" class="headerlink" title="this 原理"></a>this 原理</h3><blockquote>
<p>this 的设计目的就是在函数体内部，指代函数当前的运行环境。<br>this 是和执行上下文绑定的，也就是说每个执行上下文中都有一个 this</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2018/06/javascript-this.html">https://www.ruanyifeng.com/blog/2018/06/javascript-this.html</a></p>
<h3 id="this-基本"><a href="#this-基本" class="headerlink" title="this 基本"></a>this 基本</h3><ul>
<li>this:指向最近的 obj 对象<ul>
<li>直接用或者函数里用,表示 window</li>
<li>class 里表示这个类</li>
<li>构造函数里表示实例对象(new 了以后)</li>
<li>在事件中表示触发事件的对象,比如 click 事件的 this 就会是 button 元素</li>
<li>对象中的方法:就是指这个对象</li>
</ul>
</li>
<li>this 的 bind apply call<ul>
<li>bind:一般给函数使用,bind 一个变量,让函数内部的 this 指向这个变量<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;zzx&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">f1.bind(obj1); <span class="comment">//调用的时候就是obj作为this的指向了</span></span><br></pre></td></tr></table></figure>
关于 this 更详细的讲解参考这里：<br><a target="_blank" rel="noopener" href="https://blog.poetries.top/browser-working-principle/guide/part2/lesson11.html#javascript-%E4%B8%AD%E7%9A%84-this-%E6%98%AF%E4%BB%80%E4%B9%88">https://blog.poetries.top/browser-working-principle/guide/part2/lesson11.html#javascript-%E4%B8%AD%E7%9A%84-this-%E6%98%AF%E4%BB%80%E4%B9%88</a></li>
</ul>
</li>
</ul>
<h3 id="this-特点"><a href="#this-特点" class="headerlink" title="this 特点"></a>this 特点</h3><ol start="0">
<li>this 本质上是运行环境的指代，或者说是和执行上下文绑定。它的设计目的就是在函数体内部，指代函数当前的运行环境。</li>
<li>this 只有在<strong>执行中</strong>才能确定。因此判断 this 指向应该是看在哪里执行，而不是在哪里定义。</li>
<li>箭头函数没有自己的 this，由上一条，它内部的 this 是<strong>运行时</strong>的父环境的 this。注意是运行时才确定的。</li>
</ol>
<h3 id="从调用栈看-this"><a href="#从调用栈看-this" class="headerlink" title="从调用栈看 this"></a>从调用栈看 this</h3><p><a target="_blank" rel="noopener" href="https://blog.poetries.top/browser-working-principle/guide/part2/lesson11.html#javascript-%E4%B8%AD%E7%9A%84-this-%E6%98%AF%E4%BB%80%E4%B9%88">https://blog.poetries.top/browser-working-principle/guide/part2/lesson11.html#javascript-%E4%B8%AD%E7%9A%84-this-%E6%98%AF%E4%BB%80%E4%B9%88</a></p>
<h3 id="常见的-this-丢失指向场景："><a href="#常见的-this-丢失指向场景：" class="headerlink" title="常见的 this 丢失指向场景："></a>常见的 this 丢失指向场景：</h3><ol>
<li>对象或类内部定义一个含有 this 的方法，但是使用时没有点访问符</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getname = user.getName();</span><br><span class="line">getname(); <span class="comment">//this丢失</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getname = <span class="keyword">new</span> User().getName;</span><br><span class="line">getname(); <span class="comment">//this丢失</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>setTimeout、setInterval 中的第一个参数，由于触发环境和正常的 js 调用栈完全不同（微任务），因此内部 this 默认为 window</li>
<li>参数传递，因为传入一个函数时相当于赋值给了形参，可能会导致 this 丢失。<br>最常见的情况就是装饰器：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">  foo,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decorateFoo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    fn(<span class="built_in">arguments</span>); <span class="comment">//应当为fn.apply(this,arguments)</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fooFoo = decorateFoo(obj.foo);</span><br><span class="line">fooFoo(); <span class="comment">//丢失指向</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>箭头函数情况。如果对象中方法使用箭头函数、或者一个函数返回一个箭头函数，会使得 this 指向其父层，有可能并不存在 this。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.getName();</span><br></pre></td></tr></table></figure>

<p>这里使用箭头函数，由于没有自己的 this 上下文，<strong>调用时</strong>又没有外层代码块，因此直接指向全局（window 或 undefined）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;bbb&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> bar = foo();</span><br><span class="line">bar.call(obj2); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>由于 foo 函数中的 this 也是 window，因此 bar 函数即使绑定了 obj2 也没用。<br>箭头函数内部的 this 是指向外层代码块的 this（最近的 this，上例的 foo 函数），所以可以通过改变外层代码块的 this 的指向从而改变箭头函数中 this 的指向。<br>可以先给 foo 进行绑定 obj2，这样其内部的箭头函数中的 this 就会变成 obj2.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = foo.call(obj2);</span><br><span class="line">bar(); <span class="comment">//bbb</span></span><br></pre></td></tr></table></figure>

<h2 id="bind-apply-call"><a href="#bind-apply-call" class="headerlink" title="bind apply call"></a>bind apply call</h2><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>例子 1:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;zzx&quot;</span>,</span><br><span class="line">  <span class="attr">myFun</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">user.myFun(); <span class="comment">//&#x27;zzx&#x27;</span></span><br><span class="line"><span class="keyword">let</span> admin = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ly&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">user.myFun.apply(admin); <span class="comment">//&#x27;ly&#x27;</span></span><br><span class="line">user.myFun.call(admin); <span class="comment">//&#x27;ly&#x27;</span></span><br><span class="line">user.myFun.bind(admin)(); <span class="comment">//&#x27;ly&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个过程发生了什么?<br>首先,正常调用 <code>user.myFun()</code>,this 的指向就是 user,也就是调用该方法的对象.但是我们新建了一个对象 admin,通过 <code>apply(admin)</code>把 admin 绑定到 myFun 的 this 上,让这个 this 指向不是 user 而是 admin</p>
<p>接下来例子 2 说明一下三者区别</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;zzx&quot;</span>,</span><br><span class="line">  <span class="attr">myFun</span>: <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot; &quot;</span> + b;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">user.myFun(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;welcome&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> admin = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ly&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">user.myFun.call(admin, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;welcome&quot;</span>); <span class="comment">//&#x27;hello ly welcome&#x27;</span></span><br><span class="line">user.myFun.apply(admin, [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;welcome&quot;</span>]); <span class="comment">//&#x27;hello ly welcome&#x27;</span></span><br><span class="line">user.myFun.bind(admin, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;welcome&quot;</span>)(); <span class="comment">//&#x27;hello ly welcome&#x27;</span></span><br></pre></td></tr></table></figure>

<p>由此区别就出来了:</p>
<ul>
<li>bind 使用后返回的是一个函数,因此需要加个括号调用;</li>
<li>apply 和 call 在不传参时完全没区别;但是需要传递参数时,apply 传参是数组,而 call 是由逗号分隔的一个个参数<br>总结一下:</li>
<li>这三个都是<strong>对函数使用的</strong>,用于绑定函数内部 this 指向的方法</li>
<li>call 和 apply 只在传参上有区别,使用时相当于直接执行了函数;而 bind 是返回一个函数,可以 bind 之后用变量接住再调用</li>
</ul>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>例子 3:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    alert(<span class="string">`Hello, <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span>!`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">setTimeout</span>(user.sayHi, <span class="number">1000</span>); <span class="comment">// Hello, undefined!</span></span><br></pre></td></tr></table></figure>

<p>这是一种常见的 this 指向丢失,原因是浏览器中的 setTimeout 方法有些特殊：它为函数调用设定了 <code>this=window</code>;使用时函数和对象分离开了(一般直接调用不会出现这个问题)<br>所以可以这样:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = user.sayHi.bind(user);</span><br><span class="line"><span class="built_in">setTimeout</span>(f, <span class="number">1000</span>); <span class="comment">//hello,John!</span></span><br></pre></td></tr></table></figure>

<h3 id="bind-的特点"><a href="#bind-的特点" class="headerlink" title="bind 的特点"></a>bind 的特点</h3><p>bind 可以绑定一个上下文和若干个参数，返回绑定后的结果，并不会直接调用。<br>bind 有几个特点：</p>
<ol>
<li>bind 是“硬绑定”，一旦 bind 了一个对象，后续调用无论<code>.</code>前面是谁都不会变。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>); <span class="comment">// ?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">g</span>: f.bind(<span class="literal">null</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.g(); <span class="comment">//null，即bind绑定的</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>一个函数不能被重绑定，一次 bind 之后不能再次 bind 给其他上下文</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  clg(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f = f.bind(&#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;).bind(&#123; <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">f(); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>

<h4 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h4><p>bind 不仅可以绑定 this，还可以绑定参数。所谓绑定参数大概是这个意思：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> double = mul.bind(<span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> triple = mul.bind(<span class="literal">null</span>, <span class="number">3</span>);</span><br><span class="line">double(<span class="number">2</span>); <span class="comment">//4</span></span><br><span class="line">triple(<span class="number">3</span>); <span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<p>可以看到通过 bind 把两个参数其中之一绑定为 2 或 3，后续只需要一个参数就可以；</p>
<blockquote>
<p>偏函数应用程序（partial function application） —— 通过绑定先有函数的一些参数来创建一个新函数。</p>
</blockquote>
<p>但是 bind 必须传入一个上下文；这里用不到 this，所以直接传入 null。</p>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>当一个函数被使用 new 操作符执行时，它按照以下步骤：</p>
<ol>
<li>创建一个新的空对象，并让 this 指向这个新对象。</li>
<li>函数体执行。通常它会修改 this，为其添加新的属性。</li>
<li>返回 this 的值。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this = &#123;&#125;;（隐式创建）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加属性到 this</span></span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.isAdmin = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return this;（隐式返回）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以 <code>new User(&quot;Jack&quot;)</code> 的结果是相同的对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">  <span class="attr">isAdmin</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数和-new"><a href="#构造函数和-new" class="headerlink" title="构造函数和 new"></a>构造函数和 new</h3><p>默认情况下，所有函数都有 <code>F.prototype = &#123;constructor：F&#125;</code>，即每个函数都有一个指向自身的<code>constructor</code>。</p>
<p>如果一个函数类似这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myConst</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以让他绑定一个对象调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myConst</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">myConst.call(obj, <span class="string">&quot;zzx&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//&#123;name:&#x27;zzx&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>因此，如果有一个方法可以给这个函数传入一个空对象，并且返回，就可以实现所谓的“构造”<br>这个方法就是 new：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myConst</span>(<span class="params">name <span class="comment">/*,context=&#123;&#125;*/</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//this = context</span></span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="comment">//return context</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> myConst(<span class="string">&quot;xiaoMing&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上，因为每个函数都有 constructor，所以每个函数都可以被构造<br>new 调用的不是函数本身，是函数的<code>prototype</code>属性上的<code>constructor</code>，而<code>constructor</code>一般指向自身，因此最后还是调用自己，但是前提是必须得有<code>constructor</code>（这也是箭头函数不能 new 的原因之一）<br>new 在调用过程中传入一个空对象、进行绑定、调用该函数并最后返回值<br>因此构造函数能构造的关键不是函数，而是 new</p>
</blockquote>
<h3 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a><code>new.target</code></h3><p>在一个函数内部，可以使用 <code>new.target</code> 属性来检查它是否被使用 new 进行调用了。<br>对于常规调用，它为 undefined，对于使用 new 的调用，则等于该函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  clg(<span class="keyword">new</span>.target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不带 &quot;new&quot;：</span></span><br><span class="line">User(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带 &quot;new&quot;：</span></span><br><span class="line"><span class="keyword">new</span> User(); <span class="comment">// function User &#123; ... &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="构造函数的-return"><a href="#构造函数的-return" class="headerlink" title="构造函数的 return"></a>构造函数的 return</h3><ul>
<li>如果 return 返回的是一个对象，则返回这个对象，而不是 this。</li>
<li>如果 return 返回的是一个原始类型，则忽略。</li>
</ul>
<p>比如这个例子中由于 A 和 B 函数都返回 obj，因此两者 new 出来的实例是相同的，都是 obj 变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clg(<span class="keyword">new</span> A() == <span class="keyword">new</span> B()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这也就是在手写 new 的时候，需要判断构造函数是否显式返回了一个值，如果返回就采用这个返回值而不是创建的对象。</p>
<h2 id="防抖和节流-1"><a href="#防抖和节流-1" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><blockquote>
<p>函数防抖，就是指触发事件后，在 n 秒后只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数的执行时间。当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时.</p>
</blockquote>
<p>也就是说,一个动作连续触发但是只执行最后一次<br>上代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timeout = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">  timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fn;</span><br><span class="line">  &#125;, wait);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;事件触发&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 滚动事件</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;scroll&quot;</span>, debounce(handle, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>

<p>这段代码意思是:滚动停止后 1000 毫秒才会触发 handle.思路就是:在 debounce 函数里边设置一个定时器,当触发函数时不立即执行 fn,而是等 wait 秒后再执行;而如果调用时不停下来,<strong>就会反复清除定时</strong>,直到停下来为止再开始算<br>更好的方法是写成装饰器形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面相同</span></span><br></pre></td></tr></table></figure>

<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><blockquote>
<p>每隔一段时间只执行一次函数</p>
</blockquote>
<p>就是说,判断两次操作间隔大于一定时间再执行(比如说一直拖着进度条就每一秒触发一次),所以可以有 两次时间戳相减 或 定时器 这两种实现方案</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间戳实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">if</span> (now - pre &gt; wait) &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      pre = now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;事件触发&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;scroll&quot;</span>, throttle(handle, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时器实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> isWait = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isWait) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      isWait = <span class="literal">true</span>; <span class="comment">//在间隔期把入口卡住</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        isWait = <span class="literal">false</span>;</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//剩下一样</span></span><br></pre></td></tr></table></figure>

<p>解释一下定时器实现:首先 isWait 函数可以进入第一次触发;一旦进入 else 就把 isWait 改成 true,这样就是在定时器计时期间不再有任何可以进入 else 分支;定时器计时完毕,isWait 改为 false,又可以进入了.所以如果一直触发节流,相当于每个 wait 间隔期间就不会触发,而过了间隔期就允许触发</p>
<h2 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次<strong>重绘</strong>之前执行。<br><code>requestAnimationFrame()</code> 运行在后台标签页或者隐藏的<code>&lt;iframe&gt;</code> 里时会被暂停调用。<br>回调函数会被传入<code>DOMHighResTimeStamp</code>参数，也就是通过<code>performance.now()</code>获取的参数，表示 <code>requestAnimationFrame()</code> <strong>开始去执行回调函数的时刻</strong>。<br>这是一个比<code>Date.now()</code>更精确的时间戳（微秒级）；同一个帧的多个回调函数会被赋予相同的时间戳</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p><code>requestAnimationFrame</code>（后面简称 rAF）的使用和<code>setTimeout</code>的递归调用类似。<br>比如这是一个使用 setTimeout 的简单动画：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> times = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  block.style.transform = <span class="string">`translateX(<span class="subst">$&#123;times++&#125;</span>px)`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (times &lt; <span class="number">500</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      animation();</span><br><span class="line">    &#125;, <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(animation, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>rAF 和它的原理类似，在函数内部递归调用该函数；但是 rAF 的回调会自动传入一个表示开始运行时间戳的变量（即<code>performance.now()</code>），这个值每次递归调用都会发生变化；因此可以利用该值（timeStamp）和最开始的时间（start）的差值，来确定渲染时间（<code>interVal &lt; 2000</code>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> start = performance.now();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params">timeStamp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> interVal = timeStamp - start;</span><br><span class="line">  block.style.transform = <span class="string">`translateX(<span class="subst">$&#123;interVal * <span class="number">0.1</span>&#125;</span>px)`</span>;</span><br><span class="line">  <span class="keyword">if</span> (interVal &lt; <span class="number">2000</span>) requestAnimationFrame(animate);</span><br><span class="line">&#125;</span><br><span class="line">requestAnimationFrame(animate);</span><br></pre></td></tr></table></figure>

<p>常用的方法是，把这个函数封装成更通用的函数，参数主要有三个：</p>
<ul>
<li>timing 函数，即动画时序函数，是一个数学意义上的“函数”，可以修改这个函数来改变动画的运行方式</li>
<li>duration：持续时间</li>
<li>draw：渲染函数，一般是修改 style</li>
</ul>
<p>范例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params">&#123; timing, draw, duration &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> start = performance.now(); <span class="comment">//初始时间</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">animation</span>(<span class="params">timeStamp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeFraction = (timeStamp - start) / duration; <span class="comment">//(当前时间 - 初始时间)/总时间，相当于进度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeFraction &gt; <span class="number">1</span>) timeFraction = <span class="number">1</span>; <span class="comment">//进度不能大于100%</span></span><br><span class="line">    <span class="keyword">let</span> progress = timing(timeFraction); <span class="comment">//时序函数处理进度</span></span><br><span class="line"></span><br><span class="line">    draw(progress); <span class="comment">//根据进度绘制函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeFraction &lt; <span class="number">1</span>) requestAnimationFrame(animation); <span class="comment">//进度&lt;1，递归调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  requestAnimationFrame(animation); <span class="comment">//注意这里调用的是内部这个函数，外部的函数只起到传递参数的作用。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timing = <span class="function">(<span class="params">timeFraction</span>) =&gt;</span> timeFraction;</span><br><span class="line"><span class="keyword">const</span> draw = <span class="function">(<span class="params">progress</span>) =&gt;</span> &#123;</span><br><span class="line">  block.style.transform = <span class="string">`translateX(<span class="subst">$&#123;progress * <span class="number">500</span>&#125;</span>px)`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> duration = <span class="number">5000</span>;</span><br><span class="line">animate(&#123; timing, draw, duration &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="时序函数"><a href="#时序函数" class="headerlink" title="时序函数"></a>时序函数</h3><p>时序函数实际上就是对进度的特殊处理。<br>上面的例子原封不动返回，相当于是个正比例函数，运动是匀速的。<br>如果改成返回一个 2 次幂，就是一个初速度为 0 的匀加速运动：<br><img src="https://pic.imgdb.cn/item/622ec4a35baa1a80aba5ba14.jpg"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timing = <span class="function">(<span class="params">time</span>) =&gt;</span> time ** <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>其他时序函数：<a target="_blank" rel="noopener" href="https://zh.javascript.info/js-animation">https://zh.javascript.info/js-animation</a></p>
<h2 id="函数参数更改影响原变量的问题"><a href="#函数参数更改影响原变量的问题" class="headerlink" title="函数参数更改影响原变量的问题"></a>函数参数更改影响原变量的问题</h2><p>如果参数是基本数据类型，函数内的参数实际上是该数据的复制，并不会影响原变量；<br>如果参数是引用数据类型，参数实际上是该变量的地址，因此修改该变量会影响原变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">b</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">a,obj</span>)</span>&#123;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">    obj.b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">change(a,obj)</span><br><span class="line"><span class="built_in">console</span>.log(a,obj)<span class="comment">// 1  &#123;b:1&#125;</span></span><br></pre></td></tr></table></figure>

<p>换句话说，基本数据类型内部作用域下的改变不会影响外部作用域，但是引用数据类型由于持有的是同一个地址，因此会影响。</p>
<h2 id="原始数据不可变"><a href="#原始数据不可变" class="headerlink" title="原始数据不可变"></a>原始数据不可变</h2><blockquote>
<p>所有基本类型的值都是<strong>不可改变的</strong>。但需要注意的是，基本类型本身和一个赋值为基本类型的变量的区别。变量会被赋予一个新值，而原值不能像数组、对象以及函数那样被改变。</p>
</blockquote>
<p>MDN 上的描述，所有的原始类型数据都是不可改变的。但是不可改变并不意味着持有该数据的变量不可改变，只是说这个数据本身不能改，当改动变量时实际上是给这个变量重新赋值。也就是说，<strong>基本类型值可以被替换，但不能被改变</strong>；改变的只是变量持有的值，而不是这个值本身</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> = <span class="number">2</span> <span class="comment">// 无效，原始数据不能改动</span></span><br><span class="line"><span class="string">&#x27;hello&#x27;</span> = <span class="string">&#x27;world&#x27;</span> <span class="comment">//同理</span></span><br><span class="line"><span class="string">&#x27;hello&#x27;</span>[<span class="number">0</span>] = <span class="string">&#x27;w&#x27;</span> <span class="comment">// 同理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">a + <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1 ,直接改变原数据无效</span></span><br><span class="line"></span><br><span class="line">a = a + <span class="number">1</span> <span class="comment">// 2 , 改变的是变量的值，而不是 1 这个数字本身</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对应的，引用数据类型（Object）是可以改变的。可以把<code>Object</code>想象成一个盒子，我们可以向盒子内部装各种东西，改变盒子内部就会导致改变这个盒子的状态（虽然盒子本身并没有改变）</p>
<h2 id="和-amp-amp-的返回值"><a href="#和-amp-amp-的返回值" class="headerlink" title="|| 和 &amp;&amp; 的返回值"></a>|| 和 &amp;&amp; 的返回值</h2><p>当符号两边是<code>true</code>或<code>false</code>时，返回值也是 boolean 值，会按照<code>与</code>和<code>或</code>返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> || <span class="literal">false</span>; <span class="comment">//true</span></span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="literal">false</span>; <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &gt; <span class="number">2</span> || <span class="number">2</span> == <span class="string">&quot;2&quot;</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>当符号两边有一个是其他类型的值，就会返回两个值的中的一个。<br>原则是，<code>||</code>会在前值为假时返回后值，<code>&amp;&amp;</code>会在前值为真时返回后值，其余都是返回前值，<strong>这种情况下返回的是具体的值，而不是布尔值</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span> || <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="string">&quot;&quot;</span> &amp;&amp; <span class="number">1</span>; <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="literal">true</span> || <span class="number">1</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果比较的一方是<code>undefined</code>或者<code>null</code>，则虽然这两者都为<code>falsy</code>，但是仍不会返回布尔值，而是可能返回<code>undefined</code>或者<code>null</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> || <span class="literal">undefined</span>; <span class="comment">// undefined</span></span><br><span class="line"><span class="literal">null</span> &amp;&amp; <span class="literal">undefined</span>; <span class="comment">// null</span></span><br><span class="line"><span class="literal">undefined</span> &amp;&amp; <span class="literal">undefined</span>; <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>因此通过这种方式给变量赋值时，一定要保证符号两边都是确定的值，而不要是<code>undefined</code>，否则可能导致结果并不是想要的布尔值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getRequest = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> truthy;</span><br><span class="line">  <span class="keyword">let</span> falsy;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟异步请求</span></span><br><span class="line">    truthy = <span class="literal">true</span>;</span><br><span class="line">    falsy = <span class="literal">false</span>;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  display(truthy, falsy);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> display = <span class="function">(<span class="params">truthy, falsy</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = truthy &amp;&amp; falsy;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getRequest(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="for-循环和-let、var"><a href="#for-循环和-let、var" class="headerlink" title="for 循环和 let、var"></a>for 循环和 let、var</h2><h3 id="同步情况"><a href="#同步情况" class="headerlink" title="同步情况"></a>同步情况</h3><p>看一个最简单的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// ReferenceError: i is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(j); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>for 循环会产生多个块级作用域，每一次循环都会产生一个块；另外 for 循环的括号中是高于循环产生的块、但低于外部的作用域。</p>
<p>let 存在块作用域，因此每个<code>i</code>单独保存，每个块中的 i 独立，不会影响其他块中的 i。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//let</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// i is not defined</span></span><br></pre></td></tr></table></figure>

<p>var 不存在块作用域，因此所有的<code>i</code>都是在一个 for 内部</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* var i = undefined; */</span></span><br><span class="line">&#123;</span><br><span class="line">  i = <span class="number">0</span>; <span class="comment">// i会被变量提升到外层</span></span><br><span class="line">  i++; <span class="comment">// 没有块级作用域</span></span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>另外，for 循环是“不满足退出”，因此最后的值一定是不满足条件的值。比如条件是<code>i &lt; 2</code>，那么输出值就会是第一个不满足条件的（即<code>i</code>为 2），而不是<code>i</code>等于 1</p>
<h3 id="异步情况"><a href="#异步情况" class="headerlink" title="异步情况"></a>异步情况</h3><p>一个很经典的题目是在 for 循环中启动定时器打印<code>i</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：一秒后同时输出 <code>0 1 2 2</code></p>
<p>setTimeout 会被放入定时器线程，而同步线程的 for 循环则会被先执行完。因此当共计 4 个回调函数开始执行时，for 循环已经被执行完成了</p>
<p>按照块分解如下：</p>
<p>let 定义的<code>i</code>会被依次放入每个任务中，因为循环产生的块会持有自己的<code>i</code>；每个<code>i</code>是块中自己维护的，初始值为 0，不会影响其他块中的<code>i</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1000</span>);</span><br><span class="line">    i++; <span class="comment">//这个i是这个块中自己维护的，初始值为0，不会影响其他块中的i</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1000</span>);</span><br><span class="line">    i++; <span class="comment">//这个i是这个块中自己维护的，初始值为1，不会影响其他块中的i</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> i_first = i; <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i_first), <span class="number">1000</span>);</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> i_second = i; <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i_second), <span class="number">1000</span>);</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>var 定义的变量在<code>setTimeout</code>内部引用时相当于外部 <code>var i</code> 的闭包；因此在 for 内部更改 i，会导致<code>setTimeout</code>的<code>i</code>闭包值改变</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="literal">undefined</span>;</span><br><span class="line">&#123;</span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  i++;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1000</span>); <span class="comment">//这里的i是外部 `var i` 的闭包</span></span><br><span class="line">  i++;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在 for 执行之后再对<code>i</code>进行操作，可以看到定时器中的<code>i</code>也改变了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1秒后输出2次3</span></span><br></pre></td></tr></table></figure>

<hr>
<p>对于var导致的问题，解决方法除了使用let之外还有几种：</p>
<ol>
<li>利用IIFE(立即执行函数表达式)，每次for循环都是创建一个立即调用函数并传入当前i作为参数。这样每个调用就独立，外部的i改变不会影响传入的i<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i &lt;= <span class="number">5</span>;i++)&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="literal">undefined</span>;</span><br><span class="line">&#123;</span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  i++;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;)(i) <span class="comment">// 1</span></span><br><span class="line">  i++;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;)(i) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>利用setTimeout第三个参数，把变量传入。原理和上面差不多<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(j)</span><br><span class="line">  &#125;, <span class="number">0</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a><code>valueOf</code></h2><p>这个方法很少会用到；<br>当把一个对象转化为原始数据类型时，会调用对象上的该方法。默认调用的是<code>Object.prototype.valueOf()</code>方法，但是如果对象内部重写了该方法，会返回重写方法的返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + obj); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>调用对象 valueOf 方法的情况有：</p>
<ol>
<li>原始类型和该对象进行运算（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>、<code>**</code>）</li>
<li>用<code>==</code> / <code>&gt;=</code> / <code>&lt;=</code> / <code>&gt;</code> / <code>&lt;</code>把对象和原始数据类型进行比较</li>
</ol>
<h2 id="类的静态方法"><a href="#类的静态方法" class="headerlink" title="类的静态方法"></a>类的静态方法</h2><p>静态方法属于类本身，因此 class 的方法里，前面有 static，那么方法里的 this 是<strong>类本身</strong>；前面没有 static，那么方法里的 this 是类的实例化对象；<br>因此静态方法只能通过类本身调用，不能通过实例调用<br>另外静态方法允许和一般方法重名，因为他们所挂载的对象完全不一样。</p>
<h2 id="let-和-const-的暂时性死区-TDZ"><a href="#let-和-const-的暂时性死区-TDZ" class="headerlink" title="let 和 const 的暂时性死区(TDZ)"></a>let 和 const 的暂时性死区(TDZ)</h2><p>let 和 const 存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。<br>并且，一个块中如果已经有了 let 或 const 声明的变量，就不会再理会外部的同名变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  a = <span class="number">2</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="comment">/* 这一行之前的块内部都是暂时性死区 */</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不可引用不止是赋值操作，<code>typeof</code>/<code>instanceof</code>以及任何其他相关作为参数的操作都不可以，即只要出现就是错误的。</p>
</blockquote>
<p>原理在于，let 和 const 虽然不会像 var 一样变量提升，但是仍会在 js 解释阶段（即创建作用域阶段）先创建出该变量，然后在执行到正式声明那一行才可以使用。</p>
<h2 id="html-页面生命周期"><a href="#html-页面生命周期" class="headerlink" title="html 页面生命周期"></a>html 页面生命周期</h2><p>基本生命周期顺序如下：</p>
<ol>
<li><code>script</code>：解析同步 js 脚本；如果 js 放在页面最下部，这一步将延迟到<code>DOMContentLoaded</code>之后执行</li>
<li><code>readyState</code>：允许通过此事件监听 dom 加载状态，有三种情况；此时可能是<code>interactive</code>或<code>loading</code><ul>
<li><code>interactive</code>：准备加载</li>
<li><code>loading</code>：加载中</li>
<li><code>complete</code>：加载完成，会在后面触发</li>
</ul>
</li>
<li><code>DOMContentLoaded</code>：DOM 加载事件，触发时浏览器已完全加载 HTML，并构建了 DOM 树，但像 <code>&lt;img&gt;</code> 和样式表之类的外部资源可能尚未加载完成。该事件只能通过<code>addEventListener</code>捕获。</li>
<li><code>image onload</code>/<code>iframe onload</code>/<code>style onload</code>：加载上一步没有加载出来的外部资源，触发比如安置在<code>&lt;img&gt;</code>元素上的<code>onload</code>事件</li>
<li><code>readyState</code>: complete，即此时所有文档和资源都已经加载完成</li>
<li><code>window onload</code>：加载完成，此时已经完成了所有的加载工作，即启动的生命周期已经结束</li>
<li><code>beforeunload</code>：用户正在离开：我们可以检查用户是否保存了更改，并询问他是否真的要离开。</li>
<li><code>unload</code>：用户几乎已经离开了，但是我们仍然可以启动一些操作，例如发送统计数据。</li>
</ol>
<p>解释如下：</p>
<ol>
<li><p>script 同步的 JavaScript 脚本最先执行，它先于<code>DOMContentLoaded</code>事件执行。</p>
</li>
<li><p>此时可以通过<code>onreadystatechange</code>事件监听 document 的状态，会有三种状态；因此它在 Dom 准备前、js 同步脚本执行后就触发</p>
</li>
<li><p>当 DOM 准备就绪时，<code>DOMContentLoaded</code>事件在 document 上触发。 我们可以在这个阶段利用 JavaScript 来操作 DOM 元素。</p>
</li>
<li><p>所有脚本都执行完毕，除了那些外部使用异步（async）或延迟（defer）加载的脚本，图片和其他资源可能仍在载入过程中。</p>
</li>
<li><p>window 上的 onload 事件，在页面加载完所有资源后触发。 我们很少使用它，因为通常的操作不用等到最后才执行。</p>
</li>
</ol>
<p><code>document.readyState</code>表示文档的当前状态，可以在<code>onreadystatechange</code>事件中跟踪文档状态的变更。</p>
<ul>
<li><code>loading</code> – 文档正在载入。</li>
<li><code>interactive</code> – document 已经解析完毕时触发，几乎与<code>DOMContentLoaded</code>同时发生，但在<code>DOMContentLoaded</code>事件之前触发。</li>
<li><code>complete</code> – 文档和资源加载完成时触发，几乎与<code>window.onload</code>同时发生，但在<code>onload</code>事件之前触发。<br>一般来说，大多数的操作我们都应该放在 DOMContentLoaded 事件中执行，而不要放在 window.onload 中执行。</li>
</ul>
<p>当用户离开页面时，会触发后两个事件：</p>
<ul>
<li>window 上的<code>beforeunload</code>事件，该事件在用户准备离开页面，在<code>unload</code>事件之前触发。 如果<code>beforeunload</code>返回一个字符串，浏览器会给出用户是否真的想离开的提示。</li>
<li>window 上的<code>unload</code>事件，当用户最终离开时会触发该事件。在<code>unload</code>的事件处理程序中，我们只能做简单的事情，不涉及延迟或询问用户。由于这个限制，它很少使用。</li>
</ul>
<h2 id="js-全局对象"><a href="#js-全局对象" class="headerlink" title="js 全局对象"></a>js 全局对象</h2><p>js 中全局对象有两个概念：</p>
<ol>
<li>是指用户定义在<strong>全局作用域</strong>下的对象，即<code>var</code>定义的变量或者通过<code>function xxx()</code>定义的函数，会被自动挂载到 window 上；挂载之后可以通过<code>window.xx</code>或者<code>this</code>访问到。</li>
<li>js 的<strong>标准内置对象</strong>，并不是用户定义的，而是相当于 js 自带的一些对象和方法。实际上全局作用域包含内置对象</li>
</ol>
<p>标准内置对象很多，可以参考<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects</a><br>这里说几个主要的：</p>
<ol>
<li>内置方法，可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。</li>
</ol>
<ul>
<li><code>eval()</code></li>
<li><code>uneval()</code></li>
<li><code>isFinite()</code></li>
<li><code>isNaN()</code></li>
<li><code>parseFloat()</code></li>
<li><code>parseInt()</code></li>
<li><code>decodeURI()</code></li>
<li><code>decodeURIComponent()</code></li>
<li><code>encodeURI()</code></li>
<li><code>encodeURIComponent()</code></li>
<li>以及已废弃的<code>escape()</code>和<code>unescape()</code></li>
</ul>
<ol start="2">
<li>基本值属性，即：</li>
</ol>
<ul>
<li><code>Infinity</code></li>
<li><code>NaN</code></li>
<li><code>undefined</code></li>
<li><code>globalThis</code></li>
</ul>
<ol start="3">
<li>大多数不用定义直接引用的内置对象，比如所有数据类型的包装对象（<code>Number</code>、<code>Array</code>等），错误对象，ES6 新增的对象（<code>Promise</code>、<code>Reflect</code>、<code>Proxy</code>、<code>Map</code>、<code>Set</code>等）等。</li>
</ol>
<blockquote>
<p>注意，还有很多能直接使用的但是并非 js 内置对象，而是被挂载到了<code>window</code>上的。详见<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window">https://developer.mozilla.org/zh-CN/docs/Web/API/Window</a><br>常用的 window 上对象主要有：</p>
<ul>
<li><code>setTimeout/setInterval</code></li>
<li>console</li>
<li>alert</li>
<li><code>requestAnimationFrame</code></li>
<li><code>xhr</code>和<code>fetch</code></li>
<li>所有窗口大小相关的属性，比如<code>innerHeight</code>等</li>
</ul>
<p>基本上可以理解为，直接引用的对象除了 js 内置对象，基本都在 window 上。</p>
</blockquote>
<h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>delete 操作符用于删除对象的某个属性，不能被删除的特例有：</p>
<ul>
<li><strong><code>var</code>, <code>let</code>以及<code>const</code>创建的变量</strong></li>
<li>设置了<code>configurable:false</code>的属性</li>
<li>内置对象，不管是 window 提供的还是 js 内置的</li>
</ul>
<p>会被删除的除了对象属性，还有几个特例：</p>
<ul>
<li>非严格模式下未声明直接使用的变量，由于会被挂载到 window 上，因此会被直接删除</li>
<li><code>eval</code>中声明的变量</li>
<li>数组中的元素，删除后数组<code>length</code>并不改变，被删除的一项仍保留索引，但是值为<code>undefined</code>；</li>
</ul>
<blockquote>
<p>关于 delete 的返回值，对于所有情况都是 true，除非属性是一个自身的 不可配置的属性，在这种情况下，非严格模式返回 false，严格模式会报错</p>
</blockquote>
<h2 id="三种函数定义方式区别"><a href="#三种函数定义方式区别" class="headerlink" title="三种函数定义方式区别"></a>三种函数定义方式区别</h2><ol>
<li>函数声明，又叫函数语句；创建的函数是一个 Function 对象，具有 Function 对象的所有属性、方法和行为。<br>被声明的函数具有变量提升，可以在函数声明之前使用该函数；</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这种函数没有块级作用域，因此在条件或循环等块中声明依旧会被提升，但是不能使用。</p>
<p>并且，函数声明的提升优先级大于变量提升；也就是说如果前面还有一个同名的变量，函数声明将会覆盖它（let 和 const 不行，因为实际上 a 已经被声明到了前面，不能重复声明）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a(); <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a;</span><br><span class="line">a(); <span class="comment">// a is already been declared</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>MDN：<br>这种声明方式在不同的浏览器里可能有不同的效果。因此，不应该在生产环境代码中使用这种声明方式，应该使用函数表达式来代替。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// foo is not a function</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改成true是完全一样的</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>函数表达式，即声明一个变量是函数；函数表达式不会提升，所以不能在定义之前调用。<br>从声明角度，函数表达式可以用<code>var</code>或<code>let/const</code>定义；这两种方式的主要区别仍是在块级作用域上，但在执行到该语句之前变量都是<code>undefined</code>，都不能使用。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a(); <span class="comment">//a is not a function</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">a(); <span class="comment">//a is not a function</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// a is not defined</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，上面说到函数语句方式定义的函数，无论条件语句是 true 还是 false 都一样，都不会被提升；<br>这点使用函数表达式也是一样，只是不会有浏览器差异，结果一律都是 undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Error: a is not defined</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，这种定义方式都会把函数名直接和变量名统一，即不在<code>function</code>后再加名称；<br>加上也可以，被加上的函数名只能用于递归引用，不能在外调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Myfunc = <span class="function"><span class="keyword">function</span> <span class="title">YourFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  YourFunc();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">YourFunc(); <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>构造函数创建，即<code>new Function()</code>，语法：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>([arg1, arg2, ...argN], functionBody);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;return a + b&quot;</span>);</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该方法可以从字符串变为函数，几乎用不到；<br>这种方法创建的函数不能作为闭包，它内部的 outer 一定指向全局：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;alert(value)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> func;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFunc()(); <span class="comment">// error: value is not defined</span></span><br></pre></td></tr></table></figure>

<h2 id="函数参数作用域"><a href="#函数参数作用域" class="headerlink" title="函数参数作用域"></a>函数参数作用域</h2><p>函数有形参，形参会被添加到函数的作用域中，并且形参不会被重新定义（用 var 声明与形参同名的变量会被忽略，用 let 声明会报错），如果函数内声明一个和形参同名的函数，则内部声明的函数会覆盖参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">arg1, arg2, arg3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arg1; <span class="comment">// 声明被忽略</span></span><br><span class="line">  <span class="keyword">var</span> arg2 = <span class="string">&quot;hello&quot;</span>; <span class="comment">// var arg2 声明被忽略，arg2 = &quot;hello&quot; 被执行</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">arg3</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 函数声明会覆盖参数</span></span><br><span class="line">  <span class="built_in">console</span>.log(arg1, arg2, arg3);</span><br><span class="line">&#125;</span><br><span class="line">fun(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 1 &quot;hello&quot; [ƒ arg3() &#123;&#125;]</span></span><br></pre></td></tr></table></figure>

<p>实际上函数的参数是一个高于函数内部、低于外部的独立作用域，在函数被执行（传入具体参数）时确立其具体值</p>
<p>如果参数有默认值，则参数还会形成一个单独的作用域；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">x, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里的y默认值x会先从参数作用域中查找，即x是另一个参数，因此是2</span></span><br><span class="line">  <span class="built_in">console</span>.log(y); <span class="comment">// y === 2</span></span><br><span class="line">&#125;</span><br><span class="line">fun(<span class="number">2</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 内部作用域没有x，从外部找到x = 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(y); <span class="comment">// y === 1</span></span><br><span class="line">&#125;</span><br><span class="line">fun(<span class="number">2</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 默认参数和普通的参数一样，都是值的引用 */</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">x, y = x</span>) </span>&#123;</span><br><span class="line">  y.a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// &#123;a: 3&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">fun(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;a: 3&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果默认参数是函数，则这个函数相当于在参数作用域内部，和变量的情况是一致的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="string">&quot;outer&quot;</span>;</span><br><span class="line"><span class="comment">// 默认参数函数中的foo会从参数作用域先寻找，找到了foo变量为&#x27;other&#x27;，并且现在它是一个闭包</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">foo, func = () =&gt; foo</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(func());</span><br><span class="line">&#125;</span><br><span class="line">bar(<span class="string">&quot;other&quot;</span>); <span class="comment">// other</span></span><br></pre></td></tr></table></figure>


<h2 id="会改变原数组和不改变的数组方法"><a href="#会改变原数组和不改变的数组方法" class="headerlink" title="会改变原数组和不改变的数组方法"></a>会改变原数组和不改变的数组方法</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904192671219719">https://juejin.cn/post/6844904192671219719</a></p>
<h2 id="import-和-export-default"><a href="#import-和-export-default" class="headerlink" title="import * 和 export default"></a><code>import *</code> 和 <code>export default</code></h2><p>当使用<code>import *</code>导入另一个模块中的全部导出变量时，会将所有导出的变量都合并为一个对象。比如下面的导出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// info.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">&quot;I love JavaScript&quot;</span>;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> info <span class="keyword">from</span> <span class="string">&quot;./info&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(info);</span><br></pre></td></tr></table></figure>

<p>输出是这样的：<br><img src="https://pic.imgdb.cn/item/624a58e3239250f7c57ac84a.jpg"></p>
<p>因此可以通过<code>info.xxx</code>来获取具体的导出值，甚至可以通过<code>info.default</code>获取默认导出值。<br>还可以通过在具名导入中用<code>as</code>获取默认导出的值：<br>实际上<code>default</code>只是导出对象的一个特殊属性，只是不能显式使用而已。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// info.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">&quot;I love JavaScript&quot;</span>;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> string, name, age &#125; <span class="keyword">from</span> <span class="string">&quot;./info&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string); <span class="comment">// &quot;I love JavaScript&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<p>并且默认导出和具名导出也是可以共存的。<br>还是上面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// info.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">&quot;I love JavaScript&quot;</span>;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> string <span class="keyword">from</span> <span class="string">&quot;./info&quot;</span>; <span class="comment">// &quot;I love JavaScript&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age &#125; <span class="keyword">from</span> <span class="string">&quot;./info&quot;</span>; <span class="comment">// &quot;Lydia&quot; 21</span></span><br></pre></td></tr></table></figure>

<p>唯一的限制是，一个模块只能有一个默认导出</p>
<h2 id="细碎知识点"><a href="#细碎知识点" class="headerlink" title="细碎知识点"></a>细碎知识点</h2><ol>
<li><code>var a = b = xxx</code>形式的赋值，会导致除了第一个之外其他变量都变成全局变量（比如这里的 b）</li>
<li><code>let</code>在全局作用域下声明的变量不会挂载到 window 上，但是<code>var</code>会</li>
<li>函数的<code>arguments</code>属性是一个<strong>可迭代对象</strong>，并不是一个数组，因此没有数组方法，但是拥有<code>length</code>属性；此外可以通过<code>Array.from</code>把他变成一个真正的数组，或者直接使用<code>[...arguments]</code>展开</li>
<li>this 绑定优先级：<code>new</code>绑定优先级 &gt; 显式绑定（<code>call</code> <code>bind</code> <code>apply</code>）优先级 &gt; 隐式绑定（对象调用）优先级 &gt; 默认绑定优先级</li>
<li><code>let</code>和<code>const</code>不能对变量重复声明，这一点不仅体现在自己不能重复声明自己，也体现在不能声明<code>var</code>声明过的变量和同名函数</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li><code>call(null)</code>或<code>call(undefined)</code>都会将 this 指向 window（严格模式是 undefined）；<code>apply</code>和<code>bind</code>也一样</li>
<li>如果使用<code>clearTimeout</code>清除定时器，已放入宏任务队列或者还在等待的回调都会被清除不再执行。</li>
<li>在<code>==</code>中，<code>null</code> 和 <code>undefined</code> 除了和彼此比较以外，与其他任何类型操作数进行相等性测试都为 false</li>
<li><code>class</code>和<code>let/const</code>一样都有暂时性死区和块级作用域，都不能提升。</li>
<li><code>import</code>引入的变量是只读的，对于基本类型来说，不能修改值，修改会报只读的错误（相当于<code>const</code>）；但是引用类型可以修改，并且修改会引起源对象的值也发生改变。</li>
<li>类中可以通过<code>#xxx</code>添加私有变量，在外部不可访问；注意这是确实存在的语法，而不是一种约定，当试图在外修改时会报错。同理 static 也是确实可以添加的静态字段和，而不只是一个约定</li>
<li><code>Object.freeze()</code>可以对对象进行<strong>浅</strong>冻结（不能对值为对象的属性生效），不能对属性进行添加，修改，删除</li>
<li>可选链操作符<code>?.</code>不仅可以访问普通的对象属性，还可以通过<code>arr?.[i]</code>形式访问数组或变量形式值；或者通过<code>obj.someFunc?.()</code>调用可能不存在的函数。</li>
</ol>
<h2 id="关于对象中定时器不会被回收的问题"><a href="#关于对象中定时器不会被回收的问题" class="headerlink" title="关于对象中定时器不会被回收的问题"></a>关于对象中定时器不会被回收的问题</h2><p>这个问题来源于一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> config = &#123;</span><br><span class="line">  <span class="attr">alert</span>: <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>),</span><br><span class="line">&#125;;</span><br><span class="line">config = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>当 config 为 null 时，看起来 config 已经被回收了，但是定时器依旧每秒输出 1。<br>这个例子的原文下说的是“<code>setInterval</code>的参数是一个箭头函数（所以上下文绑定到对象 config 了），回调函数仍然保留着对 config 的引用”<br>但是这显然不对，因为替换成非箭头函数也是一样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> config = &#123;</span><br><span class="line">  <span class="attr">alert</span>: <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>),</span><br><span class="line">&#125;;</span><br><span class="line">config = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>甚至，根本就不是引用和垃圾回收的问题。当直接在对象的属性中调用一个函数时，即使只是在声明，都会直接调用该函数，并把返回值赋给这个属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> config = &#123;</span><br><span class="line">  <span class="attr">alert</span>: <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(config) <span class="comment">// &#123;alert: 158&#125; 这个值是Interval的id，显然是返回值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> config = &#123;</span><br><span class="line">  <span class="attr">alert</span>: <span class="built_in">console</span>.log(<span class="string">&quot;aaa&quot;</span>); <span class="comment">// aaa</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 即使没有config.alert，在定义时会直接执行 console.log</span></span><br></pre></td></tr></table></figure>

<p>这时把 config 设为 null 确实回收了 config，但是并没有清除定时器，依旧在运行。</p>
<h2 id="node-查找模块顺序"><a href="#node-查找模块顺序" class="headerlink" title="node 查找模块顺序"></a>node 查找模块顺序</h2><p><img src="https://pic.imgdb.cn/item/6248f91c27f86abb2a36aade.jpg"></p>
<p>查找优先级如下：</p>
<ol>
<li>缓存的模块优先级最高</li>
<li>如果是内置模块，则直接返回，优先级仅次缓存的模块；</li>
<li>如果是绝对路径 / 开头，则从根目录找</li>
<li>如果是相对路径 ./开头，则从当前 require 文件相对位置找</li>
<li>如果文件没有携带后缀，先从 js、json、node 按顺序查找</li>
<li>如果是目录，则根据 <code>package.json</code>的 main 属性值决定目录下入口文件，默认情况为 index.js</li>
<li>如果文件为第三方模块，则会引入 <code>node_modules</code> 文件，如果不在当前仓库文件中，则自动从上级递归查找，直到根目录</li>
</ol>
<blockquote>
<p>最后一步的查找优先级：<br>如果在<code>/home/ry/projects/foo.js</code>文件里调用了 <code>require(&#39;bar.js&#39;)</code>，则 Node.js 会按以下顺序查找：</p>
<ol>
<li><code>/home/ry/projects/node_modules/bar.js</code></li>
<li><code>/home/ry/node_modules/bar.js</code></li>
<li><code>/home/node_modules/bar.js</code></li>
<li><code>/home/node_modules/bar/index.js</code>；（如果上面不存在，说明可能是模块名错误，就会从默认按照 index.js 查找）</li>
<li><code>/node_modules/bar.js</code>，即总根目录下的模块</li>
</ol>
</blockquote>
<h2 id="shadowDOM"><a href="#shadowDOM" class="headerlink" title="shadowDOM"></a>shadowDOM</h2><p>shadowDOM是指浏览器内置的样式构建，通常对开发者是隐藏的；想要查看需要特别在浏览器的开发者工具中开启查看shadowdom</p>
<p>比如一个<code>&lt;input type=&quot;range&quot;&gt;</code>的内部样式实际上长这样：<br><img src="https://pic.imgdb.cn/item/628798110947543129722127.jpg"></p>
<p>这时浏览器为其内部定制的样式，不能通过js获取。类似的例子还有滚动条等</p>
<p>shadowDOM的特点：</p>
<ul>
<li>有自己独立的样式和dom，正常的css和js不能访问</li>
<li>只能通过在某个节点之下用<code>attachShadow</code>创建，并且可以选择是否挂载到shadow tree上。</li>
</ul>
<p>一个 DOM 元素可以有以下两类 DOM 子树：</p>
<ul>
<li>Light tree（光明树）：一个常规 DOM 子树，由 HTML 子元素组成。我们在之前章节看到的所有子树都是「光明的」。</li>
<li>Shadow tree（影子树）：一个隐藏的 DOM 子树，不在 HTML 中反映，无法被察觉。</li>
</ul>
<p>调用 <code>elem.attachShadow(&#123;mode: &#39;open&#39; | &#39;close&#39;&#125;)</code> 可以创建一个 shadow tree；参数为open则可以通过<code>elem.shadowRoot</code>访问。<br>这个api有几个限制：</p>
<ol>
<li>每个元素中，只能创建一个 shadow root。</li>
<li>elem 必须是自定义元素，或者是以下元素的其中一个：「article」、「aside」、「blockquote」、「body」、「div」、「footer」、「h1…h6」、「header」、「main」、「nav」、「p」、「section」或者「span」。其他元素，比如<code>&lt;img&gt;</code>，不能容纳 shadow tree。</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: red; &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;elem&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  elem.attachShadow(&#123;mode: &#x27;open&#x27;&#125;);</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  elem.shadowRoot.innerHTML = `</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"> <span class="selector-tag">p</span> &#123; <span class="attribute">font-weight</span>: bold; &#125; </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello, John!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  `;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  // <span class="tag">&lt;<span class="name">p</span>&gt;</span> 只对 shadow tree 里面的查询可见 (3)</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  clg(document.querySelectorAll(&#x27;p&#x27;).length); // 0</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  clg(elem.shadowRoot.querySelectorAll(&#x27;p&#x27;).length); // 1</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果想要更改浏览器自带的某些shadowdom的样式，比如滚动条，可以通过点开并查看这个元素上的<code>pseudo</code>属性，它的值是一个伪元素；通过给这个元素添加上伪元素限制，就可以更改这个样式了。<br><img src="https://pic.imgdb.cn/item/628798110947543129722127.jpg"></p>
</blockquote>
<h2 id="WebComponents"><a href="#WebComponents" class="headerlink" title="WebComponents"></a>WebComponents</h2><p>WebComponents就是浏览器自己支持的组件化开发，用户可以自己创建组件，也可以继承一部分原组件并改进。<br>用户可以定义两种 custom element：</p>
<ol>
<li>全新定义，通常是一个类，继承自浏览器内置的DOM对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyElement</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; <span class="built_in">super</span>(); <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  <span class="function"><span class="title">connectedCallback</span>(<span class="params"></span>)</span> &#123; <span class="comment">/* ... */</span> &#125;<span class="comment">// 在元素被添加到文档之后，浏览器会调用这个方法（挂载）</span></span><br><span class="line">  <span class="function"><span class="title">disconnectedCallback</span>(<span class="params"></span>)</span> &#123; <span class="comment">/* ... */</span>  &#125;<span class="comment">// 在元素被添加到文档之后，浏览器会调用这个方法（卸载）</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> <span class="title">observedAttributes</span>() &#123; <span class="keyword">return</span> [<span class="comment">/* 属性数组，这些属性的变化会被监视 */</span>]; &#125; <span class="comment">// watch</span></span><br><span class="line">  <span class="function"><span class="title">attributeChangedCallback</span>(<span class="params">name, oldValue, newValue</span>)</span> &#123; <span class="comment">/* ... */</span> &#125;<span class="comment">// 当上面数组中的属性发生变化的时候，这个方法会被调用</span></span><br><span class="line">  <span class="function"><span class="title">adoptedCallback</span>(<span class="params"></span>)</span> &#123; <span class="comment">/* ... */</span> &#125;<span class="comment">// 在元素被移动到新的文档的时候，这个方法会被调用</span></span><br><span class="line"> &#125;</span><br><span class="line">customElements.define(<span class="string">&#x27;my-element&#x27;</span>, MyElement);</span><br></pre></td></tr></table></figure></li>
<li>已有元素扩展，通常表现为仍是原有元素，但是属性上有一个<code>is</code>，可以把一般元素变为自定义元素。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyButton</span> <span class="keyword">extends</span> <span class="title">HTMLButtonElement</span> </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">customElements.define(<span class="string">&#x27;my-button&#x27;</span>, MyElement, &#123;<span class="attr">extends</span>: <span class="string">&#x27;button&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">/* &lt;button is=&quot;my-button&quot;&gt; */</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><p>可以使用<code>&lt;template&gt;</code>封装一部分HTML元素，浏览器会保存其内部的HTML元素排列。但是，样式不会被应用，脚本也不会被执行， <code>&lt;video autoplay&gt;</code> 也不会运行，相当于只是在单纯的保存。<br>它的一个重要应用是，可以把其中的内容完整的插入到一个元素中，而不只能通过字符串拼接的形式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;tmpl&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    alert(<span class="string">&quot;Hello&quot;</span>);</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;message&quot;</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> elem = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  elem.append(tmpl.content.cloneNode(<span class="literal">true</span>));</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.body.append(elem);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当把template元素插入节点时，实际上插入的是其内部的子节点（<code>template.content</code>值）；插入之后将会类似正常的HTML一样去解析。</p>
<p>可以把一些shadowdom的样式在template中封装好，然后插入到元素的<code>elem.shadowRoot</code>中</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/">日常学习</a></div><div class="post_share"><div class="social-share" data-image="/img/JS.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/09/blog31-es6+/"><img class="prev-cover" src="/img/ES6.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">es6一些疏漏的知识点</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/05/blog29-h5-deeping/"><img class="next-cover" src="/img/Chrome.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">前端知识深入--HTML5深入</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/11/06/blog11-myReact/" title="react知识点汇总和使用小总结(一)"><img class="cover" src="/img/react.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-06</div><div class="title">react知识点汇总和使用小总结(一)</div></div></a></div><div><a href="/2021/10/27/blog10-react-router/" title="react-router的使用"><img class="cover" src="/img/reactrouter.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-27</div><div class="title">react-router的使用</div></div></a></div><div><a href="/2021/11/20/blog14-react-ts-basic/" title="typescript+react基础部分"><img class="cover" src="/img/typescript.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-20</div><div class="title">typescript+react基础部分</div></div></a></div><div><a href="/2021/11/22/blog17-react-pubsub-issues/" title="react+typescript使用pubsub时的一点小问题"><img class="cover" src="/img/pubsub.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-22</div><div class="title">react+typescript使用pubsub时的一点小问题</div></div></a></div><div><a href="/2021/11/20/blog16-react-ts-hooks-redux/" title="typescript+react:自定义hooks代替redux"><img class="cover" src="/img/typescript.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-20</div><div class="title">typescript+react:自定义hooks代替redux</div></div></a></div><div><a href="/2021/11/25/blog18-vue3ts-basic/" title="vue3+ts配置及简单使用注意"><img class="cover" src="/img/vue3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-25</div><div class="title">vue3+ts配置及简单使用注意</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/pinkstar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xing Ye</div><div class="author-info__description">a singleThreaded boy's blog</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/penghei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/penghei" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:632885485@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">A SingleThreaded Boy...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#js-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">js 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%A7%88"><span class="toc-number">1.1.</span> <span class="toc-text">数据类型概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-1-0-2-0-3"><span class="toc-number">1.2.</span> <span class="toc-text">0.1 + 0.2 !&#x3D;&#x3D; 0.3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">避免方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%BC%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.3.</span> <span class="toc-text">值的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99"><span class="toc-number">1.3.1.</span> <span class="toc-text">&#x3D;&#x3D;的转换规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83"><span class="toc-number">1.3.2.</span> <span class="toc-text">相同类型比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83"><span class="toc-number">1.3.3.</span> <span class="toc-text">不同类型比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%80%BC%E5%88%B0%E6%95%B0%E5%AD%97%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">其他值到数字的转换规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%80%BC%E5%88%B0%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">其他值到布尔类型的值的转换规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-is"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">Object.is()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null-%E5%92%8C-undefined"><span class="toc-number">1.4.</span> <span class="toc-text">null 和 undefined</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.4.1.</span> <span class="toc-text">null</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.4.2.</span> <span class="toc-text">undefined</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NaN-%E5%92%8C-Infinity"><span class="toc-number">1.5.</span> <span class="toc-text">NaN 和 Infinity</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#isNaN-%E5%92%8C-isFinite"><span class="toc-number">1.5.1.</span> <span class="toc-text">isNaN 和 isFinite</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%BD%AC%E5%8C%96%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">对象转化原始数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BD%AC%E5%8C%96%E4%B8%BA-string"><span class="toc-number">1.6.1.</span> <span class="toc-text">1. 转化为 string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BD%AC%E5%8C%96%E4%B8%BA-number"><span class="toc-number">1.6.2.</span> <span class="toc-text">2. 转化为 number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-default"><span class="toc-number">1.6.3.</span> <span class="toc-text">3. default</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.4.</span> <span class="toc-text">转化方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol-toPrimitive"><span class="toc-number">1.6.5.</span> <span class="toc-text">Symbol.toPrimitive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toString-valueOf"><span class="toc-number">1.6.6.</span> <span class="toc-text">toString&#x2F;valueOf</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.</span> <span class="toc-text">原始数据类型和引用数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-number">1.7.1.</span> <span class="toc-text">对象包装器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.2.</span> <span class="toc-text">存储结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.</span> <span class="toc-text">检测数据类型的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof"><span class="toc-number">1.8.1.</span> <span class="toc-text">typeof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof"><span class="toc-number">1.8.2.</span> <span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constructor-NaN"><span class="toc-number">1.8.3.</span> <span class="toc-text">constructor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-prototype-toString"><span class="toc-number">1.8.4.</span> <span class="toc-text">Object.prototype.toString</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.5.</span> <span class="toc-text">判断数组的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.</span> <span class="toc-text">对象拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.1.</span> <span class="toc-text">浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-assign"><span class="toc-number">2.1.1.</span> <span class="toc-text">Object.assign</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.1.2.</span> <span class="toc-text">展开运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.2.</span> <span class="toc-text">深拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON"><span class="toc-number">2.2.1.</span> <span class="toc-text">JSON</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">2.2.2.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lodash-%E5%BA%93%E5%87%BD%E6%95%B0-cloneDeep"><span class="toc-number">2.2.3.</span> <span class="toc-text">lodash 库函数 cloneDeep</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Symbol"><span class="toc-number">3.</span> <span class="toc-text">Symbol</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">创建方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbol-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.2.</span> <span class="toc-text">Symbol 的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbol-%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">Symbol 相关方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E5%8F%AF%E8%BF%AD%E4%BB%A3"><span class="toc-number">4.</span> <span class="toc-text">迭代器和可迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#forof-%E5%92%8C-forin"><span class="toc-number">4.1.</span> <span class="toc-text">forof 和 forin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.2.</span> <span class="toc-text">可迭代对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arrayLike"><span class="toc-number">4.4.</span> <span class="toc-text">arrayLike</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Map-%E5%92%8C-Set"><span class="toc-number">5.</span> <span class="toc-text">Map 和 Set</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Map"><span class="toc-number">5.1.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Map-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">5.1.1.</span> <span class="toc-text">Map 的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map-%E8%BF%AD%E4%BB%A3"><span class="toc-number">5.1.2.</span> <span class="toc-text">Map 迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map-%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96"><span class="toc-number">5.1.3.</span> <span class="toc-text">Map 和对象相互转化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set"><span class="toc-number">5.2.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">5.2.1.</span> <span class="toc-text">Set 的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.2.</span> <span class="toc-text">Set 的主要方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-%E8%BF%AD%E4%BB%A3"><span class="toc-number">5.2.3.</span> <span class="toc-text">Set 迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.2.4.</span> <span class="toc-text">Set 的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-%E7%94%A8%E4%BA%8E%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-number">5.2.5.</span> <span class="toc-text">Set 用于数组去重</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WeakMap-%E5%92%8C-WeakSet"><span class="toc-number">5.3.</span> <span class="toc-text">WeakMap 和 WeakSet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">5.3.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.3.2.</span> <span class="toc-text">使用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE"><span class="toc-number">6.</span> <span class="toc-text">对象属性配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%BB%98%E8%AE%A4%E5%B1%9E%E6%80%A7"><span class="toc-number">6.1.</span> <span class="toc-text">对象的默认属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getter-%E5%92%8C-setter"><span class="toc-number">6.2.</span> <span class="toc-text">getter 和 setter</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">7.</span> <span class="toc-text">函数声明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.</span> <span class="toc-text">函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7"><span class="toc-number">8.1.</span> <span class="toc-text">函数属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IFE"><span class="toc-number">8.2.</span> <span class="toc-text">IFE</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-number">9.</span> <span class="toc-text">函数柯里化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">9.1.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">9.1.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%9F%E6%AD%A3%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.1.2.</span> <span class="toc-text">真正实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">9.2.</span> <span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">10.</span> <span class="toc-text">箭头函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89-this"><span class="toc-number">10.0.1.</span> <span class="toc-text">没有 this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%AD%98%E5%9C%A8-prototype"><span class="toc-number">10.0.2.</span> <span class="toc-text">不存在 prototype</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89-arguments-%E5%B1%9E%E6%80%A7"><span class="toc-number">10.0.3.</span> <span class="toc-text">没有 arguments 属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%83%BD-new"><span class="toc-number">10.0.4.</span> <span class="toc-text">不能 new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89-super"><span class="toc-number">10.0.5.</span> <span class="toc-text">没有 super</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-%E3%80%81apply-%E3%80%81bind-%E7%AD%89%E6%96%B9%E6%B3%95%E4%B8%8D%E8%83%BD%E6%94%B9%E5%8F%98%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD-this-%E7%9A%84%E6%8C%87%E5%90%91"><span class="toc-number">10.0.6.</span> <span class="toc-text">call()、apply()、bind()等方法不能改变箭头函数中 this 的指向</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">11.</span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">11.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">11.1.1.</span> <span class="toc-text">执行上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E4%BC%AA%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA"><span class="toc-number">11.1.1.1.</span> <span class="toc-text">执行上下文的伪代码表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83-Lexical-Environments"><span class="toc-number">11.1.1.2.</span> <span class="toc-text">词法环境(Lexical Environments)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%8E%AF%E5%A2%83-Variable-Environment"><span class="toc-number">11.1.1.3.</span> <span class="toc-text">变量环境(Variable Environment)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%AD%E7%9A%84-this"><span class="toc-number">11.1.1.4.</span> <span class="toc-text">执行上下文中的 this</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">11.1.2.</span> <span class="toc-text">作用域和作用域链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">11.1.2.1.</span> <span class="toc-text">作用域链</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">11.1.3.</span> <span class="toc-text">作用域和执行上下文</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85-1"><span class="toc-number">11.2.</span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">11.2.1.</span> <span class="toc-text">闭包和内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%87%BA%E7%8E%B0%E5%9C%BA%E6%99%AF"><span class="toc-number">11.2.2.</span> <span class="toc-text">闭包的出现场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">11.2.3.</span> <span class="toc-text">闭包的使用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">12.</span> <span class="toc-text">高阶函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%80%9F%E7%94%A8"><span class="toc-number">12.1.</span> <span class="toc-text">方法借用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apply-%E5%92%8C-call-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">12.2.</span> <span class="toc-text">apply 和 call 的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">12.3.</span> <span class="toc-text">常见的装饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6"><span class="toc-number">12.3.1.</span> <span class="toc-text">延时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-number">12.3.2.</span> <span class="toc-text">防抖和节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">12.3.3.</span> <span class="toc-text">缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">13.</span> <span class="toc-text">原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Prototype-%E5%92%8C-proto"><span class="toc-number">13.1.</span> <span class="toc-text">[[Prototype]]和__proto__</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B"><span class="toc-number">13.2.</span> <span class="toc-text">对象原型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-number">13.2.1.</span> <span class="toc-text">原型和继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E9%99%90%E5%88%B6%EF%BC%9A"><span class="toc-number">13.2.2.</span> <span class="toc-text">原型链的限制：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%92%8C-this"><span class="toc-number">13.2.3.</span> <span class="toc-text">原型和 this</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7-prototype"><span class="toc-number">13.3.</span> <span class="toc-text">函数属性 prototype</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#prototype-%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%8A%E7%9A%84%E8%A1%A8%E7%8E%B0"><span class="toc-number">13.3.1.</span> <span class="toc-text">prototype 在函数上的表现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%9D%A5%E4%BB%A3%E6%9B%BF-proto-%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">13.4.</span> <span class="toc-text">用来代替__proto__的函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#js-%E4%BA%94%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="toc-number">14.</span> <span class="toc-text">js 五种继承方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-number">14.1.</span> <span class="toc-text">1. 原型链继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">14.2.</span> <span class="toc-text">2. 构造函数继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-number">14.3.</span> <span class="toc-text">3. 组合继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BB%84%E5%90%88%E5%AF%84%E7%94%9F%E7%BB%A7%E6%89%BF-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E6%9C%80%E5%A5%BD%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95"><span class="toc-number">14.4.</span> <span class="toc-text">4. 组合寄生继承(构造函数中最好的继承方法)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="toc-number">14.5.</span> <span class="toc-text">5. 类继承</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">15.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81this"><span class="toc-number">15.1.</span> <span class="toc-text">类、构造函数、this</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B1%BB%E5%92%8C%E7%B1%BB%E5%AD%97%E6%AE%B5"><span class="toc-number">15.1.1.</span> <span class="toc-text">1. 类和类字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B1%BB%E5%92%8C-this"><span class="toc-number">15.1.2.</span> <span class="toc-text">2. 类和 this</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="toc-number">15.2.</span> <span class="toc-text">类继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#super-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">15.2.1.</span> <span class="toc-text">super 的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">15.2.2.</span> <span class="toc-text">super 的实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof-1"><span class="toc-number">15.3.</span> <span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%AD%97%E6%AE%B5"><span class="toc-number">15.4.</span> <span class="toc-text">类字段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E7%B1%BB%E5%AD%97%E6%AE%B5"><span class="toc-number">15.4.1.</span> <span class="toc-text">重写类字段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%86%85%E5%BB%BA%E7%B1%BB"><span class="toc-number">15.5.</span> <span class="toc-text">扩展内建类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise"><span class="toc-number">16.</span> <span class="toc-text">Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">16.1.</span> <span class="toc-text">Promise 解决的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">16.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">16.3.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-%E9%93%BE"><span class="toc-number">16.4.</span> <span class="toc-text">Promise 链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-Api"><span class="toc-number">16.5.</span> <span class="toc-text">Promise Api</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-all"><span class="toc-number">16.5.1.</span> <span class="toc-text">Promise.all</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-race"><span class="toc-number">16.5.2.</span> <span class="toc-text">Promise.race</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-allSettled"><span class="toc-number">16.5.3.</span> <span class="toc-text">Promise.allSettled</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-number">16.6.</span> <span class="toc-text">微任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promisify"><span class="toc-number">16.7.</span> <span class="toc-text">Promisify</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async-await"><span class="toc-number">16.8.</span> <span class="toc-text">async&#x2F;await</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#async-%E5%92%8C-await-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">16.8.1.</span> <span class="toc-text">async 和 await 的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="toc-number">16.8.2.</span> <span class="toc-text">处理错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F"><span class="toc-number">16.8.3.</span> <span class="toc-text">使用注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97"><span class="toc-number">17.</span> <span class="toc-text">模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="toc-number">17.1.</span> <span class="toc-text">模块的发展历程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%B1%BB%E5%9E%8B"><span class="toc-number">17.2.</span> <span class="toc-text">模块类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CommonJS"><span class="toc-number">17.2.1.</span> <span class="toc-text">CommonJS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-module"><span class="toc-number">17.2.1.1.</span> <span class="toc-text">1. module</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-exports"><span class="toc-number">17.2.1.2.</span> <span class="toc-text">2. exports</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-require"><span class="toc-number">17.2.1.3.</span> <span class="toc-text">3. require</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AMD"><span class="toc-number">17.2.2.</span> <span class="toc-text">AMD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMD"><span class="toc-number">17.2.3.</span> <span class="toc-text">CMD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UMD"><span class="toc-number">17.2.4.</span> <span class="toc-text">UMD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6-Module"><span class="toc-number">17.2.5.</span> <span class="toc-text">ES6 Module</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6-Module-%E4%B8%8E-CommonJS-%E5%BC%82%E5%90%8C"><span class="toc-number">17.2.6.</span> <span class="toc-text">ES6 Module 与 CommonJS 异同</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6-Module-1"><span class="toc-number">17.3.</span> <span class="toc-text">ES6 Module</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#import"><span class="toc-number">17.3.1.</span> <span class="toc-text">import</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Proxy-%E5%92%8C-Reflect"><span class="toc-number">18.</span> <span class="toc-text">Proxy 和 Reflect</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Proxy"><span class="toc-number">18.1.</span> <span class="toc-text">Proxy</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#get"><span class="toc-number">18.1.1.</span> <span class="toc-text">get</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set"><span class="toc-number">18.1.2.</span> <span class="toc-text">set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ownKeys"><span class="toc-number">18.1.3.</span> <span class="toc-text">ownKeys</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deleteProperty"><span class="toc-number">18.1.4.</span> <span class="toc-text">deleteProperty</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#has"><span class="toc-number">18.1.5.</span> <span class="toc-text">has</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">18.1.6.</span> <span class="toc-text">其他方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reflect"><span class="toc-number">18.2.</span> <span class="toc-text">Reflect</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E3%80%81%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E3%80%81%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%BE%AE%E4%BB%BB%E5%8A%A1%E3%80%81%E8%B0%83%E7%94%A8%E6%A0%88%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AD%89%E5%90%84%E7%A7%8D%E5%8E%9F%E7%90%86%E6%80%A7%E6%9D%82%E9%A1%B9"><span class="toc-number">19.</span> <span class="toc-text">事件循环、消息队列、同步异步、宏任务微任务、调用栈、垃圾回收等各种原理性杂项</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">20.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">20.1.</span> <span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86"><span class="toc-number">20.1.1.</span> <span class="toc-text">引用计数垃圾收集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E2%80%93%E6%B8%85%E9%99%A4"><span class="toc-number">20.1.2.</span> <span class="toc-text">标记–清除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#event-loop"><span class="toc-number">21.</span> <span class="toc-text">event loop</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-number">22.</span> <span class="toc-text">宏任务微任务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DOM"><span class="toc-number">23.</span> <span class="toc-text">DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">23.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9"><span class="toc-number">23.1.1.</span> <span class="toc-text">节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-Tree"><span class="toc-number">23.1.2.</span> <span class="toc-text">DOM Tree</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86-DOM"><span class="toc-number">23.2.</span> <span class="toc-text">遍历 DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E5%B1%82%E8%8A%82%E7%82%B9"><span class="toc-number">23.2.1.</span> <span class="toc-text">顶层节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%8A%82%E7%82%B9"><span class="toc-number">23.2.2.</span> <span class="toc-text">关系节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getElement-%E5%92%8CquerySelector"><span class="toc-number">23.3.</span> <span class="toc-text">getElement*和querySelector*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM-%E8%8A%82%E7%82%B9%E7%B1%BB"><span class="toc-number">23.4.</span> <span class="toc-text">DOM 节点类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7"><span class="toc-number">23.4.1.</span> <span class="toc-text">元素属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#innerHTML"><span class="toc-number">23.4.1.1.</span> <span class="toc-text">innerHTML</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nodeValue-data-textContent"><span class="toc-number">23.4.1.2.</span> <span class="toc-text">nodeValue&#x2F;data&#x2F;textContent</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Attributes-amp-properties"><span class="toc-number">23.5.</span> <span class="toc-text">Attributes &amp; properties</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7attributes"><span class="toc-number">23.5.1.</span> <span class="toc-text">特性attributes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7properties"><span class="toc-number">23.5.2.</span> <span class="toc-text">属性properties</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#classList%E5%92%8Cstyle"><span class="toc-number">23.6.</span> <span class="toc-text">classList和style</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Window-%E5%A4%A7%E5%B0%8F%E5%92%8C%E6%BB%9A%E5%8A%A8"><span class="toc-number">23.7.</span> <span class="toc-text">Window 大小和滚动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8"><span class="toc-number">23.7.1.</span> <span class="toc-text">滚动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mutation-Observer-API"><span class="toc-number">23.8.</span> <span class="toc-text">Mutation Observer API</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">24.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#EventTarget"><span class="toc-number">24.1.</span> <span class="toc-text">EventTarget</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5"><span class="toc-number">24.2.</span> <span class="toc-text">事件的异步和同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%AB%8B%E5%8D%B3%E8%A7%A6%E5%8F%91"><span class="toc-number">24.2.1.</span> <span class="toc-text">嵌套事件的立即触发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#addEventListener"><span class="toc-number">24.3.</span> <span class="toc-text">addEventListener</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1event"><span class="toc-number">24.4.</span> <span class="toc-text">事件对象event</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#event-target-%E5%92%8C-event-currentTarget-%E5%92%8C-this"><span class="toc-number">24.4.1.</span> <span class="toc-text">event.target 和 event.currentTarget 和 this</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-number">24.5.</span> <span class="toc-text">事件冒泡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1"><span class="toc-number">24.5.1.</span> <span class="toc-text">阻止冒泡</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7"><span class="toc-number">24.6.</span> <span class="toc-text">事件捕获</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">24.7.</span> <span class="toc-text">事件委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6"><span class="toc-number">24.8.</span> <span class="toc-text">浏览器默认事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA"><span class="toc-number">24.8.1.</span> <span class="toc-text">阻止默认行为</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="toc-number">24.9.</span> <span class="toc-text">自定义事件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82"><span class="toc-number">25.</span> <span class="toc-text">网络请求</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#fetch"><span class="toc-number">25.1.</span> <span class="toc-text">fetch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">25.1.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FormData"><span class="toc-number">25.1.2.</span> <span class="toc-text">FormData</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XHR"><span class="toc-number">25.2.</span> <span class="toc-text">XHR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebSocket"><span class="toc-number">25.3.</span> <span class="toc-text">WebSocket</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">25.3.1.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket-%E8%BF%9E%E6%8E%A5"><span class="toc-number">25.3.2.</span> <span class="toc-text">WebSocket 连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-number">25.3.3.</span> <span class="toc-text">数据传输</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96-js-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">26.</span> <span class="toc-text">其他 js 基本知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">26.1.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C-amp-amp-%E5%92%8C"><span class="toc-number">26.2.</span> <span class="toc-text">||和&amp;&amp;和??</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this"><span class="toc-number">26.3.</span> <span class="toc-text">this</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this-%E5%8E%9F%E7%90%86"><span class="toc-number">26.3.1.</span> <span class="toc-text">this 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-%E5%9F%BA%E6%9C%AC"><span class="toc-number">26.3.2.</span> <span class="toc-text">this 基本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-%E7%89%B9%E7%82%B9"><span class="toc-number">26.3.3.</span> <span class="toc-text">this 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E8%B0%83%E7%94%A8%E6%A0%88%E7%9C%8B-this"><span class="toc-number">26.3.4.</span> <span class="toc-text">从调用栈看 this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84-this-%E4%B8%A2%E5%A4%B1%E6%8C%87%E5%90%91%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">26.3.5.</span> <span class="toc-text">常见的 this 丢失指向场景：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bind-apply-call"><span class="toc-number">26.4.</span> <span class="toc-text">bind apply call</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-number">26.4.1.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95"><span class="toc-number">26.4.2.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bind-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">26.4.3.</span> <span class="toc-text">bind 的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%87%BD%E6%95%B0"><span class="toc-number">26.4.3.1.</span> <span class="toc-text">偏函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new"><span class="toc-number">26.5.</span> <span class="toc-text">new</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C-new"><span class="toc-number">26.5.1.</span> <span class="toc-text">构造函数和 new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-target"><span class="toc-number">26.5.2.</span> <span class="toc-text">new.target</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84-return"><span class="toc-number">26.5.3.</span> <span class="toc-text">构造函数的 return</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81-1"><span class="toc-number">26.6.</span> <span class="toc-text">防抖和节流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%8A%96"><span class="toc-number">26.6.1.</span> <span class="toc-text">防抖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E6%B5%81"><span class="toc-number">26.6.2.</span> <span class="toc-text">节流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#requestAnimationFrame"><span class="toc-number">26.7.</span> <span class="toc-text">requestAnimationFrame</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">26.7.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="toc-number">26.7.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E5%87%BD%E6%95%B0"><span class="toc-number">26.7.3.</span> <span class="toc-text">时序函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%9B%B4%E6%94%B9%E5%BD%B1%E5%93%8D%E5%8E%9F%E5%8F%98%E9%87%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">26.8.</span> <span class="toc-text">函数参数更改影响原变量的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">26.9.</span> <span class="toc-text">原始数据不可变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C-amp-amp-%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">26.10.</span> <span class="toc-text">|| 和 &amp;&amp; 的返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-%E5%BE%AA%E7%8E%AF%E5%92%8C-let%E3%80%81var"><span class="toc-number">26.11.</span> <span class="toc-text">for 循环和 let、var</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%83%85%E5%86%B5"><span class="toc-number">26.11.1.</span> <span class="toc-text">同步情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%83%85%E5%86%B5"><span class="toc-number">26.11.2.</span> <span class="toc-text">异步情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#valueOf-NaN"><span class="toc-number">26.12.</span> <span class="toc-text">valueOf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">26.13.</span> <span class="toc-text">类的静态方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#let-%E5%92%8C-const-%E7%9A%84%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA-TDZ"><span class="toc-number">26.14.</span> <span class="toc-text">let 和 const 的暂时性死区(TDZ)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#html-%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">26.15.</span> <span class="toc-text">html 页面生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js-%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1"><span class="toc-number">26.16.</span> <span class="toc-text">js 全局对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#delete"><span class="toc-number">26.17.</span> <span class="toc-text">delete</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F%E5%8C%BA%E5%88%AB"><span class="toc-number">26.18.</span> <span class="toc-text">三种函数定义方式区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">26.19.</span> <span class="toc-text">函数参数作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%9A%E6%94%B9%E5%8F%98%E5%8E%9F%E6%95%B0%E7%BB%84%E5%92%8C%E4%B8%8D%E6%94%B9%E5%8F%98%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-number">26.20.</span> <span class="toc-text">会改变原数组和不改变的数组方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#import-%E5%92%8C-export-default"><span class="toc-number">26.21.</span> <span class="toc-text">import * 和 export default</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%86%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">26.22.</span> <span class="toc-text">细碎知识点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%9B%9E%E6%94%B6%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">26.23.</span> <span class="toc-text">关于对象中定时器不会被回收的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node-%E6%9F%A5%E6%89%BE%E6%A8%A1%E5%9D%97%E9%A1%BA%E5%BA%8F"><span class="toc-number">26.24.</span> <span class="toc-text">node 查找模块顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shadowDOM"><span class="toc-number">26.25.</span> <span class="toc-text">shadowDOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebComponents"><span class="toc-number">26.26.</span> <span class="toc-text">WebComponents</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#template"><span class="toc-number">26.27.</span> <span class="toc-text">template</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/05/18/projects/" title="无题"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/05/18/projects/" title="无题">无题</a><time datetime="2022-05-18T02:57:57.356Z" title="发表于 2022-05-18 10:57:57">2022-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/13/handwriting/" title="js题目"><img src="/img/JS.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="js题目"/></a><div class="content"><a class="title" href="/2022/05/13/handwriting/" title="js题目">js题目</a><time datetime="2022-05-13T04:21:10.000Z" title="发表于 2022-05-13 12:21:10">2022-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/12/OS/" title="操作系统知识点总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统知识点总结"/></a><div class="content"><a class="title" href="/2022/05/12/OS/" title="操作系统知识点总结">操作系统知识点总结</a><time datetime="2022-05-12T07:58:22.000Z" title="发表于 2022-05-12 15:58:22">2022-05-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/05/blog43-algorithms/" title="算法学习总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法学习总结"/></a><div class="content"><a class="title" href="/2022/04/05/blog43-algorithms/" title="算法学习总结">算法学习总结</a><time datetime="2022-04-05T08:01:22.000Z" title="发表于 2022-04-05 16:01:22">2022-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/05/blog44-optimization/" title="优化问题总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="优化问题总结"/></a><div class="content"><a class="title" href="/2022/04/05/blog44-optimization/" title="优化问题总结">优化问题总结</a><time datetime="2022-04-05T08:01:22.000Z" title="发表于 2022-04-05 16:01:22">2022-04-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Xing Ye</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hello stranger!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>