<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>js复习知识点和部分es6学习 | XingYeBlog</title><meta name="keywords" content="日常学习"><meta name="author" content="Xing Ye,632885485@qq.com"><meta name="copyright" content="Xing Ye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本来是为了应对面试,顺便把之前js复习了一遍,还看了很多es6的新内容,在这里大概总结一下">
<meta property="og:type" content="article">
<meta property="og:title" content="js复习知识点和部分es6学习">
<meta property="og:url" content="http://example.com/2021/10/23/blog5_js/index.html">
<meta property="og:site_name" content="XingYeBlog">
<meta property="og:description" content="本来是为了应对面试,顺便把之前js复习了一遍,还看了很多es6的新内容,在这里大概总结一下">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/starry3.jpg">
<meta property="article:published_time" content="2021-10-23T15:00:00.000Z">
<meta property="article:modified_time" content="2021-11-20T16:26:19.404Z">
<meta property="article:author" content="Xing Ye">
<meta property="article:tag" content="日常学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/starry3.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2021/10/23/blog5_js/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'js复习知识点和部分es6学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-21 00:26:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/pinkstar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/starry3.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XingYeBlog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">js复习知识点和部分es6学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-23T15:00:00.000Z" title="发表于 2021-10-23 23:00:00">2021-10-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-20T16:26:19.404Z" title="更新于 2021-11-21 00:26:19">2021-11-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="js复习知识点和部分es6学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="js-数据类型"><a href="#js-数据类型" class="headerlink" title="js 数据类型"></a>js 数据类型</h2><ul>
<li>number </li>
<li>bigint </li>
<li>string </li>
<li>boolean </li>
<li>null </li>
<li>undefined </li>
<li>object </li>
<li>symbol</li>
</ul>
<h2 id="var-和-let"><a href="#var-和-let" class="headerlink" title="var 和 let"></a>var 和 let</h2><ul>
<li>var 特点：没有块级作用域；变量提升；可更改；注意变量提升是指声明提升而不是赋值提升:<code>let x</code>是声明<code>let x = 1</code>只会提升这个声明</li>
</ul>
<h2 id="和-amp-amp-和"><a href="#和-amp-amp-和" class="headerlink" title="||和&amp;&amp;和??"></a>||和&amp;&amp;和??</h2><ul>
<li>|| 可以在一排中找到第一个真值:a||b 表示 a 为假则判断 b;a 为真则直接用 a;<br>&amp;&amp;可以找到第一个假值:a&amp;&amp;b 表示 a 为假则返回 a,a 为真则返回 b;都为真返回最后一个;<br>??和||差不多,但是||是判断真值,??是判断已定义的值;比如 0 虽然为假但是已定义就可以正常返回</li>
</ul>
<h2 id="object-和-symbol"><a href="#object-和-symbol" class="headerlink" title="object 和 symbol"></a>object 和 symbol</h2><h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><ul>
<li>多词名(中间有空格)的键名要加引号,并且引用要用[]</li>
<li>[]的使用时机:多词名/键值是变量/方框中用表达式</li>
<li>“key” in object 可以判断键是否在 obj 中,也可以用来遍历:<code>for(let key in obj)&#123;&#125;</code></li>
<li>深拷贝:值也是个对象的时候:可以递归实现,或者用<code>_.cloneDeep(obj)</code></li>
<li><code>?.</code>这个东西可以实现不存在的属性读取;如果不存在的话就是 undefined 而不是错误;也可以这么使用:<code>?.[]</code>用来方括号引用属性,<code>?.()</code>可以对函数操作<h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><ul>
<li>symbol 表示一种特殊的数据类型,可以创建一个对象的隐藏属性用于辨识<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">&#x27;id&#x27;</span>)<span class="comment">//这个id是描述,在toString时会显示这个</span></span><br><span class="line"><span class="keyword">let</span> id1 = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">alert(id1 == id2); <span class="comment">// false描述相等也不会相同</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="comment">// 属于另一个代码</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">user[id] = <span class="number">1</span>;</span><br><span class="line">alert( user[id] ); <span class="comment">// 我们可以使用 Symbol 作为键来访问数据</span></span><br></pre></td></tr></table></figure></li>
<li>symbol 特点:<ul>
<li>不会被 forin 遍历</li>
<li>即便引用相同也不会相等或者改写(所有 symbol 都是不同的)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Map-和-Set"><a href="#Map-和-Set" class="headerlink" title="Map 和 Set"></a>Map 和 Set</h2><ul>
<li>map 是一个类似 obj 的东西,但是他可以保留键的类型:比如数字键啥的</li>
<li>map 一般不用.或者[]来取值赋值,要用 set 和 get</li>
<li>set:没有键的 obj,一个值只能出现一次</li>
</ul>
<h2 id="对象属性配置"><a href="#对象属性配置" class="headerlink" title="对象属性配置"></a>对象属性配置</h2><h3 id="对象标志符"><a href="#对象标志符" class="headerlink" title="对象标志符"></a>对象标志符</h3><ul>
<li>对象除了数据属性,还有三个属性:<ul>
<li>writable — 如果为 true，则值可以被修改，否则它是只可读的。</li>
<li>enumerable — 如果为 true，则会被在循环中列出，否则不会被列出。</li>
<li>configurable — 如果为 true，则此特性可以被删除，这些属性也可以被修改，否则不可以。</li>
</ul>
</li>
<li><code>getOwnPropertyDescriptor(obj, propertyName)</code>可以获取这种属性,<code>Object.defineProperty(obj, propertyName, descriptor)</code>可以修改标志属性<h3 id="getter-和-setter"><a href="#getter-和-setter" class="headerlink" title="getter 和 setter"></a>getter 和 setter</h3></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    <span class="attr">surname</span>: <span class="string">&quot;Smith&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">fullName</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.surname&#125;</span>`</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title">fullName</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        [<span class="built_in">this</span>.name, <span class="built_in">this</span>.surname] = value.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">user.fullName<span class="comment">//John Smith</span></span><br><span class="line">user.fullName = <span class="string">&quot;xxx yyy&quot;</span><span class="comment">//设置user的属性</span></span><br></pre></td></tr></table></figure>

<p>getter 和 setter 是对象的访问器属性;get 在读取时被调用,set 在赋值时被调用<br>也可以用 setter 来创建一个数据属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">user.name = <span class="string">&#x27;zzx&#x27;</span><span class="comment">//设置到user中</span></span><br></pre></td></tr></table></figure>

<p>并且这种方式可以在 set 加一些条件</p>
<h2 id="原型链和继承"><a href="#原型链和继承" class="headerlink" title="原型链和继承"></a>原型链和继承</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul>
<li>原型对象:当 a 为 b 的原型对象时,读取 a 没有的属性会自动在 b 中查找;可以通过<code>a.__proto__ = b</code>来设置 b 为 a 的原型对象.当有一长串继承就被称作原型链</li>
<li>prototype:是构造函数实例对象的属性,比如:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">    <span class="attr">run</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rabbit</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Rabbit.prototype = animal</span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> Rabbit(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">rabbit.run<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>这里把函数 Rabbit 的原型指到了 animal 身上,相当于创建出来的实例对象的原型链上一定有 animal.<br>如果不是一个构造函数,那么函数的 prototype 属性指向一个 constructor 并指向自身</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">f.prototype</span><br><span class="line">&#123;<span class="attr">constructor</span>: ƒ&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原生的原型"><a href="#原生的原型" class="headerlink" title="原生的原型"></a>原生的原型</h3><p>  当<code>let obj = &#123;&#125;</code>时,实际上是<code>let obj = new Object()</code>,(数组函数同理),因此 obj 是一个实例对象,obj 就会带有很多 Object()的属性和方法<br>  比如 obj.toString(),obj 没有这个方法,所以到 Object 这个构造函数去找<br>  但是,string/number/boolean 不是对象,也可以达成这种效果.原因在于:</p>
<blockquote>
<p>我们试图访问它们的属性，那么临时包装器对象将会通过内建的构造器 String、Number 和 Boolean 被创建。它们提供给我们操作字符串、数字和布尔值的方法然后消失。</p>
</blockquote>
<p>也就是说他们不是对象,但是访问时为他们构造了一个原型对象也就是<code>String() Number() Boolean()</code>,然后这三个对象身上有很多方法;当我们拿到方法操作完成后就消失</p>
<h3 id="proto的替代"><a href="#proto的替代" class="headerlink" title="proto的替代"></a><strong>proto</strong>的替代</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">    <span class="attr">eats</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="built_in">Object</span>.create(animal);<span class="comment">//等同于rabbit.__proto__=animal</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(rabbit)<span class="comment">//获取原型</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(rabbit, &#123;&#125;)<span class="comment">//设置原型</span></span><br></pre></td></tr></table></figure>

<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>如果没赋值的话就使用默认值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [name = <span class="string">&quot;Guest&quot;</span>, surname = <span class="string">&quot;Anonymous&quot;</span>] = [<span class="string">&quot;Julius&quot;</span>];</span><br></pre></td></tr></table></figure>

<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数:"></a>函数参数:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;zzx&quot;</span>,</span><br><span class="line">    <span class="attr">price</span>:[<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = (&#123;name=<span class="string">&quot;Stu&quot;</span>,age=<span class="number">18</span>,price&#125;)&#123;...&#125;</span><br><span class="line">f(options)</span><br></pre></td></tr></table></figure>

<p>这里实现的效果就是:把 options 有的参数赋给函数,没有的就用默认值<br>但是注意调用函数的时候要用 f({})这种,不能只写个括号会报错</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><ul>
<li>当 js 中的一个数据无法被任何引用获取时就被视作垃圾,会被回收</li>
</ul>
<h2 id="函数相关"><a href="#函数相关" class="headerlink" title="函数相关"></a>函数相关</h2><ul>
<li>函数可以传入任意数量的参数,可以用<code>...</code>展开比如:<code>function f(...args)</code></li>
<li>函数内部可以使用<code>arguments</code>数组来访问对象,<strong>箭头函数没有</strong><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul>
<li>词法环境:相当于一个有着所有变量的对象,分为全局词法环境对象和内部词法环境对象.当访问一个变量时会由内而外一次访问词法环境对象来找值</li>
<li>闭包:是指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使在其外部函数被返回（寿命终结）了之后。(官方定义).JS 中,所有函数都是闭包的。<blockquote>
<p>简单来说，就是函数总可以访问到自己外部的变量；而函数和其周边变量的和就叫闭包<br>我们可以通过这种方式访问函数内部变量：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> age = <span class="number">18</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> Age = f1()<span class="comment">//Age就是f1内部的变量</span></span><br></pre></td></tr></table></figure>
解释下原理：首先 f1 内部的这个返回的函数是可以获取到 age 的，因为他和 age 构成了一个闭包；所以当 f1 返回这个函数的时候，也就相当于把这个函数的闭包一块返回了出去：这样就可以通过这个函数来获取 f1 内部的值</li>
</ul>
</li>
<li>函数可以有自己的属性：通过这样可以给函数制造一个独有的变量，比如：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    f1.counter++</span><br><span class="line">&#125;</span><br><span class="line">f1.counter = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ul>
<li>this:指向最近的 obj 对象<ul>
<li>直接用或者函数里用,表示 window</li>
<li>class 里表示这个类</li>
<li>构造函数里表示实例对象(new 了以后)</li>
<li>在事件中表示触发事件的对象,比如 click 事件的 this 就会是 button 元素</li>
<li>对象中的方法:就是指这个对象</li>
</ul>
</li>
<li>this 的 bind apply call<ul>
<li>bind:一般给函数使用,bind 一个变量,让函数内部的 this 指向这个变量<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;zzx&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">f1.bind(obj1)<span class="comment">//调用的时候就是obj作为this的指向了</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><blockquote>
<p>Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。</p>
</blockquote>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><code>let p = new Proxy(target, handler);</code><br>target是你要代理的对象.它可以是JavaScript中的任何合法对象.如: (数组, 对象, 函数等等)handler是你要自定义操作方法的一个集合.p是一个被代理后的新对象,它拥有target的一切属性和方法.只不过其行为和结果是在handler中自定义的.<br>也就是说,代理出来的对象可以完成一些操作:比如拦截你对代理对象的读写,然后加上自己设定的操作<br>上代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a = <span class="number">1</span>,</span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> handler =  &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target,key,value</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(key === <span class="string">&#x27;c&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;我是代理&#x27;</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> target[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target,key,value</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value === <span class="number">4</span>)&#123;</span><br><span class="line">            target[key] = <span class="string">&#x27;拦截设置&#x27;</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                target[key] = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="built_in">Proxy</span>(obj,handler)</span><br><span class="line">p.a<span class="comment">//1</span></span><br><span class="line">p.c<span class="comment">//&#x27;我是代理&#x27;</span></span><br><span class="line">p.d = <span class="number">5</span><span class="comment">//5</span></span><br><span class="line">p.e = <span class="number">4</span></span><br><span class="line"><span class="built_in">console</span>.log(p.e)<span class="comment">//&#x27;拦截设置&#x27;</span></span><br></pre></td></tr></table></figure>
<p>解释一下:首先target是要代理的对象,handler也是个对象,有很多方法,常用的就是他的getter和setter;<br>当我们访问属性的时候实际上触发了getter,于是get函数内判断如果访问的键名是c就返回一个自己设定的值<br>setter也同理:设置值为4的时候会触发改变值</p>
<h2 id="线程和异步"><a href="#线程和异步" class="headerlink" title="线程和异步"></a>线程和异步</h2><h3 id="js-是单线程的"><a href="#js-是单线程的" class="headerlink" title="js 是单线程的"></a>js 是单线程的</h3><ul>
<li>单线程的原因:防止多线程情况下重复操作 dom</li>
<li>js 是单线程,但是浏览器内核不是单线程,这也是 js 实现异步的基础<h3 id="js-异步"><a href="#js-异步" class="headerlink" title="js 异步"></a>js 异步</h3></li>
<li>异步一般有两种:回调函数和 promise</li>
<li>异步的实现:简单来说就是,js 发现一个异步函数,就把他放到另外一个线程去,然后继续执行后面的代码.当同步任务全部执行完成后,异步线程的任务会将所有任务封装成消息通知给主线程;主线程根据消息通知从异步线程取出任务去执行.消息通知的途径就是消息队列;反复检查消息队列并调用就是事件循环<h3 id="消息队列和事件循环"><a href="#消息队列和事件循环" class="headerlink" title="消息队列和事件循环"></a>消息队列和事件循环</h3></li>
<li>消息就是注册异步任务时添加的回调函数。</li>
<li>事件循环是 JavaScript 实现异步的具体解决方案，其中同步代码直接执行；异步函数先放在异步队列中，待同步函数执行完毕后，轮询执行异步队列的回调函数。<h3 id="异步线程"><a href="#异步线程" class="headerlink" title="异步线程"></a>异步线程</h3></li>
<li>首先异步线程中有宏任务和微任务之分:执行先执行宏再执行微</li>
<li>异步一般主要的三个例子:回调,定时器,promise</li>
</ul>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line"><span class="comment">//输出1423</span></span><br></pre></td></tr></table></figure>

<h4 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h4><ul>
<li>回调是宏任务</li>
<li>回调在主线程生成,发现后放到异步线程;</li>
<li>当触发回调的事件没有产生,就让回调一直等待</li>
<li>当触发回调,异步线程把函数封装成 js 对象然后构造一条消息,让主线程执行该函数;异步线程把消息放到队列中等待执行;主线程收到消息就会执行该函数</li>
<li>执行完毕,从异步线程和主线程都消失,等待下一次触发<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4></li>
<li>定时器其实也是回调,只不过触发事件的方式是时间到<h4 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h4></li>
<li>promise 就是微任务</li>
<li>promise 对象产生在同步线程中,其后的.then 会当做回调一样放入异步线程</li>
<li>后续执行同回调<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3></li>
<li>await 被用在 promise 语句中</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">getUserName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> axios.get(<span class="string">&#x27;/api/&#x27;</span>)</span><br><span class="line">    res.data<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">getByFetch</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> fetch(<span class="string">&#x27;/api&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">await</span> <span class="built_in">JSON</span>.prase(res.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以这么用</span></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;/article/promise-chaining/user.json&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">await</span> response.json();</span><br><span class="line">    ...</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>Generator 函数最大特点就是可以交出函数的执行权（即暂停执行）。整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器 ）g 。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针 g 的 next 方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的 yield 语句，上例是执行到 x + 2 为止。<br>每次调用 next 方法，会返回一个对象，表示当前阶段的信息（ value 属性和 done 属性）。value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。<br>generator 函数写法:<br><code>function* gen()</code><br>*紧跟 function</p>
<h3 id="next"><a href="#next" class="headerlink" title="next"></a>next</h3><blockquote>
<p>next 方法可以带一个参数，该参数就会被当作上一个 yield 表达式的返回值。</p>
</blockquote>
<h3 id="for-of-迭代"><a href="#for-of-迭代" class="headerlink" title="for of 迭代"></a>for of 迭代</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> gen)&#123;</span><br><span class="line">    clg(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 2</span></span><br></pre></td></tr></table></figure>
<p>迭代不会返回返回值对应的值<br>或者还可以这样:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数一样</span></span><br><span class="line"><span class="keyword">let</span> genArr = [...gen()]<span class="comment">//[1,2]</span></span><br></pre></td></tr></table></figure>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">getUserNames</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> axios.get(<span class="string">&#x27;/api&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = getUserNames()</span><br><span class="line">g.next().then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;clg(res.data)&#125;)</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">let</span> res = <span class="keyword">await</span> g.next()</span><br></pre></td></tr></table></figure>
<p>用法有一点像 await,但是区别在于 yield 是直接暂停执行,需要 next</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="导入和导出"><a href="#导入和导出" class="headerlink" title="导入和导出"></a>导入和导出</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;aa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f1 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    clg(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;arr,obj,f1&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;arr,obj,f1&#125; <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span> <span class="comment">//名字要一样</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> all <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span> <span class="comment">//把全部放在all这个对象里边</span></span><br></pre></td></tr></table></figure>
<p>最基本的导出,导入时名字要和导出时一样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">TheUser</span></span>&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;aaa&#x27;</span></span><br><span class="line">    <span class="function"><span class="title">use</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        clg(<span class="string">&#x27;i can use&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//b.js</span></span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>默认导出,可以自己定义导入的名字,也不需要花括号.<strong>每个文件只能用一个默认导出</strong></p>
<h3 id="module-export-和-export-的区别"><a href="#module-export-和-export-的区别" class="headerlink" title="module.export 和 export 的区别"></a>module.export 和 export 的区别</h3><p>假设我作为模块使用者，要在我的代码中导入一个函数：<br><code>const func = require(&#39;./module&#39;);</code><br>则编写者只能使用 module.exports 来定义：<br><code>module.exports = function () &#123;&#125;</code><br>如果编写者使用 exports 来定义：<br><code>exports.func = function () &#123;&#125;</code><br>则使用者必须知道该函数的名称才能使用：<br><code>const &#123; func &#125; = require(&#39;./module&#39;);</code><br>把函数换成变量、常量或其它，也是一样道理。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类就是一个构造函数</p>
<h3 id="super-和-constructor"><a href="#super-和-constructor" class="headerlink" title="super 和 constructor"></a>super 和 constructor</h3><p>super 是调用父类属性和方法时使用的,如果不调用就不需要,constructor 也不是必须的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">speed</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.speed = speed</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">price</span>:<span class="number">100</span></span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;aCar&#x27;</span></span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;i can run&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">stop</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.speed = <span class="number">0</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;i cant run&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMW</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="attr">price</span>:<span class="number">200</span><span class="comment">//重写</span></span><br><span class="line">    <span class="function"><span class="title">stop</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.stop()<span class="comment">//super调用父类方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bmw = <span class="keyword">new</span> BMW(<span class="number">100</span>)</span><br><span class="line">bmw.speed<span class="comment">//100</span></span><br><span class="line">bmw.stop<span class="comment">//i cant run</span></span><br><span class="line">bmw.speed<span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p>上面这个例子说明了几点:首先 constructor 是初始化类用到的,参数就是 new Car()传进来的,如果不需要初始化就不用;<br>其次 super 只能调用父类方法,属性不行(属性会自动继承)<br>子类的 stop 实际上是覆写了父类的方法,调用时先调用子类再是父类<br>同理,constructor 也可以覆写:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Car类同上</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Benz</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">speed,name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(speed)</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> benz = <span class="keyword">new</span> Benz(<span class="number">100</span>,<span class="string">&#x27;benzz&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p> 一定要有 super 并且在 this 之前;负责继承父类的 constructor 内的参数,也就是说 Car 类的 speed 还需要传入</p>
<h2 id="事件-冒泡和捕获和委托"><a href="#事件-冒泡和捕获和委托" class="headerlink" title="事件:冒泡和捕获和委托"></a>事件:冒泡和捕获和委托</h2><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><blockquote>
<p>当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序。</p>
</blockquote>
<p>也就是说,触发一个元素的事件会从下向上连着触发它父元素和祖元素的事件</p>
<h3 id="event-target-和-event-currentTarget-和-this"><a href="#event-target-和-event-currentTarget-和-this" class="headerlink" title="event.target 和 event.currentTarget 和 this"></a>event.target 和 event.currentTarget 和 this</h3><p>this=event.currentTarget;他们和 target 的区别在于:target 是指具体触发的元素,this 是指事件被插入的位置那个元素<br>比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;main&quot;</span>&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span>clickme<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">//js</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;main&#x27;</span>)[<span class="number">0</span>].addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    clg(event.target)</span><br><span class="line">    clg(<span class="built_in">this</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这个时候如果点击里边的 inner,this 就还是 main,而 target 则是点击的具体元素:inner</p>
<h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><pre><code>就是冒泡的反向
</code></pre>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><blockquote>
<p>如果我们有许多以类似方式处理的元素，那么就不必为每个元素分配一个处理程序 —— 而是将单个处理程序放在它们的共同祖先上。</p>
</blockquote>
<p>举个栗子:比如说现在有一个 3*3 的单元格,现在想实现点击哪个单元格就让哪个变色</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> table = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;tab&#x27;</span>)</span><br><span class="line">table.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e.target.tagName !== <span class="string">&#x27;td&#x27;</span>) <span class="keyword">return</span></span><br><span class="line">    e.target.style.backgroundColor = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>Cookie 是浏览器访问服务器后，服务器传给浏览器的一段数据。浏览器需要保存这段数据，不得轻易删除。此后每次浏览器访问该服务器，都必须带上这段数据。</p>
<ul>
<li>cookie的一般格式<br>  <code>&quot;user=John; path=/; expires=Tue, 19 Jan 2038 03:14:07 GMT&quot;</code><br>  首先是个字符串,用分号分割;其次每一个分割出来的形式都是’a=b’这样的;最后cookie的键和值都可以是任意字符</li>
<li>cookie的读写:<br>  可以通过document.cookie来读写;其中写入时不会覆盖,如果键相同则会替换,如果不同则会新增<br>  另外,cookie除了键值还有其他很多属性</li>
</ul>
<h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><blockquote>
<p>函数防抖，就是指触发事件后，在 n 秒后只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数的执行时间。当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时.</p>
</blockquote>
<p>也就是说,一个动作连续触发但是只执行最后一次<br>上代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timeout = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;fn&#125;,wait)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;事件触发&#x27;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 滚动事件</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, debounce(handle, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>
<p>这段代码意思是:滚动停止后1000毫秒才会触发handle.思路就是:在debounce函数里边设置一个定时器,当触发函数时不立即执行fn,而是等wait秒后再执行;而如果调用时不停下来,<strong>就会反复清除定时</strong>,直到停下来为止再开始算<br>可以把timeout写在函数里边,然后debounce返回一个函数即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn,wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;fn()&#125;,wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面相同</span></span><br></pre></td></tr></table></figure>
<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><blockquote>
<p>每隔一段时间只执行一次函数</p>
</blockquote>
<p>就是说,判断两次操作间隔大于一定时间再执行(比如说一直拖着进度条就每一秒触发一次),所以可以有 两次时间戳相减/定时器 这两种实现方案</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间戳实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">        <span class="keyword">if</span>(now - pre &gt; wait)&#123;</span><br><span class="line">            fn();</span><br><span class="line">            pre = now</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;事件触发&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, throttle(handle, <span class="number">1000</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时器实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> isWait = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isWait) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            isWait = <span class="literal">true</span><span class="comment">//在间隔期把入口卡住</span></span><br><span class="line">            <span class="keyword">let</span> timeout = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;fn();isWait = <span class="literal">false</span>&#125;,wait)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//剩下一样</span></span><br></pre></td></tr></table></figure>
<p>解释一下定时器实现:首先isWait函数可以进入第一次触发;一旦进入else就把isWait改成true,这样就是在定时器计时期间不再有任何可以进入else分支;定时器计时完毕,isWait改为false,又可以进入了.所以如果一直触发节流,相当于每个wait间隔期间就不会触发,而过了间隔期就允许触发</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/">日常学习</a></div><div class="post_share"><div class="social-share" data-image="/img/starry3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/10/23/blog3_bindapplycall/"><img class="prev-cover" src="/img/codes1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">js中call apply bind详解</div></div></a></div><div class="next-post pull-right"><a href="/2021/10/23/blog4_gituse/"><img class="next-cover" src="/img/cloud.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">git学习和日常使用</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/10/27/blog10-react-router/" title="react-router的使用"><img class="cover" src="/img/reactrouter.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-27</div><div class="title">react-router的使用</div></div></a></div><div><a href="/2021/11/06/blog11-myReact/" title="react知识点汇总和使用小总结(一)"><img class="cover" src="/img/react.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-06</div><div class="title">react知识点汇总和使用小总结(一)</div></div></a></div><div><a href="/2021/11/06/blog12-myReact/" title="react知识点汇总和使用小总结(二)"><img class="cover" src="/img/react.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-06</div><div class="title">react知识点汇总和使用小总结(二)</div></div></a></div><div><a href="/2021/11/20/blog16-react-ts-router/" title="typescript+react:react-routerv6和旧版v5的使用"><img class="cover" src="/img/typescript.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-20</div><div class="title">typescript+react:react-routerv6和旧版v5的使用</div></div></a></div><div><a href="/2021/11/20/blog15-react-ts-basic/" title="typescript+react基础部分"><img class="cover" src="/img/typescript.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-20</div><div class="title">typescript+react基础部分</div></div></a></div><div><a href="/2021/10/23/blog2_manyPoint_css/" title="css小总结和复习"><img class="cover" src="/img/codes3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-23</div><div class="title">css小总结和复习</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/pinkstar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xing Ye</div><div class="author-info__description">a singleThreaded boy's blog</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/penghei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/penghei" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:632885485@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">A SingleThreaded Boy...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#js-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">js 数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#var-%E5%92%8C-let"><span class="toc-number">2.</span> <span class="toc-text">var 和 let</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C-amp-amp-%E5%92%8C"><span class="toc-number">3.</span> <span class="toc-text">||和&amp;&amp;和??</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#object-%E5%92%8C-symbol"><span class="toc-number">4.</span> <span class="toc-text">object 和 symbol</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#object"><span class="toc-number">4.1.</span> <span class="toc-text">object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#symbol"><span class="toc-number">4.2.</span> <span class="toc-text">symbol</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map-%E5%92%8C-Set"><span class="toc-number">5.</span> <span class="toc-text">Map 和 Set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE"><span class="toc-number">6.</span> <span class="toc-text">对象属性配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%A0%87%E5%BF%97%E7%AC%A6"><span class="toc-number">6.1.</span> <span class="toc-text">对象标志符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getter-%E5%92%8C-setter"><span class="toc-number">6.2.</span> <span class="toc-text">getter 和 setter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-number">7.</span> <span class="toc-text">原型链和继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B"><span class="toc-number">7.1.</span> <span class="toc-text">原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9E%8B"><span class="toc-number">7.2.</span> <span class="toc-text">原生的原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proto%E7%9A%84%E6%9B%BF%E4%BB%A3"><span class="toc-number">7.3.</span> <span class="toc-text">proto的替代</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">8.</span> <span class="toc-text">解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">8.1.</span> <span class="toc-text">默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">8.2.</span> <span class="toc-text">函数参数:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">9.</span> <span class="toc-text">垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3"><span class="toc-number">10.</span> <span class="toc-text">函数相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">10.1.</span> <span class="toc-text">闭包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this"><span class="toc-number">11.</span> <span class="toc-text">this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proxy"><span class="toc-number">12.</span> <span class="toc-text">Proxy</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">12.1.</span> <span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-number">13.</span> <span class="toc-text">线程和异步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#js-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84"><span class="toc-number">13.1.</span> <span class="toc-text">js 是单线程的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js-%E5%BC%82%E6%AD%A5"><span class="toc-number">13.2.</span> <span class="toc-text">js 异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">13.3.</span> <span class="toc-text">消息队列和事件循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B"><span class="toc-number">13.4.</span> <span class="toc-text">异步线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83"><span class="toc-number">13.4.1.</span> <span class="toc-text">回调</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">13.4.2.</span> <span class="toc-text">定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#promise"><span class="toc-number">13.4.3.</span> <span class="toc-text">promise</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-await"><span class="toc-number">13.5.</span> <span class="toc-text">async&#x2F;await</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#generator"><span class="toc-number">14.</span> <span class="toc-text">generator</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">14.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#next"><span class="toc-number">14.2.</span> <span class="toc-text">next</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-of-%E8%BF%AD%E4%BB%A3"><span class="toc-number">14.3.</span> <span class="toc-text">for of 迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">14.4.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97"><span class="toc-number">15.</span> <span class="toc-text">模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%92%8C%E5%AF%BC%E5%87%BA"><span class="toc-number">15.1.</span> <span class="toc-text">导入和导出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#module-export-%E5%92%8C-export-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">15.2.</span> <span class="toc-text">module.export 和 export 的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">16.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#super-%E5%92%8C-constructor"><span class="toc-number">16.1.</span> <span class="toc-text">super 和 constructor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6-%E5%86%92%E6%B3%A1%E5%92%8C%E6%8D%95%E8%8E%B7%E5%92%8C%E5%A7%94%E6%89%98"><span class="toc-number">17.</span> <span class="toc-text">事件:冒泡和捕获和委托</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-number">17.1.</span> <span class="toc-text">事件冒泡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#event-target-%E5%92%8C-event-currentTarget-%E5%92%8C-this"><span class="toc-number">17.2.</span> <span class="toc-text">event.target 和 event.currentTarget 和 this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7"><span class="toc-number">17.3.</span> <span class="toc-text">事件捕获</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">17.4.</span> <span class="toc-text">事件委托</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie"><span class="toc-number">18.</span> <span class="toc-text">cookie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-number">19.</span> <span class="toc-text">防抖和节流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%8A%96"><span class="toc-number">19.1.</span> <span class="toc-text">防抖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E6%B5%81"><span class="toc-number">19.2.</span> <span class="toc-text">节流</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/11/20/blog16-react-ts-router/" title="typescript+react:react-routerv6和旧版v5的使用"><img src="/img/typescript.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="typescript+react:react-routerv6和旧版v5的使用"/></a><div class="content"><a class="title" href="/2021/11/20/blog16-react-ts-router/" title="typescript+react:react-routerv6和旧版v5的使用">typescript+react:react-routerv6和旧版v5的使用</a><time datetime="2021-11-20T14:19:35.000Z" title="发表于 2021-11-20 22:19:35">2021-11-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/20/blog15-react-ts-basic/" title="typescript+react基础部分"><img src="/img/typescript.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="typescript+react基础部分"/></a><div class="content"><a class="title" href="/2021/11/20/blog15-react-ts-basic/" title="typescript+react基础部分">typescript+react基础部分</a><time datetime="2021-11-20T14:19:35.000Z" title="发表于 2021-11-20 22:19:35">2021-11-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/20/blog17-react-ts-hooks-redux/" title="typescript+react:自定义hooks代替redux"><img src="/img/typescript.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="typescript+react:自定义hooks代替redux"/></a><div class="content"><a class="title" href="/2021/11/20/blog17-react-ts-hooks-redux/" title="typescript+react:自定义hooks代替redux">typescript+react:自定义hooks代替redux</a><time datetime="2021-11-20T14:19:35.000Z" title="发表于 2021-11-20 22:19:35">2021-11-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/15/blog14-vue3/" title="vue3+ts+vuex/vuerouter配置及使用总结"><img src="/img/vue.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vue3+ts+vuex/vuerouter配置及使用总结"/></a><div class="content"><a class="title" href="/2021/11/15/blog14-vue3/" title="vue3+ts+vuex/vuerouter配置及使用总结">vue3+ts+vuex/vuerouter配置及使用总结</a><time datetime="2021-11-15T09:00:38.000Z" title="发表于 2021-11-15 17:00:38">2021-11-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/09/blog13-react-mycloudmusic/" title="react练手项目-网易云音乐总结"><img src="/img/cloudmusic.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="react练手项目-网易云音乐总结"/></a><div class="content"><a class="title" href="/2021/11/09/blog13-react-mycloudmusic/" title="react练手项目-网易云音乐总结">react练手项目-网易云音乐总结</a><time datetime="2021-11-09T09:00:38.000Z" title="发表于 2021-11-09 17:00:38">2021-11-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Xing Ye</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hello stranger!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>