<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>webpack学习 | XingYeBlog</title><meta name="keywords" content="日常学习"><meta name="author" content="Xing Ye,632885485@qq.com"><meta name="copyright" content="Xing Ye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Webpack 概述 Webpack 是一个模块打包工具，可以使用它管理项目中的模块依赖，并编译输出模块所需的静态文件。 它可以很好地管理、打包开发中所用到的 HTML,CSS,JavaScript 和静态文件（图片，字体）等，让开发更高效。 对于不同类型的依赖，Webpack 有对应的模块加载器，而且会分析模块间的依赖关系，最后合并生成优化的静态资源  核心概念 Entry：入口，Webpack">
<meta property="og:type" content="article">
<meta property="og:title" content="webpack学习">
<meta property="og:url" content="http://example.com/2022/01/09/blog35-webpack/index.html">
<meta property="og:site_name" content="XingYeBlog">
<meta property="og:description" content="Webpack 概述 Webpack 是一个模块打包工具，可以使用它管理项目中的模块依赖，并编译输出模块所需的静态文件。 它可以很好地管理、打包开发中所用到的 HTML,CSS,JavaScript 和静态文件（图片，字体）等，让开发更高效。 对于不同类型的依赖，Webpack 有对应的模块加载器，而且会分析模块间的依赖关系，最后合并生成优化的静态资源  核心概念 Entry：入口，Webpack">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/webpack.png">
<meta property="article:published_time" content="2022-01-09T05:14:15.000Z">
<meta property="article:modified_time" content="2022-05-12T06:09:01.679Z">
<meta property="article:author" content="Xing Ye">
<meta property="article:tag" content="日常学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/webpack.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2022/01/09/blog35-webpack/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'webpack学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-12 14:09:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/pinkstar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/webpack.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XingYeBlog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">webpack学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-09T05:14:15.000Z" title="发表于 2022-01-09 13:14:15">2022-01-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-12T06:09:01.679Z" title="更新于 2022-05-12 14:09:01">2022-05-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="webpack学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Webpack-概述"><a href="#Webpack-概述" class="headerlink" title="Webpack 概述"></a>Webpack 概述</h1><ol>
<li>Webpack 是一个模块打包工具，可以使用它管理项目中的模块依赖，并编译输出模块所需的静态文件。</li>
<li>它可以很好地管理、打包开发中所用到的 HTML,CSS,JavaScript 和静态文件（图片，字体）等，让开发更高效。</li>
<li>对于不同类型的依赖，Webpack 有对应的模块加载器，而且会分析模块间的依赖关系，最后合并生成优化的静态资源</li>
</ol>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul>
<li><p><code>Entry</code>：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。</p>
</li>
<li><p><code>Module</code>：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。<code>module</code>本质上是 webpack 对打包的基本单位，每一个文件都算一个 module；module 下有一个 rules 字段，rules 下有就是处理模块的规则，配置哪类的模块，交由哪类 loader 来处理。</p>
</li>
<li><p><code>Chunk</code>：代码块，Chunk 是 Webpack 打包过程中一堆 module 的集合。Webpack 的打包是从一个入口文件开始，也可以说是入口模块，入口模块引用这其他模块，模块再引用模块。Webpack 通过引用关系逐个打包模块，这些 module 就形成了一个 Chunk；一条路径一般只会形成一个 Chunk。<br>chunk 还有一些属性，被称为内置变量，可以在<code>filename</code>等配置中用<code>[]</code>引用，主要有：</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>Chunk 的唯一标识，从 0 开始</td>
</tr>
<tr>
<td>name</td>
<td>Chunk 的名称</td>
</tr>
<tr>
<td>hash</td>
<td>Chunk 的唯一标识的 Hash 值</td>
</tr>
<tr>
<td>chunkhash</td>
<td>Chunk 内容的 Hash 值</td>
</tr>
</tbody></table>
</li>
<li><p><code>Loader</code>：模块转换器，用于把模块原内容按照需求转换成新内容。</p>
</li>
<li><p><code>Plugin</code>：扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。</p>
</li>
</ul>
<blockquote>
<p>Loader 和 Plugin 的区别<br>Loader 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。<br>Plugin 就是插件，可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p>
</blockquote>
<ul>
<li><code>Output</code>：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。</li>
<li><code>Bundle</code>：最终的打包结果，即一般情况下输出的<code>bundle.js</code>文件。大多数时候<code>chunk</code>和<code>bundle</code>是一一对应的，但是如果开启了<code>sourceMap</code>可能会使<code>chunk</code>多一个。</li>
<li><code>Dependence</code>：依赖对象，webpack 基于该类型记录模块间依赖关系</li>
</ul>
<h2 id="安装使用及配置"><a href="#安装使用及配置" class="headerlink" title="安装使用及配置"></a>安装使用及配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>当前默认版本都是最新的 webpack5，对应的 loader、plugins 等也都是配套 5 的；当然 4 版本也有对应的 loader、plugin 版<br>这里除了 webpack 还会给出一些常用的安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli --save-dev</span><br><span class="line"></span><br><span class="line"># devServer</span><br><span class="line">npm install --save-dev webpack-dev-server</span><br><span class="line"></span><br><span class="line"># loader</span><br><span class="line"></span><br><span class="line">npm install --save-dev style-loader css-loader</span><br><span class="line">npm install --save-dev file-loader</span><br><span class="line">npm install --save-dev babel-loader</span><br><span class="line">npm install --save-dev typescript ts-loader</span><br><span class="line"></span><br><span class="line"># plugin</span><br><span class="line"></span><br><span class="line">npm install --save-dev html-webpack-plugin</span><br><span class="line">npm install --save-dev clean-webpack-plugin</span><br></pre></td></tr></table></figure>

<h3 id="命令配置"><a href="#命令配置" class="headerlink" title="命令配置"></a>命令配置</h3><p>这两个命令分别实现基础的配置和 devServer 的运行；</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;webpack serve --open&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>如果不生效或者报错，也可以用 npx xxx 来运行</p>
<h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><p>基本文件目录如下：<br><img src="https://pic.imgdb.cn/item/61da8cf42ab3f51d91c12781.png"></p>
<ul>
<li>assert 用于存放静态文件，包括图片等</li>
<li>dist 为设定的输出文件所在位置，以及 html-webpack-plugin 生成 html 文件的位置；如果有模板 html 最好放在 assert 防止被 clean 清除</li>
<li>src 为主要 js 或 css 文件</li>
<li>webpack.config.js 是 webpack 的设定文件</li>
</ul>
<blockquote>
<p>注意：html 文件尽量不要自己写，容易导致 devServer 找不到 html 文件；<br>一般来说 index.html 放在 dist 文件夹下，使用绝对路径(src=”bundle.js”)引入打包 js 并插入到 head 中；这点很重要！！！devServer 的根路径就是 dist 文件夹，因此建议使用 html-webpack-plugin 自动生成，不容易出错</p>
</blockquote>
<h1 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h1><p>webpack.config.js 作为 webpack 的配置文件，通常会导出一个对象给 webpack 配置使用；由于 webpack 是一个黑盒，我们不需要直到内部运行，相关的配置几乎都是在这个文件中完成并实现的。</p>
<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>引入模块是和 nodejs 一样的 commonJS 导入导出的</li>
<li>entry 是入口，表示 webpack 该从哪个文件进入开始配置；entry 可以是字符串、数组和对象（多个入口），字符串表示根目录下的相对路径；</li>
<li>output 是输出位置，内部可以配置 filename 输出文件名、path 路径等。</li>
<li>module 是 loader 的配置项；</li>
<li>plugins 是一个数组，用于配置插件，插件的形式都是 <code>new xxx()</code></li>
<li>mode 表示输出文件的模式，默认为 production 即生产环境，代码会进行压缩；none 是不进行压缩</li>
</ul>
<h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><p>Entry 类型可以是以下三种中的一种或者相互组合：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>例子</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td><code>&#39;./src/entry&#39;</code></td>
<td>入口模块的文件路径，可以是相对路径。</td>
</tr>
<tr>
<td>array</td>
<td><code>[&#39;./src/entry1&#39;, &#39;./src/entry2&#39;]</code></td>
<td>数组最后一个文件是资源的入口文件，数组其余文件会预先构建到入口文件。</td>
</tr>
<tr>
<td>object</td>
<td><code>&#123; a: &#39;./src/entry-a&#39;, b: [&#39;./src/entry-b1&#39;, &#39;./src/entry-b2&#39;]&#125;</code></td>
<td>配置多个入口，每个入口生成一个 Chunk，filename 的 <code>[name]</code> 对应这里的键名</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">  <span class="attr">entry</span>: [<span class="string">&quot;./src/entry1&quot;</span>, <span class="string">&quot;./src/entry2&quot;</span>],</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">app1</span>: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">    <span class="attr">app2</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果是 string 和 array 型的 entry 生成的 chunk 名默认都是 <code>main</code>，而 object 形式的 entry 会依据键名生成对应的 chunk 名</p>
<h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p>配置输出代码，主要有以下几个配置项：</p>
<h4 id="output-filename"><a href="#output-filename" class="headerlink" title="output.filename"></a>output.filename</h4><ul>
<li>filename 除了可以是一个文件名称，也可以是相对地址，例如<code>&#39;./js/bundle.js&#39;</code>；最终打包输出的文件是 path 绝对路径与 filename 的拼接后的地址。</li>
<li>filename 支持类似变量的方式生成动态文件名，主要写法有以下几种：<ul>
<li><code>hash</code>：<code>&#39;[hash].js&#39;</code>，表示文件的哈希值，用于区分不同文件；一般前 8 位即可，用<code>[hash:8]</code>可以取到前 8 位。hash 是根据打包中所有的文件计算出的 hash 值。在一次打包中，所有出口文件的 filename 获得的[hash]都是<strong>一样</strong>的。</li>
<li><code>id</code>：Chunk 的唯一标识，从 0 开始</li>
<li><code>name</code>：chunk 的名字，即原文件的名字，如果 entry 是对象形式就是和 entry 的键名保持一致</li>
<li><code>chunkhash</code>：Chunk 内容的 Hash 值，相比于 hash，每个 chunk 对应的出口 filename 获得的[chunkhash]是不一样的。这样可以保证打包后每一个 JS 文件名都<strong>不一样</strong></li>
</ul>
</li>
</ul>
<h4 id="output-path"><a href="#output-path" class="headerlink" title="output.path"></a>output.path</h4><p>output 的 path 要求一定是<strong>绝对路径</strong>，因此要用 nodejs 的 path 功能拼接当前绝对位置和文件夹；<br>基本格式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./a.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>webpack5 中增加一个 clean 配置项，相当于清理上次打包文件的插件，并且在启动 devServer 时也能生效</p>
<h4 id="output-publicPath"><a href="#output-publicPath" class="headerlink" title="output.publicPath"></a>output.publicPath</h4><p>通常指资源访问路径，即相当于一个根目录，表示配置发布到线上资源的 URL 前缀，为 string 类型。 默认值是空字符串 ‘’，即使用相对路径。<br>比如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filename: <span class="string">&quot;[name]_[chunkhash:8].js&quot;</span>;</span><br><span class="line">publicPath: <span class="string">&quot;https://cdn.example.com/assets/&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>表示 html 中引入文件的路径就应该是</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.example.com/assets/a_12345678.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="loader（module）"><a href="#loader（module）" class="headerlink" title="loader（module）"></a>loader（module）</h3><p>loader 属于配置项的 module 部分，主要用于解析、处理项目中的非 js、html 部分解析或者对文件进行一些预处理<br>主要体现于 rules 数组中，数组里每一项都描述了如何去处理部分文件。 配置一项 rules 时大致通过以下方式：</p>
<ol>
<li><code>条件匹配</code>：通过 <code>test</code>（正则匹配）、 <code>include</code>（包含） 、 <code>exclude</code>（排除） 三个配置项来命中 Loader 要应用规则的文件。</li>
<li><code>应用规则</code>：对选中后的文件通过 <code>use</code> 配置项来应用 Loader，可以只应用一个 Loader 或者按照从后往前的顺序应用一组 Loader，同时还可以分别给 Loader 传入参数。</li>
<li><code>重置顺序</code>：Loader 的执行顺序默认是<strong>从下向上、从右到左</strong>执行，通过 <code>enforce</code> 选项可以让其中一个 Loader 的执行顺序放到最前或者最后。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">            <span class="attr">exclude</span>:<span class="regexp">/node_modules/</span>,</span><br><span class="line">            include:<span class="regexp">/src/</span>,</span><br><span class="line">            enforce:<span class="string">&#x27;pre&#x27;</span>,<span class="comment">//强制use从左向右执行，post为从右向左，即默认的</span></span><br><span class="line">            <span class="attr">noParse</span>: <span class="regexp">/jquery|chartjs/</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>test</code> 是正则表达式或者正则数组，一般用以解析文件后缀</li>
<li><code>use</code> 可以有字符串、数组、对象三种写法；字符串和数组都是指一个或多个 loader，对象形式表示对 loader 的额外配置</li>
<li><code>exclude</code> 与 <code>include</code> 可以表示排除或只选中哪些文件，同样是用正则，也可以使用类似<code>path</code>的写法指定文件</li>
<li><code>Enforce</code> 用来强制当前 loader 在前或者在后执行，可以有<code>&#39;pre&#39;</code>和<code>&#39;post&#39;</code>两种写法</li>
<li><code>noParser</code>：可以让 Webpack 忽略对部分没采用模块化的文件的递归解析和处理，比如 jQuery 等；写法是正则、正则数组或返回正则值的函数；</li>
<li><code>parser</code>：parser 属性可以更细粒度的配置哪些模块语法要解析，哪些不解析，比如下面这样：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      use: [<span class="string">&quot;babel-loader&quot;</span>],</span><br><span class="line">      <span class="attr">parser</span>: &#123;</span><br><span class="line">        <span class="attr">amd</span>: <span class="literal">false</span>, <span class="comment">// 禁用 AMD</span></span><br><span class="line">        <span class="attr">commonjs</span>: <span class="literal">false</span>, <span class="comment">// 禁用 CommonJS</span></span><br><span class="line">        <span class="attr">system</span>: <span class="literal">false</span>, <span class="comment">// 禁用 SystemJS</span></span><br><span class="line">        <span class="attr">harmony</span>: <span class="literal">false</span>, <span class="comment">// 禁用 ES6 import/export</span></span><br><span class="line">        <span class="attr">requireInclude</span>: <span class="literal">false</span>, <span class="comment">// 禁用 require.include</span></span><br><span class="line">        <span class="attr">requireEnsure</span>: <span class="literal">false</span>, <span class="comment">// 禁用 require.ensure</span></span><br><span class="line">        <span class="attr">requireContext</span>: <span class="literal">false</span>, <span class="comment">// 禁用 require.context</span></span><br><span class="line">        <span class="attr">browserify</span>: <span class="literal">false</span>, <span class="comment">// 禁用 browserify</span></span><br><span class="line">        <span class="attr">requireJs</span>: <span class="literal">false</span>, <span class="comment">// 禁用 requirejs</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="use-的写法"><a href="#use-的写法" class="headerlink" title="use 的写法"></a>use 的写法</h4><p>如果只有一个 loader 且没有额外配置就用字符串即可；<br>use 为数组时，loader 会按照从左至右的顺序执行；对于 css 等需要严格依照顺序不然会报错；<br>use 为对象的形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    use: &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h3><p>webpack 具有解析特殊配置路径的能力，也就是通过配置 resolve，可以把一些 import 的写法解析简化<br>基本写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="resolve-alias"><a href="#resolve-alias" class="headerlink" title="resolve.alias"></a>resolve.alias</h4><p>resolve.alias 配置项通过别名来把原导入路径映射成一个新的导入路径；实质上是一种代换，把匹配的字符替换为对应的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  <span class="attr">alias</span>: &#123;</span><br><span class="line">    <span class="attr">components</span>: <span class="string">&quot;./src/components/&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>意思是 import 的路径中包含 components 的会被替换为后面的内容，比如<code>import _ from &#39;components/lodash</code>就相当于<code>import _ from &#39;./src/components/lodash</code></p>
<p>精确匹配可以使用$结尾的字符串做键名<br>比如下面表示只有单纯的<code>&#39;react&#39;</code>才可以被解析，<code>&#39;react/xxx&#39;</code>或者<code>&#39;xx/react&#39;</code>都不会被解析；<br>并且会把<code>import &#39;react&#39;</code>转化为<code>import &#39;/path/to/react.min.js&#39;</code>的形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="attr">react$</span>: <span class="string">&quot;/path/to/react.min.js&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个配置提供了一种快速引入的方式；比如 vue 的@符引入的方式简化长串的导入</p>
<h4 id="resolve-extensions"><a href="#resolve-extensions" class="headerlink" title="resolve.extensions"></a>resolve.extensions</h4><p>用于给导入语句的后缀自动加上<br>比如默认配置<code>extensions: [&#39;.js&#39;, &#39;.json&#39;]</code>，表示对于<code>&#39;./b&#39;</code>这样的无后缀引入会先查找 <code>b.js</code> 文件，再查找 <code>b.json</code></p>
<blockquote>
<p>ts 不允许引入后缀为 ts 的文件，因此就必须要有<code>extensions: [&#39;.ts&#39;, &#39;.js&#39;, &#39;.json&#39;]</code>这样的配置以保证解析</p>
</blockquote>
<p>对应的一个配置是<code>enforceExtension</code>，如果设置为 true，那么所有的文件都必须开启后缀。</p>
<h4 id="resolve-modules"><a href="#resolve-modules" class="headerlink" title="resolve.modules"></a>resolve.modules</h4><p>配置 Webpack 去哪些目录下寻找第三方模块，默认是只会去 node_modules 目录下寻找。<br>这个配置可以用于简化一些超长的路径，比如经常需要<code>../../../../xxx</code>地翻找路径，可以通过配置 modules 为’./src/components’使得导入默认在路径下寻找</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modules: [<span class="string">&quot;./src/components&quot;</span>, <span class="string">&quot;node_modules&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>就可以直接用<code>import xxx from &#39;xxx&#39;</code>引入，webpack 会默认到<code>./src/components </code>下去寻找</p>
<h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p>Plugin 的配置很简单，plugins 配置项接受一个数组，数组里每一项都是一个要使用的 Plugin 的实例，Plugin 需要的参数通过构造函数传入。</p>
<blockquote>
<p>使用 Plugin 的难点在于掌握 Plugin 本身提供的配置项，而不是如何在 Webpack 中接入 Plugin。几乎所有 Webpack 无法直接实现的功能都能在社区找到开源的 Plugin 去解决</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&quot;template.html&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ul>
<li>plugin 不同于 loader，使用时必须先引入；</li>
<li>plugin 的形式都为 new xxxPlugin()；其中参数写在对象里，如<code>new HtmlWebpackPlugin(&#123;template: &quot;template.html&quot;&#125;),</code></li>
</ul>
<h3 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h3><p>在项目根目录执行<code>npx webpack-dev-server</code>，就启动了 webpack-dev-server。</p>
<blockquote>
<p>如果 devServer 启动后的网页出现问题，可以将路由导航至 /webpack-dev-server 将会展示服务文件的位置。例如： <a target="_blank" rel="noopener" href="http://localhost:9000/webpack-dev-server%E3%80%82">http://localhost:9000/webpack-dev-server。</a><br>效果如下：<br><img src="https://pic.imgdb.cn/item/61f42a072ab3f51d917ddfd9.png"></p>
</blockquote>
<p>devServer 也是可配置的，上面的 proxy 就是 devServer 配置的一种<br>常用的配置有：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  <span class="attr">hot</span>:<span class="literal">true</span>, <span class="comment">// 它是热更新：只更新改变的组件或者模块，不会整体刷新页面，在webpack5中默认开启</span></span><br><span class="line">  <span class="attr">open</span>: <span class="literal">true</span>, <span class="comment">// 是否自动打开浏览器，webpack5中默认开启</span></span><br><span class="line">  <span class="attr">proxy</span>: &#123; &#125;,<span class="comment">//代理</span></span><br><span class="line">  <span class="attr">client</span>:&#123;</span><br><span class="line">    <span class="attr">logging</span>:<span class="string">&#x27;log&#x27;</span> | <span class="string">&#x27;info&#x27;</span> | <span class="string">&#x27;warn&#x27;</span> | <span class="string">&#x27;error&#x27;</span> | <span class="string">&#x27;none&#x27;</span> | <span class="string">&#x27;verbose&#x27;</span>,<span class="comment">//在浏览器中设置日志级别</span></span><br><span class="line">    <span class="attr">overlay</span>: <span class="literal">true</span>,<span class="comment">//当出现编译错误或警告时，在浏览器中显示全屏覆盖。</span></span><br><span class="line">    <span class="attr">progress</span>: <span class="literal">true</span>,<span class="comment">//以百分比显示编译进度。</span></span><br><span class="line">    <span class="attr">reconnect</span>: <span class="literal">true</span>,<span class="comment">//尝试重新连接客户端的次数。当为 true 时，它将无限次尝试重新连接。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">http2</span>: <span class="literal">true</span>,<span class="comment">//启用HTTP2</span></span><br><span class="line">  <span class="attr">https</span>: <span class="literal">true</span>,<span class="comment">//启用https，自动生成证书</span></span><br><span class="line">  <span class="attr">historyApiFallback</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">contentBase</span>: path.join(__dirname, <span class="string">&#x27;public&#x27;</span>),<span class="comment">//配置 DevServer HTTP 服务器的文件根目录</span></span><br><span class="line">  <span class="attr">host</span>:<span class="string">`127.0.0.1`</span>,</span><br><span class="line">  <span class="attr">port</span>:<span class="string">&#x27;8081&#x27;</span><span class="comment">//启动的主机和端口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>historyApiFallback</code>：SPA 需要， 浏览器端的 JavaScript 代码会从 URL 里解析出当前页面的状态，显示出对应的界面（返回一个 html 文件），也就是前端路由<br>如果简单的配置为 true，都只会返回 index.html；因此需要明确配置，比如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">historyApiFallback: &#123;</span><br><span class="line">  <span class="comment">// 使用正则匹配命中路由</span></span><br><span class="line">  <span class="attr">rewrites</span>: [</span><br><span class="line">    <span class="comment">// /user 开头的都返回 user.html</span></span><br><span class="line">    &#123; <span class="attr">from</span>: <span class="regexp">/^\/user/</span>, to: <span class="string">&quot;/user.html&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">from</span>: <span class="regexp">/^\/game/</span>, to: <span class="string">&quot;/game.html&quot;</span> &#125;,</span><br><span class="line">    <span class="comment">// 其它的都返回 index.html</span></span><br><span class="line">    &#123; <span class="attr">from</span>: <span class="regexp">/./</span>, to: <span class="string">&quot;/index.html&quot;</span> &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="devServer-proxy"><a href="#devServer-proxy" class="headerlink" title="devServer.proxy"></a>devServer.proxy</h4><p>可以在 webpack 的 devServer 中配置代理解决前端跨域</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  <span class="attr">hot</span>:<span class="literal">true</span>, <span class="comment">// 它是热更新：只更新改变的组件或者模块，不会整体刷新页面</span></span><br><span class="line">  <span class="attr">open</span>: <span class="literal">true</span>, <span class="comment">// 是否自动打开浏览器</span></span><br><span class="line">  <span class="attr">proxy</span>: &#123; <span class="comment">// 配置代理（只在本地开发有效，上线无效）</span></span><br><span class="line">    <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">      <span class="attr">target</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>, <span class="comment">// 这是本地用node写的一个服务，用webpack-dev-server起的服务默认端口是8080</span></span><br><span class="line">      <span class="attr">pathRewrite</span>: &#123;<span class="string">&quot;/api&quot;</span> : <span class="string">&quot;&quot;</span>&#125;, <span class="comment">// 后台在转接的时候url中是没有 /api 的</span></span><br><span class="line">      <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">// 加了这个属性，那后端收到的请求头中的host是目标地址 target</span></span><br><span class="line">      <span class="attr">secure</span>: <span class="literal">false</span>, <span class="comment">// 若代理的地址是https协议，需要配置这个属性</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><ul>
<li>Target：让 Webpack 构建出针对不同运行环境的代码，比如 web、node、electron 等</li>
<li>Devtool：配置 Webpack 如何生成 Source Map，默认值是 false 即不生成 Source Map</li>
<li>Watch 和 WatchOptions：监听模式和其配置</li>
</ul>
<p>详见：<a target="_blank" rel="noopener" href="http://webpack.wuhaolin.cn/2%E9%85%8D%E7%BD%AE/2-7%E5%85%B6%E5%AE%83%E9%85%8D%E7%BD%AE%E9%A1%B9.html">http://webpack.wuhaolin.cn/2%E9%85%8D%E7%BD%AE/2-7%E5%85%B6%E5%AE%83%E9%85%8D%E7%BD%AE%E9%A1%B9.html</a></p>
<h2 id="配置类型"><a href="#配置类型" class="headerlink" title="配置类型"></a>配置类型</h2><p>通过<code>module.exports</code>导出的不一定是个对象，还可以是一个返回对象的函数，一个包含多种配置的数组，甚至是一个 Promise</p>
<p>详见<a target="_blank" rel="noopener" href="http://webpack.wuhaolin.cn/2%E9%85%8D%E7%BD%AE/2-9%E5%A4%9A%E7%A7%8D%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%9E%8B.html">http://webpack.wuhaolin.cn/2%E9%85%8D%E7%BD%AE/2-9%E5%A4%9A%E7%A7%8D%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%9E%8B.html</a></p>
<p>比如函数类型，能通过 JavaScript 灵活的控制配置，做到只用写一个配置文件，对于不同的环境采用不同的配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">&quot;webpack/lib/optimize/UglifyJsPlugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">env = &#123;&#125;, argv</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> plugins = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isProduction = env[<span class="string">&quot;production&quot;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在生成环境才压缩</span></span><br><span class="line">  <span class="keyword">if</span> (isProduction) &#123;</span><br><span class="line">    plugins.push(</span><br><span class="line">      <span class="comment">// 压缩输出的 JS 代码</span></span><br><span class="line">      <span class="keyword">new</span> UglifyJsPlugin()</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">plugins</span>: plugins,</span><br><span class="line">    <span class="comment">// 在生成环境不输出 Source Map</span></span><br><span class="line">    <span class="attr">devtool</span>: isProduction ? <span class="literal">undefined</span> : <span class="string">&quot;source-map&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在运行 Webpack 时，会给这个函数传入 2 个参数，分别是：</p>
<ul>
<li><code>env</code>：当前运行时的 Webpack 专属环境变量，<code>env</code> 是一个 Object。读取时直接访问 Object 的属性，设置它需要在启动 Webpack 时带上参数。例如启动命令是 <code>webpack --env.production --env.bao=foo</code>时，则 env 的值是 <code>&#123;&quot;production&quot;:&quot;true&quot;,&quot;bao&quot;:&quot;foo&quot;&#125;</code>。</li>
<li><code>argv</code>：代表在启动 Webpack 时所有通过命令行传入的参数，例如 <code>--config</code>、<code>--env</code>、<code>--devtool</code>，可以通过 <code>webpack -h</code> 列出所有 Webpack 支持的命令行参数。</li>
</ul>
<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p>
<ol>
<li><code>初始化阶段</code>：启动，初始化参数，创建 compiler 对象，加载 plugin<ol>
<li><code>初始化参数</code>：从配置文件、配置对象、命令行参数中读取，与默认配置结合得出最终的参数</li>
<li><code>创建编译器对象</code>：用上一步得到的参数创建 Compiler 对象</li>
<li><code>初始化编译环境</code>：包括注入内置插件、注册各种模块工厂、初始化 RuleSet 集合、加载配置的插件等</li>
<li><code>开始编译</code>：执行 compiler 对象的 run 方法</li>
<li><code>确定入口</code>：根据配置中的 entry 找出所有的入口文件，调用 compilition.addEntry 将入口文件转换为 dependence 对象</li>
</ol>
</li>
<li><code>构建阶段（编译）</code>：递归调用 module，期间通过 loader 翻译文件内容<ol>
<li><code>编译模块</code>：根据 entry 对应的 dependence 创建 module 对象，调用 loader 将模块转译为标准 JS 内容，调用 JS 解释器将内容转换为 AST 对象，从中找出该模块依赖的模块，再<strong>递归</strong>本步骤直到所有入口依赖的文件都经过了本步骤的处理</li>
<li><code>完成模块编译</code>：上一步递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的依赖关系图</li>
</ol>
</li>
<li><code>生成阶段（输出）</code>：对编译好的 module 组合成 chunk 并转化成文件（bundle.js）<ol>
<li><code>输出资源</code>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li>
<li><code>写入文件系统</code>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li>
</ol>
</li>
</ol>
<p>另外，监听模式下文件发生变化会回到第二步</p>
<h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>初始化阶段会发生的事件如下：</p>
<ol>
<li><code>初始化参数</code>：从配置文件和命令行语句中读取与合并参数，得出最终的参数。 这个过程中还会执行配置文件中的插件实例化语句 <code>new Plugin()</code>。</li>
<li><code>实例化 Compiler</code>：用上一步得到的参数初始化 <code>Compiler 实例</code>，<code>Compiler</code> 负责文件监听和启动编译。<code>Compiler</code> 实例中包含了完整的 Webpack 配置，全局只有<strong>一个</strong> <code>Compiler</code> 实例。</li>
<li><code>加载插件</code>：依次调用插件的 <code>apply</code> 方法，让插件可以监听后续的所有事件节点。同时给插件传入 <code>compiler</code> 实例的引用，以方便插件通过 <code>compiler</code> 调用 Webpack 提供的 API。</li>
<li><code>environment</code>：开始应用 <code>Node.js</code> 风格的文件系统到 <code>compiler</code> 对象，以方便后续的文件寻找和读取。</li>
<li><code>entry-option</code>：读取配置的 <code>Entry</code>，为每个 <code>Entry</code> 实例化一个对应的 <code>EntryPlugin</code>，为后面该 <code>Entry</code> 的递归解析工作做准备。</li>
<li><code>after-plugins</code>：调用完所有内置的和配置的插件的 <code>apply</code> 方法。</li>
<li><code>after-resolvers</code>：根据配置初始化完 <code>resolver</code>，<code>resolver</code> 负责在文件系统中寻找指定路径的文件。</li>
</ol>
<h3 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h3><ol>
<li><code>run</code>：启动一次新的编译。</li>
<li><code>watch-run</code>：和 run 类似，区别在于它是在监听模式下启动的编译，在这个事件中可以获取到是哪些文件发生了变化导致重新启动一次新的编译。</li>
<li><code>compile</code>：该事件是为了告诉插件一次新的编译将要启动，同时会给插件带上 <code>compiler</code> 对象。</li>
<li><code>compilation</code>：当 Webpack 以开发模式运行时，每当检测到文件变化，一次新的 <code>Compilation</code> 将被创建。一个 <code>Compilation</code> 对象包含了当前的模块资源、编译生成资源、变化的文件等。<code>Compilation</code> 对象也提供了很多事件回调供插件做扩展。<ol>
<li><code>build-module</code>：使用对应的 Loader 去转换一个模块。</li>
<li><code>normal-module-loader</code>：在用 Loader 对一个模块转换完后，使用 acorn 解析转换后的内容，输出对应的抽象语法树（AST），以方便 Webpack 后面对代码的分析。</li>
<li><code>program</code>：从配置的入口模块开始，分析其 AST，当遇到 require 等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系。</li>
<li><code>seal</code>：所有模块及其依赖的模块都通过 Loader 转换完成后，根据依赖关系开始生成 Chunk。</li>
</ol>
</li>
<li><code>make</code>：一个新的 <code>Compilation</code> 创建完毕，即将从 Entry 开始读取文件，根据文件类型和配置的 Loader 对文件进行编译，编译完后再找出该文件依赖的文件，递归的编译和解析。</li>
<li><code>after-compile</code>：一次 <code>Compilation</code> 执行完成。</li>
<li><code>invalid</code>：当遇到文件不存在、文件编译错误等异常时会触发该事件，该事件不会导致 Webpack 退出。</li>
</ol>
<h3 id="输出阶段"><a href="#输出阶段" class="headerlink" title="输出阶段"></a>输出阶段</h3><ol>
<li><code>should-emit</code>：所有需要输出的文件已经生成好，询问插件哪些文件需要输出，哪些不需要。</li>
<li><code>emit</code>：确定好要输出哪些文件后，执行文件输出，可以在这里获取和修改输出内容。</li>
<li><code>after-emit</code>：文件输出完毕。</li>
<li><code>done</code>：成功完成一次完成的编译和输出流程。</li>
<li><code>failed</code>：如果在编译和输出流程中遇到异常导致 Webpack 退出时，就会直接跳转到本步骤，插件可以在本事件中获取到具体的错误原因。</li>
</ol>
<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>loader 本质是一个函数，类似 nodejs 的中间件<br>最简单的 loader 长这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">&quot;node-sass&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// source 为 compiler 传递给 Loader 的一个文件的原内容</span></span><br><span class="line">  <span class="keyword">return</span> sass(source);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以通过调用 nodejs 的 api 来执行一些操作，当然 webpack 本身也提供了一些 loader 的 api</p>
<p>比如想制作一个去除所有 console.log 的 loader，就可以这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// removeClg.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> source.replace(<span class="regexp">/console.log\([&#x27;|&quot;](.*?)[&#x27;|&quot;]\)/</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>:<span class="regexp">/\.js$/</span>,</span><br><span class="line">  use:[&#123;</span><br><span class="line">    <span class="attr">loader</span>:path.resolve(__dirname,<span class="string">&#x27;./src/myloader.js&#x27;</span>)</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>getOptions</code> 可以获取调用 loader 传入的 options 参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">&quot;loader-utils&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取到用户给当前 Loader 传入的 options</span></span><br><span class="line">  <span class="keyword">const</span> options = loaderUtils.getOptions(<span class="built_in">this</span>);</span><br><span class="line">  <span class="keyword">return</span> source;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>this.callback</code> 可以方便 loader 和 Webpack 之间通信</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过 this.callback 告诉 Webpack 返回的结果</span></span><br><span class="line">  <span class="built_in">this</span>.callback(<span class="literal">null</span>, source, sourceMaps);</span><br><span class="line">  <span class="comment">// 当你使用 this.callback 返回内容时，该 Loader 必须返回 undefined，</span></span><br><span class="line">  <span class="comment">// 以让 Webpack 知道该 Loader 返回的结果在 this.callback 中，而不是 return 中</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>详细参考：<a target="_blank" rel="noopener" href="http://webpack.wuhaolin.cn/5%E5%8E%9F%E7%90%86/5-3%E7%BC%96%E5%86%99Loader.html">http://webpack.wuhaolin.cn/5%E5%8E%9F%E7%90%86/5-3%E7%BC%96%E5%86%99Loader.html</a></p>
<h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><p>plugin 是一个类，这点从 plugin 需要 new 调用可以看出来<br>最基本的 plugin：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicPlugin</span> </span>&#123;</span><br><span class="line">  <span class="comment">// options是传入的配置</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compiler是上面编译过程中提到的，初始化时会传入compiler对象给插件，以进行一些操作</span></span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">compiler</span>)</span> &#123;</span><br><span class="line">    compiler.plugin(<span class="string">&quot;compilation&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">compilation</span>) </span>&#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Webpack 启动后，在读取配置的过程中会先执行 <code>new BasicPlugin(options)</code> 初始化一个 <code>BasicPlugin</code> 获得其实例。 在初始化 <code>compiler</code> 对象后，再调用 <code>basicPlugin.apply(compiler)</code> 给插件实例传入 <code>compiler</code> 对象。 插件实例在获取到 <code>compiler</code> 对象后，就可以通过 <code>compiler.plugin(eventName, callback)</code> 监听到 Webpack 广播出来的事件。 并且可以通过 <code>compiler</code> 对象去操作 Webpack。</p>
<p>详见：<a target="_blank" rel="noopener" href="http://webpack.wuhaolin.cn/5%E5%8E%9F%E7%90%86/5-4%E7%BC%96%E5%86%99Plugin.html">http://webpack.wuhaolin.cn/5%E5%8E%9F%E7%90%86/5-4%E7%BC%96%E5%86%99Plugin.html</a></p>
<h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><p>webpack 相当于一条生产线，插件就像是插入的一个功能。<br>Webpack 通过 Tapable 来组织这条复杂的生产线，也就是基于 Tapable 框架的事件流<br>Webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作。</p>
<h3 id="Compiler-和-Compilation"><a href="#Compiler-和-Compilation" class="headerlink" title="Compiler 和 Compilation"></a>Compiler 和 Compilation</h3><p>其中 compiler 就是在 webpack 执行过程中实例化的 compiler 对象，插件可以利用它去获取消息和操作 webpack<br>这里区分 Compiler 和 Compilation:</p>
<blockquote>
<ul>
<li>Compiler 对象包含了 Webpack 环境所有的的配置信息，包含 options，loaders，plugins 这些信息，这个对象在 Webpack 启动时候被实例化，它是全局唯一的，可以简单地把它理解为 Webpack 实例；</li>
<li>Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。当 Webpack 以开发模式运行时，每当检测到一个文件变化，一次新的 Compilation 将被创建。Compilation 对象也提供了很多事件回调供插件做扩展。通过 Compilation 也能读取到 Compiler 对象。</li>
</ul>
</blockquote>
<p>Compiler 代表了整个 Webpack 从启动到关闭的生命周期，而 Compilation 只是代表了一次新的编译</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>nodejs 的环境变量是 <code>process.env</code>,根据操作系统的不同会有不同的变化;<code>process.env</code> 是一个对象，通过访问内部的环境变量可以进行一些操作<br>webpack 可以利用<code>webpack.DefinePlugin</code>插件设置一些环境变量，相当于一个全局变量，可以在任意处被直接访问</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">    <span class="attr">IS_OLD</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">MY_ENV</span>: <span class="built_in">JSON</span>.stringify(<span class="string">&quot;dev&quot;</span>),</span><br><span class="line">    <span class="attr">NAME</span>: <span class="string">&quot;&#x27;zzx&#x27;&quot;</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">],</span><br><span class="line">  <span class="comment">//a.js</span></span><br><span class="line">  <span class="built_in">console</span>.log(NAME);</span><br></pre></td></tr></table></figure>

<p>此外，webpack 也同样可以使用 process.env 访问环境变量；比如常用<code>process.env.NODE_ENV === &#39;production&#39;</code>判断是否在生产环境</p>
<h2 id="文件监听"><a href="#文件监听" class="headerlink" title="文件监听"></a>文件监听</h2><p>文件监听是在发现源码文件发生变化时，自动重新构建出新的输出文件；文件监听功能是 webpack 模块提供的，直接在配置中使用<code>watch:true</code>即可开启。<br>文件监听是<code>devServer</code>和<code>HMR</code>的基础，只有通过文件监听发现了更改和要更改的地方，才会通知这两者进行自动刷新工作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  <span class="comment">// 只有在开启监听模式时，watchOptions 才有意义</span></span><br><span class="line">  <span class="comment">// 默认为 false，也就是不开启</span></span><br><span class="line">  <span class="attr">watch</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 监听模式运行时的参数</span></span><br><span class="line">  <span class="comment">// 在开启监听模式时，才有意义</span></span><br><span class="line">  <span class="attr">watchOptions</span>: &#123;</span><br><span class="line">    <span class="comment">// 不监听的文件或文件夹，支持正则匹配</span></span><br><span class="line">    <span class="comment">// 默认为空</span></span><br><span class="line">    <span class="attr">ignored</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    <span class="comment">// 监听到变化发生后会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高</span></span><br><span class="line">    <span class="comment">// 默认为 300ms</span></span><br><span class="line">    aggregateTimeout: <span class="number">300</span>,</span><br><span class="line">    <span class="comment">// 判断文件是否发生变化是通过不停的去询问系统指定文件有没有变化实现的</span></span><br><span class="line">    <span class="comment">// 默认每隔1000毫秒询问一次</span></span><br><span class="line">    <span class="attr">poll</span>: <span class="number">1000</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>文件监听的原理主要如下：</p>
<ol>
<li>基本原理是定时获取文件的最后编辑时间，如果发现<strong>当前获取</strong>的和<strong>最后一次保存</strong>的最后编辑时间不一致，就认为该文件发生了变化。<code>poll</code>配置项就是配置这个“定时”，即每隔多久检查一次</li>
<li>文件发生变化并不会立即告知监听者，而是会先缓存，积累一段时间后再一次性告知。<code>aggregateTimeout</code>就是配置这个项，相当于一个防抖的效果，即连续更新停止一段事件后才会把所有之前的任务提交给监听者。</li>
<li>默认情况下 Webpack 会从配置的 Entry 文件出发，递归解析出 Entry 文件所依赖的文件，把这些依赖的文件都加入到监听列表中去，而不是一次性把所有文件都加入监听列表。</li>
</ol>
<h2 id="自动刷新"><a href="#自动刷新" class="headerlink" title="自动刷新"></a>自动刷新</h2><p><code>webpack</code> 模块负责监听文件，<code>webpack-dev-server</code> 模块则负责刷新浏览器。 在使用 <code>webpack-dev-server</code> 模块去启动 <code>webpack</code> 模块时，<code>webpack</code> 模块的监听模式默认会被开启。 <code>webpack</code> 模块会在文件发生变化时告诉 <code>webpack-dev-server</code> 模块。</p>
<p>控制浏览器刷新有三种方法：</p>
<ol>
<li>借助浏览器扩展去通过浏览器提供的接口刷新，WebStorm IDE 的 LiveEdit 功能就是这样实现的。</li>
<li>往要开发的网页中注入代理客户端代码，通过代理客户端去刷新整个页面。</li>
<li>把要开发的网页装进一个 iframe 中，通过刷新 iframe 去看到最新效果。</li>
</ol>
<p>devServer 采用的默认是第二种方法，可以配置为第三种（配置项<code>devServer</code>的<code>inline</code>设为 false 即可开启）。</p>
<h3 id="devServer-1"><a href="#devServer-1" class="headerlink" title="devServer"></a>devServer</h3><p>简单来说，devServer 相当于把打包出来的代码（dist 文件夹）部署到一个本地服务器，创建一个线上环境；然后启动一个 使用 express 的 Http 服务器用于服务网页请求，同时会帮助启动 Webpack ，并接收 Webpack 发出的文件更变信号，通过 WebSocket 协议自动刷新网页做到实时预览。</p>
<p><img src="https://pic.imgdb.cn/item/61db12b62ab3f51d91244c5a.png"></p>
<blockquote>
<p><code>webpack-dev-server</code>服务于的是资源文件，即主要为核心代码所在的 js 文件，不会对<code>index.html</code>的修改做出反应</p>
</blockquote>
<h3 id="HMR"><a href="#HMR" class="headerlink" title="HMR"></a>HMR</h3><p>HMR 就是 devServer 的热重载效果；模块热替换的原理和自动刷新原理类似，都需要往要开发的网页中注入一个代理客户端用于连接 DevServer 和网页， 不同在于模块热替换独特的模块替换机制；相比于自动刷新的代理客户端，多出了几个用于模块热替换的文件，也就是说代理客户端更大了。</p>
<p><img src="https://pic.imgdb.cn/item/624073d827f86abb2a67f487.jpg"></p>
<p>从上面可以看到，主要组成部分有本地文件、devServer、浏览器和插入浏览器的代理客户端。</p>
<ul>
<li>使用 <code>express</code> 启动本地服务，作为一个静态资源服务器，当浏览器访问资源时对此做响应。</li>
<li>服务端和客户端使用 <code>websocket</code> 实现长连接</li>
<li><code>webpack</code> 监听源文件的变化，即当开发者保存文件时触发 <code>webpack</code> 的重新编译。<ul>
<li>每次编译都会生成 hash 值、已改动模块的 json 文件、已改动模块代码的 js 文件</li>
<li>编译完成后通过 socket 向客户端推送当前编译的 <code>hash 戳</code></li>
</ul>
</li>
<li>客户端的 websocket 监听到有文件改动推送过来的<code>hash戳</code>，会和上一次对比，一致则走缓存，不一致则通过 <code>ajax</code> 和 <code>jsonp</code> 向服务端获取最新资源，使用内存文件系统去替换有修改的内容实现局部刷新。</li>
</ul>
<blockquote>
<p>HMR 处理的对象不包括 js，js 文件发生改变会触发刷新而不是热替换；一般针对的是 css 的样式改变进行热替换。</p>
</blockquote>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>关于 webpack 的优化有很多内容，因为其优化方式本身就有很多，原理有些也比较复杂。这里只总结一些常用或常问的，最重要的还是原理性理解</p>
<h2 id="缩小搜索范围"><a href="#缩小搜索范围" class="headerlink" title="缩小搜索范围"></a>缩小搜索范围</h2><ul>
<li>在 loader 中这一点体现为用 <code>include</code>、<code>exclude</code> 规定搜索范围从而减少搜索时间</li>
<li>设置 <code>resolve.modules</code> ，使用绝对路径指明第三方模块存放的位置，以减少搜索步骤</li>
<li>设置 <code>resolve.alias</code> 使复杂的路径减少搜索</li>
<li><code>resolve.extensions</code> 设置后缀减少无后缀文件搜索范围</li>
<li><code>resolve.mainFields</code> 只采用 main 字段作为入口文件描述字段 (减少搜索步骤，需要考虑到所有运行时依赖的第三方模块的入口文件描述字段)</li>
</ul>
<p>resolve 设置:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="comment">// 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤</span></span><br><span class="line">    <span class="attr">modules</span>: [path.resolve(__dirname, <span class="string">&quot;node_modules&quot;</span>)],</span><br><span class="line">    <span class="comment">// 只采用 main 字段作为入口文件描述字段，以减少搜索步骤</span></span><br><span class="line">    <span class="attr">mainFields</span>: [<span class="string">&quot;main&quot;</span>],</span><br><span class="line">    <span class="comment">//使用 alias 把导入 react 的语句换成直接使用单独完整的 react.min.js 文件</span></span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="attr">react</span>: path.resolve(</span><br><span class="line">        __dirname,</span><br><span class="line">        <span class="string">&quot;./node_modules/react/umd/react.production.min.js&quot;</span></span><br><span class="line">      ),</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//尽可能的减少后缀尝试的可能性,相当于这一项配置尽可能少;比如如果只导入jsx文件就可以只填jsx,减少对于js/json等的匹配</span></span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&quot;js&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="压缩代码"><a href="#压缩代码" class="headerlink" title="压缩代码"></a>压缩代码</h2><h3 id="压缩-js"><a href="#压缩-js" class="headerlink" title="压缩 js"></a>压缩 js</h3><p>主要使用 UglifyJsPlugin 通过封装 UglifyJS 实现压缩。<br>主要原理是删除一些没用的、占用时间的代码从而提升代码运行速度<br>比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// 压缩输出的 JS 代码</span></span><br><span class="line">    <span class="keyword">new</span> UglifyJSPlugin(&#123;</span><br><span class="line">      <span class="attr">compress</span>: &#123;</span><br><span class="line">        <span class="attr">warnings</span>: <span class="literal">false</span>, <span class="comment">// 在UglifyJs删除没有用到的代码时不输出警告</span></span><br><span class="line">        <span class="attr">drop_console</span>: <span class="literal">true</span>, <span class="comment">// 删除所有的 `console` 语句，可以兼容ie浏览器</span></span><br><span class="line">        <span class="attr">collapse_vars</span>: <span class="literal">true</span>, <span class="comment">// 内嵌定义了但是只用到一次的变量</span></span><br><span class="line">        <span class="attr">reduce_vars</span>: <span class="literal">true</span>, <span class="comment">// 提取出出现多次但是没有定义成变量去引用的静态值</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">beautify</span>: <span class="literal">false</span>, <span class="comment">// 最紧凑的输出</span></span><br><span class="line">        <span class="attr">comments</span>: <span class="literal">false</span>, <span class="comment">// 删除所有的注释</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>但是这种方法只能用于压缩 ES5 的代码，如果处理的文件中包含 ES6，就会报错退出；<br>因此有针对 ES6 的对应版本<code>UglifyES</code>；安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D uglifyjs-webpack-plugin</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> UglifyESPlugin(&#123;</span><br><span class="line">      <span class="comment">// 多嵌套了一层</span></span><br><span class="line">      <span class="attr">uglifyOptions</span>: &#123;</span><br><span class="line">        <span class="attr">compress</span>: &#123;</span><br><span class="line">          <span class="comment">// 在UglifyJs删除没有用到的代码时不输出警告</span></span><br><span class="line">          <span class="attr">warnings</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="comment">// 删除所有的 `console` 语句</span></span><br><span class="line">          <span class="attr">drop_console</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="comment">// 内嵌定义了但是只用到一次的变量</span></span><br><span class="line">          <span class="attr">collapse_vars</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="comment">// 提取出出现多次但是没有定义成变量去引用的静态值</span></span><br><span class="line">          <span class="attr">reduce_vars</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">output</span>: &#123;</span><br><span class="line">          <span class="comment">// 最紧凑的输出</span></span><br><span class="line">          <span class="attr">beautify</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="comment">// 删除所有的注释</span></span><br><span class="line">          <span class="attr">comments</span>: <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>还需要去掉 <code>.babelrc</code> 配置文件中的 <code>babel-preset-env</code>，因为 <code>babel-preset-env</code> 负责把 ES6 代码转换为 ES5 代码。</p>
</blockquote>
<h3 id="压缩-css"><a href="#压缩-css" class="headerlink" title="压缩 css"></a>压缩 css</h3><p>使用 cssnano 优化 css，是 postCSS 的插件<br>因为 css-loader 已经将其内置了，要开启 cssnano 去压缩代码只需要开启 css-loader 的 minimize 选项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="comment">// 增加对 CSS 文件的支持</span></span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          <span class="comment">// 提取出 Chunk 中的 CSS 代码到单独的文件中</span></span><br><span class="line">          <span class="attr">use</span>: [<span class="string">&quot;css-loader?minimize&quot;</span>], <span class="comment">// 通过 minimize 选项压缩 CSS 代码</span></span><br><span class="line">        &#125;),</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree-shaking"></a>tree-shaking</h2><p><code>Tree Shaking</code> 可以用来剔除 JavaScript 中用不上的死代码。它依赖静态的 ES6 模块化语法，例如通过 import 和 export 导入导出。</p>
<blockquote>
<p>要让 <code>Tree Shaking</code> 正常工作的前提是交给 Webpack 的 JavaScript 代码必须是采用 ES6 模块化语法的， 因为 ES6 模块化语法是静态的（导入导出语句中的路径必须是静态的字符串，而且不能放入其它代码块中）</p>
</blockquote>
<p>基本的使用方法只需要开启两个 webpack 的配置项即可，原理上就是借助 webpack 找到哪些导入是没用到的，然后借助<code>UglifyJSPlugin</code>去掉这些没用的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --display-used-exports --optimize-minimize</span><br></pre></td></tr></table></figure>

<p>但是这个方法不适用于第三方库的压缩，只能压缩自己文件中的。<br>第三方库的压缩可以参考详细配置：<a target="_blank" rel="noopener" href="http://webpack.wuhaolin.cn/4%E4%BC%98%E5%8C%96/4-10%E4%BD%BF%E7%94%A8TreeShaking.html">http://webpack.wuhaolin.cn/4%E4%BC%98%E5%8C%96/4-10%E4%BD%BF%E7%94%A8TreeShaking.html</a></p>
<h2 id="按需加载-动态导入"><a href="#按需加载-动态导入" class="headerlink" title="按需加载(动态导入)"></a>按需加载(动态导入)</h2><p>即 webpack 的代码分离。原理是利用 ES6 的动态导入实现按需加载，而不是任何情况都在文件头部静态导入</p>
<p>比如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.document.getElementById(<span class="string">&quot;btn&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当按钮被点击后才去加载 show.js 文件，文件加载成功后执行文件导出的函数</span></span><br><span class="line">  <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;show&quot; */</span> <span class="string">&quot;./show&quot;</span>).then(<span class="function">(<span class="params">show</span>) =&gt;</span> &#123;</span><br><span class="line">    show(<span class="string">&quot;Webpack&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>/* webpackChunkName: &quot;show&quot; */</code>的写法指定了 webpack 对于动态导入代码的设定。当 Webpack 遇到了类似的语句时会这样处理：</p>
<ol>
<li>以 <code>./show.js</code> 为入口新生成一个 Chunk；</li>
<li>当代码执行到 <code>import</code> 所在语句时才会去加载由 Chunk 对应生成的文件。</li>
<li><code>import</code> 返回一个 <code>Promise</code>，当文件加载成功时可以在 <code>Promise</code> 的 <code>then</code> 方法中获取到 <code>show.js</code> 导出的内容。</li>
</ol>
<p>这段代码会在点击按钮时才会为 show 文件创建一个名字为 show 的 bundle；因此还需要配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">main</span>: <span class="string">&quot;./main.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;[name].js&quot;</span>, <span class="comment">// 本来的chunk</span></span><br><span class="line">    <span class="attr">chunkFilename</span>: <span class="string">&quot;[name].js&quot;</span>, <span class="comment">// 动态加载的文件的chunk</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Scope-Hoisting（作用域提升）"><a href="#Scope-Hoisting（作用域提升）" class="headerlink" title="Scope Hoisting（作用域提升）"></a>Scope Hoisting（作用域提升）</h2><blockquote>
<p>Scope Hoisting 可以让 Webpack 打包出来的代码文件更小、运行的更快， 它又译作 “作用域提升”<br>Scope Hoisting 的实现原理其实很简单：分析出模块之间的依赖关系，尽可能的把打散的模块合并到一个函数中去，但前提是不能造成代码冗余。 因此只有那些被引用了一次的模块才能被合并。</p>
</blockquote>
<p>或者说，由于模块和函数的增多会导致闭包增多，体积增大；Scope Hoisting 的作用就是把不同模块中的函数等影响作用域的部分合并到一起，并重命名变量防止冲突<br>Scope Hoisting 就是一个插件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ModuleConcatenationPlugin = <span class="built_in">require</span>(<span class="string">&quot;webpack/lib/optimize/ModuleConcatenationPlugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// 开启 Scope Hoisting</span></span><br><span class="line">    <span class="keyword">new</span> ModuleConcatenationPlugin(),</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="comment">// 针对 Npm 中的第三方模块优先采用 jsnext:main 中指向的 ES6 模块化语法的文件</span></span><br><span class="line">    <span class="attr">mainFields</span>: [<span class="string">&quot;jsnext:main&quot;</span>, <span class="string">&quot;browser&quot;</span>, <span class="string">&quot;main&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="HappyPack"><a href="#HappyPack" class="headerlink" title="HappyPack"></a>HappyPack</h2><p>把任务分解给多个子进程去并发执行，子进程处理完后再把结果发送给主进程。</p>
<p>在整个 Webpack 构建流程中，最耗时的流程可能就是 Loader 对文件的转换操作了，因为要转换的文件数据巨多，而且这些转换操作都只能一个个挨着处理。</p>
<p>HappyPack 的核心原理就是把这部分任务分解到多个进程去并行处理，从而减少了总的构建时间。</p>
<p>配置如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">&quot;extract-text-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">&quot;happypack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="comment">// 把对 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例</span></span><br><span class="line">        use: [<span class="string">&quot;happypack/loader?id=babel&quot;</span>],</span><br><span class="line">        <span class="comment">// 排除 node_modules 目录下的文件，node_modules 目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换</span></span><br><span class="line">        <span class="attr">exclude</span>: path.resolve(__dirname, <span class="string">&quot;node_modules&quot;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 把对 .css 文件的处理转交给 id 为 css 的 HappyPack 实例</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          <span class="attr">use</span>: [<span class="string">&quot;happypack/loader?id=css&quot;</span>],</span><br><span class="line">        &#125;),</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      <span class="comment">// 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件</span></span><br><span class="line">      <span class="attr">id</span>: <span class="string">&quot;babel&quot;</span>,</span><br><span class="line">      <span class="comment">// 如何处理 .js 文件，用法和 Loader 配置中一样</span></span><br><span class="line">      <span class="attr">loaders</span>: [<span class="string">&quot;babel-loader?cacheDirectory&quot;</span>],</span><br><span class="line">      <span class="comment">// ... 其它配置项</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&quot;css&quot;</span>,</span><br><span class="line">      <span class="comment">// 如何处理 .css 文件，用法和 Loader 配置中一样</span></span><br><span class="line">      <span class="attr">loaders</span>: [<span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;style-loader&quot;</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">`[name].css`</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="常用-plugin-和-loader"><a href="#常用-plugin-和-loader" class="headerlink" title="常用 plugin 和 loader"></a>常用 plugin 和 loader</h1><h2 id="loader-1"><a href="#loader-1" class="headerlink" title="loader"></a>loader</h2><ol>
<li><code>file-loader</code>：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)</li>
<li><code>url-loader</code>：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)</li>
<li><code>css-loader</code>：加载 CSS，把 css 按照字符串的形式编译，样式字符串放入模块数组中</li>
<li><code>style-loader</code>：把 CSS 插入到 DOM 中，就是处理 css-loader 导出的模块数组，然后将样式通过 style 标签或者其他形式插入到 DOM 中；</li>
</ol>
<blockquote>
<p><code>css-loader</code>把原生的 css 编译成一个数组，大概是这个样子：<br><img src="https://pic.imgdb.cn/item/6240272827f86abb2ab1732b.jpg"><br><code>style-loader</code>将<code>css-loader</code>解析后的内容挂载到 html 页面当中<br>因此<code>style-loader</code>要放在<code>css-loader</code>的左边，即先转化为字符串，然后再绑定到 dom 上。<br>如果有预处理器，就还要放在<code>css-loader</code>的右边，应该让预处理器先处理特殊格式的文件，然后再进行解析等操作。</p>
</blockquote>
<ol start="5">
<li><code>json-loader</code>: 加载 JSON 文件（默认包含）</li>
<li><code>babel-loader</code>：把 ES6 转换成 ES5</li>
<li><code>ts-loader</code>: 将 TypeScript 转换成 JavaScript</li>
<li><code>less-loader</code>：将 less 代码转换成 CSS</li>
<li><code>eslint-loader</code>：通过 ESLint 检查 JavaScript 代码</li>
<li><code>vue-loader</code>: 加载 Vue 单文件组件</li>
</ol>
<h2 id="plugin-1"><a href="#plugin-1" class="headerlink" title="plugin"></a>plugin</h2><ol>
<li><code>html-webpack-plugin</code>：根据模板页面生成打包的 html 页面，建议使用这个，极大减少因为 html 文件位置不对造成的 devServer404 问题；关于该 plugin 的配置可以看这篇文章：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903853708541959">https://juejin.cn/post/6844903853708541959</a></li>
<li><code>uglifyjs-webpack-plugin</code>：对 js 进行压缩，但不支持 ES6 压缩 ( Webpack4 以前)</li>
<li><code>mini-css-extract-plugin</code>: 分离样式文件，CSS 提取为独立文件，支持按需加载</li>
<li><code>clean-webpack-plugin</code>: 目录清理，webpack5 不需要插入，在 output 声明<code>clean:true</code>即可</li>
<li><code>copy-webpack-plugin</code>: 拷贝文件</li>
<li><code>webpack-bundle-analyzer</code>: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)</li>
</ol>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/">日常学习</a></div><div class="post_share"><div class="social-share" data-image="/img/webpack.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/10/blog36-react-deeping/"><img class="prev-cover" src="/img/my-react.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">react深入学习</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/30/blog33-nodejs/"><img class="next-cover" src="/img/nodejs.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">nodejs学习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/11/06/blog11-myReact/" title="react知识点汇总和使用小总结(一)"><img class="cover" src="/img/react.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-06</div><div class="title">react知识点汇总和使用小总结(一)</div></div></a></div><div><a href="/2021/10/27/blog10-react-router/" title="react-router的使用"><img class="cover" src="/img/reactrouter.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-27</div><div class="title">react-router的使用</div></div></a></div><div><a href="/2021/11/20/blog14-react-ts-basic/" title="typescript+react基础部分"><img class="cover" src="/img/typescript.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-20</div><div class="title">typescript+react基础部分</div></div></a></div><div><a href="/2021/11/22/blog17-react-pubsub-issues/" title="react+typescript使用pubsub时的一点小问题"><img class="cover" src="/img/pubsub.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-22</div><div class="title">react+typescript使用pubsub时的一点小问题</div></div></a></div><div><a href="/2021/11/20/blog16-react-ts-hooks-redux/" title="typescript+react:自定义hooks代替redux"><img class="cover" src="/img/typescript.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-20</div><div class="title">typescript+react:自定义hooks代替redux</div></div></a></div><div><a href="/2021/11/25/blog18-vue3ts-basic/" title="vue3+ts配置及简单使用注意"><img class="cover" src="/img/vue3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-25</div><div class="title">vue3+ts配置及简单使用注意</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/pinkstar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xing Ye</div><div class="author-info__description">a singleThreaded boy's blog</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/penghei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/penghei" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:632885485@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">A SingleThreaded Boy...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Webpack-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">Webpack 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">核心概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E5%8F%8A%E9%85%8D%E7%BD%AE"><span class="toc-number">1.2.</span> <span class="toc-text">安装使用及配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">1.2.1.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E9%85%8D%E7%BD%AE"><span class="toc-number">1.2.2.</span> <span class="toc-text">命令配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">文件目录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#webpack-config-js"><span class="toc-number">2.</span> <span class="toc-text">webpack.config.js</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE"><span class="toc-number">2.1.</span> <span class="toc-text">基本配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#entry"><span class="toc-number">2.1.1.</span> <span class="toc-text">entry</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#output"><span class="toc-number">2.1.2.</span> <span class="toc-text">output</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#output-filename"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">output.filename</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#output-path"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">output.path</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#output-publicPath"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">output.publicPath</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loader%EF%BC%88module%EF%BC%89"><span class="toc-number">2.1.3.</span> <span class="toc-text">loader（module）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#use-%E7%9A%84%E5%86%99%E6%B3%95"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">use 的写法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resolve"><span class="toc-number">2.1.4.</span> <span class="toc-text">resolve</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#resolve-alias"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">resolve.alias</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#resolve-extensions"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">resolve.extensions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#resolve-modules"><span class="toc-number">2.1.4.3.</span> <span class="toc-text">resolve.modules</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#plugins"><span class="toc-number">2.1.5.</span> <span class="toc-text">plugins</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#devServer"><span class="toc-number">2.1.6.</span> <span class="toc-text">devServer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#devServer-proxy"><span class="toc-number">2.1.6.1.</span> <span class="toc-text">devServer.proxy</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE"><span class="toc-number">2.1.7.</span> <span class="toc-text">其他配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">配置类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="toc-number">3.1.1.</span> <span class="toc-text">初始化阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5"><span class="toc-number">3.1.2.</span> <span class="toc-text">编译阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E9%98%B6%E6%AE%B5"><span class="toc-number">3.1.3.</span> <span class="toc-text">输出阶段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#loader"><span class="toc-number">3.2.</span> <span class="toc-text">loader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#plugin"><span class="toc-number">3.3.</span> <span class="toc-text">plugin</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-number">3.3.1.</span> <span class="toc-text">事件流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Compiler-%E5%92%8C-Compilation"><span class="toc-number">3.3.2.</span> <span class="toc-text">Compiler 和 Compilation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">3.4.</span> <span class="toc-text">环境变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%91%E5%90%AC"><span class="toc-number">3.5.</span> <span class="toc-text">文件监听</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0"><span class="toc-number">3.6.</span> <span class="toc-text">自动刷新</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#devServer-1"><span class="toc-number">3.6.1.</span> <span class="toc-text">devServer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HMR"><span class="toc-number">3.6.2.</span> <span class="toc-text">HMR</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%A9%E5%B0%8F%E6%90%9C%E7%B4%A2%E8%8C%83%E5%9B%B4"><span class="toc-number">4.1.</span> <span class="toc-text">缩小搜索范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E4%BB%A3%E7%A0%81"><span class="toc-number">4.2.</span> <span class="toc-text">压缩代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9-js"><span class="toc-number">4.2.1.</span> <span class="toc-text">压缩 js</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9-css"><span class="toc-number">4.2.2.</span> <span class="toc-text">压缩 css</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tree-shaking"><span class="toc-number">4.3.</span> <span class="toc-text">tree-shaking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD-%E5%8A%A8%E6%80%81%E5%AF%BC%E5%85%A5"><span class="toc-number">4.4.</span> <span class="toc-text">按需加载(动态导入)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scope-Hoisting%EF%BC%88%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%90%E5%8D%87%EF%BC%89"><span class="toc-number">4.5.</span> <span class="toc-text">Scope Hoisting（作用域提升）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HappyPack"><span class="toc-number">4.6.</span> <span class="toc-text">HappyPack</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8-plugin-%E5%92%8C-loader"><span class="toc-number">5.</span> <span class="toc-text">常用 plugin 和 loader</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#loader-1"><span class="toc-number">5.1.</span> <span class="toc-text">loader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#plugin-1"><span class="toc-number">5.2.</span> <span class="toc-text">plugin</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/05/18/projects/" title="无题"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/05/18/projects/" title="无题">无题</a><time datetime="2022-05-18T02:57:57.356Z" title="发表于 2022-05-18 10:57:57">2022-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/13/handwriting/" title="js题目"><img src="/img/JS.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="js题目"/></a><div class="content"><a class="title" href="/2022/05/13/handwriting/" title="js题目">js题目</a><time datetime="2022-05-13T04:21:10.000Z" title="发表于 2022-05-13 12:21:10">2022-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/12/OS/" title="操作系统知识点总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统知识点总结"/></a><div class="content"><a class="title" href="/2022/05/12/OS/" title="操作系统知识点总结">操作系统知识点总结</a><time datetime="2022-05-12T07:58:22.000Z" title="发表于 2022-05-12 15:58:22">2022-05-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/05/blog43-algorithms/" title="算法学习总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法学习总结"/></a><div class="content"><a class="title" href="/2022/04/05/blog43-algorithms/" title="算法学习总结">算法学习总结</a><time datetime="2022-04-05T08:01:22.000Z" title="发表于 2022-04-05 16:01:22">2022-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/05/blog44-optimization/" title="优化问题总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="优化问题总结"/></a><div class="content"><a class="title" href="/2022/04/05/blog44-optimization/" title="优化问题总结">优化问题总结</a><time datetime="2022-04-05T08:01:22.000Z" title="发表于 2022-04-05 16:01:22">2022-04-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Xing Ye</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hello stranger!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>