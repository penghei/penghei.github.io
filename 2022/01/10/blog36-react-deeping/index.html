<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>react深入源码学习 | XingYeBlog</title><meta name="keywords" content="日常学习"><meta name="author" content="Xing Ye,632885485@qq.com"><meta name="copyright" content="Xing Ye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="react 深入原理学习理念react 实现“快速响应”的原理：浏览器每个刷新周期是 16.6ms（60Hz），但是 js 脚本的执行可能远远大于这数字，这样就可能导致卡顿。react 通过在每个刷新周期预留一点时间（5ms）来更新或挂载组件；当预留的时间不够用时，React 将线程控制权交还给浏览器使其有时间渲染 UI，React 则等待下一帧时间到来继续被中断的工作。这就是 react 的时间">
<meta property="og:type" content="article">
<meta property="og:title" content="react深入源码学习">
<meta property="og:url" content="http://example.com/2022/01/10/blog36-react-deeping/index.html">
<meta property="og:site_name" content="XingYeBlog">
<meta property="og:description" content="react 深入原理学习理念react 实现“快速响应”的原理：浏览器每个刷新周期是 16.6ms（60Hz），但是 js 脚本的执行可能远远大于这数字，这样就可能导致卡顿。react 通过在每个刷新周期预留一点时间（5ms）来更新或挂载组件；当预留的时间不够用时，React 将线程控制权交还给浏览器使其有时间渲染 UI，React 则等待下一帧时间到来继续被中断的工作。这就是 react 的时间">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/my-react.jpeg">
<meta property="article:published_time" content="2022-01-10T08:24:25.000Z">
<meta property="article:modified_time" content="2022-01-11T15:01:44.081Z">
<meta property="article:author" content="Xing Ye">
<meta property="article:tag" content="日常学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/my-react.jpeg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2022/01/10/blog36-react-deeping/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'react深入源码学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-11 23:01:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/pinkstar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/my-react.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XingYeBlog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">react深入源码学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-10T08:24:25.000Z" title="发表于 2022-01-10 16:24:25">2022-01-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-11T15:01:44.081Z" title="更新于 2022-01-11 23:01:44">2022-01-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/React/">React</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="react深入源码学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="react-深入原理学习"><a href="#react-深入原理学习" class="headerlink" title="react 深入原理学习"></a>react 深入原理学习</h1><h2 id="理念"><a href="#理念" class="headerlink" title="理念"></a>理念</h2><p>react 实现“快速响应”的原理：<br>浏览器每个刷新周期是 16.6ms（60Hz），但是 js 脚本的执行可能远远大于这数字，这样就可能导致卡顿。<br>react 通过在每个刷新周期预留一点时间（5ms）来更新或挂载组件；当预留的时间不够用时，React 将线程控制权交还给浏览器使其有时间渲染 UI，React 则等待下一帧时间到来继续被中断的工作。这就是 react 的<code>时间切片</code><br><img src="https://react.iamkasong.com/img/time-slice.png"><br>由于浏览器会随时中断 react 的执行，并且我们不能把一个没有渲染完成的 ui 展示出来；react 为此将同步的更新变为<code>可中断的异步更新</code>，形成了 Scheduler（调度器）——Reconciler（协调器）——Renderer（渲染器)的基本架构。</p>
<h2 id="react-基本架构"><a href="#react-基本架构" class="headerlink" title="react 基本架构"></a>react 基本架构</h2><p>简单来说，react 是通过把 jsx 解析为虚拟 dom 并进行渲染，更新时通过 diff 算法比较不同的地方并进行增删改的操作。<br>react 的架构经过一次改动，这里只讲最新的 react 架构。<br>架构可以分为三层：</p>
<ul>
<li>Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入 Reconciler</li>
<li>Reconciler（协调器）—— 负责找出变化的组件</li>
<li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li>
</ul>
<h3 id="Scheduler（调度器）"><a href="#Scheduler（调度器）" class="headerlink" title="Scheduler（调度器）"></a>Scheduler（调度器）</h3><p>主要目的是两个：</p>
<ol>
<li>允许高优先级中断低优先级</li>
<li>获取剩余时间，允许在浏览器给的空闲时间不够的情况下终止处理并在下次有时间的时候继续</li>
</ol>
<p>所以我们通过 <code>Scheduler</code> 可以让 react 完成一种异步的更新：即在浏览器有空闲的时候去处理节点、渲染界面，从而大大提升效率<br><code>Scheduler</code>的实现可以通过浏览器提供的<code>requestIdleCallback</code>，参数是一个将在浏览器空闲时期被调用的函数，在浏览器有剩余时间就运行挂载、更新等操作；没有就等待直到下一个空闲时间。</p>
<p>浏览器一帧可以执行的步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个task(宏任务) -- 队列中全部job(微任务) -- requestAnimationFrame -- 浏览器重排/重绘 -- requestIdleCallback</span><br></pre></td></tr></table></figure>

<h4 id="理解优先级"><a href="#理解优先级" class="headerlink" title="理解优先级"></a>理解优先级</h4><p><img src="https://react.iamkasong.com/img/update-process.png"><br>状态更新由用户交互产生，用户心里对交互执行顺序有个预期。React 根据人机交互研究的结果中用户对交互的预期顺序为交互产生的<strong>状态更新</strong>赋予不同优先级。<br>具体如下：</p>
<ol>
<li>生命周期方法：同步执行。</li>
<li>受控的用户输入：比如输入框内输入文字，同步执行。</li>
<li>交互事件：比如动画，高优先级执行。</li>
<li>其他：比如数据请求，低优先级执行</li>
</ol>
<h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><p>Scheduler 内部存在 5 种优先级，对外暴露了一个方法<code>unstable_runWithPriority</code>，React 内部凡是涉及到优先级调度的地方，都会使用<code>unstable_runWithPriority</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timeout;</span><br><span class="line"><span class="keyword">switch</span> (priorityLevel) &#123;</span><br><span class="line">  <span class="keyword">case</span> ImmediatePriority:</span><br><span class="line">    timeout = IMMEDIATE_PRIORITY_TIMEOUT; <span class="comment">//-1</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> UserBlockingPriority:</span><br><span class="line">    timeout = USER_BLOCKING_PRIORITY_TIMEOUT; <span class="comment">//250</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> IdlePriority:</span><br><span class="line">    timeout = IDLE_PRIORITY_TIMEOUT; <span class="comment">//maxSigned31BitInt;</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> LowPriority:</span><br><span class="line">    timeout = LOW_PRIORITY_TIMEOUT; <span class="comment">//5000</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> NormalPriority:</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    timeout = NORMAL_PRIORITY_TIMEOUT; <span class="comment">//10000</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> expirationTime = startTime + timeout;</span><br></pre></td></tr></table></figure>

<p>不同优先级意味着不同时长的任务过期时间，过期时间理解为要等待的时间，比如 <code>ImmediatePriority</code> 的情况是-1，表示已经过期要在任何情况前立即执行。<br>Scheduler 存在两个队列：</p>
<ul>
<li>timerQueue：保存未就绪任务的队列</li>
<li>taskQueue：保存已就绪任务的队列</li>
</ul>
<ol>
<li>每当有新的未就绪的任务被注册，我们将其插入 <code>timerQueue</code> 并根据开始时间重新排列 <code>timerQueue</code> 中任务的顺序。</li>
<li>当 <code>timerQueue</code> 中有任务就绪，即 <code>startTime &lt;= currentTime</code>，我们将其取出并加入 <code>taskQueue。</code></li>
<li>取出 taskQueue 中最早过期的任务并执行他。<br>也就是相当于把最高优先级的任务（最早过期）的任务最先执行，其后依次类推。</li>
</ol>
<h3 id="Reconciler（协调器）"><a href="#Reconciler（协调器）" class="headerlink" title="Reconciler（协调器）"></a>Reconciler（协调器）</h3><p>在新 react 架构中，更新工作变成了可中断的循环过程，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shouldYield = <span class="literal">false</span>; <span class="comment">//判断是否有剩余时间</span></span><br><span class="line"><span class="keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">  <span class="comment">//处理一个fiber节点，返回下一个节点</span></span><br><span class="line">  nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">  <span class="comment">//时间不足就取消循环</span></span><br><span class="line">  shouldYield = deadline.timeRemaining() &lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过循环不断判断是否还有剩余时间，如果有就执行节点的处理，否则就中断。<br>整个 Scheduler 与 Reconciler 的工作都在内存中进行。只有当所有组件都完成 Reconciler 的工作，才会统一交给 Renderer。这样保证不会因为中断产生不完整的虚拟 dom 从而渲染出不完整的 dom 树。</p>
<h3 id="Renderer（渲染器）"><a href="#Renderer（渲染器）" class="headerlink" title="Renderer（渲染器）"></a>Renderer（渲染器）</h3><p>Renderer 根据 Reconciler 为虚拟 DOM 打的标记，同步执行对应的 DOM 操作。<br>主要的标记类型有三个：添加(PLACEMENT)、更新(UPDATE)和删除(DELETION),分别对应对节点的增、改、删处理。<br>渲染操作根据提交的 fiber 树进行“递”和“归”的操作，具体来说就是自顶向下、再自底向上</p>
<h4 id="递"><a href="#递" class="headerlink" title="递"></a>递</h4><blockquote>
<p>首先从 <code>rootFiber</code> 开始向下深度优先遍历。为遍历到的每个 Fiber 节点调用 <code>beginWork</code> 方法，也就是创建 fiber 树或新旧 fiber 树比较的过程。<br>该方法会根据传入的 Fiber 节点创建子 Fiber 节点，并将这两个 Fiber 节点连接起来。<br>当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。</p>
</blockquote>
<h4 id="归"><a href="#归" class="headerlink" title="归"></a>归</h4><blockquote>
<p>在“归”阶段会调用 <code>completeWork</code> 处理 Fiber 节点，即为 fiber 节点创建 dom 节点，把 dom 连接起来，形成 dom 树<br>当某个 Fiber 节点执行完 <code>completeWork</code>，如果其存在兄弟 Fiber 节点（即 <code>fiber.sibling !== null</code>），会进入其兄弟 Fiber 的“递”阶段。<br>如果不存在兄弟 Fiber，会进入父级 Fiber 的“归”阶段。<br>“递”和“归”阶段会交错执行直到“归”到 <code>rootFiber</code>。至此，render 阶段的工作就结束了</p>
</blockquote>
<p>于是我们可以得到整体架构大致如下：<br><img src="https://react.iamkasong.com/img/process.png"></p>
<h2 id="react-主要结构"><a href="#react-主要结构" class="headerlink" title="react 主要结构"></a>react 主要结构</h2><h3 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h3><p>Fiber 并不是计算机术语中的新名词，他的中文翻译叫做纤程，与进程（Process）、线程（Thread）、协程（Coroutine）同为程序执行过程。<br>fiber 是 react 上述架构的主要实现形式；<br>fiber 相当于一个 react 节点对象，经过解析的 jsx 每一个元素都对应一个 fiber 对象；fiber 对象包含 react 节点的属性、和其他节点的关系以及关于更新等等信息。<br>fiber 的大致内容如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FiberNode</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  tag: WorkTag,</span></span></span><br><span class="line"><span class="params"><span class="function">  pendingProps: mixed,</span></span></span><br><span class="line"><span class="params"><span class="function">  key: <span class="literal">null</span> | string,</span></span></span><br><span class="line"><span class="params"><span class="function">  mode: TypeOfMode</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 作为静态数据结构的属性</span></span><br><span class="line">  <span class="built_in">this</span>.tag = tag;</span><br><span class="line">  <span class="built_in">this</span>.key = key;</span><br><span class="line">  <span class="built_in">this</span>.elementType = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.type = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.stateNode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于连接其他Fiber节点形成Fiber树</span></span><br><span class="line">  <span class="built_in">this</span>.return = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.child = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.sibling = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.ref = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 作为动态的工作单元的属性</span></span><br><span class="line">  <span class="built_in">this</span>.pendingProps = pendingProps;</span><br><span class="line">  <span class="built_in">this</span>.memoizedProps = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.updateQueue = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.memoizedState = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.dependencies = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.mode = mode;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.effectTag = NoEffect;</span><br><span class="line">  <span class="built_in">this</span>.nextEffect = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.firstEffect = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.lastEffect = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调度优先级相关</span></span><br><span class="line">  <span class="built_in">this</span>.lanes = NoLanes;</span><br><span class="line">  <span class="built_in">this</span>.childLanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指向该fiber在另一次更新时对应的fiber</span></span><br><span class="line">  <span class="built_in">this</span>.alternate = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同的属性会在 fiber 不同功能起到主要作用；fiber 通过组合形成 fiber 树，fiber 树其实就是我们说的虚拟 DOM 树。</p>
<h4 id="作为架构（fiber-树）"><a href="#作为架构（fiber-树）" class="headerlink" title="作为架构（fiber 树）"></a>作为架构（fiber 树）</h4><p>每个 Fiber 节点有个对应的 React element，多个 Fiber 节点是如何连接形成树呢？靠如下三个属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指向父级Fiber节点</span></span><br><span class="line"><span class="built_in">this</span>.return = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 指向子Fiber节点</span></span><br><span class="line"><span class="built_in">this</span>.child = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 指向右边第一个兄弟Fiber节点</span></span><br><span class="line"><span class="built_in">this</span>.sibling = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>组合方式大致如下：<br><img src="https://react.iamkasong.com/img/fiber.png"></p>
<h4 id="静态数据结构"><a href="#静态数据结构" class="headerlink" title="静态数据结构"></a>静态数据结构</h4><p>fiber 对象中有当前节点的很多属性，主要包括：</p>
<ul>
<li>组件类型，函数组件或类组件</li>
<li>key</li>
<li>真实 dom 节点<br>等等</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fiber对应组件的类型 Function/Class/Host...</span></span><br><span class="line"><span class="built_in">this</span>.tag = tag;</span><br><span class="line"><span class="comment">// key属性</span></span><br><span class="line"><span class="built_in">this</span>.key = key;</span><br><span class="line"><span class="comment">// 大部分情况同type，某些情况不同，比如FunctionComponent使用React.memo包裹</span></span><br><span class="line"><span class="built_in">this</span>.elementType = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName</span></span><br><span class="line"><span class="built_in">this</span>.type = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// Fiber对应的真实DOM节点</span></span><br><span class="line"><span class="built_in">this</span>.stateNode = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h4 id="动态工作单元"><a href="#动态工作单元" class="headerlink" title="动态工作单元"></a>动态工作单元</h4><p>主要保存了要进行的操作、调度优先级、更新导致的状态改变等信息。<br>其中主要的比如 :</p>
<ul>
<li>effectTag，就是 Reconciler 打的提供给 Renderer 的“标记”</li>
<li>updateQueue，hook 中的更新队列，用于依次执行对 hook.state 的更新</li>
<li>xxxEffect，useEffect 的实现</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存本次更新造成的状态改变相关信息</span></span><br><span class="line"><span class="built_in">this</span>.pendingProps = pendingProps;</span><br><span class="line"><span class="built_in">this</span>.memoizedProps = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">this</span>.updateQueue = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">this</span>.memoizedState = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">this</span>.dependencies = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.mode = mode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存本次更新会造成的DOM操作</span></span><br><span class="line"><span class="built_in">this</span>.effectTag = NoEffect;</span><br><span class="line"><span class="built_in">this</span>.nextEffect = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.firstEffect = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">this</span>.lastEffect = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h4 id="fiber-的工作原理"><a href="#fiber-的工作原理" class="headerlink" title="fiber 的工作原理"></a>fiber 的工作原理</h4><p>react 最多会同时存在两棵 fiber 树：</p>
<ul>
<li>一棵是正在展示在页面上（相当于旧的）的，称为<code>currentFiber</code></li>
<li>另一个是正在内存中工作（相当于新产生的）的，称为<code>wipFiber</code>(<code>workInProgress</code>)<br>两者的每个 fiber 节点都通过 <code>alternate</code> 属性相连。<br>而切换两者的方法是通过 react 根节点的 current 指针实现，根节点在源码中称为<code>fiberRoot</code>。current 指向的当然是<code>currentFiber</code>，即显示出来的 fiber 树；<br>fiber 工作在 mount 和 update 时会有不同的表现：</li>
</ul>
<h5 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h5><ol>
<li>创建<code>fiberRoot</code>，并把 current 指针指向<code>currentFiber树</code>；但是此时没有创建 dom，因此没有后续节点</li>
<li>通过<code>requestIdleCallback</code>在浏览器空闲时间触发 Reconciler，创建 fiber 树（<code>wipFiber树</code>）；每一个 fiber 也都被创建了 dom 节点；注意这时是同时有<code>wipFiber树</code>和<code>currentFiber树</code>的，只是<code>currentFiber树</code>还没有任何节点，也就是页面上什么都没有；<code>currentFiber树</code>的<code>rootFiber</code>通过 alternate 指向<code>wipFiber树</code>。<br><img src="https://react.iamkasong.com/img/workInProgressFiber.png"></li>
<li>构建完成<code>wipFiber树</code>，提交给 renderer 进行渲染，此时变成<code>currentFiber树</code></li>
</ol>
<h5 id="update"><a href="#update" class="headerlink" title="update"></a>update</h5><p>根据上一步，我们已经有了一个有具体 dom 节点的 fiber 树，这时触发更新会创建并进行切换</p>
<ol>
<li>开启一次新的 render 阶段并构建一棵新的<code>wipFiber 树</code>。这时会通过 diff 算法判断是否需要复用、复用多少<code>currentFiber树</code>，并让这个<code>wipFiber树</code>的 fiber 节点通过<code>alternate</code>和每个<code>currentFiber</code>节点连接</li>
<li><code>commit</code> 当前<code>wipFiber树</code>，形成新的<code>currentFieber</code>，更新页面</li>
</ol>
<h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><p>直接在 js 中使用 html 标签是不会被识别的，需要有函数的转换，babel 通过 React.createElement 或者自己写的 createElement 翻译 jsx 成为对象形式，从而可以被识别。<br>jsx 可以被编译为如下对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">elememt = &#123;</span><br><span class="line">  type,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">children</span>: [],</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;main&quot;</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;zzx&quot;</span>, <span class="comment">//自定义的props</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>createElement 函数一般会接收三个参数：</p>
<ul>
<li>type：元素类型，这里是指 dom 类型，比如 <code>div/p/h1</code> 等</li>
<li>props：html 元素的属性和组件的 props</li>
<li>children：有两种组成：<ul>
<li>当前元素内部如果是 html 元素，就是另一个或数个 element 对象的数组</li>
<li>如果是文本，就是’TEXT’类型，一般是 fiber 树的最后节点，表示 dom 元素内部的文本内容</li>
</ul>
</li>
</ul>
<p>因此对于 jsx，我们可以通过大括号的方式填入变量；在标签内的变量会被解析到 props，在 children 中的变量会被自动填入</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 value=&#123;name&#125;&gt;hello &#123;name&#125;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">elememt=&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>:&#123;</span><br><span class="line">    <span class="attr">value</span>:name,</span><br><span class="line">    <span class="attr">children</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="string">&#x27;TEXT&#x27;</span>,</span><br><span class="line">        <span class="attr">nodeValue</span>:<span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">        <span class="attr">props</span>:&#123;</span><br><span class="line">          <span class="attr">chidren</span>:[]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="string">&#x27;TEXT&#x27;</span>,</span><br><span class="line">        <span class="attr">nodeValue</span>:name</span><br><span class="line">        <span class="attr">props</span>:&#123;</span><br><span class="line">          <span class="attr">children</span>:[]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然这只是一个简单的例子，实际的 jsx 还会有 key、ref 等很多属性。<br>jsx 和 fiber 差不多是一一对应的关系，但是 fiber 对象除了储存 jsx 的内容，还需要储存 state、renderer 标记等更多属性。</p>
<h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><p>函数组件简单来说就是一个返回 jsx 的函数；因此我们在原先架构的基础上添加函数组件的处理，即 fiber 的 children 不是直接给出，而是通过函数组件调用 props 并返回的；<br>同时函数组件还要在 <code>wipFiber</code> 上维护一个 hooks 数组，用于下面的 state 和 useState 的存储；不同于类组件，函数组件的 hooks 直接放在 <code>wipFiber 树</code>的根上，调用时对 <code>wipFiber 树</code>执行，并创建新的 <code>currentFiber 树</code>。</p>
<h3 id="state-amp-hooks"><a href="#state-amp-hooks" class="headerlink" title="state &amp; hooks"></a>state &amp; hooks</h3><p>由上可知在函数组件创建时，<code>wipFiber</code> 维护了一个 hooks 数组，用于存放该组件的不同 hooks。比如一个 <code>useState</code> 就相当于 hooks 数组的一个 hook，每个 hook 又独立维护一份 state 和更新队列；<br>hook 的数据结构如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = &#123;</span><br><span class="line">  <span class="comment">//hook是数据结构，保存有state和queue，即更新队列</span></span><br><span class="line">  <span class="attr">state</span>: oldHook ? oldHook.state : init,</span><br><span class="line">  <span class="attr">queue</span>: [],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中 :</p>
<ul>
<li>state 是当前 hook 的 state，也是需要更新的；</li>
<li>queue 是 hook 的更新队列，我们 <code>setState</code> 的每一个操作（函数）都会被放入，在合适的时机依次执行并重新渲染。更详细地说，每个更新也是一个对象，update 大概长这个样子：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">update = &#123;</span><br><span class="line">  eventTime, <span class="comment">//任务时间</span></span><br><span class="line">  lane, <span class="comment">//优先级</span></span><br><span class="line">  <span class="attr">eventTag</span>: <span class="string">&quot;UPDATE&quot;</span>, <span class="comment">//标记类型</span></span><br><span class="line">  <span class="attr">payload</span>: <span class="literal">null</span>, <span class="comment">//数据，useState中可能会是维护的state值</span></span><br><span class="line">  <span class="attr">callback</span>: <span class="literal">null</span>, <span class="comment">//回调</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">next</span>: <span class="literal">null</span>, <span class="comment">//和其他update形成循环链表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>wipFiber</code> 和 <code>currentFiber</code> 都各自维护一组 hooks，当我们调用 <code>useState</code> 时首先初始化<code> hook.state</code> 为 <code>oldHook.state</code>，然后执行 actions 的数个操作，再创建新 <code>wipFiber 树</code>的根并赋值给 <code>nextUnitOfWork</code> 进行更新操作，这也就是 state 的更新效果。</p>
<p>真实的 hook 还有更多的属性，包括一个 next 指针，使得 hook 之间形成单链表；而 queue 中的 update 实际上是单向循环链表，首尾相接</p>
<h3 id="Diff-算法"><a href="#Diff-算法" class="headerlink" title="Diff 算法"></a>Diff 算法</h3><h4 id="单节点-Diff"><a href="#单节点-Diff" class="headerlink" title="单节点 Diff"></a>单节点 Diff</h4><p>diff 算法的主要流程如下：<br><img src="https://react.iamkasong.com/img/diff.png"><br>确定 dom 节点是否可以复用需要经过几个步骤：</p>
<ol>
<li>首先判断上一次对应的 dom 节点是否存在：</li>
</ol>
<ul>
<li>如果旧 fiber 树有节点但新 fiber 树没有，说明要删除</li>
<li>如果旧 fiber 树没有节点但新 fiber 树有，说明要增加</li>
<li>如果都有说明是更新，就需要接下来判断是否复用</li>
</ul>
<ol start="2">
<li>比较 key 是否相同，相同即复用</li>
<li>比较 type（元素类型）是否相同，相同即复用</li>
<li>如果都不满足，就不复用，创建新的 fiber 节点。</li>
</ol>
<h4 id="多节点-diff"><a href="#多节点-diff" class="headerlink" title="多节点 diff"></a>多节点 diff</h4><p>主要是针对列表渲染，比如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">List</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他的返回值 JSX 对象的 children 属性不是单一节点，而是包含四个对象的数组<br>这时会对节点进行两轮遍历</p>
<ul>
<li>第一轮遍历：处理更新的节点。</li>
<li>第二轮遍历：处理剩下的不属于更新的节点</li>
</ul>
<h5 id="第一轮遍历"><a href="#第一轮遍历" class="headerlink" title="第一轮遍历"></a>第一轮遍历</h5><ol>
<li>遍历<code>children[i]</code>，分别和 <code>oldFiber</code> 对应节点比较，比较方式等同单节点的比较；</li>
</ol>
<ul>
<li>可复用，则 i++，继续下一个</li>
<li>不可复用：<ul>
<li>key 不同导致不可复用，立即跳出整个遍历，第一轮遍历结束。</li>
<li>key 相同 type 不同导致不可复用，会将 <code>oldFiber</code> 标记为 <code>DELETION</code>，并继续遍历</li>
</ul>
</li>
</ul>
<ol start="2">
<li>第一轮遍历的结果会有 4 种：</li>
</ol>
<ul>
<li><code>newChildren</code> 与 <code>oldFiber</code> 同时遍历完：直接结束，只需要在第一轮更新即可</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//oldFiber</span></span><br><span class="line">&lt;li key=<span class="string">&quot;0&quot;</span>&gt;<span class="number">0</span>&lt;/li&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="comment">//newChildren</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;3&quot;</span>&gt;</span>7<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>newChildren</code> 没遍历完，<code>oldFiber</code> 遍历完：已有的 DOM 节点都复用了，这时还有新加入的节点，只需要遍历剩下的 <code>newChildren</code> 为生成的 <code>workInProgress fiber</code> 依次标记 <code>Placement</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//oldFiber</span></span><br><span class="line">&lt;li key=<span class="string">&quot;0&quot;</span>&gt;<span class="number">0</span>&lt;/li&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="comment">//newChildren</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;3&quot;</span>&gt;</span>7<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;4&quot;</span>&gt;</span>8<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><span class="comment">//新节点，创建新的fiber</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>newChildren</code> 遍历完，<code>oldFiber</code> 没遍历完：节点数量少，有节点被删除了。所以需要遍历剩下的 <code>oldFiber</code>，依次标记 <code>Deletion</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//oldFiber</span></span><br><span class="line">&lt;li key=<span class="string">&quot;0&quot;</span>&gt;<span class="number">0</span>&lt;/li&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="comment">//newChildren</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>newChildren</code> 与 <code>oldFiber</code> 都没遍历完</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//oldFiber</span></span><br><span class="line">&lt;li key=<span class="string">&quot;0&quot;</span>&gt;<span class="number">0</span>&lt;/li&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="comment">//newChildren</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><span class="comment">//这里发现和oldFiber的key不对应，不可复用，这时两者都没遍历完</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>对于第四种情况还有额外的处理：</p>
<h5 id="第二轮遍历"><a href="#第二轮遍历" class="headerlink" title="第二轮遍历"></a>第二轮遍历</h5><p>第二轮遍历主要处理 key 不同的元素，即有可能产生移动的元素</p>
<ol>
<li>以最后一个可复用节点在 <code>oldFiber</code> 中的位置为 <code>lastIndex</code>，在 <code>newChild</code> 中第一个不可复用的为 <code>lasindex+1</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;li key=0&gt; --- &lt;li key=0&gt;</span><br><span class="line">&lt;li key=1&gt; --- &lt;li key=1&gt;//last index = 1</span><br><span class="line">&lt;li key=2&gt; --- &lt;li key=3&gt;//last index + 1 = 2</span><br><span class="line">&lt;li key=3&gt; --- &lt;li key=2&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>选出 <code>newChildren</code> 在 <code>lastIndex+1</code> 的元素，即上次比较终止的下一个，在 <code>oldFiber</code> 中找，并取出序号和 <code>lastIndex</code> 比较。比如上面的例子，<code>key=3</code> 在 <code>oldFiber</code> 中找到，index 为 3，规定这个值为 <code>oldIndex</code></li>
<li>比较 <code>oldIndex</code> 和 <code>lastIndex</code></li>
</ol>
<ul>
<li>如果 <code>oldIndex</code> &gt;= <code>lastIndex</code> 代表该可复用节点不需要移动，并将 <code>lastIndex = oldIndex</code>;上面的例子 <code>oldindex=3&gt;lastindex=1</code>，因此 <code>oldIndex</code> 中 <code>key=3</code> 的元素位置不动（指相对于 old 不动，仍然在最后一个）</li>
<li>如果 <code>oldIndex</code> &lt; <code>lastIndex</code> 该可复用节点之前插入的位置索引小于这次更新需要插入的位置索引，代表该节点需要向右（后）移动。<br>所以比较完成后，相当于只是把 <code>key=2</code> 的向后移动了一位，完成遍历<br>这里还有一个更清晰的例子：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">// 之前</span><br><span class="line">abcd</span><br><span class="line"></span><br><span class="line">// 之后</span><br><span class="line">dabc</span><br><span class="line"></span><br><span class="line">===第一轮遍历开始===</span><br><span class="line">d（之后）vs a（之前）</span><br><span class="line">key改变，不能复用，跳出遍历</span><br><span class="line">===第一轮遍历结束===</span><br><span class="line"></span><br><span class="line">===第二轮遍历开始===</span><br><span class="line">newChildren === dabc，没用完，不需要执行删除旧节点</span><br><span class="line">oldFiber === abcd，没用完，不需要执行插入新节点</span><br><span class="line"></span><br><span class="line">将剩余oldFiber（abcd）保存为map</span><br><span class="line"></span><br><span class="line">继续遍历剩余newChildren</span><br><span class="line"></span><br><span class="line">// 当前oldFiber：abcd</span><br><span class="line">// 当前newChildren dabc</span><br><span class="line"></span><br><span class="line">key === d 在 oldFiber中存在</span><br><span class="line">const oldIndex = d（之前）.index;</span><br><span class="line">此时 oldIndex === 3; // 之前节点为 abcd，所以d.index === 3</span><br><span class="line">比较 oldIndex 与 lastPlacedIndex;</span><br><span class="line">oldIndex 3 &gt; lastPlacedIndex 0</span><br><span class="line">则 lastPlacedIndex = 3;</span><br><span class="line">d节点位置不变</span><br><span class="line"></span><br><span class="line">继续遍历剩余newChildren</span><br><span class="line"></span><br><span class="line">// 当前oldFiber：abc</span><br><span class="line">// 当前newChildren abc</span><br><span class="line"></span><br><span class="line">key === a 在 oldFiber中存在</span><br><span class="line">const oldIndex = a（之前）.index; // 之前节点为 abcd，所以a.index === 0</span><br><span class="line">此时 oldIndex === 0;</span><br><span class="line">比较 oldIndex 与 lastPlacedIndex;</span><br><span class="line">oldIndex 0 &lt; lastPlacedIndex 3</span><br><span class="line">则 a节点需要向右移动</span><br><span class="line"></span><br><span class="line">继续遍历剩余newChildren</span><br><span class="line"></span><br><span class="line">// 当前oldFiber：bc</span><br><span class="line">// 当前newChildren bc</span><br><span class="line"></span><br><span class="line">key === b 在 oldFiber中存在</span><br><span class="line">const oldIndex = b（之前）.index; // 之前节点为 abcd，所以b.index === 1</span><br><span class="line">此时 oldIndex === 1;</span><br><span class="line">比较 oldIndex 与 lastPlacedIndex;</span><br><span class="line">oldIndex 1 &lt; lastPlacedIndex 3</span><br><span class="line">则 b节点需要向右移动</span><br><span class="line"></span><br><span class="line">继续遍历剩余newChildren</span><br><span class="line"></span><br><span class="line">// 当前oldFiber：c</span><br><span class="line">// 当前newChildren c</span><br><span class="line"></span><br><span class="line">key === c 在 oldFiber中存在</span><br><span class="line">const oldIndex = c（之前）.index; // 之前节点为 abcd，所以c.index === 2</span><br><span class="line">此时 oldIndex === 2;</span><br><span class="line">比较 oldIndex 与 lastPlacedIndex;</span><br><span class="line">oldIndex 2 &lt; lastPlacedIndex 3</span><br><span class="line">则 c节点需要向右移动</span><br><span class="line"></span><br><span class="line">===第二轮遍历结束===</span><br></pre></td></tr></table></figure>

<h1 id="my-react-代码分析"><a href="#my-react-代码分析" class="headerlink" title="my-react 代码分析"></a>my-react 代码分析</h1><p>这段代码基本上完成了一个小的 react，实现了 react 函数组件的基本功能以及一个 hooks（useState）<br>代码地址：<a target="_blank" rel="noopener" href="https://github.com/penghei/MyReact/blob/master/my-react_hooks.js">https://github.com/penghei/MyReact/blob/master/my-react_hooks.js</a></p>
<h2 id="代码模块解析"><a href="#代码模块解析" class="headerlink" title="代码模块解析"></a>代码模块解析</h2><p>这里主要是对不同函数的大致原理、功能作用的解释；部分函数的相互关系很复杂，具体算法也不简单，因此只是概述</p>
<h4 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h4><ul>
<li>相当于 <code>React.createElement</code>, 在这里就是自己手写的创建元素式. babel 通过这个函数把 jsx 解析为 react 结点对象.</li>
<li>主要原理: 返回一个对象,有 type 属性(表示结点 dom 类型,比如”div”),props 主要为 html 元素上的属性(比如 id)以及 children(子元素数组)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ele = &#123;</span><br><span class="line">    <span class="attr">type</span>:<span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    <span class="attr">props</span>:&#123;</span><br><span class="line">        <span class="attr">id</span>:<span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">        <span class="attr">children</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                type=<span class="string">&#x27;text&#x27;</span></span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个对象就是 react 的主要解析对象,也是 jsx 的 js 表现形式</p>
<h4 id="createTextElement"><a href="#createTextElement" class="headerlink" title="createTextElement"></a>createTextElement</h4><p>对于文本结点的专门创建函数, 一般是整个结构的最后一节, 表现为 type 为”TEXT”的文本, 不再有子元素, 结点值为相应的文本内容</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ele = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;TEXT_ELEMENT&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">nodeValue</span>: <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">    <span class="attr">children</span>: [],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="createDom"><a href="#createDom" class="headerlink" title="createDom"></a>createDom</h4><p>创建 fiber 对象的 dom 结点</p>
<ol>
<li>首先判断该 fiber 对象的类型, 如果非文本就调用<code>document.createElement</code>创建 dom 对象, 否则就用<code>document.createTextNode</code>创建文本.</li>
<li>使用 <code>updateDom</code> 函数给改 dom 元素打上属性、事件监听器等。这个函数后面还会讲到</li>
</ol>
<h4 id="updateDom"><a href="#updateDom" class="headerlink" title="updateDom"></a>updateDom</h4><p>给 dom 元素添加属性或事件监听器的函数。<br>这个函数的参数有三个，除了 dom 对象外还有 <code>prevProps</code> 和 <code>nextProps</code> 两个参数，分别表示旧属性和新属性，在 fiber 树中体现为上次的旧 fiber 树内容和这次更新的新 fiber 树内容。<br>通过比较对 dom 对象上的属性和事件监听器进行增删改，是 diff 算法在比较之后的实现部分。</p>
<h4 id="commitRoot-amp-commitWork"><a href="#commitRoot-amp-commitWork" class="headerlink" title="commitRoot &amp; commitWork"></a>commitRoot &amp; commitWork</h4><p>Reconciler“提交”函数<br><code>commitWork</code> 通过递归的方式，判断 fiber 的不同标记（<code>effectTag</code>），执行不同的处理（增删改）。<code>commitRoot</code> 是 <code>commitWork</code> 的辅助函数，两个合在一起体现为提交给 <code>renderer</code> 来进行真实 dom 的渲染。</p>
<h4 id="render"><a href="#render" class="headerlink" title="render"></a>render</h4><p>这里的 render 函数并不等同于架构的渲染器，而更像是一个创建 fiber 对象的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wipRoot = &#123;</span><br><span class="line">  <span class="attr">dom</span>: container,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">children</span>: [element],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">alternate</span>: currentRoot, <span class="comment">//用alternate把currentFiberTree和WipFiberTree连接起来，用diff算法比较更新</span></span><br><span class="line">&#125;;</span><br><span class="line">nextUnitOfWork = wipRoot;</span><br></pre></td></tr></table></figure>

<p>这里，<code>wip</code> 表示正在处理的 fiber 树，对应 current 表示显示的 fiber 树，在 diff 算法中体现为旧（wip）和新（current）树，两者用 <code>alternate</code> 连接；每一个 dom 节点都会渲染一次并创建出 fiber 对象</p>
<h4 id="workLoop"><a href="#workLoop" class="headerlink" title="workLoop"></a>workLoop</h4><p>Reconciler 的核心函数，通过<code>requestIdleCallback</code>执行浏览器空闲循环，并在有剩余时间时执行<code>performUnitOfWork</code>函数。这个函数的主要作用为：</p>
<ul>
<li>处理 fiber 节点</li>
<li>返回下一个节点</li>
</ul>
<h4 id="performUnitOfWork"><a href="#performUnitOfWork" class="headerlink" title="performUnitOfWork"></a>performUnitOfWork</h4><ul>
<li>首先给 fiber 创建真实 dom，依靠 <code>createDom</code> 函数</li>
<li>处理 fiber 节点依靠 <code>reconcileChildren</code> 函数，也就是 diff 算法的主要实现；</li>
<li>返回下一个节点，通过 DFS 查找，逻辑为：<ol>
<li>如果有子节点，就返回子节点为下一个</li>
<li>没有子节点返回兄弟节点</li>
<li>都没有，返回“叔叔”，即兄弟节点的父节点</li>
</ol>
</li>
</ul>
<h4 id="reconcileChildren"><a href="#reconcileChildren" class="headerlink" title="reconcileChildren"></a>reconcileChildren</h4><p>Reconciler（协调器）的核心函数</p>
<ul>
<li>对于 mount 的组件，会创建新的子 Fiber 节点</li>
<li>对于 update 的组件，会将当前组件与该组件在上次更新时对应的 Fiber 节点比较（Diff 算法），将比较的结果生成新 Fiber 节点<br>如果只通过在 <code>performUnitOfWork</code> 中为子元素创建 fiber 对象并构建 fiber 树，当浏览器中断时会造成一个不完整的 ui；因此不应该在 <code>performUnitOfWork</code> 函数中直接改变 dom。<br>参数有两个，分别是当前 fiber 和 fiber 对象的子元素。函数主要通过比较这两个的 type 判断：</li>
</ul>
<ol>
<li>比较新旧 fiber 树中的元素类型,如果相同就认作 <code>sameType</code></li>
<li>如果是 <code>sameType</code>,保留 dom 结点并更新</li>
<li>如果不是 <code>sameType</code> 但新 fiber 树中有,说明要添加</li>
<li>如果不是 <code>sameType</code> 但旧 fiber 树中有,说明要删除, 即不需要创建 <code>newFiber</code></li>
</ol>
<p>创建的 <code>newFiber</code> 如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">newFiber = &#123;</span><br><span class="line">  <span class="attr">type</span>: oldFiber.type, <span class="comment">//类型不变</span></span><br><span class="line">  <span class="attr">props</span>: element.props, <span class="comment">//新fiber树中对应节点的props</span></span><br><span class="line">  <span class="attr">dom</span>: oldFiber.dom, <span class="comment">//保留dom元素</span></span><br><span class="line">  <span class="attr">parent</span>: wipFiber, <span class="comment">//父元素仍然是oldFiber的父元素,即wipFiber</span></span><br><span class="line">  <span class="attr">alternate</span>: oldFiber, <span class="comment">//和旧元素连接起来</span></span><br><span class="line">  <span class="attr">effectTag</span>: <span class="string">&quot;UPDATE&quot;</span>, <span class="comment">//增加这个属性表示当前是更新,在commit过程中告知render执行更新操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后通过 DFS 插入 fiber 树，最后拼接成一个新的 fiber 树<br>该函数之所以选择子元素和父元素作为新、旧 fiber 对象，主要原因是同时承担了 mount 和 update 两个部分的任务</p>
<ol>
<li>mount：当第一次执行该函数时时创建 fiber 树的时候，也就是组件的挂载；这时候所有的 alternate 都是 null，表示没有 oldFiber；这里的 oldFiber 由于是 null，因此 sameType 也是 null，只会进入添加新节点的分支，也就是创建新节点并连接成 fiber 树。这时候并未触发比较更新的部分；</li>
<li>update：这时如果触发更新，新元素的 alternate 就会指向对应的旧元素；这时 oldFiber 不为 null，就会进行比较，创建新的 fiber 元素，并在结束之后回到 workLoop 函数提交给 renderer 渲染。</li>
</ol>
<p>因此这个函数会在 mount 时创建节点，也会在 update 时更新新的 fiber 和 <code>oldFiber</code> 通过 <code>alternate</code> 连接；</p>
<p>至于 diff 算法，就是在第二点更新时决定是否复用旧 fiber 树的算法。这里实现的是单节点 diff 算法，即通过判断元素的 type（如”div”）决定是否要复用、创建或者删除。</p>
<h4 id="updateFunctionComponent-amp-updateHostComponent"><a href="#updateFunctionComponent-amp-updateHostComponent" class="headerlink" title="updateFunctionComponent &amp; updateHostComponent"></a>updateFunctionComponent &amp; updateHostComponent</h4><p>函数组件特殊处理,children 从函数运行得出（return），而不是直接从 <code>fiber.props</code> 获取；<br>对于正常的非函数组件仍然按照之前的处理方式（构建 fiber 树、提交等）<br>因此我们需要在进入 <code>reconcileChildren</code> 时进行一次判断，如果是函数组件就对函数组件进行处理。</p>
<h4 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h4><p>相当于 react 原生的 <code>useState</code> 简化版。<br>在 state 和 hooks 架构中讲到过 state 更新的原理，这里详述一下 <code>useState</code> 的执行逻辑。<br>state 的数据在 mount 和 update 两种状态中都会被处理；</p>
<ul>
<li>mount 时没有 <code>currentFiber 树</code>，因此也就相当于没有 <code>oldHook</code>；这时直接把 init 值赋给 state，actions 为空；</li>
<li>update 时触发 <code>setState</code> 函数，向 actions push action，并创建新的 <code>wipRoot</code> 并赋给 <code>nextUnitOfWork</code>；<code>nextUnitOfWork</code> 被赋值就意味着新的渲染，依次调用 <code>workLoop</code>、<code>performUnitOfWork</code> 和 <code>reconcileChildren</code> 并提交渲染。</li>
</ul>
<p>一个组件可能会调用多个 <code>useState</code>，每一个 <code>useState</code> 都会维护一个 hook 对象；hooks 数组在函数组件中是唯一的，表示不同的 hook 集合成的 hooks；因此 fiber 数据结构可以表示如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">wipFiber = &#123;</span><br><span class="line">  <span class="attr">alternate</span>: <span class="literal">null</span> || currentFiber, <span class="comment">//更新时指向currentFiber</span></span><br><span class="line">  <span class="attr">child</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">dom</span>: <span class="literal">null</span> || DOM, <span class="comment">//在useState调用时还没有创建fiber树，因此没有dom节点</span></span><br><span class="line">  <span class="attr">effectTag</span>: <span class="string">&quot;PLACEMENT&quot;</span> || <span class="string">&quot;UPDATE&quot;</span>, <span class="comment">//更新时为Update</span></span><br><span class="line">  <span class="attr">hooks</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//一个hook</span></span><br><span class="line">      <span class="attr">state</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">queue</span>: [<span class="function">(<span class="params">num</span>) =&gt;</span> num++, <span class="function">(<span class="params">num</span>) =&gt;</span> num--],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//另一个hook</span></span><br><span class="line">      <span class="attr">state</span>: <span class="string">&quot;zzx&quot;</span>,</span><br><span class="line">      <span class="attr">queue</span>: [<span class="function">(<span class="params">arr</span>) =&gt;</span> arr.length],</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">parent</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">props</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">type</span>: <span class="built_in">Function</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="代码流程解析"><a href="#代码流程解析" class="headerlink" title="代码流程解析"></a>代码流程解析</h2><ol>
<li>首先调用 <code>render</code> 函数，传入解析后的 jsx 和 root 结点；</li>
<li><code>render</code> 函数创建一个根 fiber 节点</li>
<li><code>requestIdleCallback</code> 在浏览器空闲时间调用 <code>workLoop，然后依次执行</code> <code>performUnitOfWork</code> 和 <code>reconcileChildren</code> 函数，创建 <code>fiber</code> 对象的 dom 节点并组合起来构建 <code>fiber</code> 树，这时的 <code>fiber</code> 树是 <code>workInProgress Fiber树</code>；</li>
<li>如果没有时间不足，就在执行完毕后提交 dom 树给 <code>renderer</code>，<code>workInProgress Fiber 树</code>变为 <code>current Fiber 树</code>。</li>
<li><code>commitWork</code> 根据节点的 <code>effectTag</code> 调用增、改、删操作，其中更新操作依靠 <code>updateDom</code> 给 <code>fiber</code> 元素的 dom 节点增删改属性和事件监听器。</li>
<li>完成渲染，显示在页面上；</li>
<li>如果触发事件，再次调用渲染函数；这时在第三步中的 <code>reconcileChildren</code> 就会执行更新，通过 diff 算法判断是否复用并创建新<code> workInProgress Fiber 树</code>，新增的 <code>fiber</code> 树和原 <code>current Fiber 树</code>节点间通过 <code>alternate</code> 连接，然后再次 <code>commit</code> 渲染到页面上。渲染完毕后，新增的 <code>workInProgress Fiber 树</code>变为 <code>current Fiber 树</code>。后续更新依次类推。</li>
</ol>
<p>对于函数组件的 state，还有额外的步骤：</p>
<ol>
<li>定义了<code>useState</code>，在 mount 的时候会创建该<code>useState</code>的<code>hook对象</code>并放入<code>hooks数组</code>中；初始化<code>hook.state</code>为<code>useState</code>的参数（也就是初始值），<code>actions</code>为空</li>
<li>更新元素，触发<code>setState</code>，向<code>hook.queue</code>添加<code>action</code>，然后依次执行；其中如果<code>action</code>不是函数就直接赋值；再创建<code>wipRoot</code>并赋给<code>nextUnitOfWork</code>，执行更新操作。</li>
</ol>
<p>通过<code>useState</code>，可以使之前手动重新渲染改成触发<code>setState</code>就一定进行重新渲染，这也就是 react 通过 state 更新的原理。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/">日常学习</a></div><div class="post_share"><div class="social-share" data-image="/img/my-react.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/15/blog37-recoil/"><img class="prev-cover" src="/img/recoil.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">react状态管理库-Recoil</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/09/blog35-webpack/"><img class="next-cover" src="/img/webpack.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">webpack学习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/11/06/blog11-myReact/" title="react知识点汇总和使用小总结(一)"><img class="cover" src="/img/react.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-06</div><div class="title">react知识点汇总和使用小总结(一)</div></div></a></div><div><a href="/2021/10/27/blog10-react-router/" title="react-router的使用"><img class="cover" src="/img/reactrouter.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-27</div><div class="title">react-router的使用</div></div></a></div><div><a href="/2021/11/20/blog14-react-ts-basic/" title="typescript+react基础部分"><img class="cover" src="/img/typescript.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-20</div><div class="title">typescript+react基础部分</div></div></a></div><div><a href="/2021/11/22/blog17-react-pubsub-issues/" title="react+typescript使用pubsub时的一点小问题"><img class="cover" src="/img/pubsub.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-22</div><div class="title">react+typescript使用pubsub时的一点小问题</div></div></a></div><div><a href="/2021/11/20/blog16-react-ts-hooks-redux/" title="typescript+react:自定义hooks代替redux"><img class="cover" src="/img/typescript.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-20</div><div class="title">typescript+react:自定义hooks代替redux</div></div></a></div><div><a href="/2021/11/25/blog18-vue3ts-basic/" title="vue3+ts配置及简单使用注意"><img class="cover" src="/img/vue3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-25</div><div class="title">vue3+ts配置及简单使用注意</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/pinkstar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xing Ye</div><div class="author-info__description">a singleThreaded boy's blog</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/penghei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/penghei" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:632885485@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">A SingleThreaded Boy...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#react-%E6%B7%B1%E5%85%A5%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">react 深入原理学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">理念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#react-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">react 基本架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Scheduler%EF%BC%88%E8%B0%83%E5%BA%A6%E5%99%A8%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">Scheduler（调度器）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">理解优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">优先级调度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reconciler%EF%BC%88%E5%8D%8F%E8%B0%83%E5%99%A8%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">Reconciler（协调器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Renderer%EF%BC%88%E6%B8%B2%E6%9F%93%E5%99%A8%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">Renderer（渲染器）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">归</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#react-%E4%B8%BB%E8%A6%81%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">react 主要结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Fiber"><span class="toc-number">1.3.1.</span> <span class="toc-text">Fiber</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BA%E6%9E%B6%E6%9E%84%EF%BC%88fiber-%E6%A0%91%EF%BC%89"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">作为架构（fiber 树）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">静态数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">动态工作单元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fiber-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">fiber 的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#mount"><span class="toc-number">1.3.1.4.1.</span> <span class="toc-text">mount</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#update"><span class="toc-number">1.3.1.4.2.</span> <span class="toc-text">update</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSX"><span class="toc-number">1.3.2.</span> <span class="toc-text">JSX</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6"><span class="toc-number">1.3.3.</span> <span class="toc-text">函数组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#state-amp-hooks"><span class="toc-number">1.3.4.</span> <span class="toc-text">state &amp; hooks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Diff-%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.5.</span> <span class="toc-text">Diff 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E8%8A%82%E7%82%B9-Diff"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">单节点 Diff</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%8A%82%E7%82%B9-diff"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">多节点 diff</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%BD%AE%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.5.2.1.</span> <span class="toc-text">第一轮遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%BD%AE%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.5.2.2.</span> <span class="toc-text">第二轮遍历</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#my-react-%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">my-react 代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9D%97%E8%A7%A3%E6%9E%90"><span class="toc-number">2.1.</span> <span class="toc-text">代码模块解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#createElement"><span class="toc-number">2.1.0.1.</span> <span class="toc-text">createElement</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#createTextElement"><span class="toc-number">2.1.0.2.</span> <span class="toc-text">createTextElement</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#createDom"><span class="toc-number">2.1.0.3.</span> <span class="toc-text">createDom</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#updateDom"><span class="toc-number">2.1.0.4.</span> <span class="toc-text">updateDom</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#commitRoot-amp-commitWork"><span class="toc-number">2.1.0.5.</span> <span class="toc-text">commitRoot &amp; commitWork</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#render"><span class="toc-number">2.1.0.6.</span> <span class="toc-text">render</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#workLoop"><span class="toc-number">2.1.0.7.</span> <span class="toc-text">workLoop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#performUnitOfWork"><span class="toc-number">2.1.0.8.</span> <span class="toc-text">performUnitOfWork</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reconcileChildren"><span class="toc-number">2.1.0.9.</span> <span class="toc-text">reconcileChildren</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#updateFunctionComponent-amp-updateHostComponent"><span class="toc-number">2.1.0.10.</span> <span class="toc-text">updateFunctionComponent &amp; updateHostComponent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#useState"><span class="toc-number">2.1.0.11.</span> <span class="toc-text">useState</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">代码流程解析</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/28/blog39-canvas/" title="canvas学习"><img src="/img/canvas.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="canvas学习"/></a><div class="content"><a class="title" href="/2022/01/28/blog39-canvas/" title="canvas学习">canvas学习</a><time datetime="2022-01-28T06:28:26.000Z" title="发表于 2022-01-28 14:28:26">2022-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/28/blog38-svg/" title="svg学习"><img src="/img/svg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="svg学习"/></a><div class="content"><a class="title" href="/2022/01/28/blog38-svg/" title="svg学习">svg学习</a><time datetime="2022-01-28T06:00:12.000Z" title="发表于 2022-01-28 14:00:12">2022-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/15/blog37-recoil/" title="react状态管理库-Recoil"><img src="/img/recoil.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="react状态管理库-Recoil"/></a><div class="content"><a class="title" href="/2022/01/15/blog37-recoil/" title="react状态管理库-Recoil">react状态管理库-Recoil</a><time datetime="2022-01-15T09:03:25.000Z" title="发表于 2022-01-15 17:03:25">2022-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/10/blog36-react-deeping/" title="react深入源码学习"><img src="/img/my-react.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="react深入源码学习"/></a><div class="content"><a class="title" href="/2022/01/10/blog36-react-deeping/" title="react深入源码学习">react深入源码学习</a><time datetime="2022-01-10T08:24:25.000Z" title="发表于 2022-01-10 16:24:25">2022-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/09/blog35-webpack/" title="webpack学习"><img src="/img/webpack.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="webpack学习"/></a><div class="content"><a class="title" href="/2022/01/09/blog35-webpack/" title="webpack学习">webpack学习</a><time datetime="2022-01-09T05:14:15.000Z" title="发表于 2022-01-09 13:14:15">2022-01-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Xing Ye</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hello stranger!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>