<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>多种react状态管理库——介绍和原理 | XingYeBlog</title><meta name="keywords" content="日常学习"><meta name="author" content="Xing Ye,632885485@qq.com"><meta name="copyright" content="Xing Ye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redux基础概念首先是 Redux 的一些结构： store用于保存 state 的一个对象。在一个 Redux app 中，通常只有一个 store，可以有多个 reducer 表示不同的状态的持有。就像一个 React 组件中可以有多个 useState，但是 fiber 只能有一个。 store 对象是一些函数的集合： 1234567const store &#x3D; &amp;#123;  dispat">
<meta property="og:type" content="article">
<meta property="og:title" content="多种react状态管理库——介绍和原理">
<meta property="og:url" content="http://example.com/2022/01/15/react-state-store/index.html">
<meta property="og:site_name" content="XingYeBlog">
<meta property="og:description" content="Redux基础概念首先是 Redux 的一些结构： store用于保存 state 的一个对象。在一个 Redux app 中，通常只有一个 store，可以有多个 reducer 表示不同的状态的持有。就像一个 React 组件中可以有多个 useState，但是 fiber 只能有一个。 store 对象是一些函数的集合： 1234567const store &#x3D; &amp;#123;  dispat">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/recoil.png">
<meta property="article:published_time" content="2022-01-15T09:03:25.000Z">
<meta property="article:modified_time" content="2023-07-22T02:17:56.220Z">
<meta property="article:author" content="Xing Ye">
<meta property="article:tag" content="日常学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/recoil.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2022/01/15/react-state-store/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '多种react状态管理库——介绍和原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-22 10:17:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/pinkstar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/recoil.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XingYeBlog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">多种react状态管理库——介绍和原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-15T09:03:25.000Z" title="发表于 2022-01-15 17:03:25">2022-01-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-22T02:17:56.220Z" title="更新于 2023-07-22 10:17:56">2023-07-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/React/">React</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>68分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="多种react状态管理库——介绍和原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>首先是 Redux 的一些结构：<br><img src="https://pic.imgdb.cn/item/63b64b07be43e0d30e702dc8.jpg"></p>
<h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p>用于保存 state 的一个对象。在一个 Redux app 中，通常只有一个 store，可以有多个 reducer 表示不同的状态的持有。就像一个 React 组件中可以有多个 useState，但是 fiber 只能有一个。</p>
<p>store 对象是一些函数的集合：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = &#123;</span><br><span class="line">  <span class="attr">dispatch</span>: dispatch <span class="keyword">as</span> Dispatch&lt;A&gt;,</span><br><span class="line">  subscribe,</span><br><span class="line">  getState,</span><br><span class="line">  replaceReducer,</span><br><span class="line">  [$$observable]: observable,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>store 对象内部并没有一个“state”属性，只有在调用函数时才会使用这个 state。<br>state 实际上是 createStore 函数内部的一个变量 currentState，而其他函数都是使用这个变量的闭包；</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currentState = preloadedState <span class="keyword">as</span> S;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>): <span class="title">S</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentState <span class="keyword">as</span> S;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  currentState = currentReducer(currentState, action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><p>一个接收 state、返回 state 的函数。在 redux 中还有第二个参数 action，表示要更改的类型（type）和携带的数据（payload）。经过逻辑处理后，返回的 state 将作为新的 state 使用。</p>
<p>reducer 不能直接修改 state（state 是对象或数组），而是要复制 state，并对复制的值做修改。不能修改的主要原因是要符合 Redux“数据不可变”的理念。</p>
<blockquote>
<p>其实纯 redux 并没有对 reducer 内部的操作做出限制，源码中也只是调用获取 state：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  isDispatching = <span class="literal">true</span>;</span><br><span class="line">  currentState = currentReducer(currentState, action);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  isDispatching = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但维持这种形式，主要目的是维持其他功能的有效性，比如状态的回溯、测试等。</p>
</blockquote>
<p>reducer 可以有多个，但是最终 redux 会将其合为一个，作为一个“rootReducer”。从 createStore 函数内部可以看出，参数只能是一个 reducer，调用也只调用了一次。<br>如果有多个 reducer，那就需要 combineReducer 合并了。</p>
<h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>action是一个包含type和payload?的对象。<br>action本身比较简单，但是有个问题是，为什么redux一定需要一个action？</p>
<p>显然直接调dispatch传入状态也是完全可以的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch(someState)</span><br></pre></td></tr></table></figure>

<p>主要原因有几个：</p>
<ol>
<li>action体现了redux对状态的可控性、复现性。也就是说，action的存在使得redux可以更好地追踪状态的流向，可以很轻易地跟踪、捕获和预测状态变化。</li>
</ol>
<p>如果只是一个简单的数据而不是action，当通过dispatch调度时就很难确定这个状态到底是来自哪里、归属于哪个reducer、哪个状态里的修改。<br>比如一个action是这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">type</span>: <span class="string">&#x27;todos/todoAdded&#x27;</span>, <span class="attr">payload</span>: todoText&#125;</span><br></pre></td></tr></table></figure>

<p>这样很容易就能确认，这个action是为了todos状态服务的，且要修改的操作为todoAdded。<br>当redux进行调试、测试时，也能很容易捕获状态以及其所指向的状态对象。</p>
<ol start="2">
<li>action配合reducer内的条件语句，才能达成更好的状态修改，以保证状态不可变。</li>
</ol>
<p>假如我们只是给reducer传一个状态</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reducer(someState)</span><br></pre></td></tr></table></figure>

<p>那么这个状态是干什么的呢？它应该怎么创建新的state？这个传入的参数只是一个变量，还是原来的整个state？显然这些都很难确定。<br>reducer的存在就是为了服务于redux“状态不可变”的理念。redux要求reducer必须传出一个新的状态用以替代原状态，那么reducer就需要知道具体对状态是怎么操作的。</p>
<h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>redux 的核心数据，也是数据的基本单位，即“状态”。状态不能手动直接改变，唯一改变的方式就是调用 dispatch，触发 reducer，并在 reducer 内部做出修改。</p>
<p><strong>Redux 的状态只能为对象或数组</strong>，其他的类型都不可以，包括 map、set、一般数据类型。</p>
<p>state 是不可变的，每一次对 state 的更改都是以一个新的值替换旧的 state，而不是修改 state。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能这样</span></span><br><span class="line"><span class="keyword">const</span> state = store.getState();</span><br><span class="line">state.count = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer中也不能直接修改</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  state.count = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这两种操作本身的逻辑是没有问题的。也就是说，直接修改了 state 确实会使 state 改变，但 redux 限制这种做法。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p>subscriber：当 state 发生改变时，store 会通知所有的订阅者，将最新的 state 传给他。在 React-Redux 中，订阅者就是 React 组件</p>
</li>
<li><p>selector：一个“取 state”的函数。因为 state 通常是对象，selector 的作用就是把 state 的某个属性提取出来，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selectCounterValue = <span class="function">(<span class="params">state</span>) =&gt;</span> state.value;</span><br><span class="line"><span class="keyword">const</span> currentValue = selectCounterValue(store.getState());</span><br><span class="line"><span class="built_in">console</span>.log(currentValue);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="middleWare"><a href="#middleWare" class="headerlink" title="middleWare"></a>middleWare</h3><p>即“中间件”，类似于 express 这种中间件的形式。在 redux 中中间件主要是在调用 dispatch 方法时添加操作<br>比如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> middlewareEnhancer = applyMiddleware(print1, print2, print3);</span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer, middlewareEnhancer);</span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">&quot;todos/todoAdded&quot;</span>, <span class="attr">payload</span>: <span class="string">&quot;Learn about actions&quot;</span> &#125;);</span><br><span class="line"><span class="comment">// log: &#x27;1&#x27;</span></span><br><span class="line"><span class="comment">// log: &#x27;2&#x27;</span></span><br><span class="line"><span class="comment">// log: &#x27;3&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果需要编写 middeware，redux 提供了一个范式，即所有的 middleware 其实都是这种形式的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exampleMiddleware</span>(<span class="params">storeAPI</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">wrapDispatch</span>(<span class="params">next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">handleAction</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 这里是主要逻辑</span></span><br><span class="line">      <span class="keyword">return</span> next(action);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>exampleMiddleware：即中间件本身。比如上面的 print1、print2 这几个函数就是这样。参数 storeAPI 是 store 的一部分，只包含 dispatch 和 getState 方法</li>
<li>wrapDispatch：用于传递 dispatch。参数 next 可能是原本的 store.dispatch 函数，也可能是下一个中间件函数，调用 next 函数会将 action 传递给下一个中间件，或直接调用真实的 dispatch 结束中间件的调用。</li>
<li>handleAction：中间件实际执行逻辑的地方，参数是本次调用的 action。</li>
</ul>
<p>这三个函数没有明确的函数名，甚至可以这样写：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> anotherExampleMiddleware = <span class="function">(<span class="params">storeAPI</span>) =&gt;</span> <span class="function">(<span class="params">next</span>) =&gt;</span> <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 其他逻辑</span></span><br><span class="line">  <span class="keyword">return</span> next(action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在编写 middleware 时，可以看作是一个函数被传入了三个参数，即 store、dispatch 和 action</p>
<p>举个例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loggerMiddleware = <span class="function">(<span class="params">storeAPI</span>) =&gt;</span> <span class="function">(<span class="params">next</span>) =&gt;</span> <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;dispatching&quot;</span>, action);</span><br><span class="line">  <span class="keyword">let</span> result = next(action);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;next state&quot;</span>, storeAPI.getState());</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>中间件的返回值</p>
<h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><h3 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h3><p>createStore redux 中通过 createStore 可以创建一个 Store ，使用者可以将这个 Store 保存传递给 React 应用，具体怎么传递那就是 React-Redux 做的事了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Store = createStore(rootReducer, initialState, middleware);</span><br></pre></td></tr></table></figure>

<p>createStore 函数实际上是几个函数的集合。在函数内部创建了 currentReducer、currentState 和 currentListeners 这三个关键对象，后面将作为其他函数的闭包使用。<br>这几个关键变量的含义：</p>
<ul>
<li>currentReducer：即传入的 reducer</li>
<li>currentState：传给 reducer 的 state，同时也作为 reducer 的返回值，getState 返回的就是这个 state</li>
<li>currentListeners：一个 listeners 数组，表示所有的 listeners。当调用 dispatch 时会遍历这个数组并执行每个 listener；</li>
<li>nextListeners：currentListeners 的副本，调用 subscribe 时实际上是向 nextListeners 内放入 listener，最后会将 nextListeners 赋给 currentListeners</li>
<li>isDispatching：一个类似于 react 中批量更新开关的变量。表示当前“正在执行 dispatch”，具体来说是正在执行 reducer。如果 isDispatching 为 true，就不能执行其他操作，比如 subscribe、getState 等。主要是保证 reducer 执行过程的稳定</li>
</ul>
<p>然后就是几个关键的函数，下面会分章节说</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  reducer: Reducer&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  preloadedState?: PreloadedState&lt;S&gt; | StoreEnhancer&lt;Ext, StateExt&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  enhancer?: StoreEnhancer&lt;Ext, StateExt&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Store</span>&lt;<span class="title">ExtendState</span>&lt;<span class="title">S</span>, <span class="title">StateExt</span>&gt;, <span class="title">A</span>, <span class="title">StateExt</span>, <span class="title">Ext</span>&gt; &amp; <span class="title">Ext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currentReducer = reducer;</span><br><span class="line">  <span class="keyword">let</span> currentState = preloadedState <span class="keyword">as</span> S;</span><br><span class="line">  <span class="keyword">let</span> currentListeners: (<span class="function">() =&gt;</span> <span class="built_in">void</span>)[] | <span class="literal">null</span> = [];</span><br><span class="line">  <span class="keyword">let</span> nextListeners = currentListeners;</span><br><span class="line">  <span class="keyword">let</span> isDispatching = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>): <span class="title">S</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener: () =&gt; <span class="built_in">void</span></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action: A</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">replaceReducer</span>(<span class="params">nextReducer</span>): <span class="title">Store</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个type的action会将所有的reducer初始化，将他们持有的state初始化</span></span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: ActionTypes.INIT &#125; <span class="keyword">as</span> A);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> store = &#123;</span><br><span class="line">    <span class="attr">dispatch</span>: dispatch <span class="keyword">as</span> Dispatch&lt;A&gt;,</span><br><span class="line">    subscribe,</span><br><span class="line">    getState,</span><br><span class="line">    replaceReducer,</span><br><span class="line">    [$$observable]: observable,</span><br><span class="line">  &#125; <span class="keyword">as</span> unknown <span class="keyword">as</span> Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext;</span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getState"><a href="#getState" class="headerlink" title="getState"></a>getState</h4><p>非常简单，就是返回 currentState<br>唯一需要注意的是，在 isDispatching 期间不能获取。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>): <span class="title">S</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">&quot;You may not call store.getState() while the reducer is executing. &quot;</span> +</span><br><span class="line">        <span class="string">&quot;The reducer has already received the state as an argument. &quot;</span> +</span><br><span class="line">        <span class="string">&quot;Pass it down from the top reducer instead of reading it from the store.&quot;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> currentState <span class="keyword">as</span> S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h4><p>核心内容就是添加 listener 到 nextListeners 数组中去，返回一个 unsubscribe 函数用于卸载本次添加的 listener</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener: () =&gt; <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> isSubscribed = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 复制currListeners，主要目的是防止dispatch期间出现的问题</span></span><br><span class="line">  ensureCanMutateNextListeners();</span><br><span class="line">  nextListeners.push(listener);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isSubscribed) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    isSubscribed = <span class="literal">false</span>;</span><br><span class="line">    ensureCanMutateNextListeners();</span><br><span class="line">    <span class="keyword">const</span> index = nextListeners.indexOf(listener);</span><br><span class="line">    nextListeners.splice(index, <span class="number">1</span>);</span><br><span class="line">    currentListeners = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h4><p>传入一个 action，内部调用 reducer 获取最新 state，然后逐个调用 listener</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action: A</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行currentReducer的过程就是isDispatching的过程</span></span><br><span class="line">    isDispatching = <span class="literal">true</span>;</span><br><span class="line">    currentState = currentReducer(currentState, action);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isDispatching = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行listeners</span></span><br><span class="line">  <span class="keyword">const</span> listeners = (currentListeners = nextListeners);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> listener = listeners[i];</span><br><span class="line">    listener();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="replaceReducer"><a href="#replaceReducer" class="headerlink" title="replaceReducer"></a>replaceReducer</h4><p>替换当前的 reducer。<br>官方的注释说，这个函数主要用于动态加载或更新 reducer。他会将原本的 reducer 替换为传入的 reducer，然后返回一个 store</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceReducer</span>&lt;<span class="title">NewState</span>, <span class="title">NewActions</span> <span class="title">extends</span> <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  nextReducer: Reducer&lt;NewState, NewActions&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Store</span>&lt;<span class="title">ExtendState</span>&lt;<span class="title">NewState</span>, <span class="title">StateExt</span>&gt;, <span class="title">NewActions</span>, <span class="title">StateExt</span>, <span class="title">Ext</span>&gt; &amp; <span class="title">Ext</span> </span>&#123;</span><br><span class="line">  currentReducer = nextReducer;</span><br><span class="line">  <span class="comment">// store初始化会做的操作</span></span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: ActionTypes.REPLACE &#125; <span class="keyword">as</span> A);</span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如官方示例的热重载功能，即当在开发环境下修改了 reducer 后，如果不添加热重载，就需要刷新去重新读取新的 reducer；而热重载可以监听 reducer 的变化，如果发生改变就调用 replaceReducer 更新 reducer。</p>
<p>其中，module.hot.accept 方法来自于 webpack 提供的 api，用以监听哪个模块发生了变动，应该被重载。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; applyMiddleware, compose, createStore &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> thunkMiddleware <span class="keyword">from</span> <span class="string">&quot;redux-thunk&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> monitorReducersEnhancer <span class="keyword">from</span> <span class="string">&quot;./enhancers/monitorReducers&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> loggerMiddleware <span class="keyword">from</span> <span class="string">&quot;./middleware/logger&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">&quot;./reducers&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">configureStore</span>(<span class="params">preloadedState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> middlewares = [loggerMiddleware, thunkMiddleware];</span><br><span class="line">  <span class="keyword">const</span> middlewareEnhancer = applyMiddleware(...middlewares);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> enhancers = [middlewareEnhancer, monitorReducersEnhancer];</span><br><span class="line">  <span class="keyword">const</span> composedEnhancers = compose(...enhancers);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> store = createStore(rootReducer, preloadedState, composedEnhancers);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span> &amp;&amp; <span class="built_in">module</span>.hot) &#123;</span><br><span class="line">    <span class="built_in">module</span>.hot.accept(<span class="string">&quot;./reducers&quot;</span>, <span class="function">() =&gt;</span> store.replaceReducer(rootReducer));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="preloadedState"><a href="#preloadedState" class="headerlink" title="preloadedState"></a>preloadedState</h4><p>可以作为 createStore 的第二个参数传入，表示 state 的初始值。<br>虽然 reducer 本身也有一个初始值，但由于 createStore 的创建时机，这时可以进行进行一些预操作，比如取 localStorage 等。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> preloadedState;</span><br><span class="line"><span class="keyword">const</span> persistedTodosString = <span class="built_in">localStorage</span>.getItem(<span class="string">&quot;todos&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (persistedTodosString) &#123;</span><br><span class="line">  preloadedState = &#123;</span><br><span class="line">    <span class="attr">todos</span>: <span class="built_in">JSON</span>.parse(persistedTodosString),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer, preloadedState);</span><br></pre></td></tr></table></figure>

<h4 id="enhancer"><a href="#enhancer" class="headerlink" title="enhancer"></a>enhancer</h4><p>作为创建的 store 的“增强剂”，enhancer 是一个接受原 createStore 函数，并返回一个“增强”之后的 createStore 函数的函数。<br>enhancer 函数接受旧的 reducer，会返回一个新的 reducer，并且新的 reducer 内部会调用旧的 reducer。这样，就相当于在旧 reducer 的基础上，添加了一些 case 用以强化原 reducer。<br>比如一个添加撤销效果的 enhancer，他可以接受任意一个普通的 reducer，在原本 reducer 基础上添加 undo 和 redo 两个 case，从而添加撤销和重做功能。原本的 case 和 state 依然存在</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">undoable</span>(<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> initialState = &#123;</span><br><span class="line">    <span class="attr">past</span>: [],</span><br><span class="line">    <span class="attr">present</span>: reducer(<span class="literal">undefined</span>, &#123;&#125;),</span><br><span class="line">    <span class="attr">future</span>: [],</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 返回的新reducer</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">state = initialState, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; past, present, future &#125; = state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;UNDO&quot;</span>:</span><br><span class="line">        <span class="keyword">const</span> previous = past[past.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">const</span> newPast = past.slice(<span class="number">0</span>, past.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">past</span>: newPast,</span><br><span class="line">          <span class="attr">present</span>: previous,</span><br><span class="line">          <span class="attr">future</span>: [present, ...future],</span><br><span class="line">        &#125;;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;REDO&quot;</span>:</span><br><span class="line">        <span class="keyword">const</span> next = future[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">const</span> newFuture = future.slice(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">past</span>: [...past, present],</span><br><span class="line">          <span class="attr">present</span>: next,</span><br><span class="line">          <span class="attr">future</span>: newFuture,</span><br><span class="line">        &#125;;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 在内部调用旧reducer，保证兼容原本reducer的情况</span></span><br><span class="line">        <span class="comment">// 旧reducer返回值就是原本的state，原来的state也要和当前的state合并</span></span><br><span class="line">        <span class="keyword">const</span> newPresent = reducer(present, action);</span><br><span class="line">        <span class="keyword">if</span> (present === newPresent) &#123;</span><br><span class="line">          <span class="keyword">return</span> state;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">past</span>: [...past, present],</span><br><span class="line">          <span class="attr">present</span>: newPresent,</span><br><span class="line">          <span class="attr">future</span>: [],</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>enhancer 的调用，具体来说是这样：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 enhancer 的返回值其实就是 createStore 函数的强化版</p>
<p>多个 enhancer 可以通过 compose 函数合并：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  sayHiOnDispatch,</span><br><span class="line">  includeMeaningOfLife,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;./exampleAddons/enhancers&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> composedEnhancer = compose(sayHiOnDispatch, includeMeaningOfLife);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer, <span class="literal">undefined</span>, composedEnhancer);</span><br></pre></td></tr></table></figure>

<h3 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h3><p>正常状态可以会有多个 reducer ，combineReducers 可以合并多个 reducer。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将 number 和 PersonalInfo 两个reducer合并   */</span></span><br><span class="line"><span class="keyword">const</span> rootReducer = combineReducers(&#123;</span><br><span class="line">  <span class="attr">number</span>: numberReducer,</span><br><span class="line">  <span class="attr">info</span>: InfoReducer,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>combineReducers 接受一个对象，其中键名将成为根状态对象中的键。这个键很重要，在 combineReducers 内部就是通过键来分配 state 的。</p>
<p>combineReducers 函数代码简化如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">combineReducers</span>(<span class="params">reducers: ReducersMapObject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 复制reducers对象到finalReducers</span></span><br><span class="line">  <span class="keyword">const</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers);</span><br><span class="line">  <span class="keyword">const</span> finalReducers: ReducersMapObject = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; reducerKeys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = reducerKeys[i];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> reducers[key] === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      finalReducers[key] = reducers[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> finalReducerKeys = <span class="built_in">Object</span>.keys(finalReducers);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个地方是检查每个reducer有没有问题，比如类型不是函数、返回undefined等</span></span><br><span class="line">  <span class="keyword">let</span> shapeAssertionError: unknown;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    assertReducerShape(finalReducers);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    shapeAssertionError = e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个combination函数，即新的reducer，参数和单个reducer相同</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">combination</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// 这里的state被合并成了一个大的state。下面会说</span></span></span></span><br><span class="line"><span class="params"><span class="function">    state: StateFromReducersMapObject&lt;<span class="keyword">typeof</span> reducers&gt; = &#123;&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">    action: AnyAction</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> hasChanged = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 新的state</span></span><br><span class="line">    <span class="keyword">const</span> nextState: StateFromReducersMapObject&lt;<span class="keyword">typeof</span> reducers&gt; = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> key = finalReducerKeys[i];</span><br><span class="line">      <span class="keyword">const</span> reducer = finalReducers[key];</span><br><span class="line">      <span class="keyword">const</span> previousStateForKey = state[key];</span><br><span class="line">      <span class="comment">// 遍历所有的reducer，把对应的state传进去</span></span><br><span class="line">      <span class="keyword">const</span> nextStateForKey = reducer(previousStateForKey, action);</span><br><span class="line">      nextState[key] = nextStateForKey;</span><br><span class="line">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;</span><br><span class="line">    &#125;</span><br><span class="line">    hasChanged =</span><br><span class="line">      hasChanged || finalReducerKeys.length !== <span class="built_in">Object</span>.keys(state).length;</span><br><span class="line">    <span class="comment">// 返回新的state，和原本的state相同结构</span></span><br><span class="line">    <span class="keyword">return</span> hasChanged ? nextState : state;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>combineReducers 的返回值 combine 函数实际上就是一个 reducer。这个 reducer 并不会被用户调用，而是和其他所有的 reducer 一样，在 dispatch 函数内部被调用。</p>
<p>如果使用了 combineReducers，会发现它返回的 state 并不是一个单一的 state，而是一个由 key 标记的 state 对象；<br>比如原本有 count 和 color 两个 state：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> countState = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> colorState = &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>合并之后就成了：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="attr">count</span>: countState,</span><br><span class="line">  <span class="attr">color</span>: colorState,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>state 的合并也是在 combineReducers 中完成的，即 combineReducers 函数的返回值 nextState 本身就是一个合并的 state。<br>这也就是为什么说 combineReducers 传入的参数对象中的键很重要，因为这些键将会作为合并 state 的键；当调用<code>store.getState</code>时，返回的也是这样一个合并对象。</p>
<p>剩下的操作就是：遍历合并 reducer 对象中的每个 reducer，传入对应的 state，得到新的 state 单个，再插入到新的合并 state 对象上。<br>每个合并 reducer 对象上每个 reducer 的键和合并 state 对象上每个 state 的键是相同的。</p>
<h3 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h3><p>将中间件合并，返回一个 enhancer。<br>要说这个函数，主要要先讲一下中间件的概念。在 redux 中，中间件实际上是对 dispatch 方法的包装，即用一个函数包装 dispatch 方法，在调用 dispatch 之前先调用该中间件内的逻辑。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  ...middlewares: Middleware[]</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">StoreEnhancer</span>&lt;<span class="title">any</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">createStore: StoreEnhancerStoreCreator</span>) =&gt;</span></span><br><span class="line">    <span class="function">(<span class="params">reducer, preloadedState</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> store = createStore(reducer, preloadedState);</span><br><span class="line">      <span class="keyword">let</span> dispatch: Dispatch = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">          <span class="string">&quot;Dispatching while constructing your middleware is not allowed. &quot;</span> +</span><br><span class="line">            <span class="string">&quot;Other middleware would not be applied to this dispatch.&quot;</span></span><br><span class="line">        );</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> middlewareAPI: MiddlewareAPI = &#123;</span><br><span class="line">        <span class="attr">getState</span>: store.getState,</span><br><span class="line">        <span class="attr">dispatch</span>: <span class="function">(<span class="params">action, ...args</span>) =&gt;</span> dispatch(action, ...args),</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">const</span> chain = middlewares.map(<span class="function">(<span class="params">middleware</span>) =&gt;</span> middleware(middlewareAPI));</span><br><span class="line">      dispatch = compose&lt;<span class="keyword">typeof</span> dispatch&gt;(...chain)(store.dispatch);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...store,</span><br><span class="line">        dispatch,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面详细介绍一下这个函数。<br>首先，这个函数的返回值是一个 enhancer；上面说过 enhancer 实际上是接受 createStore 函数，返回一个新的 createStore 函数，新的 createStore 函数也要创建并返回一个 store 对象。因此这个函数的这些部分实际上是 enhancer 内容：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function">(<span class="params">createStore: StoreEnhancerStoreCreator</span>) =&gt;</span></span><br><span class="line">  <span class="function">(<span class="params">reducer, preloadedState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...实际的逻辑</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">enhancer(createStore)(currReducer, preloadedState);</span><br></pre></td></tr></table></figure>

<p>抽出内部的内容，才是 applyMiddleware 真正的执行内容</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(reducer, preloadedState);</span><br><span class="line"><span class="keyword">let</span> dispatch: Dispatch = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">    <span class="string">&quot;Dispatching while constructing your middleware is not allowed. &quot;</span> +</span><br><span class="line">      <span class="string">&quot;Other middleware would not be applied to this dispatch.&quot;</span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个对象将作为中间件函数的外层函数的参数，即storeAPI</span></span><br><span class="line"><span class="keyword">const</span> middlewareAPI: MiddlewareAPI = &#123;</span><br><span class="line">  <span class="attr">getState</span>: store.getState,</span><br><span class="line">  <span class="comment">// 注意这个dispatch，后面的dispatch实际上是上面用let定义的dispatch，调用会报错</span></span><br><span class="line">  <span class="attr">dispatch</span>: <span class="function">(<span class="params">action, ...args</span>) =&gt;</span> dispatch(action, ...args),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// chain是一个middleware数组，每一项都是middleware的第二层的那个函数（即接收next参数）</span></span><br><span class="line"><span class="keyword">const</span> chain = middlewares.map(<span class="function">(<span class="params">middleware</span>) =&gt;</span> middleware(middlewareAPI));</span><br><span class="line"><span class="comment">// 关键，调用compose函数把chain内的函数合并起来，并传入真正的dispatch</span></span><br><span class="line">dispatch = compose(...chain)(store.dispatch);</span><br></pre></td></tr></table></figure>

<p>上面说过 middleware 的第二层实际上是这样：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapDispatch</span>(<span class="params">next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">handleAction</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> next(action);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此 chain 数组内的每一项，都是这样一个函数；</p>
<p>那么 compose 函数怎么做的呢？</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs: <span class="built_in">Function</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(</span><br><span class="line">    <span class="function">(<span class="params">a, b</span>) =&gt;</span></span><br><span class="line">      <span class="function">(<span class="params">...args: <span class="built_in">any</span></span>) =&gt;</span></span><br><span class="line">        a(b(...args))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如说有两个函数 a 和 b，那么 compose 的返回就是一个这样的函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function">(<span class="params">num</span>) =&gt;</span> num++</span><br><span class="line"><span class="keyword">const</span> b = <span class="function">(<span class="params">num</span>) =&gt;</span> num--</span><br><span class="line"></span><br><span class="line">compose(a,b) === <span class="function">(<span class="params">...args</span>) =&gt;</span> a(b(...args))</span><br></pre></td></tr></table></figure>

<p>compose 的返回值是一个函数，这个函数接收的参数将会作为最内部的 compose 函数的参数调用，然后最内部的函数的返回值交给下一个函数，依次类推。<br>注意 compose 的返回值的返回值还是一个函数，因此实际调用是这样的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compose(...chain)(store.dispatch)(action);</span><br></pre></td></tr></table></figure>

<p>上面说过 chain 函数的形式就是 wrapDispatch 这种类型。那么通过 compose 合并之后就会形成一个链式调用。传入的 store.dispatch 会传给最内层的（也就是最后面的）中间件函数<br>因此<strong>第一个中间件函数的参数 next 实际上是 store.dispatch。而后面的中间件的 next 则是前一个中间件的返回值，即前一个中间件的 handleAction 函数</strong>。最终，最后一个调用的中间件（即第一个参数）的返回值将作为 dispatch 函数的返回值。</p>
<p>最后，当 compose 合并完成后会赋给 dispatch 函数，这个 dispatch 会覆盖前面的 dispatch 并最终返回。因此最后的 dispatch 就是这个包装好的函数</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch = compose&lt;<span class="keyword">typeof</span> dispatch&gt;(...chain)(store.dispatch);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  ...store,</span><br><span class="line">  dispatch,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当调用 dispatch 时，实际上是在调用最后一个中间件的最后一层的 handleAction 函数。将 action 传入，然后调用真实的 dispatch 去执行 reducer。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleAction</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> next(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是上面说的步骤，handleAction 函数交给下一个 wrapDispatch，在执行一次上面的步骤，直到所有的中间件函数都被执行完。</p>
<p>注意：中间件本身的返回值并不重要（即 handleAction 的返回值），重要的是 wrapDispatch 函数的返回值，即 handleAction 函数本身；wrapDispatch 函数的返回值将传递给下一个 wrapDispatch 函数使用，这期间和 handleAction 函数内部并无关系。因此除了最后一个调用的中间件，其他中间件的返回值都不重要</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>下面是官方文档上的一个例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Redux basic example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/redux@latest/dist/redux.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        Clicked: <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;value&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span> times</span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;decrement&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> initialState = &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">value</span>: <span class="number">0</span>,</span></span><br><span class="line"><span class="javascript">      &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">counterReducer</span>(<span class="params">state = initialState, action</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">switch</span> (action.type) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">case</span> <span class="string">&quot;counter/incremented&quot;</span>:</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123; ...state, <span class="attr">value</span>: state.value + <span class="number">1</span> &#125;;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">case</span> <span class="string">&quot;counter/decremented&quot;</span>:</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123; ...state, <span class="attr">value</span>: state.value - <span class="number">1</span> &#125;;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">default</span>:</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> state;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> store = Redux.createStore(counterReducer);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> valueEl = <span class="built_in">document</span>.getElementById(<span class="string">&quot;value&quot;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// store.getState可以在任何地方获取到最新的state</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> state = store.getState();</span></span><br><span class="line"><span class="javascript">        valueEl.innerHTML = state.value.toString();</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      render();</span></span><br><span class="line"><span class="javascript">      <span class="comment">// render函数作为订阅者；当state发生改变时，render会被调用，内部的store.getState就会获得最新的state，从而更新ui</span></span></span><br><span class="line"><span class="javascript">      store.subscribe(render);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span></span></span><br><span class="line"><span class="javascript">        .getElementById(<span class="string">&quot;increment&quot;</span>)</span></span><br><span class="line"><span class="javascript">        .addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          store.dispatch(&#123; <span class="attr">type</span>: <span class="string">&quot;counter/incremented&quot;</span> &#125;);</span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span></span></span><br><span class="line"><span class="javascript">        .getElementById(<span class="string">&quot;decrement&quot;</span>)</span></span><br><span class="line"><span class="javascript">        .addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          store.dispatch(&#123; <span class="attr">type</span>: <span class="string">&quot;counter/decremented&quot;</span> &#125;);</span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="处理异步"><a href="#处理异步" class="headerlink" title="处理异步"></a>处理异步</h3><p>由于 reducer 必须是纯函数，因此如果想异步地修改状态，就只能通过在 dispatch 周围操作了。<br>redux 提供了中间件的形式去处理异步。基本思路是，当时 dispatch 传入的是一个函数时，调用这个函数；这个函数内部是异步代码，并最终会调用一个新的 dispatch。随后 state 会在新的 dispatch 中进行更新</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncFunctionMiddleware = <span class="function">(<span class="params">storeAPI</span>) =&gt;</span> <span class="function">(<span class="params">next</span>) =&gt;</span> <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> action(storeAPI.dispatch, storeAPI.getState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> next(action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后可以编写一个异步的 action 函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchSomeData = <span class="function">(<span class="params">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class="line">  request.get(<span class="string">&quot;todos&quot;</span>).then(<span class="function">(<span class="params">todos</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="string">&quot;todos/todosLoaded&quot;</span>, <span class="attr">payload</span>: todos &#125;);</span><br><span class="line">    <span class="keyword">const</span> allTodos = getState().todos;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">store.dispatch(fetchSomeData);</span><br></pre></td></tr></table></figure>

<p>这样当执行 dispatch 时，实际上就是执行 fetchSomeData 这个函数。当异步请求完成后，调用同步的 dispatch。由于此时 action 不再是一个函数，因此会正常更新。</p>
<p>redux 存在这样一个中间件，叫做 redux-thunk</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> thunkMiddleware <span class="keyword">from</span> <span class="string">&quot;redux-thunk&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">&quot;./reducer&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> composedEnhancer = applyMiddleware(thunkMiddleware);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer, composedEnhancer);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">store.dispatch(<span class="keyword">async</span> (dispatch, getState) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> client.get(<span class="string">&quot;/fakeApi/todos&quot;</span>);</span><br><span class="line">  log(<span class="string">&quot;before&quot;</span>, getState());</span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: <span class="string">&quot;todos/todosLoaded&quot;</span>, <span class="attr">payload</span>: response.todos &#125;);</span><br><span class="line">  log(<span class="string">&quot;after&quot;</span>, getState());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>其中，getState 方法可以获取实时的 state 值，用在 dispatch 前后就可以获取更新前后的值。</p>
<h1 id="React-Redux"><a href="#React-Redux" class="headerlink" title="React-Redux"></a>React-Redux</h1><p>React-Redux 实际上就是把 Redux 接入到 React 中。在历史版本中曾经还有 connect 这样的高阶函数来主动连接，不过现在则主要依赖 hooks 和 context 完成。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><p>Provider 是一个封装了 Context.Provider 的组件，接受一个 store 作为 props：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Provider</span>&lt;<span class="title">A</span> <span class="title">extends</span> <span class="title">Action</span> = <span class="title">AnyAction</span>, <span class="title">S</span> = <span class="title">unknown</span>&gt;(<span class="params">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  store,</span></span></span><br><span class="line"><span class="params"><span class="function">  context,</span></span></span><br><span class="line"><span class="params"><span class="function">  children,</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;: ProviderProps&lt;A, S&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ContextValue是创建的context对象，包含store和subscription对象</span></span><br><span class="line">  <span class="keyword">const</span> contextValue = useMemo(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// subscription对象持有一个listeners链表，上面有订阅、触发等方法</span></span><br><span class="line">    <span class="keyword">const</span> subscription = createSubscription(store);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      store,</span><br><span class="line">      subscription,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [store]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 即持有的state</span></span><br><span class="line">  <span class="keyword">const</span> previousState = useMemo(<span class="function">() =&gt;</span> store.getState(), [store]);</span><br><span class="line"></span><br><span class="line">  useLayoutEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; subscription &#125; = contextValue;</span><br><span class="line">    subscription.onStateChange = subscription.notifyNestedSubs;</span><br><span class="line">    subscription.trySubscribe();</span><br><span class="line">    <span class="comment">// 如果新旧状态不一致，就触发所有的listeners</span></span><br><span class="line">    <span class="keyword">if</span> (previousState !== store.getState()) &#123;</span><br><span class="line">      subscription.notifyNestedSubs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      subscription.tryUnsubscribe();</span><br><span class="line">      subscription.onStateChange = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [contextValue, previousState]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Context = context || ReactReduxContext;</span><br><span class="line">  <span class="comment">// 将contextValue对象放入context下发</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Context.Provider</span> <span class="attr">value</span>=<span class="string">&#123;contextValue&#125;</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">Context.Provider</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>contextValue 保存有创建的 store 和 subscription 对象。当 store 更新时，contextValue 就会被更新，从而触发 useLayoutEffect 内部的逻辑去触发 listeners。<br>subscription 上的 listeners 是在 useSelector 函数内部被加入的，在下面会说到。</p>
<p>可以看到，contextValue 的更新主要依赖 store 对象。</p>
<h3 id="selector-和-useSelector"><a href="#selector-和-useSelector" class="headerlink" title="selector 和 useSelector"></a>selector 和 useSelector</h3><p>useSelector 简化如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useSelector</span>&lt;<span class="title">TState</span>, <span class="title">Selected</span> <span class="title">extends</span> <span class="title">unknown</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  selector: (state: TState) =&gt; Selected,</span></span></span><br><span class="line"><span class="params"><span class="function">  equalityFn: EqualityFn&lt;NoInfer&lt;Selected&gt;&gt; = refEquality</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Selected</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里就是通过context获取contextValue对象</span></span><br><span class="line">  <span class="keyword">const</span> &#123; store, subscription &#125; = useContext();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> selectedState = useSyncExternalStoreWithSelector(</span><br><span class="line">    subscription.addNestedSub,</span><br><span class="line">    store.getState,</span><br><span class="line">    getServerState || store.getState,</span><br><span class="line">    selector,</span><br><span class="line">    equalityFn</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> selectedState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到核心的函数实际上是一个 useSyncExternalStoreWithSelector。这个函数其实是基于 useSyncExternalStore 的封装，后者是 React18 新的 hook。<br>useSyncExternalStoreWithSelector 的逻辑和 useSyncExternalStore 基本差不多，只是添加了 selector 用于取到指定的 state，以及 equalityFn 用于比较 state 是否改变。<br>同样，当调用 dispatch 改变 state 时，会执行更新并返回最新的 state 供 React 使用</p>
<h4 id="useSyncExternalStore"><a href="#useSyncExternalStore" class="headerlink" title="useSyncExternalStore"></a>useSyncExternalStore</h4><p>useSyncExternalStore 接受一个 subscribe 函数和一个外部数据源，当数据源的值发生变化时，会触发 subscribe 绑定的 listeners，并计算最新的 state 并返回，同时还会强制调度更新一次。<br>具体来说，现在有一个简单 redux 的例子：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numberReducer</span>(<span class="params">state = <span class="number">1</span>, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;ADD&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;DEL&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootReducer = combineReducers(&#123; <span class="attr">number</span>: numberReducer &#125;);</span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer, &#123; <span class="attr">number</span>: <span class="number">1</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Index</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 订阅外部数据源 */</span></span><br><span class="line">  <span class="keyword">const</span> state = useSyncExternalStore(</span><br><span class="line">    store.subscribe,</span><br><span class="line">    <span class="function">() =&gt;</span> store.getState().number</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;state&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> store.dispatch(&#123; type: &quot;ADD&quot; &#125;)&#125;&gt;点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 useSyncExternalStore 内部，第一次调用时会调用一个 subscribeToStore 函数，这个函数会调用 store.subscribe 并传入一个 handleStoreChange 函数。<br>handleStoreChange 的作用就是检查 state（即从第二个参数来的 state）是否发生变化。如果变化就触发更新。</p>
<p>而传入的 store.subcribe 函数会将 handleStoreChange 放入 store 的 listeners 上，在 dispatch 时调用。<br>因此后面调用 dispatch 时就会执行 handleStoreChange，得到新的 state、比较新旧 state、触发更新。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountSyncExternalStore</span>(<span class="params">subscribe, getSnapshot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="comment">// 第二个参数返回一个state，将作为后续判断的依据</span></span><br><span class="line">  <span class="keyword">let</span> nextSnapshot = getSnapshot();</span><br><span class="line"></span><br><span class="line">  hook.memoizedState = nextSnapshot;</span><br><span class="line">  <span class="keyword">const</span> inst = &#123;</span><br><span class="line">    <span class="attr">value</span>: nextSnapshot,</span><br><span class="line">    getSnapshot,</span><br><span class="line">  &#125;;</span><br><span class="line">  hook.queue = inst;</span><br><span class="line"></span><br><span class="line">  mountEffect(subscribeToStore.bind(<span class="literal">null</span>, fiber, inst, subscribe), [subscribe]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nextSnapshot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调度一次更新</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forceStoreRerender</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribeToStore</span>(<span class="params">fiber, inst, subscribe</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> handleStoreChange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* 检查 state 是否发生变化 */</span></span><br><span class="line">    <span class="keyword">if</span> (checkIfSnapshotChanged(inst)) &#123;</span><br><span class="line">      <span class="comment">/* 触发更新 */</span></span><br><span class="line">      forceStoreRerender(fiber);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/* 发起订阅 */</span></span><br><span class="line">  <span class="keyword">return</span> subscribe(handleStoreChange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 hooks 最重要的作用是，它的数据来源是一个外部的状态（store.state），但他返回一个能供 React 使用的 state，并且还依赖的是外部的 subscribe 函数。</p>
<h3 id="dispatch-和-useDispatch"><a href="#dispatch-和-useDispatch" class="headerlink" title="dispatch 和 useDispatch"></a>dispatch 和 useDispatch</h3><p>React-Redux 的 dispatch 实际上仍然是 store.dispatch:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDispatch</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">AppDispatch</span> <span class="title">extends</span> <span class="title">Dispatch</span>&lt;<span class="title">A</span>&gt; = <span class="title">Dispatch</span>&lt;<span class="title">A</span>&gt;</span></span><br><span class="line"><span class="function">&gt;(<span class="params"></span>): <span class="title">AppDispatch</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> store = useStore();</span><br><span class="line">  <span class="comment">// @ts-ignore</span></span><br><span class="line">  <span class="keyword">return</span> store.dispatch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 store 就是在 Provider 中传入的那个 store。store 的创建则是在 toolkit 的 configureStore 中实现。</p>
<h3 id="store-1"><a href="#store-1" class="headerlink" title="store"></a>store</h3><p>store 的创建主要是通过 configureStore api，其内部本质上还是调用了 createStore</p>
<p>简化代码如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">configureStore</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    reducer = <span class="literal">undefined</span>, <span class="comment">// reducer是一个对象，可以是combineReducer的结果，也可以是多个reducer</span></span><br><span class="line">    middleware = curriedGetDefaultMiddleware(), <span class="comment">// 添加默认middleware，包括thunk、检查错误的一些中间件</span></span><br><span class="line">    devTools = <span class="literal">true</span>,</span><br><span class="line">    preloadedState = <span class="literal">undefined</span>,</span><br><span class="line">    enhancers = <span class="literal">undefined</span>, <span class="comment">// 一个enhancers数组</span></span><br><span class="line">  &#125; = options || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> rootReducer: Reducer&lt;S, A&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用combineReducers</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> reducer === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    rootReducer = reducer;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPlainObject(reducer)) &#123;</span><br><span class="line">    rootReducer = combineReducers(reducer) <span class="keyword">as</span> unknown <span class="keyword">as</span> Reducer&lt;S, A&gt;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理middleware，自动添加thunk中间件</span></span><br><span class="line">  <span class="keyword">let</span> finalMiddleware = middleware;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> finalMiddleware === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> middlewareEnhancer: StoreEnhancer = applyMiddleware(...finalMiddleware);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> finalCompose = compose;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理enhancer，将多个enhancer合并</span></span><br><span class="line">  <span class="keyword">let</span> storeEnhancers: Enhancers = [middlewareEnhancer];</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(enhancers)) &#123;</span><br><span class="line">    storeEnhancers = [middlewareEnhancer, ...enhancers];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancers === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    storeEnhancers = enhancers(storeEnhancers);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> composedEnhancer = finalCompose(</span><br><span class="line">    ...storeEnhancers</span><br><span class="line">  ) <span class="keyword">as</span> StoreEnhancer&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> createStore(rootReducer, preloadedState, composedEnhancer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="api-1"><a href="#api-1" class="headerlink" title="api"></a>api</h2><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>connect 实际上是类组件时代的产物，它主要作用是将 redux 和 react 组件结合起来。<br>函数组件可以通过 hooks 直接获取 dispatch 函数和保持的 state，但是类组件只能通过向 props 注入的方式添加。connect 函数返回一个函数，其实是一个高阶组件，它接受一个组件，并返回一个强化后的组件。强化后的组件相对于原组件，添加了 state 和 dispatch。</p>
<p>connect 的两个参数，分别是 mapStateToProps 和 mapDispatchToProps。这两个函数的结构相似，都返回一个对象，将融合在被包裹组件的 props 中。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, ownProps</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// ... computed data from state and optionally ownProps</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = &#123;</span><br><span class="line">  <span class="comment">// ... normally is an object full of action creators</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `connect` returns a new function that accepts the component to wrap:</span></span><br><span class="line"><span class="keyword">const</span> connectToStore = connect(mapStateToProps, mapDispatchToProps);</span><br><span class="line"><span class="comment">// and that function returns the connected, wrapper component:</span></span><br><span class="line"><span class="keyword">const</span> ConnectedComponent = connectToStore(Component);</span><br><span class="line"></span><br><span class="line"><span class="comment">// We normally do both in one step, like this:</span></span><br><span class="line">connect(mapStateToProps, mapDispatchToProps)(Component);</span><br></pre></td></tr></table></figure>

<h3 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps"></a>mapStateToProps</h3><p>mapStateToProps 类似 useSelector，它接收一个来自 store 的 state，然后内部对 state 进行解构，最后返回一个对象合并到 props 中</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> todos = state.map(...)</span><br><span class="line">  <span class="keyword">return</span> &#123; todos &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件内</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">this</span>.props.todos.map(<span class="function">(<span class="params">todo</span>) =&gt;</span> (...))</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps"></a>mapDispatchToProps</h3><p>和 mapStateToProps 类似，不过注入对象是 dispatch 函数。<br>mapDispatchToProps 接受一个 dispatch 参数，即真实的 dispatch。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const mapDispatchToProps = dispatch =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    toggleTodo: todoId =&gt; dispatch(toggleTodo(todoId))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 组件内</span><br><span class="line">render()&#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; this.props.toggleTodo()&#125;&gt;&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Redux-Toolkit"><a href="#Redux-Toolkit" class="headerlink" title="Redux-Toolkit"></a>Redux-Toolkit</h1><p>Toolkit 是一个工具包，并非必须的。Toolkit 可以简化 React-Redux 的使用，当然完全不用 toolkit，手动创建 store 也是可以的。</p>
<h2 id="常用-api"><a href="#常用-api" class="headerlink" title="常用 api"></a>常用 api</h2><h3 id="configureStore"><a href="#configureStore" class="headerlink" title="configureStore"></a>configureStore</h3><p>这个在上面说过，主要作用有：</p>
<ul>
<li>处理 reducers，调用 combineReducers 组合</li>
<li>创建 Redux store</li>
<li>自动添加了 thunk 中间件</li>
<li>自动添加了更多中间件来检查常见错误，例如意外改变状态</li>
<li>自动设置 Redux DevTools 扩展连接</li>
</ul>
<p>通过 configureStore 传入的 reducer 内部如果直接修改 state，则会导致崩溃（中间件作用）。</p>
<h3 id="createSlice"><a href="#createSlice" class="headerlink" title="createSlice"></a>createSlice</h3><p>Redux 定义了一个“slice”的概念，可以理解为一个 state 的专属的对象：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> postsSlice = createSlice(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;posts&quot;</span>,</span><br><span class="line">  <span class="attr">initialState</span>: [],</span><br><span class="line">  <span class="attr">reducers</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">createPost</span>(<span class="params">state, action</span>)</span> &#123;&#125;,</span><br><span class="line">    <span class="function"><span class="title">updatePost</span>(<span class="params">state, action</span>)</span> &#123;&#125;,</span><br><span class="line">    <span class="function"><span class="title">deletePost</span>(<span class="params">state, action</span>)</span> &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>每个 slice 只管理一个状态，可以配置他的 name、初始值，以及修改这个状态用到的函数。</p>
<p>其中，reducers 内部的这几个函数可以理解为原本的 reducer 的 switchcase 逻辑拆分。<br>在 createSlice 内部，这些 reducers 函数会组合为一个 reducer。name 属性的字符串会成为返回的 action 传的 key 的一部分（比如调用 createPost，绑定的 type 就是’posts/createPost’）<br>并且，在这些函数内部，可以直接修改 state，类似使用了 immer 的 reducer。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todosSlice = createSlice(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;todos&quot;</span>,</span><br><span class="line">  initialState,</span><br><span class="line">  <span class="attr">reducers</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">todoAdded</span>(<span class="params">state, action</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// ✅ This &quot;mutating&quot; code is okay inside of createSlice!</span></span><br><span class="line">      state.entities.push(action.payload);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">todoToggled</span>(<span class="params">state, action</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> todo = state.entities.find(<span class="function">(<span class="params">todo</span>) =&gt;</span> todo.id === action.payload);</span><br><span class="line">      todo.completed = !todo.completed;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">todosLoading</span>(<span class="params">state, action</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        <span class="attr">status</span>: <span class="string">&quot;loading&quot;</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>createSlice 的返回值是一个对象，导出时需要分开导出：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    <span class="function"><span class="title">reducer</span>(<span class="params">state, action</span>)</span> &#123;&#125;,</span><br><span class="line">    <span class="attr">actions</span>: actionCreators</span><br><span class="line">    <span class="attr">caseReducers</span>: sliceCaseReducersByName,</span><br><span class="line">    <span class="function"><span class="title">getInitialState</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大概是这样：</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;posts&#x27;</span>,</span><br><span class="line">    <span class="attr">actions</span> : &#123;</span><br><span class="line">        createPost,</span><br><span class="line">        updatePost,</span><br><span class="line">        deletePost,</span><br><span class="line">    &#125;,</span><br><span class="line">    reducer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，传入的 reducers 对象内的函数会被 createAction 转换成自动绑定了 type 的 action，因此调用时不需要传入 type，直接传 payload 即可。<br>当存在这些 action 时，就不必再调用 dispatch 函数了</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">createPost(&#123; <span class="attr">id</span>: <span class="number">123</span>, <span class="attr">title</span>: <span class="string">&quot;Hello World&quot;</span> &#125;);</span><br><span class="line"><span class="comment">// 这个函数会返回实际的action对象</span></span><br><span class="line"><span class="comment">// &#123;type : &quot;posts/createPost&quot;, payload : &#123;id : 123, title : &quot;Hello World&quot;&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>而 reducer 对象则是 redux 要用的 reducer，需要导出</p>
<p>因此整体导出就是<strong>分别导出各个 action，然后默认导出 reducer</strong>即可。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; actions, reducer &#125; = postsSlice;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123; createPost, updatePost, deletePost &#125; = actions;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> reducer;</span><br></pre></td></tr></table></figure>

<p>导出的 reducer 将会作为 configureStore 的 reducer</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = configureStore(&#123;</span><br><span class="line">  <span class="attr">reducer</span>: &#123;</span><br><span class="line">    <span class="attr">A</span>: ReducerA,</span><br><span class="line">    <span class="attr">B</span>: ReducerB,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>最后把 store 传给 Provider 组件。<br>完整的过程如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建slice</span></span><br><span class="line"><span class="keyword">const</span> counterSliceA = createSlice(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;counterA&quot;</span>,</span><br><span class="line">  <span class="attr">initialState</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">reducers</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">state, &#123; payload, <span class="keyword">type</span> &#125;</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state + payload.count;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">addFive</span>(<span class="params">state, action</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">5</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 导出reducer和action</span></span><br><span class="line"><span class="keyword">const</span> &#123; actions, reducer &#125; = counterSliceA;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123; increment, addFive &#125; = actions;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> reducer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建store</span></span><br><span class="line"><span class="keyword">const</span> store = configureStore(&#123;</span><br><span class="line">  <span class="attr">reducer</span>: &#123;</span><br><span class="line">    <span class="attr">counterA</span>: counterAReducer,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用store</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>).render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>,</span><br><span class="line">  rootElement</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件内部调用action</span></span><br><span class="line">increment(&#123; <span class="attr">count</span>: <span class="number">2</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件内部使用state</span></span><br><span class="line"><span class="keyword">const</span> count = useSelector(<span class="function">(<span class="params">state</span>) =&gt;</span> state.counterA);</span><br></pre></td></tr></table></figure>

<h2 id="配合-TS"><a href="#配合-TS" class="headerlink" title="配合 TS"></a>配合 TS</h2><p>Redux 需要单独编写一部分类型代码<br>首先是在 configureStore 附近的，定义 store 的 state 和 dispatch 类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = configureStore(&#123;</span><br><span class="line">  <span class="attr">reducer</span>: &#123;</span><br><span class="line">    <span class="attr">posts</span>: postsReducer,</span><br><span class="line">    <span class="attr">comments</span>: commentsReducer,</span><br><span class="line">    <span class="attr">users</span>: usersReducer,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> RootState = ReturnType&lt;<span class="keyword">typeof</span> store.getState&gt;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> AppDispatch = <span class="keyword">typeof</span> store.dispatch;</span><br></pre></td></tr></table></figure>

<p>然后定义 useSelector 和 useDispatch。这里实际上是重新创建了这两个 hook。在组件内调用的是这两个重新创建的 hook 而不是原生的 useSelector 和 useDispatch</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; TypedUseSelectorHook, useDispatch, useSelector &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; RootState, AppDispatch &#125; <span class="keyword">from</span> <span class="string">&quot;./store&quot;</span>; <span class="comment">// 上面的两个类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useAppDispatch: <span class="function">() =&gt;</span> AppDispatch = useDispatch;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useAppSelector: TypedUseSelectorHook&lt;RootState&gt; = useSelector;</span><br></pre></td></tr></table></figure>

<p>如果没有用 slice，到这就结束了。反之还需要设置 slice<br>在 slice 对象中主要要设置 initiateState 的类型，将作为后面的 reducers 函数中 state 的类型。而 action 则可以由 PayloadAction 泛型指定。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createSlice, PayloadAction &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; RootState &#125; <span class="keyword">from</span> <span class="string">&quot;../../app/store&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> CounterState &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState: CounterState = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> counterSlice = createSlice(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;counter&quot;</span>,</span><br><span class="line">  initialState,</span><br><span class="line">  <span class="attr">reducers</span>: &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      state.value += <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">decrement</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      state.value -= <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">incrementByAmount</span>: <span class="function">(<span class="params">state, action: PayloadAction&lt;<span class="built_in">number</span>&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">      state.value += action.payload;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123; increment, decrement, incrementByAmount &#125; = counterSlice.actions;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counterSlice.reducer;</span><br></pre></td></tr></table></figure>

<h1 id="Redux-哲学"><a href="#Redux-哲学" class="headerlink" title="Redux 哲学"></a>Redux 哲学</h1><p>Redux 官方文档除了介绍 Redux 的使用之外，还讲述了不少 Redux 的使用哲学，这些思维模式不仅仅可以用于 redux，也适用于平时的 react 项目。</p>
<h2 id="xxxManager"><a href="#xxxManager" class="headerlink" title="xxxManager"></a>xxxManager</h2><p>官方文档在介绍动态替换 Reducer 是，介绍了一个对象，即 reducerMangaer。manager 本质上是一个维护一些方法的对象，这些方法会对某个数据结构进行增删改等操作。该对象由一个 createXxxManager 创建，该对象内的方法将作为闭包，使用 createXxxManager 函数内的变量作为自己维护的数据。</p>
<p>举个例子，reducerManager 其实就是维护一个 reducers 对象，reducers 实际上是 createReducerManager 函数的一个内部变量；同时 createReducerManager 函数返回一个对象（即 manager 对象），对 reducers 的增删查操作则作为 manager 对象的属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createReducerManager</span>(<span class="params">initialReducers</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reducers = &#123; ...initialReducers &#125;;</span><br><span class="line">  <span class="keyword">let</span> combinedReducer = combineReducers(reducers);</span><br><span class="line">  <span class="keyword">let</span> keysToRemove = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">getReducerMap</span>: <span class="function">() =&gt;</span> reducers,</span><br><span class="line">    <span class="comment">// 修改reducer时，顺带把state对象上该reducer对应的state也修改，并最后返回一个combine结果</span></span><br><span class="line">    <span class="attr">reduce</span>: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (keysToRemove.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        state = &#123; ...state &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> keysToRemove) &#123;</span><br><span class="line">          <span class="keyword">delete</span> state[key];</span><br><span class="line">        &#125;</span><br><span class="line">        keysToRemove = [];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> combinedReducer(state, action);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 增加和移除reducer</span></span><br><span class="line">    <span class="attr">add</span>: <span class="function">(<span class="params">key, reducer</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!key || reducers[key]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      reducers[key] = reducer;</span><br><span class="line">      combinedReducer = combineReducers(reducers);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">remove</span>: <span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!key || !reducers[key]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">delete</span> reducers[key];</span><br><span class="line">      keysToRemove.push(key);</span><br><span class="line">      combinedReducer = combineReducers(reducers);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> staticReducers = &#123;</span><br><span class="line">  <span class="attr">users</span>: usersReducer,</span><br><span class="line">  <span class="attr">posts</span>: postsReducer,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">configureStore</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reducerManager = createReducerManager(staticReducers);</span><br><span class="line">  <span class="keyword">const</span> store = createStore(reducerManager.reduce, initialState);</span><br><span class="line">  store.reducerManager = reducerManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一种思路，即维护一种数据结构时，将其封装在函数内部，通过返回 manager 对象的方法来修改该数据结构。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createXxxManager</span>(<span class="params">initalValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = initalValue;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">    <span class="function"><span class="title">remove</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">    <span class="attr">getData</span>: <span class="function">() =&gt;</span> data,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实 createStore 函数本质上也是这个思路，其函数内部有 getState、dispatch 等方法，最后返回一个对象包含了这些方法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  reducer: Reducer&lt;S, A&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  preloadedState?: PreloadedState&lt;S&gt; | StoreEnhancer&lt;Ext, StateExt&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  enhancer?: StoreEnhancer&lt;Ext, StateExt&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currentReducer = reducer;</span><br><span class="line">  <span class="keyword">let</span> currentState = preloadedState <span class="keyword">as</span> S;</span><br><span class="line">  <span class="keyword">let</span> currentListeners: (<span class="function">() =&gt;</span> <span class="built_in">void</span>)[] | <span class="literal">null</span> = [];</span><br><span class="line">  <span class="keyword">let</span> nextListeners = currentListeners;</span><br><span class="line">  <span class="keyword">let</span> isDispatching = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>): <span class="title">S</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener: () =&gt; <span class="built_in">void</span></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action: A</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">replaceReducer</span>(<span class="params">nextReducer</span>): <span class="title">Store</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    subscribe,</span><br><span class="line">    getState,</span><br><span class="line">    replaceReducer,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Reducer-的要求"><a href="#Reducer-的要求" class="headerlink" title="Reducer 的要求"></a>Reducer 的要求</h2><p>官方通过 12 个章节来介绍怎么构建一个合适的 reducer。即使不用 redux，有时为了整理 state 也会创建 reducer，官方提供的思路就可以很好的优化 reducer 结构。</p>
<h3 id="reducer-的基本特点"><a href="#reducer-的基本特点" class="headerlink" title="reducer 的基本特点"></a>reducer 的基本特点</h3><ol>
<li><code>(previousState, action) =&gt; newState</code>，即接受旧状态和 action，返回新状态。至于内部怎么处理没有关系，但是外部一定是这样的</li>
<li>纯函数，即 reducer 内部不能有任何副作用，比如</li>
</ol>
<ul>
<li>定时器、网络请求等异步任务，</li>
<li>修改外部变量（state 应该复制而不是直接修改）</li>
<li>调用 date.now 等非纯函数，因为每次调用显然值都不相同</li>
</ul>
<h3 id="拆分-reducer"><a href="#拆分-reducer" class="headerlink" title="拆分 reducer"></a>拆分 reducer</h3><p>按照通常 reducer 的写法，可能会导致 reducer 内部很臃肿，即，一个 switch case 下有很长的一段逻辑，多个 case 下的逻辑可能是重复的，也可能毫不相关。这时就可以把这些 case 下的逻辑抽出来单独形成一个函数。具体来说是两步：</p>
<ol>
<li>把 case 下相同的逻辑抽出来成一个函数。比如复制原对象修改新属性的函数</li>
<li>把 case 下不同的逻辑每个单独创建函数，reducer 内部只是调用这些函数。</li>
</ol>
<p>比如现在有个 reducer：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  <span class="attr">visibilityFilter</span>: <span class="string">&quot;SHOW_ALL&quot;</span>,</span><br><span class="line">  <span class="attr">todos</span>: [],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appReducer</span>(<span class="params">state = initialState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;SET_VISIBILITY_FILTER&quot;</span>: &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">        <span class="attr">visibilityFilter</span>: action.filter,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;ADD_TODO&quot;</span>: &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">        <span class="attr">todos</span>: state.todos.concat(&#123;</span><br><span class="line">          <span class="attr">id</span>: action.id,</span><br><span class="line">          <span class="attr">text</span>: action.text,</span><br><span class="line">          <span class="attr">completed</span>: <span class="literal">false</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;TOGGLE_TODO&quot;</span>: &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">        <span class="attr">todos</span>: state.todos.map(<span class="function">(<span class="params">todo</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (todo.id !== action.id) &#123;</span><br><span class="line">            <span class="keyword">return</span> todo;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, todo, &#123;</span><br><span class="line">            <span class="attr">completed</span>: !todo.completed,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;),</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;EDIT_TODO&quot;</span>: &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">        <span class="attr">todos</span>: state.todos.map(<span class="function">(<span class="params">todo</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (todo.id !== action.id) &#123;</span><br><span class="line">            <span class="keyword">return</span> todo;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, todo, &#123;</span><br><span class="line">            <span class="attr">text</span>: action.text,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;),</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Object.assign 方法频繁出现，因此我们可以抽象成一个函数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateObject</span>(<span class="params">oldObject, newValues</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, oldObject, newValues);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 todos 数组的操作也可以抽象成一个函数，因为上面的基本逻辑都是在 todos 数找到对应的 id，然后修改这一项，复制其他项。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateItemInArray</span>(<span class="params">array, itemId, updateItemCallback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> updatedItems = array.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.id !== itemId) &#123;</span><br><span class="line">      <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> updatedItem = updateItemCallback(item);</span><br><span class="line">    <span class="keyword">return</span> updatedItem;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> updatedItems;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后把每个 case 下面的内容分成不同的函数</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Omitted</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateObject</span>(<span class="params">oldObject, newValues</span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateItemInArray</span>(<span class="params">array, itemId, updateItemCallback</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setVisibilityFilter</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> updateObject(state, &#123; <span class="attr">visibilityFilter</span>: action.filter &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newTodos = state.todos.concat(&#123;</span><br><span class="line">    <span class="attr">id</span>: action.id,</span><br><span class="line">    <span class="attr">text</span>: action.text,</span><br><span class="line">    <span class="attr">completed</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> updateObject(state, &#123; <span class="attr">todos</span>: newTodos &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleTodo</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newTodos = updateItemInArray(state.todos, action.id, <span class="function">(<span class="params">todo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> updateObject(todo, &#123; <span class="attr">completed</span>: !todo.completed &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> updateObject(state, &#123; <span class="attr">todos</span>: newTodos &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">editTodo</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newTodos = updateItemInArray(state.todos, action.id, <span class="function">(<span class="params">todo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> updateObject(todo, &#123; <span class="attr">text</span>: action.text &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> updateObject(state, &#123; <span class="attr">todos</span>: newTodos &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appReducer</span>(<span class="params">state = initialState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;SET_VISIBILITY_FILTER&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> setVisibilityFilter(state, action);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;ADD_TODO&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> addTodo(state, action);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;TOGGLE_TODO&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> toggleTodo(state, action);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;EDIT_TODO&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> editTodo(state, action);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果再进一步优化，可以把 state 中的 visibilityFilter 和其他对 todos 函数的操作分开，使一个 reducer 只维护一个逻辑上相同的 state。<br>这个思维不仅可以用于 reducer，对于项目中其他庞大的函数，也可以按照这个思维模式去优化（复用+拆分）</p>
<h3 id="减少样板"><a href="#减少样板" class="headerlink" title="减少样板"></a>减少样板</h3><p>所谓“样板”，其实是指一些相似结构的对象、函数重复出现。比如 action 对象的结构都是差不多的，那么这些 action 就是样板。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;ADD_TODO&#x27;</span>, <span class="attr">text</span>: <span class="string">&#x27;Use Redux&#x27;</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;REMOVE_TODO&#x27;</span>, <span class="attr">id</span>: <span class="number">42</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;LOAD_ARTICLE&#x27;</span>, <span class="attr">response</span>: &#123; ... &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>因为他们都有 type 属性和一个其他属性，因此可以用一个 createAction 函数来创建他们<br>但是注意这里的方式，如果你使用这种形式，那么实际上并没有减少样板，只是把传对象改成了传参数而已</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAction</span>(<span class="params"><span class="keyword">type</span>, payload</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">type</span>,</span><br><span class="line">    payload,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们希望的肯定是减少样板，而不是少了对象样板，又出来一个函数样板。<br>官方提供的思路是，把每个 type 对应的 action 的创建都变成一个函数，这样调用这些函数就不需要传 type，只需要传后面的值就可以：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;ADD_TODO&quot;</span>,</span><br><span class="line">    text,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">editTodo</span>(<span class="params">id, text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;EDIT_TODO&quot;</span>,</span><br><span class="line">    id,</span><br><span class="line">    text,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">removeTodo</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;REMOVE_TODO&quot;</span>,</span><br><span class="line">    id,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这些函数结构相似，因此需要再抽象一层，即再创建一个创建这些函数的函数。这个函数就应该是返回一个函数的函数，返回的函数就是上面的这几个</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeActionCreator</span>(<span class="params"><span class="keyword">type</span>, ...argNames</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> action = &#123; <span class="keyword">type</span> &#125;;</span><br><span class="line">    argNames.forEach(<span class="function">(<span class="params">arg, index</span>) =&gt;</span> &#123;</span><br><span class="line">      action[argNames[index]] = args[index];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> action;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addTodo = makeActionCreator(<span class="string">&quot;ADD_TODO&quot;</span>, <span class="string">&quot;text&quot;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> editTodo = makeActionCreator(<span class="string">&quot;EDIT_TODO&quot;</span>, <span class="string">&quot;id&quot;</span>, <span class="string">&quot;text&quot;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> removeTodo = makeActionCreator(<span class="string">&quot;REMOVE_TODO&quot;</span>, <span class="string">&quot;id&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>因此基本思路是：</p>
<ol>
<li>把重复、相似的数据结构（对象、数组、字符串等）的创建改成函数的创建。注意这个过程最好是减少参数，但不需要减少数量，比如这里是减少了 type 参数的传入，但是实际上每种 type 还是对应一个函数</li>
<li>再创建一个创建第一步函数的函数，即一个高阶函数，根据参数返回不同的函数，这些返回的函数就是第一步需要的这些函数。</li>
</ol>
<h3 id="格式化数据"><a href="#格式化数据" class="headerlink" title="格式化数据"></a>格式化数据</h3><p>通常后端传来的数据是这样的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> blogPosts = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;post1&quot;</span>,</span><br><span class="line">    <span class="attr">author</span>: &#123; <span class="attr">username</span>: <span class="string">&quot;user1&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;User 1&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">body</span>: <span class="string">&quot;......&quot;</span>,</span><br><span class="line">    <span class="attr">comments</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&quot;comment1&quot;</span>,</span><br><span class="line">        <span class="attr">author</span>: &#123; <span class="attr">username</span>: <span class="string">&quot;user2&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;User 2&quot;</span> &#125;,</span><br><span class="line">        <span class="attr">comment</span>: <span class="string">&quot;.....&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&quot;comment2&quot;</span>,</span><br><span class="line">        <span class="attr">author</span>: &#123; <span class="attr">username</span>: <span class="string">&quot;user3&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;User 3&quot;</span> &#125;,</span><br><span class="line">        <span class="attr">comment</span>: <span class="string">&quot;.....&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;post2&quot;</span>,</span><br><span class="line">    <span class="attr">author</span>: &#123; <span class="attr">username</span>: <span class="string">&quot;user2&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;User 2&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">body</span>: <span class="string">&quot;......&quot;</span>,</span><br><span class="line">    <span class="attr">comments</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&quot;comment3&quot;</span>,</span><br><span class="line">        <span class="attr">author</span>: &#123; <span class="attr">username</span>: <span class="string">&quot;user3&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;User 3&quot;</span> &#125;,</span><br><span class="line">        <span class="attr">comment</span>: <span class="string">&quot;.....&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&quot;comment4&quot;</span>,</span><br><span class="line">        <span class="attr">author</span>: &#123; <span class="attr">username</span>: <span class="string">&quot;user1&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;User 1&quot;</span> &#125;,</span><br><span class="line">        <span class="attr">comment</span>: <span class="string">&quot;.....&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&quot;comment5&quot;</span>,</span><br><span class="line">        <span class="attr">author</span>: &#123; <span class="attr">username</span>: <span class="string">&quot;user3&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;User 3&quot;</span> &#125;,</span><br><span class="line">        <span class="attr">comment</span>: <span class="string">&quot;.....&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>这种形式被称为是“嵌套的”。虽然里边的数据很复杂，但是本质上其实就是三个对象的数据（post、comment 和 author），而这个数据中 post 内嵌套了 author 和 comments，每个 comments 又嵌套了 author。<br>这种数据结构会有什么问题呢？比如说我想维护一个 comments 列表的增删改和渲染，那么我就需要很长的逻辑去取出来这些 comments</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> comments = posts.reduce(<span class="function">(<span class="params">comments, post</span>) =&gt;</span></span><br><span class="line">  comments.concat(post.coomments)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果是在 reducer 或者 useState 维护的状态里，那就更加麻烦了，比如想修改一个 comments，还得先找到对应的 post，并且修改 comments 还需要复制一大堆完全不相关的属性</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postReducer</span>(<span class="params">state, &#123; <span class="keyword">type</span>, payload &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; commentId, commentValue &#125; = payload;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;EDIT_COMMENT&quot;</span>: &#123;</span><br><span class="line">      <span class="keyword">const</span> post = state.find(<span class="function">(<span class="params">post</span>) =&gt;</span></span><br><span class="line">        post.comments.include(<span class="function">(<span class="params">comment</span>) =&gt;</span> (comment.id = commentId))</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...post,</span><br><span class="line">        <span class="attr">comments</span>: post.comments.map(<span class="function">(<span class="params">comment</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (comment.id !== commentId) <span class="keyword">return</span> comment;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            ...comment,</span><br><span class="line">            <span class="attr">comment</span>: commentValue,</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;),</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们维护的数据应该是扁平的。<br>即，这个数据内有三个核心对象，即 comment、post 和 author，他们三个的共同特点是都有对应的 id；那么就可以把这三个对象分别列出来，以自己的 id 形成序列：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">posts</span> : &#123;</span><br><span class="line">        <span class="attr">byId</span> : &#123;</span><br><span class="line">            <span class="string">&quot;post1&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">id</span> : <span class="string">&quot;post1&quot;</span>,</span><br><span class="line">                <span class="attr">author</span> : <span class="string">&quot;user1&quot;</span>,</span><br><span class="line">                <span class="attr">body</span> : <span class="string">&quot;......&quot;</span>,</span><br><span class="line">                <span class="attr">comments</span> : [<span class="string">&quot;comment1&quot;</span>, <span class="string">&quot;comment2&quot;</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;post2&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">id</span> : <span class="string">&quot;post2&quot;</span>,</span><br><span class="line">                <span class="attr">author</span> : <span class="string">&quot;user2&quot;</span>,</span><br><span class="line">                <span class="attr">body</span> : <span class="string">&quot;......&quot;</span>,</span><br><span class="line">                <span class="attr">comments</span> : [<span class="string">&quot;comment3&quot;</span>, <span class="string">&quot;comment4&quot;</span>, <span class="string">&quot;comment5&quot;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">allIds</span> : [<span class="string">&quot;post1&quot;</span>, <span class="string">&quot;post2&quot;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">comments</span> : &#123;</span><br><span class="line">        <span class="attr">byId</span> : &#123;</span><br><span class="line">            <span class="string">&quot;comment1&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">id</span> : <span class="string">&quot;comment1&quot;</span>,</span><br><span class="line">                <span class="attr">author</span> : <span class="string">&quot;user2&quot;</span>,</span><br><span class="line">                <span class="attr">comment</span> : <span class="string">&quot;.....&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;comment2&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">id</span> : <span class="string">&quot;comment2&quot;</span>,</span><br><span class="line">                <span class="attr">author</span> : <span class="string">&quot;user3&quot;</span>,</span><br><span class="line">                <span class="attr">comment</span> : <span class="string">&quot;.....&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;comment3&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">id</span> : <span class="string">&quot;comment3&quot;</span>,</span><br><span class="line">                <span class="attr">author</span> : <span class="string">&quot;user3&quot;</span>,</span><br><span class="line">                <span class="attr">comment</span> : <span class="string">&quot;.....&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;comment4&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">id</span> : <span class="string">&quot;comment4&quot;</span>,</span><br><span class="line">                <span class="attr">author</span> : <span class="string">&quot;user1&quot;</span>,</span><br><span class="line">                <span class="attr">comment</span> : <span class="string">&quot;.....&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;comment5&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">id</span> : <span class="string">&quot;comment5&quot;</span>,</span><br><span class="line">                <span class="attr">author</span> : <span class="string">&quot;user3&quot;</span>,</span><br><span class="line">                <span class="attr">comment</span> : <span class="string">&quot;.....&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">allIds</span> : [<span class="string">&quot;comment1&quot;</span>, <span class="string">&quot;comment2&quot;</span>, <span class="string">&quot;comment3&quot;</span>, <span class="string">&quot;comment4&quot;</span>, <span class="string">&quot;comment5&quot;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">users</span> : &#123;</span><br><span class="line">        <span class="attr">byId</span> : &#123;</span><br><span class="line">            <span class="string">&quot;user1&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">username</span> : <span class="string">&quot;user1&quot;</span>,</span><br><span class="line">                <span class="attr">name</span> : <span class="string">&quot;User 1&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;user2&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">username</span> : <span class="string">&quot;user2&quot;</span>,</span><br><span class="line">                <span class="attr">name</span> : <span class="string">&quot;User 2&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;user3&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">username</span> : <span class="string">&quot;user3&quot;</span>,</span><br><span class="line">                <span class="attr">name</span> : <span class="string">&quot;User 3&quot;</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">allIds</span> : [<span class="string">&quot;user1&quot;</span>, <span class="string">&quot;user2&quot;</span>, <span class="string">&quot;user3&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的数据就可以直接存储在 state 中，作为 reducer 使用或直接给 useState 使用。<br>这种数据可以很方便的修改和查找，只需要他们各自的 id 即可。</p>
<p>因此这样格式化的核心就是找到数据中的关键数据，然后将他们单独以 id 形成列表，将数据扁平化。</p>
<p>这种方法实际上是<strong>数据库</strong>思维，即，这里的 users、comments、posts 都是一个个<strong>表</strong>，而每个 id 则是<strong>主键</strong>，其他属性则作为其他字段存在。</p>
<p>用于格式化的库有一个 normalizr，具体的会单独写一篇笔记。</p>
<h2 id="Undo-Redo"><a href="#Undo-Redo" class="headerlink" title="Undo-Redo"></a>Undo-Redo</h2><p>参考<a target="_blank" rel="noopener" href="https://redux.js.org/usage/implementing-undo-history">https://redux.js.org/usage/implementing-undo-history</a></p>
<p>这部分内容其实和 redux 没啥关系，但是文档提出了一种实现 undo-redo 的方式，可以学习一下。</p>
<h1 id="Recoil"><a href="#Recoil" class="headerlink" title="Recoil"></a>Recoil</h1><p>Recoil 的基本使用不再赘述。</p>
<p>相关学习文档：<br><a target="_blank" rel="noopener" href="https://bytedance.feishu.cn/wiki/wikcnqR8zdxiE7jKoqbtVc0hsgd#20H8nV">https://bytedance.feishu.cn/wiki/wikcnqR8zdxiE7jKoqbtVc0hsgd#20H8nV</a><br><a target="_blank" rel="noopener" href="https://bytedance.feishu.cn/wiki/wikcnX74vA1xU60eGqzqiaG1gvg#hr7PnL">https://bytedance.feishu.cn/wiki/wikcnX74vA1xU60eGqzqiaG1gvg#hr7PnL</a></p>
<h2 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h2><h3 id="原子化"><a href="#原子化" class="headerlink" title="原子化"></a>原子化</h3><p>即 recoil 的基本特点，Reocil 推崇 state 分散管理，我们可以单独定义应用中各个独立的子状态。一个状态可以放在一个 atom 里，每个状态独立，而不用像在 redux 中将其整合在一个 reducer 中。<br>原子化的 state 主要特点有：</p>
<ol>
<li>清晰易辨。由于状态都是以最小单位 atom 保存的，因此不同的 atom 之间相互独立</li>
<li>状态之间不会互相影响，即下面说的 items 问题，如果不希望一个 item 的改变会导致其他 item 都被更新，那么将每个 item 单独管理就是很好的方法，再通过 atomFamily 等方式将其整合起来。这样每个状态都是独立的，修改状态并不会影响其他 item 的状态</li>
<li>（缺点）不容易获得全局状态。不像 reducer 本身就是在维护全局状态，atom 的缺点就是难以一眼看清全局有哪些状态，不过可以用 snapshot 做为弥补</li>
</ol>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p><img src="https://pic.imgdb.cn/item/63d9339ae90d1c00983cfbc5.jpg"></p>
<p>这张图很好展示了 recoil 的结构，可以看到基本单位是 atom，从 atom 派生的 selector，这两个都是提供状态的对象；他们将状态下发到 React 的组件树中。</p>
<p>本质上这种关系是一种双向图，从共享状态到组件，组件到共享状态这样一个闭环。组件订阅状态，则就形成了从状态到组件的一个数据流，组件更新状态，则形成了从组件到状态的一个数据流。<br>为什么叫图呢，就是因为 Atom 和 Selector 可以看作是图上的节点，Atom 和 Selector 通过有向图的连接方式连接，形成一个图；这个数据流图和 React 组件树并不相关，哪个节点用到了数据，哪个地方才会和图关联起来<br><img src="https://pic.imgdb.cn/item/63da5aa4ac6ef860166cd018.jpg"></p>
<p>这个图路径上的函数可以是异步的（即 selector 函数可以是异步的）。比如 selector 的 get 函数中如果返回一个 Promise，那它就被视为是一个异步的数据，将会异步加载这个状态。</p>
<h3 id="SnapShot-全局状态管理"><a href="#SnapShot-全局状态管理" class="headerlink" title="SnapShot 全局状态管理"></a>SnapShot 全局状态管理</h3><p>Snapshot 对象是 Recoil atoms 状态的一个不可改变的快照。它的目的是规范用于观察、检查和管理全局 Recoil 状态的 API。对于开发工具、全局状态同步、历史导航等大部分需求，它都是很有用的。<br>实际上是对 recoil 松散状态的一个补充</p>
<h3 id="对-ConcurrentMode-的支持"><a href="#对-ConcurrentMode-的支持" class="headerlink" title="对 ConcurrentMode 的支持"></a>对 ConcurrentMode 的支持</h3><p>ConcurrentMode 最大的特点是渲染中断。render 阶段可能会被多次打断、多次重复，这种情况对于状态管理来说，很可能的问题是状态的不一致。</p>
<p><img src="https://pic.imgdb.cn/item/63d93c30e90d1c00986009da.jpg"></p>
<p>如上，在 react 中断渲染的这段时间，可能状态已经发生变化，这时回来重新渲染就会出现状态不一致的问题。这不仅仅是 recoil 的问题，所有的外部状态管理库都会有这个问题。<br>在 Recoil 的最新版本，已经提供了一些实验性的 api 来支持该模式。Recoil 在渲染时如果检测到状态已经发生了改变，则会重新渲染整个节点树来避免状态的不一致。目前该机制是高效的，之后会继续优化性能。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="atom"><a href="#atom" class="headerlink" title="atom"></a>atom</h3><p>atom 是一个原子状态。在 Recoil 中，核心理念是状态的原子化，即将状态细分，划分到足够细的粒度，成为一个“atom”。<br>比如有一个画布，这个画布上可能有很多的图案，每一个图案（items）都有它自己的状态。按照传统 redux 的管理方式，就用一个 items 数组存储各个 item</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="attr">items</span>: [] &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">itemReducer</span>(<span class="params">state = initialState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;ADD&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">items</span>: [...state.items, action.preload] &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = createStore(itemReducer);</span><br></pre></td></tr></table></figure>

<p>这种方式有一个致命的问题，就是一个 item 状态的改变，会导致整个 items 数组被更新。因为 redux 的理念不是修改 state，而是替换 state。<br>如果 item 的更新需要通过拖动这种的高频率事件触发，那么就会造成极大的更新消耗。我们希望的是每个 item 的更新独立，更新一个 item 不会导致其他 item 更新。</p>
<p>atom 就是这样一种方式。为每个 item 创建一个 atom，然后用一个整体的数据结构（atomFamily）来管理。<br>比如单个 item 的状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const item = atom(&#123;</span><br><span class="line">  key: &#x27;item&#x27;,</span><br><span class="line">  defaultValue: &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function Item() &#123;</span><br><span class="line">  const [item, setItem] = useRecoilState(itemState);</span><br><span class="line">  // other</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;&#123; item.title &#125;&lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们创建一个这样的函数，为每一个 item 根据 id 创建一个 atom</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const itemsList = &#123;&#125;;</span><br><span class="line">export const getItemState = id =&gt; &#123;</span><br><span class="line">  if (!itemsList[id]) &#123;</span><br><span class="line">    itemsList[id] = atom(&#123;</span><br><span class="line">      key: `item-$&#123;id&#125;`,</span><br><span class="line">      default: &#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  return itemsList[id]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Item(&#123; id &#125;) &#123;</span><br><span class="line">  const [item, setItem] = useRecoilState(getItemState(id));</span><br><span class="line">  // other</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;&#123; item.title &#125;&lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式，给 item 组件传入不同的 id，就可以得到独立的 item 对象，每个维护自己独立的状态。</p>
<p>Recoil 提供了这种方式的 api atomFamily。经过 atomFamily 创建的 family 对象可以看作是和普通的 atom 相同，但它会根据不同的参数创建不同的单个 atom，保证不同的 id 对应到不同的 atom，从而形成 item 的独立，一个 item 状态的更改不会影响其他 item</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">export const itemFamily = atomFamily(&#123;</span><br><span class="line">  key: &#x27;itemFamily&#x27;,</span><br><span class="line">  default: &#123;</span><br><span class="line">    x: 0,</span><br><span class="line">    y: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function Item(&#123; id &#125;) &#123;</span><br><span class="line">  // 这里的item管理的是这个item独立的状态，setItem也是设置这个状态</span><br><span class="line">  const [item, setItem] = useRecoilState(itemFamily(id));</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        position:</span><br><span class="line">        x: &#123;item.x&#125;</span><br><span class="line">        y: &#123;item.y&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setItem(pos =&gt; (&#123;...pos,x: pos.x + 1&#125;))&#125;&gt;向下&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setItem(pos =&gt; (&#123;...pos,x: pos.y + 1&#125;))&#125;&gt;向右&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ItemsList(...)&#123;</span><br><span class="line">  //...</span><br><span class="line">  return (</span><br><span class="line">    &#123;</span><br><span class="line">      items.map(item =&gt; (&lt;Item id=&#123;item.id&#125; /&gt;))</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是 Recoil 状态管理的核心理念，抽离独立的状态，独立管理，避免不必要的渲染，同时便于扩展和管理。而 Redux 是状态的集中管理，基本上整个应用只有一个全局的状态。</p>
<h3 id="selector"><a href="#selector" class="headerlink" title="selector"></a>selector</h3><p>selector 是一种派生状态的方式，即根据一个原生状态派生出一个新的状态。<br>比如说（官方文档例子），以 todoList 项目为例，todos 数组是一个原始状态（atom），而 todos 列表的信息（比如 todos 数量、已完成和未完成数量），或者通过某种方式过滤的 todos，都属于基于 todos 的派生状态。<br>因此 selector 基于 atom 或者其他的 selector，它的参数需要传递一个 atom 或 selector。<br>这种派生方式可以避免冗余 state，即不需要为可以派生的状态单独创建一个 atom 或维护一个状态（比如 completeTodos 派生于 todos，如果不采用 selector，就需要单独维护一个 completeTodos 状态）</p>
<p>selector 结构如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someState = selector(&#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&quot;someState&quot;</span>,</span><br><span class="line">  <span class="attr">get</span>: <span class="function">(<span class="params">&#123; get &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> otherState = get(otherAtom);</span><br><span class="line">    <span class="keyword">const</span> anotherState = get(otherSelector);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      otherState,</span><br><span class="line">      anotherState,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function">(<span class="params">&#123; get, set, reset &#125;, newValue</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>get 方法通过其他的 atom 或 selector 的 state，返回一个新的 state 作为派生值。通常就是从原生状态 get 获取 state，然后返回一个派生的 state。比如基于 todos atom 派生的 filterTodos：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> completeSelector = selector(&#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&quot;completeTodos&quot;</span>,</span><br><span class="line">  <span class="attr">get</span>: <span class="function">(<span class="params">&#123; get &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> todos = get(todoAtom);</span><br><span class="line">    <span class="keyword">return</span> todos.filter(<span class="function">(<span class="params">todo</span>) =&gt;</span> todo.isComplete);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用和atom一样</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> completeTodos = useRecoilValue(completeSelector);</span><br></pre></td></tr></table></figure>

<p>一旦通过 get 获取了某个 atom 的状态，该 selector 就会和 atom“连接”，源 atom 的状态改变会导致重新执行 get 方法，自动重新计算新值，并触发订阅组件的更新。</p>
<p>需要注意的是，如果 selector 只设置了 get 而没有设置 set，那么就只能取值而不是调用 setState 修改值。如果希望调用 setState 修改状态，那么还需要设置 set 方法<br>set 方法参数是一个对象，包含 get、set 和 reset 三个方法，不需要返回值，关键是调用 set 方法修改数据来源的 atom。</p>
<ul>
<li>get：和 get 里的那个 get 相同，可以从 atom 中获取状态。</li>
<li>set：格式为<code>(atom, value) =&gt; void</code>，可以 value 设置为 atom 的 state 值。</li>
</ul>
<p>比如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> completeSelector = selector(&#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&#x27;completeTodos&#x27;</span>,</span><br><span class="line">  <span class="attr">get</span>: <span class="function">(<span class="params">&#123;get&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> todos = get(todoAtom)</span><br><span class="line">    <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.isComplete)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function">(<span class="params">&#123;get, set&#125;,newValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 调用set修改todoAtom，才能使得源状态更改，从而使派生状态更改</span></span><br><span class="line">    set(todoAtom, newValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件内</span></span><br><span class="line"><span class="keyword">const</span> setCompleteTodosState = useSetRecoilState(completeSelector)</span><br><span class="line">setCompleteTodosState([...])</span><br></pre></td></tr></table></figure>

<h3 id="异步数据流"><a href="#异步数据流" class="headerlink" title="异步数据流"></a>异步数据流</h3><p>Recoil 可以实现在正常的数据流图中直接添加异步函数来实现异步数据查询。<br>而 redux 的异步方案，其实是一种同步的流程中加入了异步函数，即通过传递 dispatch 回调，让异步任务完成后调用 dispatch。这实际上和 react 原生的异步方式没有区别<br>但是 recoil 的异步则是直接在数据流中的。通过 selector 设置一个异步函数，消费这个 selector 的组件，类似于 react 提出的 suspense 用法，会让渲染和请求同时启动，当异步任务完成后才渲染完成。<br>参考 React 对 suspense 组件的新用法：<a target="_blank" rel="noopener" href="https://beta.reactjs.org/reference/react/Suspense">https://beta.reactjs.org/reference/react/Suspense</a> ，可以看到第一和第二个例子中，Suspense 包裹的组件内部直接渲染的数据实际上是一个在 render 阶段执行的异步任务，这和普通 React 组件要求在 useEffect 内完成不同。Recoil 的异步实现也类似于这种方式。</p>
<h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>通常的同步数据查询方式，即从 atom 向某个 selector 派生一个状态出来，比如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> currentUserIDState = atom(&#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&quot;CurrentUserID&quot;</span>,</span><br><span class="line">  <span class="attr">default</span>: <span class="number">1</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> currentUserNameState = selector(&#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&quot;CurrentUserName&quot;</span>,</span><br><span class="line">  <span class="attr">get</span>: <span class="function">(<span class="params">&#123; get &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tableOfUsers[get(currentUserIDState)].name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CurrentUserInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> userName = useRecoilValue(currentUserNameState);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;userName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么异步数据，就只需要修改 selector 的 get 方法为异步函数，即返回一个 promise，或者改为 async 函数</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> currentUserNameQuery = selector(&#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&quot;CurrentUserName&quot;</span>,</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">async</span> (&#123; get &#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> myDBQuery(&#123;</span><br><span class="line">      <span class="attr">userID</span>: get(currentUserIDState),</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> response.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这时对于组件来说，就不能再使用 useRecoilValue，因为显然这个状态是异步产生的。在 await 任务完成之前，状态都是空值；<br>因此应该采取一个特别的 hooks useRecoilValueLoadable。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function UserInfo(&#123; userID &#125;) &#123;</span><br><span class="line">  const userNameLoadable = useRecoilValueLoadable(userNameQuery(userID));</span><br><span class="line">  switch (userNameLoadable.state) &#123;</span><br><span class="line">    case &quot;hasValue&quot;:</span><br><span class="line">      return &lt;div&gt;&#123;userNameLoadable.contents&#125;&lt;/div&gt;;</span><br><span class="line">    case &quot;loading&quot;:</span><br><span class="line">      return &lt;div&gt;加载中……&lt;/div&gt;;</span><br><span class="line">    case &quot;hasError&quot;:</span><br><span class="line">      throw userNameLoadable.contents;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 contents 是一个<code>T | Error | LoadablePromise&lt;T&gt;</code>的复合类型，会比较难用，所以可以封装一个小的 hooks 用于过滤 contents</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useLoadable</span>(<span class="params">loadableSelector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; contents, state &#125; = useRecoilValueLoadable(loadableSelector);</span><br><span class="line">  <span class="keyword">const</span> [loading, setLoading] = useState(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;hasValue&quot;</span>:</span><br><span class="line">      setLoading(<span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">return</span> &#123; contents, loading &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;loading&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; contents, loading &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;hasError&quot;</span>:</span><br><span class="line">      <span class="keyword">throw</span> contents;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种方式是仍然正常使用 useRecoilValue，但是使用的组件外部应该包裹 Suspense 组件，并且还需要包裹 ErrorBoundary 去处理错误</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;RecoilRoot&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">React.Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">CurrentUserInfo</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">React.Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line">&lt;/RecoilRoot&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> currentUserNameQuery = selector(&#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&#x27;CurrentUserName&#x27;</span>,</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">async</span> (&#123;get&#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> myDBQuery(&#123;</span><br><span class="line">      <span class="attr">userID</span>: get(currentUserIDState),</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="keyword">throw</span> err)</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CurrentUserInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> userName = useRecoilValue(currentUserNameState);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;userName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="带参请求"><a href="#带参请求" class="headerlink" title="带参请求"></a>带参请求</h4><p>上面这种形式只适用于不需要额外参数的（请求参数只来自于其他 atom 的派生，比如上面的 id 来自于别的 atom，但没有调用时传入的参数）<br>如果需要额外参数，就需要使用 selectorFamily。selectorFamily 的 get 方法是一个高阶函数，类比 atomFamily 的使用</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userNameQuery = selectorFamily(&#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&quot;UserName&quot;</span>,</span><br><span class="line">  <span class="attr">get</span>: <span class="function">(<span class="params">userID</span>) =&gt;</span> <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> myDBQuery(&#123; userID &#125;);</span><br><span class="line">    <span class="keyword">if</span> (response.error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> response.error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserInfo</span>(<span class="params">&#123; userID &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> userName = useRecoilValue(userNameQuery(userID));</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;userName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">React.Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>加载中……<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">UserInfo</span> <span class="attr">userID</span>=<span class="string">&#123;1&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">UserInfo</span> <span class="attr">userID</span>=<span class="string">&#123;2&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">UserInfo</span> <span class="attr">userID</span>=<span class="string">&#123;3&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">React.Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="刷新请求"><a href="#刷新请求" class="headerlink" title="刷新请求"></a>刷新请求</h4><p>需要注意的是，如果我们通过上面的方式发起了请求，那就和在 React 中使用的 useEffect 形式完全不同。<br>在 React 中可以控制 effect 从而实现请求的刷新和初始化，把请求放在 useEffect 内部。但是 Recoil 则是把请求放在 selector 中，因此不能依靠 effect 刷新请求。</p>
<p>但是 selector 的一个特点是可以随着订阅的 atom 的更新而更新，因此我们可以让它订阅一个 atom，只需要刷新这个 atom，就能刷新请求。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; selector, atom, DefaultValue &#125; <span class="keyword">from</span> <span class="string">&quot;recoil&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> fetchData, &#123; MockData &#125; <span class="keyword">from</span> <span class="string">&quot;../mock/fetchData&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requestIdState = atom(&#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="string">`requestId`</span>,</span><br><span class="line">  <span class="attr">default</span>: <span class="number">0</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> dataQuery = selector(&#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&quot;dataQuery&quot;</span>,</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">async</span> (&#123; get &#125;) =&gt; &#123;</span><br><span class="line">    get(requestIdState);</span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> fetchData();</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function">(<span class="params">&#123; set &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    set(requestIdState, <span class="function">(<span class="params">requestId</span>) =&gt;</span> requestId + <span class="number">1</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件内</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [data, refresh] = useRecoilState(dataQuery);</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  refresh();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="其他状态管理库"><a href="#其他状态管理库" class="headerlink" title="其他状态管理库"></a>其他状态管理库</h1><h2 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h2><p>flux 官方文档：<a target="_blank" rel="noopener" href="https://facebook.github.io/flux/docs/">https://facebook.github.io/flux/docs/</a></p>
<p>flux 是一种理念，redux 是基于 flux 的实现。<br>flux 的核心主要有四个：</p>
<p><img src="https://pic.imgdb.cn/item/63da5ba9ac6ef860166eff72.jpg"></p>
<ul>
<li>View：视图层</li>
<li>Action：动作，即数据改变的消息对象<ul>
<li>Store 的改变只能通过 Action</li>
<li>具体 Action 的处理逻辑一般放在 Store 里</li>
<li>Action 对象包含 type （类型）与 payload （传递参数）</li>
</ul>
</li>
<li>Dispatcher：派发器，接收 Actions ，发给所有的 Store</li>
<li>Store：数据层，存放应用状态与更新状态的方法，一旦发生变动，就提醒 Views 更新页面</li>
</ul>
<p>flux 的特点可以参考 redux 的特点（redux 是 flux 较为完善的实现），唯一不太一样的是，store 可以有多个，而 redux 中无论是 store 还是 reducer 都是一个</p>
<h2 id="MobX"><a href="#MobX" class="headerlink" title="MobX"></a>MobX</h2><p><img src="https://pic.imgdb.cn/item/63da613dac6ef860167ceea4.jpg"></p>
<p><img src="https://pic.imgdb.cn/item/63da6198ac6ef860167dd17d.jpg"></p>
<h3 id="核心理念"><a href="#核心理念" class="headerlink" title="核心理念"></a>核心理念</h3><p>mobx 推崇一种响应式编程。 mobx 的实现和使用方式和 redux 差距很大。</p>
<ul>
<li>observable：即“被监听的”状态，通常用于定义一个状态。这个状态可以是任意类型，比如字符串、数字、对象、数组、map 等</li>
<li>action：用于修改状态的函数，只有被标记为 action 的函数内部修改的状态才会生效，在其内部采用直接修改 state 值的形式，而非 redux 那种复制形式</li>
<li>computed：一个 getter，相当于监听一个 observable 的函数，当 observable 变化时，computed 会执行并返回一个派生的状态。</li>
</ul>
<p>上面三个是主要的形式，通过 observable 创建一个 state，然后用 action 修改，再配合 computed 配合派生状态，就完成了一个状态管理的基本结构。</p>
<p>下面是一个例子：<br>这里我们在一个类中使用 makeObservable 标记属性和方法的类型，把 todos 标记为 observable，用于修改 todo 的函数标记为 action，根据 todo 变化而变化的状态标记为 computed</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; makeObservable, observable, action &#125; <span class="keyword">from</span> <span class="string">&quot;mobx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoStore</span> </span>&#123;</span><br><span class="line">  todos = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    makeObservable(<span class="built_in">this</span>, &#123;</span><br><span class="line">      <span class="attr">todos</span>: observable,</span><br><span class="line">      <span class="attr">addTodo</span>: action,</span><br><span class="line">      <span class="attr">removeTodo</span>: action,</span><br><span class="line">      <span class="attr">todoLen</span>: computed,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">addTodo</span>(<span class="params">todo</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.todos.push(todo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">removeTodo</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.todos.splice(index, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">todoLen</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.todos.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里返回的是store的实例，而非类本身</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> TodoStore();</span><br></pre></td></tr></table></figure>

<p>也可以使用 makeAutoObservable 自动将所有属性和方法变为 observable 或 action，把 getter 变为 computed</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoStore</span> </span>&#123;</span><br><span class="line">  todos = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    makeAutoObservable(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">addTodo</span>(<span class="params">todo</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.todos.push(todo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">removeTodo</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.todos.splice(index, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">todoLen</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.todos.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了这三个之外，还有几个：</p>
<ul>
<li>autorun：类似 watch 的功能，它接受一个函数，函数内引用的状态（即上面的 store 的实例）变化时，这个函数会自动执行</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderLine</span> </span>&#123;</span><br><span class="line">  price = <span class="number">0</span>;</span><br><span class="line">  amount = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> order = <span class="keyword">new</span> OrderLine(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改order的值，这个函数就会继续执行</span></span><br><span class="line"><span class="keyword">const</span> stop = autorun(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Total: &quot;</span> + order.total);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>reaction：类似于 autorun，但可以让你更加精细地控制要跟踪的可观察对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  name;</span><br><span class="line">  energyLevel;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> giraffe = <span class="keyword">new</span> Animal(<span class="string">&quot;Gary&quot;</span>);</span><br><span class="line"></span><br><span class="line">reaction(</span><br><span class="line">  <span class="function">() =&gt;</span> giraffe.isHungry,</span><br><span class="line">  <span class="function">(<span class="params">isHungry</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isHungry) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Now I&#x27;m hungry!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;I&#x27;m not hungry!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Energy level:&quot;</span>, giraffe.energyLevel);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="和-React-结合"><a href="#和-React-结合" class="headerlink" title="和 React 结合"></a>和 React 结合</h3><p>上面的例子讲了如何创建一个 store。通过 class 的形式可以创建一个 store，然后导出类的实例，直接访问实例的属性就可以获得状态的输出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo = <span class="keyword">new</span> TodoList()</span><br><span class="line"></span><br><span class="line">todo.todos</span><br><span class="line">todo.addTodo(...)</span><br></pre></td></tr></table></figure>

<p>和 react 结合的话，最重要的是告知 react mobx 输出的状态是一个合法的 react state，从而使得 state 改变时，react 组件能够相应的更新。<br>在 redux 中采用的方法是通过 context 下发状态，然后再通过 useSelector 订阅状态并强制更新。<br>mobx 采用了一种“响应式”的方式，用 observer 将函数包裹起来，当函数内使用的状态发生变化时，就相应地更新函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">useMobxStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">count</span>: number = <span class="number">0</span> <span class="comment">// 初始化状态数据</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 对初始化数据进行响应式处理</span></span><br><span class="line">    makeAutoObservable(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置改变初始化数据方法</span></span><br><span class="line">  addCount = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.count++</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.count)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数组件</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; observer &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react-lite&#x27;</span> <span class="comment">// 从mobx-react-lite内部引入observer让mobx与react进行关联</span></span><br><span class="line"><span class="keyword">import</span> UseMobxStore <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useMobxStoreState = <span class="keyword">new</span> UseMobxStore()</span><br><span class="line"><span class="keyword">const</span> MobxDemo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;useMobxStoreState.count&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;useMobxStoreState.addCount&#125;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> observer(MobxDemo)</span><br></pre></td></tr></table></figure>

<p>实际使用过程中，由于一个 store 对应一部分 state，项目中可能有很多 store，因此我们可以采用类似 combineReducer 的方式，将多个 store 合并到一个 RootStore 中去，然后用 context 将其下发，在组件中使用 useContext 获取 RootStore</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store.ts</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store1</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">rootStore:RootStore</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.rootStore = rootStore</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store2</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">rootStore:RootStore</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.rootStore = rootStore</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootStore</span></span>&#123;</span><br><span class="line">  <span class="attr">store1</span>:Store1</span><br><span class="line">  <span class="attr">store2</span>:Store2</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.store1 = <span class="keyword">new</span> Store1(<span class="built_in">this</span>)</span><br><span class="line">    <span class="built_in">this</span>.store2 = <span class="keyword">new</span> Store2(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RootStateContext = createContext(<span class="keyword">new</span> RootStore())</span><br><span class="line"></span><br><span class="line"><span class="comment">// some-component.tsx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SomeComponent = observer(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;store1,store2&#125; = useContext(RootStateContext)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以参考：<img src="https://pic.imgdb.cn/item/640f5ef7f144a010075c3e09.jpg"></p>
<h3 id="和-redux-比较"><a href="#和-redux-比较" class="headerlink" title="和 redux 比较"></a>和 redux 比较</h3><p>相同点：</p>
<ul>
<li>两者都秉持视图的改变必须要通过 state 改变来实现的思想。而 state 也不能直接改变，需要通过 action 改变。如果直接修改 state，将不会导致视图的更新</li>
<li>单向数据流。虽然两者实现单向数据的方式不一样，并且 mobx 并没有很强调单向数据，即 action -&gt; state -&gt; view -&gt; action 这种基本形式。</li>
</ul>
<p>不同点：</p>
<ol>
<li>Redux 是 FLUX 编程思想，单向数据流。Mobx 是 TFRP 编程思想，响应式编程。</li>
</ol>
<p>redux 是每次返回一个全新的状态，一般搭配实现对象 immutable 的库来用。<br>mobx 每次都是修改的同一个状态对象，基于响应式代理，也就是 Object.defineProperty 代理 get、set 的处理，get 时把依赖收集起来，set 修改时通知所有的依赖做更新。</p>
<p>关于 mobx 的基本原理，可以这样理解：<br>当通过 makeObservable 处理类组件中的 state 之后，该 state 的 getter 和 setter 操作会被拦截。如果调用 setter，那就会触发执行保存的依赖，即类似 listeners。也就是说当更新 state 时，就会执行 listeners，从而执行一些更新，比如对 react 组件使用 forceUpdate。<br>当在组件中使用 state 的 getter 时（即获取 state），mobx 就会顺带收集该组件到全局中，这样到执行更新时就知道该更新哪个组件了。</p>
<ol start="2">
<li><p>redux 推崇纯函数的函数式编程，而 mobx 是面向对象的思想</p>
</li>
<li><p>mobx 的响应式能精准的通知依赖做更新，而 redux 只能全局通知，而且 mobx 只是修改同一个对象，不是每次创建新对象，性能会比 redux 更高。</p>
</li>
</ol>
<p>mobx 的问题：</p>
<ol>
<li>mobx 的编程思想和 react 不搭。mobx 是类似 vue 的响应式编程，和 react 推崇的单向数据、函数式编程矛盾。如果把大量状态都使用 mobx 这种形式去修改的话，肯定不符合 react 的 setState 修改原则</li>
<li>调试困难，最大的问题是打印状态时打印的是一个 proxy</li>
<li>对 hooks 支持一般</li>
</ol>
<h2 id="zustand"><a href="#zustand" class="headerlink" title="zustand"></a>zustand</h2><p>zustand 是一个轻量级状态管理库，和 redux 一样都是基于不可变状态模型和单向数据流的，状态对象 state 不可被修改，只能被替换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; create &#125; <span class="keyword">from</span> <span class="string">&quot;zustand&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useBearStore = create(<span class="function">(<span class="params">set</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">bears</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">increasePopulation</span>: <span class="function">() =&gt;</span> set(<span class="function">(<span class="params">state</span>) =&gt;</span> (&#123; <span class="attr">bears</span>: state.bears + <span class="number">1</span> &#125;)),</span><br><span class="line">  <span class="attr">removeAllBears</span>: <span class="function">() =&gt;</span> set(&#123; <span class="attr">bears</span>: <span class="number">0</span> &#125;),</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BearCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> bears = useBearStore(<span class="function">(<span class="params">state</span>) =&gt;</span> state.bears);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;bears&#125; around here ...<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Controls</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> increasePopulation = useBearStore(<span class="function">(<span class="params">state</span>) =&gt;</span> state.increasePopulation);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increasePopulation&#125;</span>&gt;</span>one up<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>zustand 和其他状态管理库最大的一个差异在于它全局同例。也就是说它并没有采用 context，而是在全局仅保存一个 useStore，每次返回的是同一个实例。<br>不过 zustand 也对此做了优化，它可以保证组件内每个函数的引用都是固定的，类似 useMemo 的效果，可以保证减少重复渲染。</p>
<p>和其他状态管理库一样，zustand 也有类似的 action 和 selector，用于处理状态的派生和修改：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> create <span class="keyword">from</span> <span class="string">&#x27;zustand&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加第一个入参 set</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useStore = create(<span class="function">(<span class="params">set</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">panelTabKey</span>: <span class="string">&#x27;antd&#x27;</span>,</span><br><span class="line">  <span class="attr">iconList</span>: ...,</span><br><span class="line">  antdIconList,</span><br><span class="line"></span><br><span class="line">  <span class="attr">selectIcon</span>: <span class="function">(<span class="params">icon</span>) =&gt;</span> &#123;</span><br><span class="line">    set(&#123; icon, <span class="attr">open</span>: <span class="literal">false</span>, <span class="attr">filterKeywords</span>: <span class="literal">undefined</span> &#125;);</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展示用户会看到 icon list</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> displayListSelector = <span class="function">(<span class="params">s: <span class="keyword">typeof</span> useStore</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Jotai"><a href="#Jotai" class="headerlink" title="Jotai"></a>Jotai</h2><p>和 recoil 一样的追求原子性的库，使用起来也很简单，并且没有什么多余的 api，一个 useAtom 就够了。<br>和 recoil 相比还有一个特点是不需要一个独立的 key 值来用作表示 atom，每个 atom 都是自然独立的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; atom &#125; <span class="keyword">from</span> <span class="string">&#x27;jotai&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> countAtom = atom(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> countryAtom = atom(<span class="string">&#x27;Japan&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> citiesAtom = atom([<span class="string">&#x27;Tokyo&#x27;</span>, <span class="string">&#x27;Kyoto&#x27;</span>, <span class="string">&#x27;Osaka&#x27;</span>])</span><br><span class="line"><span class="keyword">const</span> mangaAtom = atom(&#123; <span class="string">&#x27;Dragon Ball&#x27;</span>: <span class="number">1984</span>, <span class="string">&#x27;One Piece&#x27;</span>: <span class="number">1997</span>, <span class="attr">Naruto</span>: <span class="number">1999</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; useAtom &#125; <span class="keyword">from</span> <span class="string">&#x27;jotai&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useAtom(countAtom)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;h1&gt;</span><br><span class="line">      &#123;count&#125;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(<span class="function">(<span class="params">c</span>) =&gt;</span> c + <span class="number">1</span>)&#125;&gt;one up&lt;/button&gt;</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>

<p>派生状态也很容易，是和 recoil selector 类似的写法，通过 get 函数捕获一个 atom，然后返回新的状态。只不过这里并不需要额外的 api，使用 atom 就好</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doubledCountAtom = atom(<span class="function">(<span class="params">get</span>) =&gt;</span> get(countAtom) * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DoubleCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [doubledCount] = useAtom(doubledCountAtom);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;doubledCount&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点可能就是比较小众的库，维护上不一定比得上 recoil</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/">日常学习</a></div><div class="post_share"><div class="social-share" data-image="/img/recoil.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/28/svg/"><img class="prev-cover" src="/img/svg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">svg学习</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/09/blog6-webpack/"><img class="next-cover" src="/img/webpack.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">webpack学习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/05/12/OS/" title="操作系统知识点总结"><img class="cover" src="/img/OS.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-12</div><div class="title">操作系统知识点总结</div></div></a></div><div><a href="/2021/12/05/blog1-h5-deeping/" title="前端知识深入--HTML5深入"><img class="cover" src="/img/Chrome.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-05</div><div class="title">前端知识深入--HTML5深入</div></div></a></div><div><a href="/2022/02/02/RegExp/" title="正则表达式学习和常用正则"><img class="cover" src="/img/canvas.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-02</div><div class="title">正则表达式学习和常用正则</div></div></a></div><div><a href="/2021/12/10/blog2-css-deeping/" title="CSS学习总结"><img class="cover" src="/img/CSS.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-10</div><div class="title">CSS学习总结</div></div></a></div><div><a href="/2021/12/02/blog4-web/" title="网络知识学习总结"><img class="cover" src="/img/web.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-02</div><div class="title">网络知识学习总结</div></div></a></div><div><a href="/2021/12/02/blog5-browser/" title="浏览器知识学习总结"><img class="cover" src="/img/Chrome.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-02</div><div class="title">浏览器知识学习总结</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/pinkstar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xing Ye</div><div class="author-info__description">a singleThreaded boy's blog</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/penghei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/penghei" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:632885485@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">A SingleThreaded Boy...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redux"><span class="toc-number">1.</span> <span class="toc-text">Redux</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#store"><span class="toc-number">1.1.1.</span> <span class="toc-text">store</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reducer"><span class="toc-number">1.1.2.</span> <span class="toc-text">reducer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#action"><span class="toc-number">1.1.3.</span> <span class="toc-text">action</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#state"><span class="toc-number">1.1.4.</span> <span class="toc-text">state</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">1.1.5.</span> <span class="toc-text">其他</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#middleWare"><span class="toc-number">1.1.6.</span> <span class="toc-text">middleWare</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#api"><span class="toc-number">1.2.</span> <span class="toc-text">api</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#createStore"><span class="toc-number">1.2.1.</span> <span class="toc-text">createStore</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#getState"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">getState</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#subscribe"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">subscribe</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dispatch"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">dispatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#replaceReducer"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">replaceReducer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#preloadedState"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">preloadedState</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#enhancer"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">enhancer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#combineReducers"><span class="toc-number">1.2.2.</span> <span class="toc-text">combineReducers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#applyMiddleware"><span class="toc-number">1.2.3.</span> <span class="toc-text">applyMiddleware</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5"><span class="toc-number">1.3.1.</span> <span class="toc-text">处理异步</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React-Redux"><span class="toc-number">2.</span> <span class="toc-text">React-Redux</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Provider"><span class="toc-number">2.1.1.</span> <span class="toc-text">Provider</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#selector-%E5%92%8C-useSelector"><span class="toc-number">2.1.2.</span> <span class="toc-text">selector 和 useSelector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#useSyncExternalStore"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">useSyncExternalStore</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dispatch-%E5%92%8C-useDispatch"><span class="toc-number">2.1.3.</span> <span class="toc-text">dispatch 和 useDispatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#store-1"><span class="toc-number">2.1.4.</span> <span class="toc-text">store</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#api-1"><span class="toc-number">2.2.</span> <span class="toc-text">api</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#connect"><span class="toc-number">2.2.1.</span> <span class="toc-text">connect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mapStateToProps"><span class="toc-number">2.2.2.</span> <span class="toc-text">mapStateToProps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mapDispatchToProps"><span class="toc-number">2.2.3.</span> <span class="toc-text">mapDispatchToProps</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redux-Toolkit"><span class="toc-number">3.</span> <span class="toc-text">Redux-Toolkit</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8-api"><span class="toc-number">3.1.</span> <span class="toc-text">常用 api</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#configureStore"><span class="toc-number">3.1.1.</span> <span class="toc-text">configureStore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#createSlice"><span class="toc-number">3.1.2.</span> <span class="toc-text">createSlice</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E5%90%88-TS"><span class="toc-number">3.2.</span> <span class="toc-text">配合 TS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redux-%E5%93%B2%E5%AD%A6"><span class="toc-number">4.</span> <span class="toc-text">Redux 哲学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#xxxManager"><span class="toc-number">4.1.</span> <span class="toc-text">xxxManager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reducer-%E7%9A%84%E8%A6%81%E6%B1%82"><span class="toc-number">4.2.</span> <span class="toc-text">Reducer 的要求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#reducer-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E7%82%B9"><span class="toc-number">4.2.1.</span> <span class="toc-text">reducer 的基本特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%86%E5%88%86-reducer"><span class="toc-number">4.2.2.</span> <span class="toc-text">拆分 reducer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E6%A0%B7%E6%9D%BF"><span class="toc-number">4.2.3.</span> <span class="toc-text">减少样板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%95%B0%E6%8D%AE"><span class="toc-number">4.2.4.</span> <span class="toc-text">格式化数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Undo-Redo"><span class="toc-number">4.3.</span> <span class="toc-text">Undo-Redo</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Recoil"><span class="toc-number">5.</span> <span class="toc-text">Recoil</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E7%82%B9"><span class="toc-number">5.1.</span> <span class="toc-text">基本特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%8C%96"><span class="toc-number">5.1.1.</span> <span class="toc-text">原子化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">5.1.2.</span> <span class="toc-text">数据流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SnapShot-%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="toc-number">5.1.3.</span> <span class="toc-text">SnapShot 全局状态管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9-ConcurrentMode-%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">5.1.4.</span> <span class="toc-text">对 ConcurrentMode 的支持</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">5.2.</span> <span class="toc-text">核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#atom"><span class="toc-number">5.2.1.</span> <span class="toc-text">atom</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#selector"><span class="toc-number">5.2.2.</span> <span class="toc-text">selector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">5.2.3.</span> <span class="toc-text">异步数据流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">简单请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E8%AF%B7%E6%B1%82"><span class="toc-number">5.2.3.2.</span> <span class="toc-text">带参请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%B7%E6%96%B0%E8%AF%B7%E6%B1%82"><span class="toc-number">5.2.3.3.</span> <span class="toc-text">刷新请求</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%BA%93"><span class="toc-number">6.</span> <span class="toc-text">其他状态管理库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Flux"><span class="toc-number">6.1.</span> <span class="toc-text">Flux</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MobX"><span class="toc-number">6.2.</span> <span class="toc-text">MobX</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%90%86%E5%BF%B5"><span class="toc-number">6.2.1.</span> <span class="toc-text">核心理念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C-React-%E7%BB%93%E5%90%88"><span class="toc-number">6.2.2.</span> <span class="toc-text">和 React 结合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C-redux-%E6%AF%94%E8%BE%83"><span class="toc-number">6.2.3.</span> <span class="toc-text">和 redux 比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zustand"><span class="toc-number">6.3.</span> <span class="toc-text">zustand</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jotai"><span class="toc-number">6.4.</span> <span class="toc-text">Jotai</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/30/react-priority/" title="使用Priority管理React组件渲染优先级"><img src="/img/priority.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用Priority管理React组件渲染优先级"/></a><div class="content"><a class="title" href="/2023/06/30/react-priority/" title="使用Priority管理React组件渲染优先级">使用Priority管理React组件渲染优先级</a><time datetime="2023-06-30T06:58:28.000Z" title="发表于 2023-06-30 14:58:28">2023-06-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/28/carousel-source-code/" title="轮播图是怎么动起来的——轮播图的基本原理和源码学习"><img src="/img/swiper.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="轮播图是怎么动起来的——轮播图的基本原理和源码学习"/></a><div class="content"><a class="title" href="/2023/05/28/carousel-source-code/" title="轮播图是怎么动起来的——轮播图的基本原理和源码学习">轮播图是怎么动起来的——轮播图的基本原理和源码学习</a><time datetime="2023-05-28T11:37:56.000Z" title="发表于 2023-05-28 19:37:56">2023-05-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/17/react-native/" title="React Native 学习"><img src="/img/rn.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React Native 学习"/></a><div class="content"><a class="title" href="/2023/05/17/react-native/" title="React Native 学习">React Native 学习</a><time datetime="2023-05-17T06:58:28.000Z" title="发表于 2023-05-17 14:58:28">2023-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/05/konva/" title="konva学习和原理浅析"><img src="/img/konva.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="konva学习和原理浅析"/></a><div class="content"><a class="title" href="/2023/03/05/konva/" title="konva学习和原理浅析">konva学习和原理浅析</a><time datetime="2023-03-05T09:23:35.000Z" title="发表于 2023-03-05 17:23:35">2023-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/16/react-router/" title="react-router使用及原理浅析"><img src="/img/react.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="react-router使用及原理浅析"/></a><div class="content"><a class="title" href="/2023/02/16/react-router/" title="react-router使用及原理浅析">react-router使用及原理浅析</a><time datetime="2023-02-16T10:06:32.000Z" title="发表于 2023-02-16 18:06:32">2023-02-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Xing Ye</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hello stranger!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>