<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>js题目 | XingYeBlog</title><meta name="keywords" content="面试"><meta name="author" content="Xing Ye,632885485@qq.com"><meta name="copyright" content="Xing Ye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="手写题手写 newnew 的大致原理: 12345function _new(fn) &amp;#123;  const obj &#x3D; &amp;#123;&amp;#125;;  obj.__proto__ &#x3D; fn.prototype;  return fn.call(obj);&amp;#125;   创建一个对象，将来作为实例 将实例的__proto__属性指向构造函数的prototype属性，即let obj; obj.">
<meta property="og:type" content="article">
<meta property="og:title" content="js题目">
<meta property="og:url" content="http://example.com/2022/05/13/handwriting/index.html">
<meta property="og:site_name" content="XingYeBlog">
<meta property="og:description" content="手写题手写 newnew 的大致原理: 12345function _new(fn) &amp;#123;  const obj &#x3D; &amp;#123;&amp;#125;;  obj.__proto__ &#x3D; fn.prototype;  return fn.call(obj);&amp;#125;   创建一个对象，将来作为实例 将实例的__proto__属性指向构造函数的prototype属性，即let obj; obj.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/JS.png">
<meta property="article:published_time" content="2022-05-13T04:21:10.000Z">
<meta property="article:modified_time" content="2022-05-15T07:15:17.443Z">
<meta property="article:author" content="Xing Ye">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/JS.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2022/05/13/handwriting/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'js题目',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-15 15:15:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/pinkstar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/JS.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XingYeBlog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">js题目</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-13T04:21:10.000Z" title="发表于 2022-05-13 12:21:10">2022-05-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-15T07:15:17.443Z" title="更新于 2022-05-15 15:15:17">2022-05-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaScript/">JavaScript</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>36分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="js题目"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="手写题"><a href="#手写题" class="headerlink" title="手写题"></a>手写题</h1><h2 id="手写-new"><a href="#手写-new" class="headerlink" title="手写 new"></a>手写 new</h2><p>new 的大致原理:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">  obj.__proto__ = fn.prototype;</span><br><span class="line">  <span class="keyword">return</span> fn.call(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>创建一个对象，将来作为实例</li>
<li>将实例的<code>__proto__</code>属性指向构造函数的<code>prototype</code>属性，即<code>let obj; obj.__proto__ = fn.prototype</code></li>
<li>调用构造函数并绑定 this 到 obj 上</li>
<li>返回调用结果</li>
</ol>
<p>因此手写 new 按照类似的原理创建：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(fn.prototype); <span class="comment">//新建对象并将原型指向构造函数的prototype</span></span><br><span class="line">  <span class="keyword">const</span> ret = fn.apply(obj, args); <span class="comment">//调用构造函数，并把上下文指定为当前对象（让构造函数内的this都指向当前对象）</span></span><br><span class="line">  <span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj; <span class="comment">//检查返回值，如果没有返回值就返回该对象，如果有就返回返回值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = _new(Animal, <span class="string">&quot;Puppy&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>实际上关键的一步就是<code>fn.apply(obj, args)</code>；<br>如果函数没有显式的返回值（构造函数如果显式返回对象，new 会直接返回该对象而不是实例），实际上就是一个绑定对象，给对象添加属性并设置原型的过程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj.__proto = fn.prototype;</span><br><span class="line">fn.call(obj, ...args);</span><br><span class="line"><span class="keyword">let</span> dog = obj;</span><br></pre></td></tr></table></figure>

<h2 id="手写数组去重"><a href="#手写数组去重" class="headerlink" title="手写数组去重"></a>手写数组去重</h2><p>原理:</p>
<ul>
<li>filter 会在返回为 false 时去除该元素</li>
<li>indexOf 会返回第一个找到的该元素的索引; 如果有重复元素则显然 indexOf 只返回第一个该元素, 不会等于当前 index,就会返回 false 从而筛掉</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = arr.filter(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> array.indexOf(item) === index;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce也可以</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre, cur, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.indexOf(cur) === index ? pre.concat(cur) : pre;</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写数组扁平"><a href="#手写数组扁平" class="headerlink" title="手写数组扁平"></a>手写数组扁平</h2><p>原理:</p>
<ul>
<li><code>arr.some()</code> 方法, 参数传递一个测试函数, 对每个元素测试, 如果至少一个通过测试就会返回 true; 也就是判断这个数组中是否至少还有一个数组(至少还有一维没有展平)</li>
<li><code>Array.isArray</code> 判断是否是一个数组</li>
<li>核心方法是 <code>concat</code> ,这个方法会抹平二维数组(<code>[].concat(1,[2]) = [1,2]</code>), 所以只需要递归/循环就行</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (arr.some(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">    arr = [].concat(...arr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[].concat(1,[2]) = [1,2]</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p>或者不使用 concat 函数直接抹平，而是利用 reduce 逐个拼接数组中的元素，如果遇到数组类型就递归一次直到深度为 0</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) <span class="keyword">return</span> arr;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre, curr, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pre.concat(flatten(curr));</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写-reduce"><a href="#手写-reduce" class="headerlink" title="手写 reduce"></a>手写 reduce</h2><p>reduce 实际上是一个循环，依次把之前的数据和初始值（或第一次）一起调用回调<br>考虑到初始值的情况，如果有初始值就从初始值开始，并且从数组第二项开始调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myReduce</span>(<span class="params">callback, init</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(<span class="built_in">this</span>)) <span class="keyword">return</span>; <span class="comment">//要求是数组</span></span><br><span class="line">  <span class="keyword">const</span> arr = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> total = init || arr[<span class="number">0</span>]; <span class="comment">//如果有初始值就取初始值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = init ? <span class="number">0</span> : <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">//有初始值就从i=1开始，即从第二项开始</span></span><br><span class="line">    total = callback(total, arr[i], i, arr); <span class="comment">//调用callback，每次的total都是上次的返回值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h2><h3 id="基本递归"><a href="#基本递归" class="headerlink" title="基本递归"></a>基本递归</h3><p>最基本的递归很简单：<br>原理就是先创建一个新对象，然后依次把旧对象的值赋值过去；如果这个值是一个对象，就递归一次，否则就直接复制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newObj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    newObj[key] = clone(obj[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加数组判断"><a href="#添加数组判断" class="headerlink" title="添加数组判断"></a>添加数组判断</h3><p>但是要考虑到数组，就得稍微改进一下：<br>只需要添加类型判断，不同的初始化即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span> target;</span><br><span class="line">  <span class="keyword">let</span> newTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">    newTarget[key] = clone(target[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newTarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="避免循环调用"><a href="#避免循环调用" class="headerlink" title="避免循环调用"></a>避免循环调用</h3><p>当对象的属性间接或直接的引用了自身，就会形成循环引用。上面的方法处理一个循环引用会导致栈溢出。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj.obj = obj;</span><br></pre></td></tr></table></figure>

<p>这种情况下，访问 <code>obj.obj</code> 依旧是一个 obj 类型，无论如何都不会退出递归，会形成死循环。<br>解决的方法是设定一个存储空间 <code>Map</code>，每次 <code>clone</code> 都向 <code>Map</code> 中添加，并且每次递归都先检查是否有克隆过的对象，如果有就直接返回<br>范例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span> target;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="comment">//如果有这个对象就返回一个空对象或数组，阻止循环调用</span></span><br><span class="line">  <span class="comment">//正常情况下都没有，只有重复引用时target和newTarget都是一样的对象</span></span><br><span class="line">  <span class="keyword">if</span> (map.has(target)) <span class="keyword">return</span> map.get(target);</span><br><span class="line"></span><br><span class="line">  map.set(target, newTarget); <span class="comment">//没有对象就创建一个索引，键为当前值，值为空</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">    newTarget[key] = clone(target[key], map); <span class="comment">//把当前的map传下去</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newTarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下更进阶的可以参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903929705136141">https://juejin.cn/post/6844903929705136141</a></p>
<h2 id="手写深比较"><a href="#手写深比较" class="headerlink" title="手写深比较"></a>手写深比较</h2><p>深比较即主要针对对象的比较，不能直接通过<code>===</code>判断。思路就是取出两个对象的键，分别遍历比较每个键对应的值是否相等；然后再通过递归的形式比较值是对象类型的键。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEqual</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> x === <span class="string">&quot;object&quot;</span> &amp;&amp;</span><br><span class="line">    x !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> y === <span class="string">&quot;object&quot;</span> &amp;&amp;</span><br><span class="line">    y !== <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">const</span> keysX = <span class="built_in">Object</span>.keys(x);</span><br><span class="line">    <span class="keyword">const</span> keysY = <span class="built_in">Object</span>.keys(y);</span><br><span class="line">    <span class="keyword">if</span> (keysX.length !== keysY.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> keysX) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isEqual(x[key], y[key])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外一种写法，思路上有点像比较两棵树；但是由于对象的键可能大于 2，因此写出来更像回溯：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isObj = <span class="function">(<span class="params">obj</span>) =&gt;</span> <span class="keyword">typeof</span> obj === <span class="string">&quot;object&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEqual</span>(<span class="params">obj1, obj2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObj(obj1) &amp;&amp; !isObj(obj2)) <span class="keyword">return</span> obj1 === obj2;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((isObj(obj1) &amp;&amp; !isObj(obj2)) || (!isObj(obj1) &amp;&amp; isObj(obj2)))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj1) &#123;</span><br><span class="line">    flag = flag &amp;&amp; isEqual(obj1[key], obj2[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写防抖-节流"><a href="#手写防抖-节流" class="headerlink" title="手写防抖/节流"></a>手写防抖/节流</h2><ul>
<li>防抖</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>节流</li>
</ul>
<p>时间戳实现：在外部函数留一个闭包表示上次调用时间，函数内部每次请求当前时间，如果时间戳小于延迟就不执行；反之执行之后修改上次时间为当前</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="keyword">if</span> (now - pre &lt; delay) <span class="keyword">return</span>;</span><br><span class="line">    fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    pre = now;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>setTimeout</code>实现：几乎和防抖一样，只是如果 timeout 存在就不进入；并且执行之后把 timeout 设为 null，相当于 timeout 是一个“大门”</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout) <span class="keyword">return</span>;</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      timeout = <span class="literal">null</span>;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写柯里化"><a href="#手写柯里化" class="headerlink" title="手写柯里化"></a>手写柯里化</h2><p>具体解析见上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length === func.length) &#123;</span><br><span class="line">      <span class="comment">//这次调用传入的参数个数和函数总参数个数比较，如果等于说明是完整调用，直接返回；</span></span><br><span class="line">      <span class="comment">//如果小于，比如add(1)(2,3)，原本本来是三个参数，现在只传入一个，因此进入柯里化步骤</span></span><br><span class="line">      <span class="keyword">return</span> func(args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//这里把柯里化的前部分和后部分拆开，这个函数的参数是后部分的</span></span><br><span class="line">        <span class="comment">//即，add(1)(2,3) 中，...agrs是1，...args2是2和3，然后把这两组参数合并调用；</span></span><br><span class="line">        <span class="comment">//如果还有n组参数会放在下一次递归</span></span><br><span class="line">        <span class="keyword">return</span> curried(...args, ...args2);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写-Promise"><a href="#手写-Promise" class="headerlink" title="手写 Promise"></a>手写 Promise</h2><h3 id="基础-Promise"><a href="#基础-Promise" class="headerlink" title="基础 Promise"></a>基础 Promise</h3><p>原理:<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903625769091079">具体原理可以看这里</a></p>
<ol>
<li>首先构造一个类, promise 对象是需要传一个函数的，这里直接作为 constructor 的参数；在 constructor 中做如下配置：</li>
</ol>
<ul>
<li>设置状态 state，有三种情况：<code>pending</code>、<code>fulfilled</code>、<code>rejected</code></li>
<li>设置 value 用于维持一个值，在后面 resolve 到 then 中，then 也需要这个 value</li>
<li>设置 <code>resolve</code> 函数，原理就是：<ol>
<li>调用时更改 state 状态</li>
<li>存储调用时传入的值</li>
</ol>
</li>
<li>设置 <code>rejected</code>，原理是：<ol>
<li>更改 <code>state</code> 为 <code>rejected</code></li>
<li>设置错误原因</li>
</ol>
</li>
<li>设置完上面之后通过传入的 <code>executor</code> 传入 <code>resolve</code> 和 <code>rejected</code>；在外部使用 <code>resolve</code> 和 <code>rejected</code> 都会直接触发类中的这两个函数</li>
</ul>
<ol start="2">
<li>设计 then；then 实际上是类的一个方法，参数为 <code>onFulfilled</code> 和 <code>onRejected</code>，分别表示成功回调和失败回调</li>
</ol>
<ul>
<li>调用时先判断 state；如果为 fulfilled，就调用外部自定义的 <code>onFulfilled</code> 函数，参数为 <code>this.value</code>，也就相当于我们常写的”res”；如果为 <code>rejected</code> 同理</li>
</ul>
<ol start="3">
<li>添加定时器异步</li>
</ol>
<ul>
<li>首先在构造函数添加成功存放的数组和失败存放的数组，这两个存的分别是后续外部定义的 <code>onFulfilled</code> 函数和 <code>onRejected</code> 函数，在“完成的时刻”再从数组中取出调用他们。使用数组的原因是多个 <code>then</code>（不是 <code>then</code> 链，还没实现）</li>
<li>在 <code>resolve</code> 和 <code>rejected</code> 函数中添加调用上面两个数组中所有函数；这步最为关键，也就是说必须直到状态改变，后续的 <code>then</code> 中函数才会被调用，是一种异步效果</li>
<li>在 <code>then</code> 中设置 <code>pending</code> 状态的操作：如果在 <code>pending</code> 状态说明 <code>executor</code> 函数中有延时执行的任务，这时候就把所有的回调放在成功/失败数组中，等待完成后执行</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化state为等待态</span></span><br><span class="line">    <span class="built_in">this</span>.state = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line">    <span class="comment">// 成功的值</span></span><br><span class="line">    <span class="built_in">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 失败的原因</span></span><br><span class="line">    <span class="built_in">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 成功存放的数组，主要是应对异步任务</span></span><br><span class="line">    <span class="built_in">this</span>.onResolvedCallbacks = [];</span><br><span class="line">    <span class="comment">// 失败存放的数组</span></span><br><span class="line">    <span class="built_in">this</span>.onRejectedCallbacks = [];</span><br><span class="line">    <span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// state改变,resolve调用就会失败</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// resolve调用后，state转化为成功态</span></span><br><span class="line">        <span class="built_in">this</span>.state = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line">        <span class="comment">// 储存成功的值</span></span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="comment">// 一旦resolve执行，调用成功数组的函数</span></span><br><span class="line">        <span class="built_in">this</span>.onResolvedCallbacks.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// state改变,reject调用就会失败</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// reject调用后，state转化为失败态</span></span><br><span class="line">        <span class="built_in">this</span>.state = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">        <span class="comment">// 储存失败的原因</span></span><br><span class="line">        <span class="built_in">this</span>.reason = reason;</span><br><span class="line">        <span class="comment">// 一旦reject执行，调用失败数组的函数</span></span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 如果executor执行报错，直接执行reject</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 状态为fulfilled，执行onFulfilled，传入成功的值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line">      onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态为rejected，执行onRejected，传入失败的原因</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">      onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当状态state为pending时，说明任务是个异步，需要把任务放在数组中，等到reslove/reject执行再执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// onFulfilled传入到成功数组</span></span><br><span class="line">      <span class="built_in">this</span>.onResolvedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// onRejected传入到失败数组</span></span><br><span class="line">      <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="then-穿透"><a href="#then-穿透" class="headerlink" title="then 穿透"></a>then 穿透</h3><p><code>Promise</code>还有一个很重要的效果就是 then 的穿透，即 then 返回一个<code>Promise</code>给下一个 then 继续链式调用。<br>这个过程的实现主要有以下几点：</p>
<ul>
<li>then 可以没有参数，如果没有参数，<code>onFulfilled</code>默认向下继续传递，<code>onRejected</code>向外冒泡错误</li>
<li>then 需要返回一个<code>Promise</code>，而不是上面的只是进行<code>onFulfilled</code>操作。这个<code>Promise</code>如果<code>resolve</code>就相当于向下穿透到了下一个 then，而其中任何一个<code>reject</code>都会被直接冒泡到最外层。</li>
<li>这个<code>Promise</code>需要判断 then 的返回是不是一个<code>Promise</code>；也就是说，由于 then 可以显式返回一个<code>新的Promise</code>，源码中<code>原本要返回的Promise</code>要和<code>新的自定义Promise</code>同步状态：<code>新的自定义Promise</code>如果<code>resolve</code>，原本的也要<code>resolve</code>，反之亦然；</li>
<li>上述的同步过程主要通过捕获 then 实现，也就是说根据<code>新Promise</code>中 then 的调用判断是哪种情况，然后在<code>原本的Promise</code>中进行<code>resolve</code>或<code>reject</code>。</li>
<li>最后，因为上面说过的 Promise 延迟绑定回调的特性，每个修改状态等操作都应该是异步的，保证 then 先绑定完整再进行操作。本来 then 应当是微任务实现，原教程使用了 setTimeout 宏任务代替，但<code>queueMicrotask</code>是更好的选择。（微任务：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide%EF%BC%89">https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide）</a></li>
</ul>
<p>下面是具体实现，详细解释在注释中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&quot;PENDING&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&quot;FULFILLED&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&quot;REJECTED&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.status = PENDING;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="built_in">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="built_in">this</span>.onResolvedCallback = [];</span><br><span class="line">    <span class="built_in">this</span>.onRejectedCallback = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">      <span class="built_in">this</span>.status = FULFILLED;</span><br><span class="line">      <span class="built_in">this</span>.value = value;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.onResolvedCallback.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn());</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">      <span class="built_in">this</span>.status = REJECTED;</span><br><span class="line">      <span class="built_in">this</span>.reason = reason;</span><br><span class="line">      <span class="built_in">this</span>.onRejectedCallback.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn());</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//判断参数是不是函数，如果不是就直接resolve或者直接reject</span></span><br><span class="line">    onFulfilled =</span><br><span class="line">      <span class="keyword">typeof</span> onFulfilled === <span class="string">&quot;function&quot;</span> ? onFulfilled : <span class="function">(<span class="params">val</span>) =&gt;</span> val;</span><br><span class="line">    onRejected =</span><br><span class="line">      <span class="keyword">typeof</span> onRejected === <span class="string">&quot;function&quot;</span></span><br><span class="line">        ? onRejected</span><br><span class="line">        : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个Promise</span></span><br><span class="line">    <span class="keyword">const</span> thenPromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line">        <span class="comment">//创建一个微任务</span></span><br><span class="line">        queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//先执行一次onFulfilled，取得当前then的调用结果</span></span><br><span class="line">            <span class="keyword">let</span> returnValueFromThen = onFulfilled(<span class="built_in">this</span>.value); <span class="comment">//这个值是当前then的返回值，有可能是promise（then返回一个promise供下个then使用）</span></span><br><span class="line">            <span class="comment">//下面这个函数可以看作是一系列判断和同步后进行具体的resolve和reject操作</span></span><br><span class="line">            resolvePromise(thenPromise, returnValueFromThen, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">        queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> returnValueFromThen = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">            resolvePromise(thenPromise, returnValueFromThen, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="built_in">this</span>.onResolvedCallback.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> returnValueFromThen = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">              resolvePromise(thenPromise, returnValueFromThen, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">              reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallback.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> returnValueFromThen = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">              resolvePromise(thenPromise, returnValueFromThen, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">              reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> thenPromise;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolvePromise = <span class="function">(<span class="params">thenPromise, returnValueFromThen, resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (returnValueFromThen === thenPromise) &#123;</span><br><span class="line">    <span class="comment">/*不能return自己，即不能</span></span><br><span class="line"><span class="comment">      const p1 = promise.then(value =&gt; &#123;</span></span><br><span class="line"><span class="comment">        return p1</span></span><br><span class="line"><span class="comment">      &#125;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> reject(</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Chaining cycle detected for promise #&lt;Promise&gt;&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**理论上这时直接resolve(returnValueFromThen)就可以了，但是还需要考虑then返回一个Promise的情况，要确保这个新Promise状态和现在的同步</span></span><br><span class="line"><span class="comment">    *也就是说，如果这个新Promise失败，那么当前这个Promise应该直接reject，反之亦然</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">let</span> settledCalled; <span class="comment">//是否调用过resolve或reject，如果有后续都无视</span></span><br><span class="line">  <span class="keyword">if</span> (returnValueFromThen <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">    <span class="comment">//如果then的返回值是个Promise</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> thenFromThen = returnValueFromThen.then; <span class="comment">//这里是then返回的那个Promise中的then，后面叫做套娃then（multiThen）</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> thenFromThen === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">/**正常调用这个套娃then（&quot;multiThen&quot;），绑定原先的Promise上下文（也就是then返回的那个Promise）</span></span><br><span class="line"><span class="comment">          *根据这个套娃then的结果决定当前then的结果</span></span><br><span class="line"><span class="comment">          *如果套娃then resolve，当前就resolve，反之亦然</span></span><br><span class="line"><span class="comment">          *因此给这个套娃then传两个回调，触发哪个就执行哪个</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        thenFromThen.call(</span><br><span class="line">          returnValueFromThen,</span><br><span class="line">          <span class="function">(<span class="params">multiThenFulfilled</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//套娃then resolve的回调，如果套娃then resolve，当前的then也就resolve</span></span><br><span class="line">            <span class="keyword">if</span> (settledCalled) <span class="keyword">return</span>;</span><br><span class="line">            settledCalled = <span class="literal">true</span>; <span class="comment">//如果之前被调用过就返回，否则就执行并设置为已调用过</span></span><br><span class="line">            resolve(multiThenFulfilled); <span class="comment">//这个地方更好的方法是递归调用，因为套娃then 还可能再返回一个promise；但是不考虑那么复杂的情况，直接resolve是可以的</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function">(<span class="params">multiThenRejected</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//如果套娃then被rejected，当前then也rejected</span></span><br><span class="line">            <span class="keyword">if</span> (settledCalled) <span class="keyword">return</span>;</span><br><span class="line">            settledCalled = <span class="literal">true</span>;</span><br><span class="line">            reject(multiThenRejected);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果then的Promise返回一个普通值，就直接resolve</span></span><br><span class="line">        resolve(returnValueFromThen);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="comment">//这个trycatch是捕获访问套娃then中出现的任何错误的，会向上冒泡</span></span><br><span class="line">      <span class="keyword">if</span> (settledCalled) <span class="keyword">return</span>;</span><br><span class="line">      settledCalled = <span class="literal">true</span>;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果then的返回值并不是一个Promise就直接resolve</span></span><br><span class="line">    resolve(returnValueFromThen);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Promise-Api"><a href="#Promise-Api" class="headerlink" title="Promise Api"></a>Promise Api</h3><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a><code>Promise.all</code></h4><p>主要逻辑是把一个数组中的 promise 遍历依次执行<code>.then</code>，并把返回值（resolve 值）按顺序放入数组中，等待全部完成后再统一<code>resolve</code>。<br>因此内部实际上返回了一个 Promise，当全部完成时进行 resolve 操作，如果有一个发生 reject 则全部 reject。</p>
<blockquote>
<p>注意执行多个异步任务是并行执行的，并行执行完成后会一起 resolve，消耗时间是最长的那个任务。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.all = <span class="function"><span class="keyword">function</span> (<span class="params">values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(values)) &#123;</span><br><span class="line">    <span class="comment">//首先要求参数必须可迭代</span></span><br><span class="line">    <span class="keyword">const</span> type = <span class="keyword">typeof</span> values;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`TypeError: <span class="subst">$&#123;type&#125;</span> <span class="subst">$&#123;values&#125;</span> is not iterable`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> resultArr = [];</span><br><span class="line">    <span class="keyword">let</span> orderIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> processResultByKey = <span class="function">(<span class="params">result, index</span>) =&gt;</span> &#123;</span><br><span class="line">      resultArr[index] = result; <span class="comment">//按照顺序把刚刚的resolve值放到数组</span></span><br><span class="line">      <span class="keyword">if</span> (++orderIndex === values.length) &#123;</span><br><span class="line">        <span class="comment">//如果满了就全部resolve掉</span></span><br><span class="line">        resolve(resultArr);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      <span class="comment">//遍历参数，对每个参数执行then；</span></span><br><span class="line">      <span class="comment">// 由于for循环是同步的，因此所有任务都是同步启动、并行执行的</span></span><br><span class="line">      <span class="keyword">let</span> value = values[i];</span><br><span class="line">      <span class="keyword">if</span> (value &amp;&amp; <span class="keyword">typeof</span> value.then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        value.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">          processResultByKey(res, i);</span><br><span class="line">        &#125;, reject); <span class="comment">//如果有一个触发reject，相当于触发了整个的reject，直接退出</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果参数有不是Promise的，不用then直接传入</span></span><br><span class="line">        processResultByKey(value, i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不用递归也可以，在循环内部新建一个 Promise 并执行即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pAll</span>(<span class="params">_promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Iterable =&gt; Array</span></span><br><span class="line">    <span class="keyword">const</span> promises = <span class="built_in">Array</span>.from(_promises);</span><br><span class="line">    <span class="comment">// 结果用一个数组维护</span></span><br><span class="line">    <span class="keyword">const</span> r = [];</span><br><span class="line">    <span class="keyword">const</span> len = promises.length;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="comment">// Promise.resolve 确保把所有数据都转化为 Promise</span></span><br><span class="line">      <span class="built_in">Promise</span>.resolve(promises[i])</span><br><span class="line">        .then(<span class="function">(<span class="params">o</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 因为 promise 是异步的，保持数组一一对应</span></span><br><span class="line">          r[i] = o;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果数组中所有 promise 都完成，则返回结果数组</span></span><br><span class="line">          <span class="keyword">if</span> (++count === len) &#123;</span><br><span class="line">            resolve(r);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 当发生异常时，直接 reject</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> reject(e));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键在于“依次执行”，可以看到上面的循环中，每个小 Promise 都在 then 之后把结果放入数组，待数组放满后才 resolve。</p>
<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a><code>Promise.race</code></h4><p>如果让 Promise 在 then 之后立刻就进行 resolve，相当于让每个小 Promise 中最快的返回，就可以实现<code>Promise.race</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.race = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> val = promises[i];</span><br><span class="line">      <span class="keyword">if</span> (val &amp;&amp; <span class="keyword">typeof</span> val.then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">//谁先执行完谁直接resolve</span></span><br><span class="line">        val.then(resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 普通值</span></span><br><span class="line">        resolve(val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Promise-map限制并发"><a href="#Promise-map限制并发" class="headerlink" title="Promise.map限制并发"></a><code>Promise.map</code>限制并发</h4><p>通过传入 limit 参数限制最多同时并发的 promise 数量，每一个任务完成之后及时替换。</p>
<p>思路：</p>
<ol>
<li>把执行任务和并发启动分开，通过 for 循环的形式一次同时启动 limit 个任务，每个任务自行递归选择下一个</li>
<li>和 promise.all 一样的顺序判断，通过设定 index 使得输出按顺序，并通过设定 count 判断是否全部运行完成。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyPromiseMap = <span class="function">(<span class="params">promises, limit</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> results = [];</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;<span class="comment">// 正在执行的序号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.min(limit, promises.length); i++) &#123; </span><br><span class="line">        <span class="comment">// 同时启动limit个任务</span></span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> currIndex = index;<span class="comment">// 存一下当前index</span></span><br><span class="line">      index++;<span class="comment">//每次递归都先自增</span></span><br><span class="line">      <span class="keyword">if</span> (promises[currIndex]) &#123;<span class="comment">// 因为有可能一组并发中最后几个刚好超出，因此要判断一下</span></span><br><span class="line">        promises[currIndex].then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">          results[currIndex] = res;</span><br><span class="line">          <span class="keyword">if</span> (++count === promises.length) resolve(results);</span><br><span class="line">          <span class="keyword">else</span> next();<span class="comment">// 每个任务执行完后，单独递归调用下一个</span></span><br><span class="line">        &#125;, reject);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="手写-call-apply-和-bind"><a href="#手写-call-apply-和-bind" class="headerlink" title="手写 call apply 和 bind"></a>手写 call apply 和 bind</h2><p>call 和 apply 的实现思路类似，都是作用在函数上，参数是要设置的上下文和调用时传入的参数。</p>
<p>先来说 call：<br>call 方法应该在<code>Function.prototype</code>上，并且 call 内部的 this 应该是点号前面的函数。因此可以让这个函数在传入参数（context）下调用，再返回结果即可。<br>关键在于，怎么实现“函数在 context 下调用”：可以给这个 context 添加一个当前函数属性（即 this）并调用，然后删去并返回返回值即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mycall = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) <span class="keyword">return</span>; <span class="comment">//this就是call前面的函数，比如fn.call(...)的this就是fn</span></span><br><span class="line">  context = context || <span class="built_in">window</span>; <span class="comment">//如果没有指定参数就是window</span></span><br><span class="line">  context.fn = <span class="built_in">this</span>; <span class="comment">//给context添加一个属性，这个属性就是当前的函数</span></span><br><span class="line">  <span class="keyword">let</span> res = context.fn(...args); <span class="comment">//在context上调用函数</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn; <span class="comment">//删去这个属性</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>apply 和 call 只差在参数传递方式，其实改一点就好了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myapply = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是这两个方法都有漏洞：如果 fn 和 context 上某个属性同名，就会删去原先的方法。<br>因此可以把 fn 改为 Symbol，保证不会影响旧属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mycall = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">const</span> fnSymbol = <span class="built_in">Symbol</span>();</span><br><span class="line">  context[fnSymbol] = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> res = context[fnSymbol](...args);</span><br><span class="line">  <span class="keyword">delete</span> context[fnSymbol];</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>对于 bind，其实主要是返回值不同，bind 会返回绑定好的函数，因此把调用封装在要返回的函数内部即可：<br>最简单的 bind：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 箭头函数保证返回的this是外层的</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...rest</span>) =&gt;</span> <span class="built_in">this</span>.apply(context, [...args, ...rest]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然还要亿些细节，详见<a target="_blank" rel="noopener" href="https://github.com/sisterAn/JavaScript-Algorithms/issues/81">https://github.com/sisterAn/JavaScript-Algorithms/issues/81</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mybind = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//这里是考虑到返回的函数有可能作为构造函数的情况</span></span><br><span class="line">    <span class="comment">//两个this不一样；作为调用函数的this现在是fn；现在的this是fn中的this，即如果返回的函数用作构造函数，这个this应该指向实例</span></span><br><span class="line">    <span class="comment">//因此需要判定一下fn内部的this是不是返回函数的实例，如果是的话就不改变指向</span></span><br><span class="line">    <span class="keyword">return</span> fn.apply(</span><br><span class="line">      <span class="built_in">this</span> <span class="keyword">instanceof</span> Fn ? <span class="built_in">this</span> : context,</span><br><span class="line">      args.concat(<span class="built_in">arguments</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  Fn.prototype = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">  <span class="keyword">return</span> Fn;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>bind 多次调用会无视掉后面的绑定，多次调用只会以第一个为准；<br>为此可以单独实现一个<code>softBind</code>，多次调用以最后一个为准。其原理是<code>!this || this === window ? context : this</code>，即如果 this 不为空就把新的 context 绑定，相当于覆盖了前面的绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.softBind = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">const</span> bound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(!<span class="built_in">this</span> || <span class="built_in">this</span> === <span class="built_in">window</span> ? context : <span class="built_in">this</span>, [</span><br><span class="line">      ...arguments,</span><br><span class="line">      ...args,</span><br><span class="line">    ]);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> bound;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="手写-instanceof"><a href="#手写-instanceof" class="headerlink" title="手写 instanceof"></a>手写 instanceof</h2><p>原理很简单，参数传入父子，获取父对象（函数）的<code>prototype</code>和子对象的<code>__proto__</code>比较，如果没有就沿着子对象的<code>__proto__</code>循环向上找，直到为 null 或找到为止</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Instanceof</span>(<span class="params">parent, child</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cp = <span class="built_in">Object</span>.getPrototypeOf(child);</span><br><span class="line">  <span class="keyword">const</span> pp = parent.prototype;</span><br><span class="line">  <span class="keyword">while</span> (cp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pp === cp) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    cp = <span class="built_in">Object</span>.getPrototypeOf(cp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个问题：<br>不管是函数的<code>prototype</code>还是对象的<code>__proto__</code>，实际上都是对象，对象之间为什么能用<code>===</code>判断相等？<br>原因是这样的：因为实际上在构造的时候，有一步就是让构造的对象的<code>__proto__</code>等于函数的<code>prototype</code>。比如这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">  fn.apply(obj, args);</span><br><span class="line">  obj.__proto__ = fn.prototype;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就使得这两个值指向<strong>同一个索引</strong>；即在后续的使用中，这两个值始终是同一个对象（函数的 prototype）的索引。因为索引相同，因此可以使用等号判断。</p>
<h2 id="手写-sleep-delay"><a href="#手写-sleep-delay" class="headerlink" title="手写 sleep/delay"></a>手写 sleep/delay</h2><p>sleep 函数使后面代码阻塞：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">delay</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve,delay)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">testFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">1000</span>)</span><br><span class="line">  <span class="comment">//后续代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">sleep(<span class="number">1000</span>).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//后续代码</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>delay 使被传入的部分延迟执行，并阻塞后面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">func, second, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(func(...args));</span><br><span class="line">    &#125;, seconds);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> delay(<span class="function">(<span class="params">name</span>) =&gt;</span> <span class="string">`hello,<span class="subst">$&#123;name&#125;</span>`</span>, <span class="number">1000</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line">  res; <span class="comment">// 1秒后返回 hello,jack</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写-compose-函数"><a href="#手写-compose-函数" class="headerlink" title="手写 compose 函数"></a>手写 compose 函数</h2><p>compose 函数实现的效果类似数学中的多次函数。比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(x) = x + 10</span><br><span class="line">g(x) = x * 5</span><br><span class="line">f(g(x)) = x*5 + 10</span><br></pre></td></tr></table></figure>

<p>要实现的 compose 也要满足这个效果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fx = <span class="function">(<span class="params">x</span>) =&gt;</span> x + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> gx = <span class="function">(<span class="params">x</span>) =&gt;</span> x * <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> fgx = compose(fx, gx);</span><br><span class="line">fgx(<span class="number">5</span>); <span class="comment">// 5 * 5 + 10 = 35</span></span><br></pre></td></tr></table></figure>

<p>思路如下：</p>
<p>compose 为了符合数学上的定义，应当是从内向外计算的。因此应该按照其传入的参数从右向左计算。最简单的实现是利用 reduce：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fns.reduce(<span class="function">(<span class="params">f, g</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> f(g(...args));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>reduce 内部每次返回的都是一个函数。当 reduce 叠加时，相当于不断叠加<strong>内部</strong>包裹的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次</span></span><br><span class="line">total = <span class="function">(<span class="params">...args</span>) =&gt;</span> f(g(...args))</span><br><span class="line"><span class="comment">// 后续</span></span><br><span class="line">f = <span class="function">(<span class="params">...args</span>) =&gt;</span> f(g(...args))</span><br><span class="line">g = h(x)</span><br><span class="line">total = <span class="function">(<span class="params">...args</span>) =&gt;</span> f(h(...args)) = f(g(h(..args)))</span><br><span class="line"><span class="comment">// 依次类推</span></span><br></pre></td></tr></table></figure>

<h2 id="手写洗牌函数-shuffle"><a href="#手写洗牌函数-shuffle" class="headerlink" title="手写洗牌函数 shuffle"></a>手写洗牌函数 shuffle</h2><p>洗牌函数的关键是利用随机数的概率，让数组中的每个数随机排列。<br>让每个数随机排列的方法有很多，比如利用<code>sort</code>，或者让随机两个数两两交换</p>
<blockquote>
<p>有一种洗牌算法如下：<br>第 N 项数字与前 N 项数字随机选一相互交换<br>第 N-1 项数字与前 N-1 项数字随机选一相互交换<br>…<br>第 2 项数字与前 2 项数字随机选一相互交换</p>
</blockquote>
<p>利用这种算法，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shuffle = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * i + <span class="number">1</span>);</span><br><span class="line">    [arr[tmp], arr[i]] = [arr[i], arr[tmp]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(arr);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还有一种更简单的，直接利用 sort 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shuffle = <span class="function">(<span class="params">arr</span>) =&gt;</span> arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure>

<h2 id="手写对象扁平化和逆扁平化"><a href="#手写对象扁平化和逆扁平化" class="headerlink" title="手写对象扁平化和逆扁平化"></a>手写对象扁平化和逆扁平化</h2><h3 id="扁平化"><a href="#扁平化" class="headerlink" title="扁平化"></a>扁平化</h3><p>要求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123;</span><br><span class="line">    <span class="attr">b</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">d</span>: &#123; <span class="attr">e</span>: <span class="number">5</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">b</span>: [<span class="number">1</span>, <span class="number">3</span>, &#123; <span class="attr">a</span>: <span class="number">2</span>, <span class="attr">b</span>: <span class="number">3</span> &#125;],</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//flatten(obj) 结果返回如下</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//  &#x27;a.b&#x27;: 1,</span></span><br><span class="line"><span class="comment">//  &#x27;a.c&#x27;: 2,</span></span><br><span class="line"><span class="comment">//  &#x27;a.d.e&#x27;: 5,</span></span><br><span class="line"><span class="comment">//  &#x27;b[0]&#x27;: 1,</span></span><br><span class="line"><span class="comment">//  &#x27;b[1]&#x27;: 3,</span></span><br><span class="line"><span class="comment">//  &#x27;b[2].a&#x27;: 2,</span></span><br><span class="line"><span class="comment">//  &#x27;b[2].b&#x27;: 3</span></span><br><span class="line"><span class="comment">//   c: 3</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>是一个不需要任何剪枝的回溯问题。从根对象向下遍历到值为非对象为止，把沿途的路径记录下来，插入到新对象中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123;</span><br><span class="line">    <span class="attr">b</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">d</span>: &#123; <span class="attr">e</span>: <span class="number">5</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">b</span>: [<span class="number">1</span>, <span class="number">3</span>, &#123; <span class="attr">a</span>: <span class="number">2</span>, <span class="attr">b</span>: <span class="number">3</span> &#125;],</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isObject = <span class="function">(<span class="params">val</span>) =&gt;</span> <span class="keyword">typeof</span> val === <span class="string">&quot;object&quot;</span> &amp;&amp; val !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(obj)) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">cur, prefix</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isObject(cur)) &#123;</span><br><span class="line">      <span class="keyword">const</span> key = prefix.join(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">      res[key] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> cur) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(cur)) prefix.push(<span class="string">`[<span class="subst">$&#123;key&#125;</span>]`</span>);</span><br><span class="line">      <span class="keyword">else</span> prefix.push(key);</span><br><span class="line">      dfs(cur[key], prefix);</span><br><span class="line">      prefix.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  dfs(obj, []);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="逆扁平化"><a href="#逆扁平化" class="headerlink" title="逆扁平化"></a>逆扁平化</h3><blockquote>
<p>写一个函数，将 entry 格式转化成 output 的格式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entry = &#123;</span><br><span class="line">  <span class="string">&quot;a.b.c.dd&quot;</span>: <span class="string">&quot;value&quot;</span>,</span><br><span class="line">  <span class="string">&quot;a.d.xx&quot;</span>: <span class="string">&quot;val&quot;</span>,</span><br><span class="line">  <span class="string">&quot;a.e&quot;</span>: <span class="string">&quot;v&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 要求转换成如下对象</span></span><br><span class="line"><span class="keyword">var</span> output = &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123;</span><br><span class="line">    <span class="attr">b</span>: &#123;</span><br><span class="line">      <span class="attr">c</span>: &#123;</span><br><span class="line">        <span class="attr">dd</span>: <span class="string">&quot;value&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">d</span>: &#123;</span><br><span class="line">      <span class="attr">xx</span>: <span class="string">&quot;val&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">e</span>: <span class="string">&quot;v&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>实现思路<br>遍历对象，如果键名称含有 <code>.</code>， 将最后一个子键拿出来，构成对象，如 <code>&#123;&#39;a.b.c.dd&#39;: &#39;abcdd&#39;&#125;</code> 变为 <code>&#123;&#39;a.b.c&#39;: &#123; dd: &#39;abcdd&#39; &#125;&#125;</code> , 如果变换后的新父键名中仍还有点，递归进行以上操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nested</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).map(<span class="function">(<span class="params">k</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//一次传递一个键，这一组键拆分完后再处理第二组</span></span><br><span class="line">    getNested(k);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getNested</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> idx = key.lastIndexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> value = obj[key];</span><br><span class="line">    <span class="keyword">if</span> (idx !== -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> obj[key]; <span class="comment">//删掉原对象的这个键</span></span><br><span class="line">      <span class="comment">//取最后一个点前面和后面的部分，分别作为主键和副键（要被放入内部的键）</span></span><br><span class="line">      <span class="keyword">const</span> mainKey = key.substring(<span class="number">0</span>, idx);</span><br><span class="line">      <span class="keyword">const</span> subKey = key.substr(idx + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (!obj[mainKey]) &#123;</span><br><span class="line">        <span class="comment">//如果原对象没有主键，创建一个新键，值是一个新对象</span></span><br><span class="line">        obj[mainKey] = &#123; [subKey]: value &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//这种情况是源对象已经有一个同名的键，把新值直接放入原先有的键下面</span></span><br><span class="line">        obj[mainKey][subKey] = value;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (mainKey.includes(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        getNested(mainKey);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Promise-异步-相关题目"><a href="#Promise-异步-相关题目" class="headerlink" title="Promise/异步 相关题目"></a>Promise/异步 相关题目</h1><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;timer1&quot;</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;timer2&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;start&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;start&#x27;</span><br><span class="line">&#x27;timer1&#x27;</span><br><span class="line">&#x27;promise&#x27;</span><br><span class="line">&#x27;timer2&#x27;</span><br></pre></td></tr></table></figure>

<p>注意<code>promise</code>在<code>timer2</code>之前，因为<code>Promise.resolve().then</code>内的是微任务，和<code>timer2</code>的<code>setTimeout</code>宏任务相比要更优先。<br>即会先执行完第一个<code>setTimeout</code>内的代码，才会执行第二个，并且第一个内的代码执行期间，第二个<code>setTimeout</code>仍然是异步宏任务，并不会和第一个一起同时把回调放入宏任务队列。</p>
<h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>注意<code>reject</code>会直接跳到 <code>catch</code>，忽略过程中的 <code>then</code>；而 <code>catch</code> 如果有返回值，则还会递交给下一个 <code>then</code>，并不会彻底结束。</p>
<h2 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="built_in">console</span>.err);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</span><br></pre></td></tr></table></figure>

<p><code>Promise</code> 的 <code>then</code> 中不能返回他自己，否则会报错。这点在手写 promise 中也体现过，进入 <code>then</code> 之后需要有一个判断，如果返回值是自己就会报错。</p>
<h2 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>).then(<span class="number">2</span>).then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>)).then(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p><code>.then</code> 或者 <code>.catch</code> 的参数期望是函数，传入非函数则会发生值透传。<br>透传是会将 <code>resolve</code> 的结果透传到第一个能接受的 <code>then</code> 里边，而并不会理会其他 <code>then</code> 或 <code>catch</code> 中的参数。如果一直没有，就会直接返回一个 <code>Promise</code> 对象，中间都不会处理。<br>从手写 promise 中可以看到，如果参数不是函数，就变成一个直接返回参数值的函数<code>(val)=&gt;val</code>，然后在下面的新<code>Promise</code>中直接返回上一个<code>resolve</code>值（即<code>this.value</code>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//判断参数是不是函数</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&quot;function&quot;</span> ? onFulfilled : <span class="function">(<span class="params">val</span>) =&gt;</span> val;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">let</span> returnValueFromThen = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">  .finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;finally2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;我是finally2返回的值&quot;</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;finally2后面的then函数&quot;</span>, res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;1&#x27;</span><br><span class="line">&#x27;finally2&#x27;</span><br><span class="line">&#x27;finally&#x27;</span><br><span class="line">&#x27;finally2后面的then函数&#x27; &#x27;2&#x27;</span><br></pre></td></tr></table></figure>

<p><code>finally</code>的特点：</p>
<ul>
<li>任何情况下都会调用，不管<code>fulfilled</code>还是<code>rejected</code></li>
<li>回调不接受参数，因此不能收到任何内部的值，也没法知道<code>Promise</code>最终的状态是<code>resolved</code>还是<code>rejected</code></li>
<li>返回的默认会是一个上一次的<code>Promise</code>对象的返回值，如果抛出的是一个异常则返回异常的<code>Promise</code>对象，也就是说如果<code>finally</code>位于中间，则他的返回值不会对其他<code>then</code>或<code>catch</code>有任何影响，相当于原封不动的传递。</li>
<li><code>finally</code>依然是一个微任务，和<code>then</code>和<code>catch</code>一样，按照微任务顺序执行</li>
</ul>
<h2 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(x);</span><br><span class="line">      <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runReject</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="string">`Error: <span class="subst">$&#123;x&#125;</span>`</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;, <span class="number">1000</span> * x)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.all([runAsync(<span class="number">1</span>), runReject(<span class="number">4</span>), runAsync(<span class="number">3</span>), runReject(<span class="number">2</span>)])</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1s后输出</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">// 2s后输出</span><br><span class="line">2</span><br><span class="line">Error: 2</span><br><span class="line">// 4s后输出</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p><code>Promise.all</code>的执行原则：</p>
<ol>
<li>所有任务并行执行，最终输出事件以最长任务为准；每个任务内部的同步代码会独立并行执行。</li>
<li>如果有一个任务<code>reject</code>或者抛出错误，就会触发<code>Promise.all</code>后面的<code>catch</code>，这时整个<code>Promise.all</code>状态变为<code>rejected</code>，不会再触发<code>then</code>；但是并不代表所有任务都不再执行，任务<strong>仍会继续</strong>执行，但不会有有效的返回结果。像上面的例子中虽然 3 秒时已经<code>rejected</code>，但是最后一个任务还是会执行，输出自己内部的<code>4</code>，并且不会再触发<code>then</code>或<code>catch</code></li>
</ol>
<h2 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 success&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;async1 end&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;srcipt start&quot;</span>);</span><br><span class="line">async1().then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;srcipt end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;script start&#x27;</span><br><span class="line">&#x27;async1 start&#x27;</span><br><span class="line">&#x27;promise1&#x27;</span><br><span class="line">&#x27;script end&#x27;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>await</code>紧挨的内容如果是普通代码，相当于<code>new Promise</code>内部的，其后的代码相当于<code>.then</code>；如果是<code>Promise</code>对象，则会等待这个<code>Promise resolve</code>并阻塞后面代码，如果该 Promise 没有返回值，就会一直在<code>pending</code>状态，一直阻塞。</p>
</blockquote>
<p>在<code>async1</code>中<code>await</code>后面的<code>Promise</code>是没有返回值的，也就是它的状态始终是<code>pending</code>状态，因此相当于一直在 await，await，await 却始终没有响应…<br>所以在<code>await</code>之后的内容是不会执行的，也包括<code>async1</code>后面的 <code>.then</code>。</p>
<h2 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;async1 success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">    reject(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">async1().then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res));</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;async2&#x27;</span><br><span class="line">Uncaught (in promise) error</span><br></pre></td></tr></table></figure>

<p><code>await</code>之后的代码相当于被包裹在了一个<code>then</code>中，因此执行条件是<code>await</code>的<code>promise</code>被<code>resolve</code>；对应的，如果这个<code>promise</code>被<code>reject</code>，那么结果就是其后的代码都不会执行了，而是直接跳到 catch（如果没有 catch 就直接抛出错误）。<br>上面的代码相当于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">    reject(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1&#x27;</span>);</span><br><span class="line">    resolve(<span class="string">&#x27;async1 success&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>显然后面的两个<code>then</code>中代码都不会执行。</p>
<hr>
<p>但是如果使用<code>try catch</code>包裹并捕获错误，那么将会在 catch 中将错误立即处理，并且继续执行之后的代码。<br>所以这段代码会正常执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&quot;error!!!&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&quot;async1 success&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1().then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line">(<span class="string">&quot;error!!!&quot;</span>);</span><br><span class="line">(<span class="string">&quot;async1&quot;</span>);</span><br><span class="line">(<span class="string">&quot;async1 success&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="9"><a href="#9" class="headerlink" title="9."></a>9.</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;resolve3&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;timer1&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  resolve(<span class="string">&quot;resovle1&quot;</span>);</span><br><span class="line">  resolve(<span class="string">&quot;resolve2&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(p1);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;finally&quot;</span>, res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;resolve1&#x27;</span><br><span class="line">&#x27;finally&#x27; undefined</span><br><span class="line">&#x27;timer1&#x27;</span><br><span class="line">Promise&#123;&lt;resolved&gt;: undefined&#125;</span><br></pre></td></tr></table></figure>

<p>首先要说一下，<code>then</code>中执行完成后会紧接着把后面的下一个<code>then/finally/catch</code>放入微任务队列，如果连续接着很多 then 就会依次放入；这个过程中相当于微任务队列一直有任务，定时器等宏任务不会执行。<br>就比如本题中，虽然第一个<code>setTimeout</code>在同步阶段都已经被放入宏任务队列，但是仍会先执行<code>then</code>和<code>finally</code>中的代码，等这两个中的代码都被执行完后才会执行剩下的宏任务。</p>
<p>最后一个定时器打印出的 p1 其实是<code>.finally</code>的返回值，我们知道<code>.finally</code>的返回值如果在没有抛出错误的情况下默认会是上一个<code>Promise</code>的返回值，而这道题中.<code>finally</code>上一个<code>Promise</code>是<code>.then()</code>，但是这个<code>.then()</code>并没有返回值，所以 p1 打印出来的<code>Promise</code>的值会是<code>undefined</code>，如果你在定时器的下面加上一个<code>return 1</code>，则值就会变成 1。</p>
<h2 id="使用-Promise-实现红绿灯交替重复亮"><a href="#使用-Promise-实现红绿灯交替重复亮" class="headerlink" title="使用 Promise 实现红绿灯交替重复亮"></a>使用 Promise 实现红绿灯交替重复亮</h2><p>红灯 3 秒亮一次，黄灯 2 秒亮一次，绿灯 1 秒亮一次；如何让三个灯不断交替重复亮灯？</p>
<p>要求：用 Promise 实现</p>
<p>三个亮灯函数已经存在：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">red</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">green</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;green&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yellow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>延迟亮灯比较好实现，就是用 promise 包裹定时器，到时间就<code>resolve</code>并执行亮灯函数；<br>要让这三个不断亮灯，可以采用无限递归的方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">red</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">green</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;green&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yellow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> light = <span class="function">(<span class="params">timer, cb</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      cb();</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, timer);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> step = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> light(<span class="number">3000</span>, red);</span><br><span class="line">  <span class="keyword">await</span> light(<span class="number">2000</span>, yellow);</span><br><span class="line">  <span class="keyword">await</span> light(<span class="number">1000</span>, green);</span><br><span class="line">  <span class="keyword">await</span> step();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">step();</span><br></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="/img/JS.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/18/projects/"><img class="prev-cover" src="/img/codes1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2022/05/12/OS/"><img class="next-cover" src="/img/codes1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统知识点总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/02/06/do-exercise-2/" title="工程化、React以及其他知识刷题总结"><img class="cover" src="/img/codes1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-06</div><div class="title">工程化、React以及其他知识刷题总结</div></div></a></div><div><a href="/2022/04/05/blog44-optimization/" title="优化问题总结"><img class="cover" src="/img/codes1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-05</div><div class="title">优化问题总结</div></div></a></div><div><a href="/2022/04/05/blog45-fe-engineering/" title="前端工程化总结"><img class="cover" src="/img/codes1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-05</div><div class="title">前端工程化总结</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/pinkstar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xing Ye</div><div class="author-info__description">a singleThreaded boy's blog</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/penghei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/penghei" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:632885485@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">A SingleThreaded Boy...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">手写题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-new"><span class="toc-number">1.1.</span> <span class="toc-text">手写 new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-number">1.2.</span> <span class="toc-text">手写数组去重</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3"><span class="toc-number">1.3.</span> <span class="toc-text">手写数组扁平</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-reduce"><span class="toc-number">1.4.</span> <span class="toc-text">手写 reduce</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.5.</span> <span class="toc-text">手写深拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E9%80%92%E5%BD%92"><span class="toc-number">1.5.1.</span> <span class="toc-text">基本递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%95%B0%E7%BB%84%E5%88%A4%E6%96%AD"><span class="toc-number">1.5.2.</span> <span class="toc-text">添加数组判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%BE%AA%E7%8E%AF%E8%B0%83%E7%94%A8"><span class="toc-number">1.5.3.</span> <span class="toc-text">避免循环调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E6%B7%B1%E6%AF%94%E8%BE%83"><span class="toc-number">1.6.</span> <span class="toc-text">手写深比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E9%98%B2%E6%8A%96-%E8%8A%82%E6%B5%81"><span class="toc-number">1.7.</span> <span class="toc-text">手写防抖&#x2F;节流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-number">1.8.</span> <span class="toc-text">手写柯里化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-Promise"><span class="toc-number">1.9.</span> <span class="toc-text">手写 Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-Promise"><span class="toc-number">1.9.1.</span> <span class="toc-text">基础 Promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#then-%E7%A9%BF%E9%80%8F"><span class="toc-number">1.9.2.</span> <span class="toc-text">then 穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-Api"><span class="toc-number">1.9.3.</span> <span class="toc-text">Promise Api</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-all"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">Promise.all</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-race"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">Promise.race</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-map%E9%99%90%E5%88%B6%E5%B9%B6%E5%8F%91"><span class="toc-number">1.9.3.3.</span> <span class="toc-text">Promise.map限制并发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-call-apply-%E5%92%8C-bind"><span class="toc-number">1.10.</span> <span class="toc-text">手写 call apply 和 bind</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-instanceof"><span class="toc-number">1.11.</span> <span class="toc-text">手写 instanceof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-sleep-delay"><span class="toc-number">1.12.</span> <span class="toc-text">手写 sleep&#x2F;delay</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-compose-%E5%87%BD%E6%95%B0"><span class="toc-number">1.13.</span> <span class="toc-text">手写 compose 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E6%B4%97%E7%89%8C%E5%87%BD%E6%95%B0-shuffle"><span class="toc-number">1.14.</span> <span class="toc-text">手写洗牌函数 shuffle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E5%AF%B9%E8%B1%A1%E6%89%81%E5%B9%B3%E5%8C%96%E5%92%8C%E9%80%86%E6%89%81%E5%B9%B3%E5%8C%96"><span class="toc-number">1.15.</span> <span class="toc-text">手写对象扁平化和逆扁平化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%81%E5%B9%B3%E5%8C%96"><span class="toc-number">1.15.1.</span> <span class="toc-text">扁平化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E6%89%81%E5%B9%B3%E5%8C%96"><span class="toc-number">1.15.2.</span> <span class="toc-text">逆扁平化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise-%E5%BC%82%E6%AD%A5-%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE"><span class="toc-number">2.</span> <span class="toc-text">Promise&#x2F;异步 相关题目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1"><span class="toc-number">2.1.</span> <span class="toc-text">1.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2"><span class="toc-number">2.2.</span> <span class="toc-text">2.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3"><span class="toc-number">2.3.</span> <span class="toc-text">3.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4"><span class="toc-number">2.4.</span> <span class="toc-text">4.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5"><span class="toc-number">2.5.</span> <span class="toc-text">5.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6"><span class="toc-number">2.6.</span> <span class="toc-text">6.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7"><span class="toc-number">2.7.</span> <span class="toc-text">7.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8"><span class="toc-number">2.8.</span> <span class="toc-text">8.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9"><span class="toc-number">2.9.</span> <span class="toc-text">9.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Promise-%E5%AE%9E%E7%8E%B0%E7%BA%A2%E7%BB%BF%E7%81%AF%E4%BA%A4%E6%9B%BF%E9%87%8D%E5%A4%8D%E4%BA%AE"><span class="toc-number">2.10.</span> <span class="toc-text">使用 Promise 实现红绿灯交替重复亮</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/05/18/projects/" title="无题"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/05/18/projects/" title="无题">无题</a><time datetime="2022-05-18T02:57:57.356Z" title="发表于 2022-05-18 10:57:57">2022-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/13/handwriting/" title="js题目"><img src="/img/JS.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="js题目"/></a><div class="content"><a class="title" href="/2022/05/13/handwriting/" title="js题目">js题目</a><time datetime="2022-05-13T04:21:10.000Z" title="发表于 2022-05-13 12:21:10">2022-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/12/OS/" title="操作系统知识点总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统知识点总结"/></a><div class="content"><a class="title" href="/2022/05/12/OS/" title="操作系统知识点总结">操作系统知识点总结</a><time datetime="2022-05-12T07:58:22.000Z" title="发表于 2022-05-12 15:58:22">2022-05-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/05/blog43-algorithms/" title="算法学习总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法学习总结"/></a><div class="content"><a class="title" href="/2022/04/05/blog43-algorithms/" title="算法学习总结">算法学习总结</a><time datetime="2022-04-05T08:01:22.000Z" title="发表于 2022-04-05 16:01:22">2022-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/05/blog44-optimization/" title="优化问题总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="优化问题总结"/></a><div class="content"><a class="title" href="/2022/04/05/blog44-optimization/" title="优化问题总结">优化问题总结</a><time datetime="2022-04-05T08:01:22.000Z" title="发表于 2022-04-05 16:01:22">2022-04-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Xing Ye</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hello stranger!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>