<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>js手写 | XingYeBlog</title><meta name="keywords" content="面试"><meta name="author" content="Xing Ye,632885485@qq.com"><meta name="copyright" content="Xing Ye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="手写题手写 newnew 的大致原理: 12345function _new(fn) &amp;#123;  const obj &#x3D; &amp;#123;&amp;#125;;  obj.__proto__ &#x3D; fn.prototype;  return fn.call(obj);&amp;#125;   创建一个对象，将来作为实例 将实例的__proto__属性指向构造函数的prototype属性，即let obj; obj.">
<meta property="og:type" content="article">
<meta property="og:title" content="js手写">
<meta property="og:url" content="http://example.com/2022/05/13/blog10-handwriting/index.html">
<meta property="og:site_name" content="XingYeBlog">
<meta property="og:description" content="手写题手写 newnew 的大致原理: 12345function _new(fn) &amp;#123;  const obj &#x3D; &amp;#123;&amp;#125;;  obj.__proto__ &#x3D; fn.prototype;  return fn.call(obj);&amp;#125;   创建一个对象，将来作为实例 将实例的__proto__属性指向构造函数的prototype属性，即let obj; obj.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/JS.png">
<meta property="article:published_time" content="2022-05-13T04:21:10.000Z">
<meta property="article:modified_time" content="2023-07-22T02:14:52.005Z">
<meta property="article:author" content="Xing Ye">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/JS.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2022/05/13/blog10-handwriting/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'js手写',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-22 10:14:52'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/pinkstar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/JS.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XingYeBlog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">js手写</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-13T04:21:10.000Z" title="发表于 2022-05-13 12:21:10">2022-05-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-22T02:14:52.005Z" title="更新于 2023-07-22 10:14:52">2023-07-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaScript/">JavaScript</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">25k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>104分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="js手写"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="手写题"><a href="#手写题" class="headerlink" title="手写题"></a>手写题</h1><h2 id="手写-new"><a href="#手写-new" class="headerlink" title="手写 new"></a>手写 new</h2><p>new 的大致原理:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">  obj.__proto__ = fn.prototype;</span><br><span class="line">  <span class="keyword">return</span> fn.call(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>创建一个对象，将来作为实例</li>
<li>将实例的<code>__proto__</code>属性指向构造函数的<code>prototype</code>属性，即<code>let obj; obj.__proto__ = fn.prototype</code></li>
<li>调用构造函数并绑定 this 到 obj 上</li>
<li>返回调用结果</li>
</ol>
<p>因此手写 new 按照类似的原理创建：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(fn.prototype); <span class="comment">//新建对象并将原型指向构造函数的prototype</span></span><br><span class="line">  <span class="keyword">const</span> ret = fn.apply(obj, args); <span class="comment">//调用构造函数，并把上下文指定为当前对象（让构造函数内的this都指向当前对象）</span></span><br><span class="line">  <span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj; <span class="comment">//检查返回值，如果没有返回值就返回该对象，如果有就返回返回值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = _new(Animal, <span class="string">&quot;Puppy&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>实际上关键的一步就是<code>fn.apply(obj, args)</code>；<br>如果函数没有显式的返回值（构造函数如果显式返回对象，new 会直接返回该对象而不是实例），实际上就是一个绑定对象，给对象添加属性并设置原型的过程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj.__proto = fn.prototype;</span><br><span class="line">fn.call(obj, ...args);</span><br><span class="line"><span class="keyword">let</span> dog = obj;</span><br></pre></td></tr></table></figure>

<h2 id="实现一个-const"><a href="#实现一个-const" class="headerlink" title="实现一个 const"></a>实现一个 const</h2><p>const 可以通过对对象属性的配置实现，即用 Object.defineProperty 设置某个对象下的值不能被修改即可。</p>
<p>假设存在一个作用域对象 scopeObj，所有通过 const 定义的变量都会存储为这个对象的属性。然后对这个属性配置 set 时报错并不能修改即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _const = <span class="function"><span class="keyword">function</span> (<span class="params">name, val, scopeObj = <span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">  scopeObj[name] = val;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(scopeObj, name, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (value !== val)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Assignment to constant variable.&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="手写数组去重"><a href="#手写数组去重" class="headerlink" title="手写数组去重"></a>手写数组去重</h2><p>原理:</p>
<ul>
<li>filter 会在返回为 false 时去除该元素</li>
<li>indexOf 会返回第一个找到的该元素的索引; 如果有重复元素则显然 indexOf 只返回第一个该元素, 不会等于当前 index,就会返回 false 从而筛掉</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = arr.filter(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> array.indexOf(item) === index;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce也可以</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre, cur, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.indexOf(cur) === index ? pre.concat(cur) : pre;</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写数组扁平"><a href="#手写数组扁平" class="headerlink" title="手写数组扁平"></a>手写数组扁平</h2><p>原理:</p>
<ul>
<li><code>arr.some()</code> 方法, 参数传递一个测试函数, 对每个元素测试, 如果至少一个通过测试就会返回 true; 也就是判断这个数组中是否至少还有一个数组(至少还有一维没有展平)</li>
<li><code>Array.isArray</code> 判断是否是一个数组</li>
<li>核心方法是 <code>concat</code> ,这个方法会抹平二维数组(<code>[].concat(1,[2]) = [1,2]</code>), 所以只需要递归/循环就行</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (arr.some(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">    arr = [].concat(...arr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[].concat(1,[2]) = [1,2]</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p>如果需要加上深度判断：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr, depth = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) <span class="keyword">return</span> arr;</span><br><span class="line">  <span class="keyword">while</span> (arr.some(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">Array</span>.isArray(item)) &amp;&amp; depth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    arr = [].concat(...arr);</span><br><span class="line">    depth--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他递归写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) <span class="keyword">return</span> arr;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre, curr, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pre.concat(flatten(curr));</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) <span class="keyword">return</span> arr;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> val <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    res = res.concat(flatten(val));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不用concat也可以</span></span><br><span class="line"><span class="comment">// concat的主要作用就是可以接受一个值，也可以接受一个数组，把所有的值连接到新数组</span></span><br><span class="line"><span class="comment">// 不用concat的话，就区分一下是否是数组就可以了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr, depth = <span class="literal">Infinity</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (depth === <span class="number">0</span>) <span class="keyword">return</span> arr;</span><br><span class="line">  <span class="keyword">let</span> newArr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(item)) &#123;</span><br><span class="line">      <span class="keyword">const</span> resArr = flatten(item, depth - <span class="number">1</span>);</span><br><span class="line">      newArr.push(...resArr);</span><br><span class="line">    &#125; <span class="keyword">else</span> newArr.push(item);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写数组分组"><a href="#手写数组分组" class="headerlink" title="手写数组分组"></a>手写数组分组</h2><p>实现一个函数，参数是数组 arr 和要分的每组大小 size，返回这个数组分成 n 个这么大的数组的二维数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chunk([1,2,3,4],2)</span><br><span class="line">=&gt; [[1,2],[3,4]]</span><br><span class="line"></span><br><span class="line">chunk([1,2,3,4],3)</span><br><span class="line">=&gt; [[1,2,3],[4]]</span><br></pre></td></tr></table></figure>

<p>最基本写法：每 n 个放入一个数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chunk = <span class="function">(<span class="params">arr, size</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">while</span> (arr.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> top = arr.shift();</span><br><span class="line">      <span class="keyword">if</span> (top) tmp.push(top);</span><br><span class="line">    &#125;</span><br><span class="line">    res.push([...tmp]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还可以在一次循环中完成。即用 i 和 size 的商得到每个新数组的位置，显然当 i 是 size 的 n 倍时，这些数字会被放入同一个数组。<br>比如 size 是 3，那么 3 4 5 得到的 index 都是 1，就会被放入同一个数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chunk</span>(<span class="params">arr, size</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="built_in">Math</span>.floor(i / size);</span><br><span class="line">    <span class="keyword">if</span> (res[index] == <span class="literal">undefined</span>) res[index] = [];</span><br><span class="line">    res[index].push(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写-reduce"><a href="#手写-reduce" class="headerlink" title="手写 reduce"></a>手写 reduce</h2><p>reduce 实际上是一个循环，依次把之前的数据和初始值（或第一次）一起调用回调<br>考虑到初始值的情况，如果有初始值就从初始值开始，并且从数组第二项开始调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myReduce</span>(<span class="params">callback, init</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(<span class="built_in">this</span>)) <span class="keyword">return</span>; <span class="comment">//要求是数组</span></span><br><span class="line">  <span class="keyword">const</span> arr = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> total = init || arr[<span class="number">0</span>]; <span class="comment">//如果有初始值就取初始值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = init ? <span class="number">0</span> : <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">//有初始值就从i=1开始，即从第二项开始</span></span><br><span class="line">    total = callback(total, arr[i], i, arr); <span class="comment">//调用callback，每次的total都是上次的返回值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h2><h3 id="基本递归"><a href="#基本递归" class="headerlink" title="基本递归"></a>基本递归</h3><p>最基本的递归很简单，实际上就是一个回溯复制：<br>原理就是先创建一个新对象，然后依次把旧对象的值赋值过去；如果这个值是一个对象，就递归一次，否则就直接复制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newObj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    newObj[key] = clone(obj[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加数组判断"><a href="#添加数组判断" class="headerlink" title="添加数组判断"></a>添加数组判断</h3><p>但是要考虑到数组，就得稍微改进一下：<br>只需要添加类型判断，不同的初始化即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span> target;</span><br><span class="line">  <span class="keyword">let</span> newTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">    newTarget[key] = clone(target[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newTarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="避免循环调用"><a href="#避免循环调用" class="headerlink" title="避免循环调用"></a>避免循环调用</h3><p>当对象的属性间接或直接的引用了自身，就会形成循环引用。上面的方法处理一个循环引用会导致栈溢出。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj.obj = obj;</span><br></pre></td></tr></table></figure>

<p>这种情况下，访问 <code>obj.obj</code> 依旧是一个 obj 类型，无论如何都不会退出递归，会形成死循环。<br>解决的方法是设定一个存储空间 <code>Map</code>，每次 <code>clone</code> 都向 <code>Map</code> 中添加，并且每次递归都先检查是否有克隆过的对象，如果有就直接返回<br>范例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span> target;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="comment">//如果有这个对象就返回一个空对象或数组，阻止循环调用</span></span><br><span class="line">  <span class="comment">//正常情况下都没有，只有重复引用时target和newTarget都是一样的对象</span></span><br><span class="line">  <span class="keyword">if</span> (map.has(target)) <span class="keyword">return</span> map.get(target);</span><br><span class="line"></span><br><span class="line">  map.set(target, newTarget); <span class="comment">// 存键为当前对象，值为当前对象的复制对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">    newTarget[key] = clone(target[key], map); <span class="comment">//把当前的map传下去</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newTarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="检查更多类型"><a href="#检查更多类型" class="headerlink" title="检查更多类型"></a>检查更多类型</h3><p>考虑到参数还可能是更多的类型，并且 typeof 判断类型不一定准确，因此可以考虑更改一下判断参数类型的函数：</p>
<p>考虑用 Object.prototype.toString 来判断类型，可以把类型分为可继续遍历和不可继续遍历两类：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapTag = <span class="string">&quot;[object Map]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> setTag = <span class="string">&quot;[object Set]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> arrayTag = <span class="string">&quot;[object Array]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> objectTag = <span class="string">&quot;[object Object]&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boolTag = <span class="string">&quot;[object Boolean]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">&quot;[object Date]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">&quot;[object Error]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">&quot;[object Number]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">&quot;[object RegExp]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">&quot;[object String]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> symbolTag = <span class="string">&quot;[object Symbol]&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>如果 value 是可遍历的 5 种类型，那就需要进一步处理。比如 map 不能直接复制值，而是展开遍历 map 再复制到一个新的 map 中。</p>
<p>而对于不可遍历的类型，也要考虑其复制。比如 symbol、正则等需要重新构造</p>
<p>至于数组和对象的区分，我们可以考虑直接用它的 constructor 属性构造，这样就不用判断了。比如数组的 constructor 就是 Array 构造函数，直接调用就可以。</p>
<p>并且由于 forin 的性能很差，这里采用 while 循环的形式。对于数组直接遍历即可，而对于对象则遍历其<code>Object.keys(target)</code>。实际上这个循环函数和 forEach 的用法是完全一样的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapTag = <span class="string">&quot;[object Map]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> setTag = <span class="string">&quot;[object Set]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> arrayTag = <span class="string">&quot;[object Array]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> objectTag = <span class="string">&quot;[object Object]&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boolTag = <span class="string">&quot;[object Boolean]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">&quot;[object Date]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">&quot;[object Error]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">&quot;[object Number]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">&quot;[object RegExp]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">&quot;[object String]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> symbolTag = <span class="string">&quot;[object Symbol]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> bigIntTag = <span class="string">&quot;[object BigInt]&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> functionTag = <span class="string">&quot;[object Function]&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getType = <span class="function">(<span class="params">target</span>) =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(target); <span class="comment">// 获取类型</span></span><br><span class="line"><span class="keyword">const</span> getInit = <span class="function">(<span class="params">target</span>) =&gt;</span> <span class="keyword">new</span> target.constructor(); <span class="comment">// 用构造函数构造</span></span><br><span class="line"><span class="keyword">const</span> isObject = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  target <span class="comment">// 是否是对象或数组</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> getType(target) === arrayTag || getType(target) === objectTag;</span><br><span class="line"><span class="keyword">const</span> deepTag = [mapTag, setTag, arrayTag, objectTag]; <span class="comment">// 可以深度遍历的类型</span></span><br><span class="line"><span class="keyword">const</span> whileLoop = <span class="function">(<span class="params">target, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// while循环代替forin</span></span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (start &lt; target.length) &#123;</span><br><span class="line">    callback(target[start], start);</span><br><span class="line">    start++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> cloneReg = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 复制正则</span></span><br><span class="line">  <span class="keyword">const</span> reFlags = <span class="regexp">/\w*$/</span>;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> target.constructor(target.source, reFlags.exec(target)[<span class="number">0</span>]); <span class="comment">// 第一个参数是原正则的字符串形式，第二个是范围符，比如&#x27;g&#x27;、&#x27;i&#x27;等</span></span><br><span class="line">  result.lastIndex = target.lastIndex; <span class="comment">// 指定下一次匹配的起始索引</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> cloneSymbol = <span class="function">(<span class="params">target</span>) =&gt;</span> <span class="built_in">Object</span>(<span class="built_in">Symbol</span>.prototype.valueOf.call(target)); <span class="comment">// symbol的复制就是取其valueOf并转为对象</span></span><br><span class="line"><span class="keyword">const</span> cloneBigInt = <span class="function">(<span class="params">target</span>) =&gt;</span> <span class="built_in">BigInt</span>(target.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可深度遍历类型的处理</span></span><br><span class="line"><span class="keyword">const</span> cloneBasicType = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ctor = target.constructor;</span><br><span class="line">  <span class="keyword">switch</span> (getType(target)) &#123;</span><br><span class="line">    <span class="keyword">case</span> boolTag:</span><br><span class="line">    <span class="keyword">case</span> numberTag:</span><br><span class="line">    <span class="keyword">case</span> stringTag:</span><br><span class="line">    <span class="keyword">case</span> errorTag:</span><br><span class="line">    <span class="keyword">case</span> dateTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ctor(target);</span><br><span class="line">    <span class="keyword">case</span> regexpTag:</span><br><span class="line">      <span class="keyword">return</span> cloneReg(target);</span><br><span class="line">    <span class="keyword">case</span> symbolTag:</span><br><span class="line">      <span class="keyword">return</span> cloneSymbol(target);</span><br><span class="line">    <span class="keyword">case</span> bigIntTag:</span><br><span class="line">      <span class="keyword">return</span> cloneBigInt(target);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> type = getType(target);</span><br><span class="line">  <span class="keyword">let</span> cloneTarget; <span class="comment">// 最终复制结果</span></span><br><span class="line">  <span class="keyword">if</span> (deepTag.includes(type)) cloneTarget = getInit(target);</span><br><span class="line">  <span class="keyword">else</span> cloneTarget = cloneBasicType(target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (map.has(target)) <span class="keyword">return</span> map.get(target);</span><br><span class="line">  map.set(target, cloneTarget);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map的处理，遍历map并创建新的</span></span><br><span class="line">  <span class="keyword">if</span> (type === mapTag) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> target.entries()) &#123;</span><br><span class="line">      cloneTarget.set(key, deepClone(value, map));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type === setTag) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> target.values()) &#123;</span><br><span class="line">      cloneTarget.add(deepClone(value, map));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type === objectTag) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(target);</span><br><span class="line">    <span class="comment">// 取keys遍历，key就是每个键，相当于forin</span></span><br><span class="line">    whileLoop(keys, <span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">      cloneTarget[key] = deepClone(target[key], map);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type === arrayTag) &#123;</span><br><span class="line">    <span class="comment">// 直接取值遍历，用index作为索引</span></span><br><span class="line">    whileLoop(target, <span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">      cloneTarget[index] = deepClone(value, map);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下更进阶的可以参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903929705136141">https://juejin.cn/post/6844903929705136141</a></p>
<h2 id="手写深比较"><a href="#手写深比较" class="headerlink" title="手写深比较"></a>手写深比较</h2><p>深比较即主要针对对象的比较，不能直接通过<code>===</code>判断。思路就是取出两个对象的键，分别遍历比较每个键对应的值是否相等；然后再通过递归的形式比较值是对象类型的键。</p>
<p>其实可以理解为多叉树的比较。二叉树的比较很简单，这里就是在二叉树的基础上改为多叉树就可以了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的比较</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compareTree</span>(<span class="params">root1, root2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root1 &amp;&amp; !root2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> ((!root1 &amp;&amp; root2) || (root1 &amp;&amp; !root2)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    compareTree(root1.left) &amp;&amp;</span><br><span class="line">    compareTree(root2.left) &amp;&amp;</span><br><span class="line">    root1.val === root2.val</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多叉树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compareTree</span>(<span class="params">root1, root2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root1 &amp;&amp; !root2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> ((!root1 &amp;&amp; root2) || (root1 &amp;&amp; !root2)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> pairs = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> child <span class="keyword">of</span> root1.children) &#123;</span><br><span class="line">    <span class="comment">// 这里把children换为Object.values(root1)就可以</span></span><br><span class="line">    pairs.push([child]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; root2.children.length; i++) &#123;</span><br><span class="line">    pairs[i].push(root2.children[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> pair <span class="keyword">of</span> pairs) &#123;</span><br><span class="line">    res = res &amp;&amp; compareTree(...pair);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res &amp;&amp; root1.val === root2.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEqual</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> x === <span class="string">&quot;object&quot;</span> &amp;&amp;</span><br><span class="line">    x !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> y === <span class="string">&quot;object&quot;</span> &amp;&amp;</span><br><span class="line">    y !== <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">const</span> keysX = <span class="built_in">Object</span>.keys(x);</span><br><span class="line">    <span class="keyword">const</span> keysY = <span class="built_in">Object</span>.keys(y);</span><br><span class="line">    <span class="keyword">if</span> (keysX.length !== keysY.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> keysX) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isEqual(x[key], y[key])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外一种写法，思路上有点像比较两棵树；但是由于对象的键可能大于 2，因此写出来更像回溯：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isObj = <span class="function">(<span class="params">obj</span>) =&gt;</span> <span class="keyword">typeof</span> obj === <span class="string">&quot;object&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEqual</span>(<span class="params">obj1, obj2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObj(obj1) &amp;&amp; !isObj(obj2)) <span class="keyword">return</span> obj1 === obj2;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((isObj(obj1) &amp;&amp; !isObj(obj2)) || (!isObj(obj1) &amp;&amp; isObj(obj2)))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> keysX = <span class="built_in">Object</span>.keys(obj1);</span><br><span class="line">  <span class="keyword">const</span> keysY = <span class="built_in">Object</span>.keys(obj2);</span><br><span class="line">  <span class="keyword">if</span> (keysX.length !== keysY.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj1) &#123;</span><br><span class="line">    flag = flag &amp;&amp; isEqual(obj1[key], obj2[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写防抖-节流"><a href="#手写防抖-节流" class="headerlink" title="手写防抖/节流"></a>手写防抖/节流</h2><p>基本实现见下，更加高级的实现可以参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7057053516849758222#heading-7">https://juejin.cn/post/7057053516849758222#heading-7</a></p>
<ul>
<li>防抖</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的写法有个缺点，就是第一次触发时间时仍然会等待 wait 秒。可以增加一个 immediate，使得第一次执行不用等待</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, isImmediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">let</span> once = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isImmediate &amp;&amp; once) &#123;</span><br><span class="line">      func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      once = <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// 注意这里还是要设置一个timeout</span></span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">      &#125;, wait);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>节流</li>
</ul>
<p>时间戳实现：在外部函数留一个闭包表示上次调用时间，函数内部每次请求当前时间，如果时间戳小于延迟就不执行；反之执行之后修改上次时间为当前</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="keyword">if</span> (now - pre &lt; delay) <span class="keyword">return</span>;</span><br><span class="line">    fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    pre = now;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>setTimeout</code>实现：几乎和防抖一样，只是如果 timeout 存在就不进入；并且执行之后把 timeout 设为 null，相当于 timeout 是一个“大门”。在定时器执行期间不会进入定时器，只有当定时器内的代码执行之后才会运行下一个定时器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout) <span class="keyword">return</span>;</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      timeout = <span class="literal">null</span>;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种写法可以结合一下。使用时间戳记录时间差值，然后和设定的时间间隔相减作为 remain；如果 remain&lt;=0，就立即执行；反之就是开启一个定时器，等到 remain 时间结束后再执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="keyword">const</span> remain = delay - (now - pre);</span><br><span class="line">    <span class="keyword">if</span> (remain &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      pre = now;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(fn, remain);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写柯里化"><a href="#手写柯里化" class="headerlink" title="手写柯里化"></a>手写柯里化</h2><p>柯里化本质是对一个函数的反复调用和返回，让原先直接返回结果的函数，变成返回一个函数，再次或 n 次调用之后才返回结果。在这 n 次之内的返回值都是函数</p>
<p>比如，想要对 add 函数实现柯里化，可能有很多层：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两层</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...args1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...args1, ...args2].reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三层</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...args1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args3</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> [...args1, ...args2, ...args3].reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，随着需要的层数增加，本质上就是函数的嵌套，逐层收集参数，在某个终止条件下得到结果。</p>
<p>因此对于不确定的层数，最佳的实现方式就是递归：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...args1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">add2</span>(<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 某个条件下，比如参数达到限制，就合并参数计算</span></span><br><span class="line">    <span class="keyword">return</span> add(...args1, ...args2);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 给函数安插某些方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当层数超过 2 时，每增加一层都相当于递归调用了一次 add，得到的是 add2，也就相当于每次都是在执行 add2。<br>注意递归的应该是外层的 add，而不是里层的 add2。如果调用 add2 就会发现参数不对：因为 args1 始终没有改变，一直都是第一次的</p>
<p>如果是要求函数接收一个函数并转化为柯里化的函数，就在外层套一个函数就可以。本质上递归还是在调用第一次调用的函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里可以记录调用层数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length === func.length) &#123;</span><br><span class="line">      <span class="comment">//这次调用传入的参数个数和函数总参数个数比较，如果等于说明是完整调用，直接返回；</span></span><br><span class="line">      <span class="comment">//如果小于，比如add(1)(2,3)，原本本来是三个参数，现在只传入一个，因此进入柯里化步骤</span></span><br><span class="line">      <span class="keyword">return</span> func(args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//这里把柯里化的前部分和后部分拆开，这个函数的参数是后部分的</span></span><br><span class="line">        <span class="comment">//即，add(1)(2,3) 中，...agrs是1，...args2是2和3，然后把这两组参数合并调用；</span></span><br><span class="line">        <span class="comment">//如果还有n组参数会放在下一次递归</span></span><br><span class="line">        <span class="keyword">return</span> curried(...args, ...args2);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写懒计算函数"><a href="#手写懒计算函数" class="headerlink" title="手写懒计算函数"></a>手写懒计算函数</h2><blockquote>
<p>实现一个无限累加的 sum 函数如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).valueOf(); <span class="comment">//6</span></span><br><span class="line">sum(<span class="number">2</span>, <span class="number">3</span>)(<span class="number">2</span>).valueOf(); <span class="comment">//7</span></span><br><span class="line">sum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>).valueOf(); <span class="comment">//10</span></span><br><span class="line">sum(<span class="number">2</span>)(<span class="number">4</span>, <span class="number">1</span>)(<span class="number">2</span>).valueOf(); <span class="comment">//9</span></span><br><span class="line">sum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>)(<span class="number">6</span>).valueOf(); <span class="comment">// 21</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>这道题开始的思路是用上一道的柯里化函数包裹 sum 函数解决。但是问题在于 sum 的参数不确定，不能直接用。</p>
<p>因此实际的思路应该是先收集所有调用的参数，然后给函数一个 valueOf 方法，调用这个方法时计算参数只和即可。</p>
<p>收集参数的方法和柯里化类似：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args2</span>) =&gt;</span> sum(...args1, ...args2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一次额外调用，都会产生一个递归，合并之前调用的所有参数。</p>
<p>但是这样没有终止条件。在柯里化中终止条件通常是总参数个数达到函数最大参数个数。而这里我们就需要一个 valueOf 方法，当调用这个方法时就终止，并返回计算结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum(...args1, ...args2);</span><br><span class="line">  &#125;;</span><br><span class="line">  f.valueOf = <span class="function">() =&gt;</span> args1.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写-Promise"><a href="#手写-Promise" class="headerlink" title="手写 Promise"></a>手写 Promise</h2><h3 id="基础-Promise"><a href="#基础-Promise" class="headerlink" title="基础 Promise"></a>基础 Promise</h3><p>原理:<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903625769091079">具体原理可以看这里</a></p>
<ol>
<li>首先构造一个类, promise 对象是需要传一个函数的，这里直接作为 constructor 的参数；在 constructor 中做如下配置：</li>
</ol>
<ul>
<li>设置状态 state，有三种情况：<code>pending</code>、<code>fulfilled</code>、<code>rejected</code></li>
<li>设置 value 用于维持一个值，在后面 resolve 到 then 中，then 也需要这个 value</li>
<li>设置 <code>resolve</code> 函数，原理就是：<ol>
<li>调用时更改 state 状态</li>
<li>存储调用时传入的值</li>
</ol>
</li>
<li>设置 <code>rejected</code>，原理是：<ol>
<li>更改 <code>state</code> 为 <code>rejected</code></li>
<li>设置错误原因</li>
</ol>
</li>
<li>设置完上面之后通过传入的 <code>executor</code> 传入 <code>resolve</code> 和 <code>rejected</code>；在外部使用 <code>resolve</code> 和 <code>rejected</code> 都会直接触发类中的这两个函数</li>
</ul>
<ol start="2">
<li>设计 then；then 实际上是类的一个方法，参数为 <code>onFulfilled</code> 和 <code>onRejected</code>，分别表示成功回调和失败回调</li>
</ol>
<ul>
<li>调用时先判断 state；如果为 fulfilled，就调用外部自定义的 <code>onFulfilled</code> 函数，参数为 <code>this.value</code>，也就相当于我们常写的”res”；如果为 <code>rejected</code> 同理</li>
</ul>
<ol start="3">
<li>添加定时器异步</li>
</ol>
<ul>
<li>首先在构造函数添加成功存放的数组和失败存放的数组，这两个存的分别是后续外部定义的 <code>onFulfilled</code> 函数和 <code>onRejected</code> 函数，在“完成的时刻”再从数组中取出调用他们。使用数组的原因是多个 <code>then</code>（不是 <code>then</code> 链，还没实现）</li>
<li>在 <code>resolve</code> 和 <code>rejected</code> 函数中添加调用上面两个数组中所有函数；这步最为关键，也就是说必须直到状态改变，后续的 <code>then</code> 中函数才会被调用，是一种异步效果</li>
<li>在 <code>then</code> 中设置 <code>pending</code> 状态的操作：如果在 <code>pending</code> 状态说明 <code>executor</code> 函数中有延时执行的任务，这时候就把所有的回调放在成功/失败数组中，等待完成后执行</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化state为等待态</span></span><br><span class="line">    <span class="built_in">this</span>.state = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line">    <span class="comment">// 成功的值</span></span><br><span class="line">    <span class="built_in">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 失败的原因</span></span><br><span class="line">    <span class="built_in">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 成功存放的数组，主要是应对异步任务</span></span><br><span class="line">    <span class="built_in">this</span>.onResolvedCallbacks = [];</span><br><span class="line">    <span class="comment">// 失败存放的数组</span></span><br><span class="line">    <span class="built_in">this</span>.onRejectedCallbacks = [];</span><br><span class="line">    <span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// state改变,resolve调用就会失败</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// resolve调用后，state转化为成功态</span></span><br><span class="line">        <span class="built_in">this</span>.state = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line">        <span class="comment">// 储存成功的值</span></span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="comment">// 一旦resolve执行，调用成功数组的函数</span></span><br><span class="line">        <span class="built_in">this</span>.onResolvedCallbacks.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// state改变,reject调用就会失败</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// reject调用后，state转化为失败态</span></span><br><span class="line">        <span class="built_in">this</span>.state = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">        <span class="comment">// 储存失败的原因</span></span><br><span class="line">        <span class="built_in">this</span>.reason = reason;</span><br><span class="line">        <span class="comment">// 一旦reject执行，调用失败数组的函数</span></span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 如果executor执行报错，直接执行reject</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 状态为fulfilled，执行onFulfilled，传入成功的值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line">      onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态为rejected，执行onRejected，传入失败的原因</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">      onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当状态state为pending时，说明任务是个异步，需要把任务放在数组中，等到resolve/reject执行再执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// onFulfilled传入到成功数组</span></span><br><span class="line">      <span class="built_in">this</span>.onResolvedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// onRejected传入到失败数组</span></span><br><span class="line">      <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// catch可以简单实现为执行then的第二个参数</span></span><br><span class="line">  <span class="keyword">catch</span>(onReject) &#123;</span><br><span class="line">    <span class="built_in">this</span>.then(<span class="function">() =&gt;</span> &#123;&#125;, onReject);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果希望 then 内部通过微任务的方式执行，可以使用 queueMicrotask：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onResolve, onReject</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;fulfilled&quot;</span> &amp;&amp; onResolve) &#123;</span><br><span class="line">    queueMicrotask(<span class="function">() =&gt;</span> onResolve(<span class="built_in">this</span>.value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;rejected&quot;</span> &amp;&amp; onReject) &#123;</span><br><span class="line">    queueMicrotask(<span class="function">() =&gt;</span> onReject(error));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">    onResolve &amp;&amp;</span><br><span class="line">      <span class="built_in">this</span>.onResolvedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        queueMicrotask(<span class="function">() =&gt;</span> onResolve(<span class="built_in">this</span>.value));</span><br><span class="line">      &#125;);</span><br><span class="line">    onReject &amp;&amp;</span><br><span class="line">      <span class="built_in">this</span>.onRejectCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        queueMicrotask(<span class="function">() =&gt;</span> onReject(<span class="built_in">this</span>.error));</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="then-穿透"><a href="#then-穿透" class="headerlink" title="then 穿透"></a>then 穿透</h3><p><code>Promise</code>还有一个很重要的效果就是 then 的穿透，即 then 返回一个<code>Promise</code>给下一个 then 继续链式调用。<br>这个过程的实现主要有以下几点：</p>
<ul>
<li>then 可以没有参数，如果没有参数，<code>onFulfilled</code>默认向下继续传递，<code>onRejected</code>向外冒泡错误</li>
<li>then 需要返回一个<code>Promise</code>，而不是上面的只是进行<code>onFulfilled</code>操作。这个<code>Promise</code>如果<code>resolve</code>就相当于向下穿透到了下一个 then，而其中任何一个<code>reject</code>都会被直接冒泡到最外层。</li>
<li>这个<code>Promise</code>需要判断 then 的返回是不是一个<code>Promise</code>；也就是说，由于 then 可以显式返回一个<code>新的Promise</code>，源码中<code>原本要返回的Promise</code>要和<code>新的自定义Promise</code>同步状态：<code>新的自定义Promise</code>如果<code>resolve</code>，原本的也要<code>resolve</code>，反之亦然；</li>
<li>上述的同步过程主要通过捕获 then 实现，也就是说根据<code>新Promise</code>中 then 的调用判断是哪种情况，然后在<code>原本的Promise</code>中进行<code>resolve</code>或<code>reject</code>。</li>
<li>最后，因为上面说过的 Promise 延迟绑定回调的特性，每个修改状态等操作都应该是异步的，保证 then 先绑定完整再进行操作。本来 then 应当是微任务实现，原教程使用了 setTimeout 宏任务代替，但<code>queueMicrotask</code>是更好的选择。（微任务：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide%EF%BC%89">https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide）</a></li>
</ul>
<p>下面是具体实现，详细解释在注释中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&quot;PENDING&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&quot;FULFILLED&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&quot;REJECTED&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.status = PENDING;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="built_in">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="built_in">this</span>.onResolvedCallback = [];</span><br><span class="line">    <span class="built_in">this</span>.onRejectedCallback = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">      <span class="built_in">this</span>.status = FULFILLED;</span><br><span class="line">      <span class="built_in">this</span>.value = value;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.onResolvedCallback.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn());</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">      <span class="built_in">this</span>.status = REJECTED;</span><br><span class="line">      <span class="built_in">this</span>.reason = reason;</span><br><span class="line">      <span class="built_in">this</span>.onRejectedCallback.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn());</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//判断参数是不是函数，如果不是就直接resolve或者直接reject</span></span><br><span class="line">    onFulfilled =</span><br><span class="line">      <span class="keyword">typeof</span> onFulfilled === <span class="string">&quot;function&quot;</span> ? onFulfilled : <span class="function">(<span class="params">val</span>) =&gt;</span> val;</span><br><span class="line">    onRejected =</span><br><span class="line">      <span class="keyword">typeof</span> onRejected === <span class="string">&quot;function&quot;</span></span><br><span class="line">        ? onRejected</span><br><span class="line">        : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个Promise</span></span><br><span class="line">    <span class="keyword">const</span> thenPromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === FULFILLED) &#123;</span><br><span class="line">        <span class="comment">//创建一个微任务</span></span><br><span class="line">        queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//先执行一次onFulfilled，取得当前then的调用结果</span></span><br><span class="line">            <span class="keyword">let</span> returnValueFromThen = onFulfilled(<span class="built_in">this</span>.value); <span class="comment">//这个值是当前then的返回值，有可能是promise（then返回一个promise供下个then使用）</span></span><br><span class="line">            <span class="comment">//下面这个函数可以看作是一系列判断和同步后进行具体的resolve和reject操作</span></span><br><span class="line">            resolvePromise(thenPromise, returnValueFromThen, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECTED) &#123;</span><br><span class="line">        queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> returnValueFromThen = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">            resolvePromise(thenPromise, returnValueFromThen, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="built_in">this</span>.onResolvedCallback.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> returnValueFromThen = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">              resolvePromise(thenPromise, returnValueFromThen, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">              reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallback.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> returnValueFromThen = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">              resolvePromise(thenPromise, returnValueFromThen, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">              reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> thenPromise;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolvePromise = <span class="function">(<span class="params">thenPromise, returnValueFromThen, resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (returnValueFromThen === thenPromise) &#123;</span><br><span class="line">    <span class="comment">/*不能return自己，即不能</span></span><br><span class="line"><span class="comment">      const p1 = promise.then(value =&gt; &#123;</span></span><br><span class="line"><span class="comment">        return p1</span></span><br><span class="line"><span class="comment">      &#125;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> reject(</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Chaining cycle detected for promise #&lt;Promise&gt;&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**理论上这时直接resolve(returnValueFromThen)就可以了，但是还需要考虑then返回一个Promise的情况，要确保这个新Promise状态和现在的同步</span></span><br><span class="line"><span class="comment">    *也就是说，如果这个新Promise失败，那么当前这个Promise应该直接reject，反之亦然</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">let</span> settledCalled; <span class="comment">//是否调用过resolve或reject，如果有后续都无视</span></span><br><span class="line">  <span class="keyword">if</span> (returnValueFromThen <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">    <span class="comment">//如果then的返回值是个Promise</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> thenFromThen = returnValueFromThen.then; <span class="comment">//这里是then返回的那个Promise中的then，后面叫做套娃then（multiThen）</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> thenFromThen === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">/**正常调用这个套娃then（&quot;multiThen&quot;），绑定原先的Promise上下文（也就是then返回的那个Promise）</span></span><br><span class="line"><span class="comment">          *根据这个套娃then的结果决定当前then的结果</span></span><br><span class="line"><span class="comment">          *如果套娃then resolve，当前就resolve，反之亦然</span></span><br><span class="line"><span class="comment">          *因此给这个套娃then传两个回调，触发哪个就执行哪个</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        thenFromThen.call(</span><br><span class="line">          returnValueFromThen,</span><br><span class="line">          <span class="function">(<span class="params">multiThenFulfilled</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//套娃then resolve的回调，如果套娃then resolve，当前的then也就resolve</span></span><br><span class="line">            <span class="keyword">if</span> (settledCalled) <span class="keyword">return</span>;</span><br><span class="line">            settledCalled = <span class="literal">true</span>; <span class="comment">//如果之前被调用过就返回，否则就执行并设置为已调用过</span></span><br><span class="line">            resolve(multiThenFulfilled); <span class="comment">//这个地方更好的方法是递归调用，因为套娃then 还可能再返回一个promise；但是不考虑那么复杂的情况，直接resolve是可以的</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function">(<span class="params">multiThenRejected</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//如果套娃then被rejected，当前then也rejected</span></span><br><span class="line">            <span class="keyword">if</span> (settledCalled) <span class="keyword">return</span>;</span><br><span class="line">            settledCalled = <span class="literal">true</span>;</span><br><span class="line">            reject(multiThenRejected);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果then的Promise返回一个普通值，就直接resolve</span></span><br><span class="line">        resolve(returnValueFromThen);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="comment">//这个trycatch是捕获访问套娃then中出现的任何错误的，会向上冒泡</span></span><br><span class="line">      <span class="keyword">if</span> (settledCalled) <span class="keyword">return</span>;</span><br><span class="line">      settledCalled = <span class="literal">true</span>;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果then的返回值并不是一个Promise就直接resolve</span></span><br><span class="line">    resolve(returnValueFromThen);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Promise-Api"><a href="#Promise-Api" class="headerlink" title="Promise Api"></a>Promise Api</h3><h4 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally"></a><code>Promise.prototype.finally</code></h4><p>无论当前 Promise 是成功还是失败，调用 finally 之后都会执行 finally 中传入的函数，并且将值原封不动的往下传。</p>
<p>因此可以看作 finally 内部实际上是执行了一个当前 Promise 的 then，在 then 中执行回调函数，然后把该 then 接收到的参数（即上一层传下来的值）继续传下去</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.then(</span><br><span class="line">    <span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function">() =&gt;</span> res),</span><br><span class="line">    <span class="function">(<span class="params">error</span>) =&gt;</span></span><br><span class="line">      <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> error;</span><br><span class="line">      &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>考虑到 callback 可能是个 promise，就需要 Promise.resolve 包裹一下，但不用获取回调的返回值，而是返回 then 从上一层接到的返回值。</p>
<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a><code>Promise.all</code></h4><p>主要逻辑是把一个数组中的 promise 遍历依次执行<code>.then</code>，并把返回值（resolve 值）按顺序放入数组中，等待全部完成后再统一<code>resolve</code>。<br>因此内部实际上返回了一个 Promise，当全部完成时进行 resolve 操作，如果有一个发生 reject 则全部 reject。</p>
<blockquote>
<p>注意执行多个异步任务是并行执行的，并行执行完成后会一起 resolve，消耗时间是最长的那个任务。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.all = <span class="function"><span class="keyword">function</span> (<span class="params">values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(values)) &#123;</span><br><span class="line">    <span class="comment">//首先要求参数必须可迭代</span></span><br><span class="line">    <span class="keyword">const</span> type = <span class="keyword">typeof</span> values;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`TypeError: <span class="subst">$&#123;type&#125;</span> <span class="subst">$&#123;values&#125;</span> is not iterable`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> resultArr = [];</span><br><span class="line">    <span class="keyword">let</span> orderIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> processResultByKey = <span class="function">(<span class="params">result, index</span>) =&gt;</span> &#123;</span><br><span class="line">      resultArr[index] = result; <span class="comment">//按照顺序把刚刚的resolve值放到数组</span></span><br><span class="line">      <span class="keyword">if</span> (++orderIndex === values.length) &#123;</span><br><span class="line">        <span class="comment">//如果满了就全部resolve掉</span></span><br><span class="line">        resolve(resultArr);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">      <span class="comment">//遍历参数，对每个参数执行then；</span></span><br><span class="line">      <span class="comment">// 由于for循环是同步的，因此所有任务都是同步启动、并行执行的</span></span><br><span class="line">      <span class="keyword">let</span> value = values[i];</span><br><span class="line">      <span class="keyword">if</span> (value &amp;&amp; <span class="keyword">typeof</span> value.then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        value.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">          processResultByKey(res, i);</span><br><span class="line">        &#125;, reject); <span class="comment">//如果有一个触发reject，相当于触发了整个的reject，直接退出</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果参数有不是Promise的，不用then直接传入</span></span><br><span class="line">        processResultByKey(value, i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>稍微简化一点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pAll</span>(<span class="params">_promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Iterable =&gt; Array</span></span><br><span class="line">    <span class="keyword">const</span> promises = <span class="built_in">Array</span>.from(_promises);</span><br><span class="line">    <span class="comment">// 结果用一个数组维护</span></span><br><span class="line">    <span class="keyword">const</span> r = [];</span><br><span class="line">    <span class="keyword">const</span> len = promises.length;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="comment">// Promise.resolve 确保把所有数据都转化为 Promise</span></span><br><span class="line">      <span class="comment">// 为什么不直接 promise[i].then, 因为promise[i]可能不是一个promise</span></span><br><span class="line">      <span class="built_in">Promise</span>.resolve(promises[i])</span><br><span class="line">        .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 因为 promise 是异步的，保持数组一一对应</span></span><br><span class="line">          r[i] = res;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果数组中所有 promise 都完成，则返回结果数组</span></span><br><span class="line">          <span class="keyword">if</span> (++count === len) &#123;</span><br><span class="line">            resolve(r);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 当发生异常时，直接 reject</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键在于“依次执行”，可以看到上面的循环中，每个小 Promise 都在 then 之后把结果放入数组，待数组放满后才 resolve。</p>
<h4 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a><code>Promise.allSettled</code></h4><p>和 Promise.all 的唯一区别，就是错误并不直接 reject，而是像收集正常结果一样收集错误，最后等到装满时返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseAllSettled</span>(<span class="params">_promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Iterable =&gt; Array</span></span><br><span class="line">    <span class="keyword">const</span> promises = <span class="built_in">Array</span>.from(_promises);</span><br><span class="line">    <span class="comment">// 结果用一个数组维护</span></span><br><span class="line">    <span class="keyword">const</span> r = [];</span><br><span class="line">    <span class="keyword">const</span> len = promises.length;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="comment">// Promise.resolve 确保把所有数据都转化为 Promise</span></span><br><span class="line">      <span class="comment">// 为什么不直接 promise[i].then, 因为promise[i]可能不是一个promise</span></span><br><span class="line">      <span class="built_in">Promise</span>.resolve(promises[i]).then(</span><br><span class="line">        <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 因为 promise 是异步的，保持数组一一对应</span></span><br><span class="line">          r[i] = res;</span><br><span class="line">          <span class="comment">// 如果数组中所有 promise 都完成，则返回结果数组</span></span><br><span class="line">          <span class="keyword">if</span> (++count === len) &#123;</span><br><span class="line">            resolve(r);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          r[i] = err;</span><br><span class="line">          <span class="keyword">if</span> (++count === len) &#123;</span><br><span class="line">            resolve(r);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a><code>Promise.race</code></h4><p>如果让 Promise 在 then 之后立刻就进行 resolve，相当于让每个小 Promise 中最快的返回，就可以实现<code>Promise.race</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.race = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> val = promises[i];</span><br><span class="line">      <span class="keyword">if</span> (val &amp;&amp; <span class="keyword">typeof</span> val.then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">//谁先执行完谁直接resolve</span></span><br><span class="line">        val.then(resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 普通值</span></span><br><span class="line">        resolve(val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a><code>Promise.any</code></h4><p>和 Promise.race 唯一的区别在于，它会 resolve 第一个达到成功状态的的 promise，而不是只要有一个成功或失败就会 resolve。<br>如果没有成功的 promise，就会 reject 一个<code>AggregateError</code>，还会包含原因。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.any = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> errs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> val = promises[i];</span><br><span class="line">      <span class="keyword">if</span> (val &amp;&amp; <span class="keyword">typeof</span> val.then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">//谁先执行完谁直接resolve</span></span><br><span class="line">        val.then(resolve, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (++errs === promises.length)</span><br><span class="line">            reject(</span><br><span class="line">              <span class="keyword">new</span> AggregateError(<span class="string">`No Promise in Promise.any was resolved`</span>)</span><br><span class="line">            );</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 普通值</span></span><br><span class="line">        resolve(val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Promise-map限制并发"><a href="#Promise-map限制并发" class="headerlink" title="Promise.map限制并发"></a><code>Promise.map</code>限制并发</h4><p>通过传入 limit 参数限制最多同时并发的 promise 数量，每一个任务完成之后及时替换。</p>
<p>思路：</p>
<ol>
<li>把执行任务和并发启动分开，通过 for 循环的形式一次同时启动 limit 个任务，每个任务自行递归选择下一个</li>
<li>和 promise.all 一样的顺序判断，通过设定 index 使得输出按顺序，并通过设定 count 判断是否全部运行完成。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyPromiseMap = <span class="function">(<span class="params">promises, limit</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> results = [];</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>; <span class="comment">// 正在执行的序号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.min(limit, promises.length); i++) &#123;</span><br><span class="line">      <span class="comment">// 同时启动limit个任务</span></span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> currIndex = index; <span class="comment">// 存一下当前index</span></span><br><span class="line">      index++; <span class="comment">//每次递归都先自增</span></span><br><span class="line">      <span class="keyword">if</span> (promises[currIndex]) &#123;</span><br><span class="line">        <span class="comment">// 递归边界</span></span><br><span class="line">        promises[currIndex].then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">          results[currIndex] = res;</span><br><span class="line">          <span class="keyword">if</span> (++count === promises.length) resolve(results);</span><br><span class="line">          <span class="keyword">else</span> next(); <span class="comment">// 每个任务执行完后，单独递归调用下一个</span></span><br><span class="line">        &#125;, reject);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="手写-async-pool"><a href="#手写-async-pool" class="headerlink" title="手写 async pool"></a>手写 async pool</h2><p>async pool 和 promise map 的功能类似，即限制 promise 任务的并发数量，但是实现方式不同，下面是一种实现方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async pool一般不直接接收promise数组，而是通过函数生成</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPool</span>(<span class="params">poolLimit, array, iteratorFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ret = []; <span class="comment">// 存储所有的异步任务</span></span><br><span class="line">  <span class="keyword">const</span> executing = []; <span class="comment">// 存储正在执行的异步任务</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> array) &#123;</span><br><span class="line">    <span class="comment">// 调用iteratorFn函数创建promise</span></span><br><span class="line">    <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> iteratorFn(item, array));</span><br><span class="line">    ret.push(p); <span class="comment">// 同步任务，保存新的异步任务</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当poolLimit值小于或等于总任务个数时，进行并发控制</span></span><br><span class="line">    <span class="keyword">if</span> (poolLimit &lt;= array.length) &#123;</span><br><span class="line">      <span class="comment">// 创建e，e在p执行完后从正在执行的任务数组里删掉</span></span><br><span class="line">      <span class="keyword">const</span> e = p.then(<span class="function">() =&gt;</span> executing.splice(executing.indexOf(e), <span class="number">1</span>));</span><br><span class="line">      executing.push(e); <span class="comment">// 保存正在执行的异步任务</span></span><br><span class="line">      <span class="keyword">if</span> (executing.length &gt;= poolLimit) &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">Promise</span>.race(executing); <span class="comment">// 等待较快的任务执行完成</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个的实现逻辑是这样的：</p>
<ol>
<li>遍历数组，为每个数组中的项创建 promise 对象。需要注意的是，这个遍历在这里很重要，下面会说到</li>
<li>创建 p，然后创建 e。e 就相当于是执行完具体的任务 p 之后，再在 executing 数组中把 e 删掉；也就是说在这个 pool 内，谁执行完谁就把自己顺便清除掉了</li>
<li>使用 Promise.race 执行任务队列。相当于让 pool 中的任务竞争完成。下面举个例子</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如现在有三个任务，executing数组内 = [a,b,c]</span><br><span class="line">调用Promise.race执行三个任务，假设a先执行完</span><br><span class="line">a就是上面的e，因此会从executing数组内删掉自己，变成[b,c]</span><br><span class="line">然后，跳出await，进入下一次循环，取数组中的下一项（比如e）再继续，executing数组变成[b,c,e]</span><br><span class="line">重复上面几步，直到executing.length &lt; poolLimit，最后剩下的几个任务并发执行。</span><br></pre></td></tr></table></figure>

<p>核心有两个：</p>
<ul>
<li>每个任务执行完成后会从数组中删掉自己，腾出空间；</li>
<li>利用 <code>await Promise.race(executing)</code>，等待正在执行任务列表中较快的任务执行完成之后，才会继续执行下一次循环。</li>
</ul>
<h2 id="实现异步-sum-add"><a href="#实现异步-sum-add" class="headerlink" title="实现异步 sum/add"></a>实现异步 sum/add</h2><blockquote>
<p>请实现以下 sum 函数，只能调用 add 进行实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  请实现一个 sum 函数，接收一个数组 arr 进行累加，并且只能使用add异步方法</span></span><br><span class="line"><span class="comment">  add 函数已实现，模拟异步请求后端返回一个相加后的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>追加问题：如何控制 add 异步请求的并发次数</p>
</blockquote>
<p>这道题实际上是考察异步并行和串行。add 函数模拟的是一个返回 promise 的函数，要求对这个函数传入数组中的参数，依次计算。</p>
<p>基本的思路是串行实现，即 for await。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = arr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    res = <span class="keyword">await</span> add(res, arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不用 await，就可以这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="built_in">Promise</span>.resolve(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    res = res.then(<span class="function">(<span class="params">val</span>) =&gt;</span> add(val, arr[i]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce也可</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(</span><br><span class="line">    <span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre.then(<span class="function">(<span class="params">res</span>) =&gt;</span> add(res, cur)),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">0</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果考虑并行，既然是把数组变为 promise 形式，那么首先想到的肯定是<code>Promise.all</code>。我们把数组的每两项都变成 add 函数，再按照归并的方式，两两合并计算即可。<br>关键就在这个“归并”，到底要怎么把计算的结果两两合并？<br>首先<code>Promise.all</code>会返回一个结果数组。第一步中会返回所有的两两计算的结果数组，并且这个数组是一个<code>number[]</code>。因此我们可以<strong>递归</strong>再把这个数组传入 sum，最后直到数组只有一项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length === <span class="number">1</span>) <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 分割数组用到了上面的chunk，将数组分为n个两份</span></span><br><span class="line">  <span class="comment">// 这里注意，因为有可能两两分组还剩下一个，所以需要判断一下y是否存在</span></span><br><span class="line">  <span class="keyword">const</span> promises = chunk(arr, <span class="number">2</span>).map(<span class="function">(<span class="params">[x, y]</span>) =&gt;</span> (y ? add(x, y) : x));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises).then(<span class="function">(<span class="params">resArr</span>) =&gt;</span> sum(resArr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个方法仍然有问题。比如有 10000 个数据，那第一次就会发送 5000 个请求，网络拥堵了，控制成只能同时发送 10 个请求怎么办？<br>这就需要借用 Promise.map。只需要把 Promise.all 改成 map 即可。<br>（假设 Promise.map 代码已有）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr, limit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length === <span class="number">1</span>) <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> promises = chunk(arr, <span class="number">2</span>).map(<span class="function">(<span class="params">[x, y]</span>) =&gt;</span> (y ? add(x, y) : x));</span><br><span class="line">  <span class="keyword">return</span> promiseMap(promises, limit).then(<span class="function">(<span class="params">resArr</span>) =&gt;</span> sum(resArr, limit));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>并行还有一种写法更直观，本质上也是每次放入相邻两个值的 add 调用结果，然后用 promise.all 执行，再把结果（原先是 n 个 promise，结果就是 n/2 个 promise）递归</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (args.length === <span class="number">1</span>) <span class="keyword">return</span> args[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> tasks = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; args.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">    tasks.push(add(args[i], args[i + <span class="number">1</span>] || <span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(tasks);</span><br><span class="line">  <span class="keyword">return</span> sum(...results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写-call-apply-和-bind"><a href="#手写-call-apply-和-bind" class="headerlink" title="手写 call apply 和 bind"></a>手写 call apply 和 bind</h2><p>call 和 apply 的实现思路类似，都是作用在函数上，参数是要设置的上下文和调用时传入的参数。</p>
<p>先来说 call：<br>call 方法应该在<code>Function.prototype</code>上，并且 call 内部的 this 应该是点号前面的函数。因此可以让这个函数在传入参数（context）下调用，再返回结果即可。<br>关键在于，怎么实现“函数在 context 下调用”：可以给这个 context 添加一个当前函数属性（即 this）并调用，然后删去并返回返回值即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mycall = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) <span class="keyword">return</span>; <span class="comment">//this就是call前面的函数，比如fn.call(...)的this就是fn</span></span><br><span class="line">  context = context || <span class="built_in">window</span>; <span class="comment">//如果没有指定参数就是window</span></span><br><span class="line">  context.fn = <span class="built_in">this</span>; <span class="comment">//给context添加一个属性，这个属性就是当前的函数</span></span><br><span class="line">  <span class="keyword">let</span> res = context.fn(...args); <span class="comment">//在context上调用函数</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn; <span class="comment">//删去这个属性</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>apply 和 call 只差在参数传递方式，其实改一点就好了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myapply = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是这两个方法都有漏洞：如果 fn 和 context 上某个属性同名，就会删去原先的方法。<br>因此可以把 fn 改为 Symbol，保证不会影响旧属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mycall = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">const</span> fnSymbol = <span class="built_in">Symbol</span>();</span><br><span class="line">  context[fnSymbol] = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> res = context[fnSymbol](...args);</span><br><span class="line">  <span class="keyword">delete</span> context[fnSymbol];</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>对于 bind，其实主要是返回值不同，bind 会返回绑定好的函数，因此把调用封装在要返回的函数内部即可：<br>最简单的 bind：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 箭头函数保证返回的this是外层的</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...rest</span>) =&gt;</span> <span class="built_in">this</span>.apply(context, [...args, ...rest]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然还要亿些细节，详见<a target="_blank" rel="noopener" href="https://github.com/sisterAn/JavaScript-Algorithms/issues/81">https://github.com/sisterAn/JavaScript-Algorithms/issues/81</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mybind = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//这里是考虑到返回的函数有可能作为构造函数的情况</span></span><br><span class="line">    <span class="comment">//两个this不一样；作为调用函数的this现在是fn；现在的this是fn中的this，即如果返回的函数用作构造函数，这个this应该指向实例</span></span><br><span class="line">    <span class="comment">//因此需要判定一下fn内部的this是不是返回函数的实例，如果是的话就不改变指向</span></span><br><span class="line">    <span class="keyword">return</span> fn.apply(</span><br><span class="line">      <span class="built_in">this</span> <span class="keyword">instanceof</span> Fn ? <span class="built_in">this</span> : context,</span><br><span class="line">      args.concat(<span class="built_in">arguments</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  Fn.prototype = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">  <span class="keyword">return</span> Fn;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>bind 的链式调用会无视掉后面的绑定，多次调用只会以第一个为准。也就是说 bind 返回的函数不能再用 bind 绑定为其他的上下文和参数。原因是第一次绑定之后的<code>context</code>不能再改变了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> func.call(</span><br><span class="line">  context, <span class="comment">// 这个context是死绑的</span></span><br><span class="line">  ...args,</span><br><span class="line">  ...args1</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果能够改变这个死绑，就可以实现软绑定<br>为此可以单独实现一个<code>softBind</code>，多次调用以最后一个为准。其原理是<code>!this || this === window ? context : this</code>，即如果 this 为空就把新的 context 绑定，相当于覆盖了前面的绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.softBind = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">const</span> bound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(!<span class="built_in">this</span> || <span class="built_in">this</span> === <span class="built_in">window</span> ? context : <span class="built_in">this</span>, [</span><br><span class="line">      ...arguments,</span><br><span class="line">      ...args,</span><br><span class="line">    ]);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> bound;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="手写-instanceof"><a href="#手写-instanceof" class="headerlink" title="手写 instanceof"></a>手写 instanceof</h2><p>原理很简单，参数传入父子，获取父对象（函数）的<code>prototype</code>和子对象的<code>__proto__</code>比较，如果没有就沿着子对象的<code>__proto__</code>循环向上找，直到为 null 或找到为止</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Instanceof</span>(<span class="params">parent, child</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cp = <span class="built_in">Object</span>.getPrototypeOf(child);</span><br><span class="line">  <span class="keyword">const</span> pp = parent.prototype;</span><br><span class="line">  <span class="keyword">while</span> (cp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pp === cp) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    cp = <span class="built_in">Object</span>.getPrototypeOf(cp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写-sleep-delay"><a href="#手写-sleep-delay" class="headerlink" title="手写 sleep/delay"></a>手写 sleep/delay</h2><p>sleep 函数使后面代码阻塞：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">delay</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve,delay)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">testFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">1000</span>)</span><br><span class="line">  <span class="comment">//后续代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">sleep(<span class="number">1000</span>).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//后续代码</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>delay 使被传入的部分延迟执行，并阻塞后面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">func, second, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(func(...args));</span><br><span class="line">    &#125;, seconds);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> delay(<span class="function">(<span class="params">name</span>) =&gt;</span> <span class="string">`hello,<span class="subst">$&#123;name&#125;</span>`</span>, <span class="number">1000</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line">  res; <span class="comment">// 1秒后返回 hello,jack</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写-compose-函数"><a href="#手写-compose-函数" class="headerlink" title="手写 compose 函数"></a>手写 compose 函数</h2><p>compose 函数实现的效果类似数学中的多次函数。比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(x) = x + 10</span><br><span class="line">g(x) = x * 5</span><br><span class="line">f(g(x)) = x*5 + 10</span><br></pre></td></tr></table></figure>

<p>要实现的 compose 也要满足这个效果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fx = <span class="function">(<span class="params">x</span>) =&gt;</span> x + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> gx = <span class="function">(<span class="params">x</span>) =&gt;</span> x * <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> fgx = compose(fx, gx);</span><br><span class="line">fgx(<span class="number">5</span>); <span class="comment">// 5 * 5 + 10 = 35</span></span><br></pre></td></tr></table></figure>

<p>思路如下：</p>
<p>compose 为了符合数学上的定义，应当是从内向外计算的。因此应该按照其传入的参数从右向左计算。最简单的实现是利用 reduce：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fns.reduce(<span class="function">(<span class="params">f, g</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> f(g(...args));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>reduce 内部每次返回的都是一个函数。当 reduce 叠加时，相当于不断叠加<strong>外部</strong>包裹的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次</span></span><br><span class="line">total = <span class="function">(<span class="params">...args</span>) =&gt;</span> f(g(...args))</span><br><span class="line"><span class="comment">// 后续</span></span><br><span class="line">f = <span class="function">(<span class="params">...args</span>) =&gt;</span> f(g(...args))</span><br><span class="line">g = h(x)</span><br><span class="line">total = <span class="function">(<span class="params">...args</span>) =&gt;</span> f(h(...args)) = f(g(h(..args)))</span><br><span class="line"><span class="comment">// 依次类推</span></span><br></pre></td></tr></table></figure>

<h2 id="手写对象扁平化和逆扁平化"><a href="#手写对象扁平化和逆扁平化" class="headerlink" title="手写对象扁平化和逆扁平化"></a>手写对象扁平化和逆扁平化</h2><h3 id="扁平化"><a href="#扁平化" class="headerlink" title="扁平化"></a>扁平化</h3><p>要求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123;</span><br><span class="line">    <span class="attr">b</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">d</span>: &#123; <span class="attr">e</span>: <span class="number">5</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">b</span>: [<span class="number">1</span>, <span class="number">3</span>, &#123; <span class="attr">a</span>: <span class="number">2</span>, <span class="attr">b</span>: <span class="number">3</span> &#125;],</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//flatten(obj) 结果返回如下</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//  &#x27;a.b&#x27;: 1,</span></span><br><span class="line"><span class="comment">//  &#x27;a.c&#x27;: 2,</span></span><br><span class="line"><span class="comment">//  &#x27;a.d.e&#x27;: 5,</span></span><br><span class="line"><span class="comment">//  &#x27;b[0]&#x27;: 1,</span></span><br><span class="line"><span class="comment">//  &#x27;b[1]&#x27;: 3,</span></span><br><span class="line"><span class="comment">//  &#x27;b[2].a&#x27;: 2,</span></span><br><span class="line"><span class="comment">//  &#x27;b[2].b&#x27;: 3</span></span><br><span class="line"><span class="comment">//   c: 3</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>是一个不需要任何剪枝的回溯问题。从根对象向下遍历到值为非对象为止，把沿途的路径记录下来，插入到新对象中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123;</span><br><span class="line">    <span class="attr">b</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">d</span>: &#123; <span class="attr">e</span>: <span class="number">5</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">b</span>: [<span class="number">1</span>, <span class="number">3</span>, &#123; <span class="attr">a</span>: <span class="number">2</span>, <span class="attr">b</span>: <span class="number">3</span> &#125;],</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isObject = <span class="function">(<span class="params">val</span>) =&gt;</span> <span class="keyword">typeof</span> val === <span class="string">&quot;object&quot;</span> &amp;&amp; val !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(obj)) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">cur, prefix</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isObject(cur)) &#123;</span><br><span class="line">      <span class="keyword">const</span> key = prefix.join(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">      res[key] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> cur) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(cur)) prefix.push(<span class="string">`[<span class="subst">$&#123;key&#125;</span>]`</span>);</span><br><span class="line">      <span class="keyword">else</span> prefix.push(key);</span><br><span class="line">      dfs(cur[key], prefix);</span><br><span class="line">      prefix.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  dfs(obj, []);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="逆扁平化"><a href="#逆扁平化" class="headerlink" title="逆扁平化"></a>逆扁平化</h3><blockquote>
<p>写一个函数，将 entry 格式转化成 output 的格式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entry = &#123;</span><br><span class="line">  <span class="string">&quot;a.b.c.dd&quot;</span>: <span class="string">&quot;value&quot;</span>,</span><br><span class="line">  <span class="string">&quot;a.d.xx&quot;</span>: <span class="string">&quot;val&quot;</span>,</span><br><span class="line">  <span class="string">&quot;a.e&quot;</span>: <span class="string">&quot;v&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 要求转换成如下对象</span></span><br><span class="line"><span class="keyword">var</span> output = &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123;</span><br><span class="line">    <span class="attr">b</span>: &#123;</span><br><span class="line">      <span class="attr">c</span>: &#123;</span><br><span class="line">        <span class="attr">dd</span>: <span class="string">&quot;value&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">d</span>: &#123;</span><br><span class="line">      <span class="attr">xx</span>: <span class="string">&quot;val&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">e</span>: <span class="string">&quot;v&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>实现思路<br>递归。每次处理一个属性的键，有点像前缀树的思路</p>
<ul>
<li>每次递归的 level 表示“层级”，即键数组的序号。比如键为<code>a.b.c.d</code>，拆成数组<code>[a,b,c,d]</code>，那么每次递归就是从第一项开始，每递归一次向后走一个，然后把上一层创建的对象传下去，本层递归在上一层创建的对象上添加属性<ul>
<li>如果属性存在，那就继续往下走</li>
<li>如果属性不存在，就创建属性，初始化为空对象</li>
</ul>
</li>
<li>当<code>level === keysArr.length - 1</code>，表示走到了最后一个属性，这时就把值赋给这个属性即可。</li>
</ul>
<p>这是基础的版本，暂时没有处理数组的情况。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deFlat = <span class="function">(<span class="params">object</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!object) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> entries = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(object)) &#123;</span><br><span class="line">    <span class="keyword">const</span> keysArr = key.split(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    entries.push([keysArr, value]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; entries.length; i++) &#123;</span><br><span class="line">    dfs(<span class="number">0</span>, res, entries[i][<span class="number">0</span>], entries[i][<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">level, parentObj, keysArr, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level &gt;= keysArr.length) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> key = keysArr[level];</span><br><span class="line">    <span class="keyword">if</span> (keysArr[level] != <span class="literal">null</span> &amp;&amp; level &lt; keysArr.length - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (parentObj[key] != <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> parentObj[key] === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">        dfs(level + <span class="number">1</span>, parentObj[key], keysArr, value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parentObj[key] = &#123;&#125;;</span><br><span class="line">        dfs(level + <span class="number">1</span>, parentObj[key], keysArr, value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (level === keysArr.length - <span class="number">1</span>) &#123;</span><br><span class="line">      parentObj[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="手写虚拟-dom-转化为真实-dom"><a href="#手写虚拟-dom-转化为真实-dom" class="headerlink" title="手写虚拟 dom 转化为真实 dom"></a>手写虚拟 dom 转化为真实 dom</h2><p>虚拟 dom 的大致结构如下：</p>
<p><img src="https://pic.imgdb.cn/item/637cf98116f2c2beb1f0c0fc.jpg"></p>
<p>需要转化为真实 dom，其实也就是递归遍历虚拟 dom 对象，然后利用几个创建 dom 对象和插入 dom 的 api 实现。<br>要用到的 api 包括：</p>
<ul>
<li><code>document.createElement(type)</code>，其中 type 设置为 tag 即可，但对于 tag 为非 dom 元素节点需要特殊处理</li>
<li><code>document.createTextNode(value)</code>，创建文本节点，对于类型为非对象而是字符串的元素可以创建文本节点</li>
<li><code>node.setAttribute(attr,value)</code>，为节点设置属性</li>
<li><code>node.appendChild(node)</code>，插入创建的 dom 节点</li>
</ul>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    node = <span class="built_in">document</span>.createTextNode(vnode);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; tag, key, children, attrs &#125; = vnode;</span><br><span class="line">    node = <span class="built_in">document</span>.createElement(tag);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(attrs).length !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> attr <span class="keyword">of</span> <span class="built_in">Object</span>.keys(attrs)) &#123;</span><br><span class="line">        node.setAttribute(attr, attrs[attr]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(children).length !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> child <span class="keyword">of</span> children) &#123;</span><br><span class="line">        render(child, node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  container.appendChild(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vnode 的类型可能有多种。在 React 中一共有七种 vnode 类型；除去不好处理的 Fragment 类型，其他的类型还包括：</p>
<ul>
<li>数组</li>
<li>组件，包括函数组件和类组件</li>
<li>三元运算</li>
<li>函数执行</li>
</ul>
<p>后两个其实在 jsx 解析过程中就转化为了具体的变量，因此需要额外考虑的也只有组件和数组两种情况。<br>如果 vnode 是数组，那就再递归一次，但 container 不改变<br>如果 vnode 是函数，就执行，得到的返回值作为新的 vnode 操作即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> type = <span class="built_in">Object</span>.prototype.toString.call(vnode).slice(<span class="number">8</span>, -<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">&quot;String&quot;</span>) &#123;</span><br><span class="line">    node = <span class="built_in">document</span>.createTextNode(vnode);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&quot;Object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; tag, key, children, attrs &#125; = vnode;</span><br><span class="line">    node = <span class="built_in">document</span>.createElement(tag);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(attrs).length !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> attr <span class="keyword">of</span> <span class="built_in">Object</span>.keys(attrs)) &#123;</span><br><span class="line">        node.setAttribute(attr, attrs[attr]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(children).length !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> child <span class="keyword">of</span> children) &#123;</span><br><span class="line">        render(child, node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&quot;Array&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(container);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> val <span class="keyword">of</span> vnode) &#123;</span><br><span class="line">      render(val, container);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&quot;Function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = vnode();</span><br><span class="line">    render(res, container);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  container.appendChild(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写-JSON-stringify"><a href="#手写-JSON-stringify" class="headerlink" title="手写 JSON.stringify"></a>手写 JSON.stringify</h2><p>利用递归逐层解析并转化为 json 格式。<br>注意转化过程中有一些特殊值会被忽略或改写：</p>
<ul>
<li>对象中的 function、symbol、undefined 会被忽略，即直接没有这个属性；boolean、number、string 会保持原样</li>
<li>数组中的 function、symbol、undefined 会被改为 null</li>
</ul>
<p>具体实现上，对于某一层对象，设置一个数组用于存储当前对象的每个值的遍历结果。对于每个值都递归一次，非对象会返回原值或忽略掉，而对象会返回递归之后的结果（该对象的 stringify 结果），最后将数组中的值用<code>join(&#39;,&#39;)</code>连接起来，再根据数组或是对象在外部加上<code>&#123;&#125;</code>或<code>[]</code>就可以。</p>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringify</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> type = <span class="keyword">typeof</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">&quot;number&quot;</span> || type === <span class="string">&quot;boolean&quot;</span>) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">&quot;string&quot;</span>) <span class="keyword">return</span> <span class="string">`&quot;<span class="subst">$&#123;obj&#125;</span>&quot;`</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> isArray = <span class="built_in">Array</span>.isArray(obj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">let</span> val = obj[key];</span><br><span class="line">    val = stringify(val);</span><br><span class="line">    <span class="keyword">if</span> (val === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isArray) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">else</span> val = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前obj是对象，那么每个值都是`key:value`形式，否则就只是value</span></span><br><span class="line">    res.push((isArray ? <span class="string">&quot;&quot;</span> : <span class="string">`&quot;<span class="subst">$&#123;key&#125;</span>&quot;:`</span>) + val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isArray ? <span class="string">`[<span class="subst">$&#123;res.join(<span class="string">&quot;,&quot;</span>)&#125;</span>]`</span> : <span class="string">`&#123;<span class="subst">$&#123;res.join(<span class="string">&quot;,&quot;</span>)&#125;</span>&#125;`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写-LazyMan-类"><a href="#手写-LazyMan-类" class="headerlink" title="手写 LazyMan 类"></a>手写 LazyMan 类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">实现一个LazyMan，可以按照以下方式调用:</span><br><span class="line">LazyMan(“Hank”)输出:</span><br><span class="line">Hi! This is Hank!</span><br><span class="line"></span><br><span class="line">LazyMan(“Hank”).sleep(10).eat(“dinner”)输出</span><br><span class="line">Hi! This is Hank!</span><br><span class="line">//等待10秒..</span><br><span class="line">Wake up after 10</span><br><span class="line">Eat dinner~</span><br><span class="line"></span><br><span class="line">LazyMan(“Hank”).eat(“dinner”).eat(“supper”)输出</span><br><span class="line">Hi This is Hank!</span><br><span class="line">Eat dinner~</span><br><span class="line">Eat supper~</span><br><span class="line"></span><br><span class="line">LazyMan(“Hank”).sleepFirst(5).eat(“supper”)输出</span><br><span class="line">//等待5秒</span><br><span class="line">Wake up after 5</span><br><span class="line">Hi This is Hank!</span><br><span class="line">Eat supper</span><br></pre></td></tr></table></figure>

<p>这道题有两个思路</p>
<ol>
<li>最直观的，通过阻塞执行线程实现 sleep；再利用微任务会在宏任务之前执行的特点，sleepFirst 写成微任务，其他的用 setTimeout 包裹，保证 sleepFirst 最先执行。</li>
<li>利用任务队列；每个链式调用会放入一个任务，eat 放入同步任务，两个 sleep 放入定时器任务；每个任务调用时，会调用其后的任务执行（<code>next()</code>），这样依次链接执行。而 sleepFirst 放入队列最前即可。</li>
</ol>
<p>关于链式调用的问题：<br>链式调用的关键的返回 this，并且应该是在同步部分返回。那为什么依然还可以依次执行呢？<br>关键在于“调用”和“执行”的区分。return this 的部分会在同步任务中一次性完成，也就是一次把所有任务都先放进队列；然后再进入异步任务阶段，按照一定顺序执行。</p>
<p>阻塞写法：不能用 await 阻塞，因为 async 会强制返回 promise，导致链式调用失效。<br>方法是用 while 阻塞同步任务，但是会导致卡死，不是很好。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyMan</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.say();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`hello <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>), <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">eat</span>(<span class="params">food</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Eat <span class="subst">$&#123;food&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sleep</span>(<span class="params">delay</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">Date</span>.now() - now &lt; delay * <span class="number">1000</span>) &#123;</span><br><span class="line">      <span class="comment">// wait</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Wake up after <span class="subst">$&#123;delay&#125;</span>`</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sleepFirst</span>(<span class="params">delay</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">      <span class="keyword">while</span> (<span class="built_in">Date</span>.now() - now &lt; delay * <span class="number">1000</span>) &#123;</span><br><span class="line">        <span class="comment">// wait</span></span><br><span class="line">      &#125;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Wake up after <span class="subst">$&#123;delay&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务队列写法：核心思想就是先把所有任务按照顺序放入 tasks 数组，再依次取出来执行。任务有同步异步之分，执行定时器任务时，就相当于 sleep 了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_LazyMan</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.tasks = [];</span><br><span class="line">    <span class="built_in">this</span>.tasks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">      <span class="built_in">this</span>.next(); <span class="comment">// 每个task都必须调用next，不然会卡住</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 这里一定是异步，因为必须需要先同步收集所有任务，再开始依次执行。</span></span><br><span class="line">    <span class="comment">// 这个setTimeout是第一个执行的异步任务，相当于“开始执行”</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.next();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> task = <span class="built_in">this</span>.tasks.shift(); <span class="comment">// 取第一个任务执行即可，每个任务会自己调用下一个</span></span><br><span class="line">    <span class="keyword">if</span> (task) task();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">eat</span>(<span class="params">food</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// eat放入同步函数</span></span><br><span class="line">    <span class="built_in">this</span>.tasks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Eat <span class="subst">$&#123;food&#125;</span>`</span>);</span><br><span class="line">      <span class="built_in">this</span>.next();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sleep</span>(<span class="params">delay</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// sleep放入定时器异步函数，delay之后调用next执行下一个</span></span><br><span class="line">    <span class="built_in">this</span>.tasks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Wake up after <span class="subst">$&#123;delay&#125;</span>`</span>);</span><br><span class="line">        <span class="built_in">this</span>.next();</span><br><span class="line">      &#125;, delay * <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sleepFirst</span>(<span class="params">delay</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 注意unshift，将会第一个执行</span></span><br><span class="line">    <span class="built_in">this</span>.tasks.unshift(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Wake up First after <span class="subst">$&#123;delay&#125;</span>`</span>);</span><br><span class="line">        <span class="built_in">this</span>.next();</span><br><span class="line">      &#125;, delay * <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写-LRUCache-类"><a href="#手写-LRUCache-类" class="headerlink" title="手写 LRUCache 类"></a>手写 LRUCache 类</h2><p>LRU 就是操作系统中的那个 LRU。<br>实现可以借助 map，关键是怎么在 map 中删除元素和移动位置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除map中的元素</span></span><br><span class="line"><span class="comment">// 直接用delete传入键名就行</span></span><br><span class="line">map.delete(map.keys().next().value); <span class="comment">// map中的第一个值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改变位置</span></span><br><span class="line"><span class="comment">// 删除再插入即可</span></span><br><span class="line"><span class="keyword">const</span> value = map.get(key);</span><br><span class="line">map.delete(key);</span><br><span class="line">map.set(key, value);</span><br></pre></td></tr></table></figure>

<p>整体代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">limit</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.limit = limit;</span><br><span class="line">    <span class="built_in">this</span>.cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.cache.has(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="built_in">this</span>.cache.get(key);</span><br><span class="line">    <span class="built_in">this</span>.cache.delete(key);</span><br><span class="line">    <span class="built_in">this</span>.cache.set(key, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">put</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.cache.has(key)) <span class="built_in">this</span>.cache.delete(key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.cache.size &gt;= <span class="built_in">this</span>.limit) &#123;</span><br><span class="line">      <span class="built_in">this</span>.cache.delete(<span class="built_in">this</span>.cache.keys().next().value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.cache.set(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写发布-订阅类-Event"><a href="#手写发布-订阅类-Event" class="headerlink" title="手写发布/订阅类 Event"></a>手写发布/订阅类 Event</h2><blockquote>
<p>使用 JS 实现一个发布订阅器，Event，示例如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> e = <span class="keyword">new</span> Event();</span><br><span class="line"></span><br><span class="line">e.on(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">console</span>.log(x.id));</span><br><span class="line"></span><br><span class="line">e.once(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">console</span>.log(id));</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt; 3</span></span><br><span class="line">e.emit(<span class="string">&quot;click&quot;</span>, &#123; <span class="attr">id</span>: <span class="number">3</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt; 4</span></span><br><span class="line">e.emit(<span class="string">&quot;click&quot;</span>, &#123; <span class="attr">id</span>: <span class="number">4</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>API 如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">emit</span>(<span class="params">type, ...args</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">type, listener</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">once</span>(<span class="params">type, listener</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">off</span>(<span class="params">type, listener</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>基本思路比较简单，可以用一个数组存储注册的事件；在 emit 时，寻找该事件并执行对应的监听函数即可。</p>
<p>但是这道题有其他特点：同一个事件可能会注册多个处理函数。同时，on 和 once 的注册应该分开，即使回调相同。</p>
<p>因此存储注册事件的数据结构就不能选取一个单数组，应该这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> events = &#123;</span><br><span class="line">  <span class="attr">click</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">once</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">listener</span>: callback,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">listener</span>: callback,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对 once 的处理上，只需要在触发时检查 once 的值，如果为 true 就用 off 取消注册即可。</p>
<p>具体代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Event</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.events = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">emit</span>(<span class="params">type, ...args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> events = <span class="built_in">this</span>.events[type];</span><br><span class="line">    <span class="keyword">if</span> (events) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">of</span> events) &#123;</span><br><span class="line">        e.listener(...args);</span><br><span class="line">        <span class="keyword">if</span> (e.once) <span class="built_in">this</span>.off(type, e.listener);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">type, listener</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> events = <span class="built_in">this</span>.events[type];</span><br><span class="line">    <span class="keyword">if</span> (events) &#123;</span><br><span class="line">      events.push(&#123;</span><br><span class="line">        listener,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.events[type] = [&#123; listener &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">once</span>(<span class="params">type, listener</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> events = <span class="built_in">this</span>.events[type];</span><br><span class="line">    <span class="keyword">if</span> (events) &#123;</span><br><span class="line">      events.push(&#123;</span><br><span class="line">        listener,</span><br><span class="line">        <span class="attr">once</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.events[type] = [&#123; listener, <span class="attr">once</span>: <span class="literal">true</span> &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个off取消监听是依靠listener查找的</span></span><br><span class="line">  <span class="function"><span class="title">off</span>(<span class="params">type, listener</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> events = <span class="built_in">this</span>.events[type];</span><br><span class="line">    <span class="keyword">if</span> (events)</span><br><span class="line">      <span class="built_in">this</span>.events[type] = events.filter(<span class="function">(<span class="params">ev</span>) =&gt;</span> ev.listener !== listener);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写-batcher-实现异步任务队列"><a href="#手写-batcher-实现异步任务队列" class="headerlink" title="手写 batcher 实现异步任务队列"></a>手写 batcher 实现异步任务队列</h2><p>要求实现一个函数，像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> executeCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 要求就是这个函数只能被执行一次</span></span><br><span class="line">  executeCount++;</span><br><span class="line">  <span class="keyword">return</span> nums.map(<span class="function">(<span class="params">x</span>) =&gt;</span> x * <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> batcher = <span class="function">(<span class="params">f</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// todo 实现 batcher 函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> batchedFn = batcher(fn);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [r1, r2, r3] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">    batchedFn([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]),</span><br><span class="line">    batchedFn([<span class="number">4</span>, <span class="number">5</span>]),</span><br><span class="line">    batchedFn([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]),</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//满足以下 test case</span></span><br><span class="line">  assert(r1).tobe([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]); <span class="comment">// 即r1r2r3的值分别为tobe里边的</span></span><br><span class="line">  assert(r2).tobe([<span class="number">8</span>, <span class="number">10</span>]);</span><br><span class="line">  assert(r3).tobe([<span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>]);</span><br><span class="line">  assert(executeCount).tobe(<span class="number">1</span>); <span class="comment">// executeCount必须是1，也就是说fn只能执行一次</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这道题的关键在于要获取三个数组的 fn 结果，但是要求 fn 只能执行一次。<br>因此最基本是思路是，想办法把这三个调用的数组组合成一个数组，然后用 fn 处理一次数组，这三个函数再分别从中 slice 就可以。</p>
<p>这个思路关键就在于怎么先收集所有的值，并且收集完成之后还能继续交给这三个函数。可以想到的方法就是利用异步；如果把收集值的过程放到同步任务中，把 fn 的调用和最后的 slice 放到异步中，就可以实现这个效果。</p>
<p>具体来说，因为有一个 Promise.all，所以 batchedFn 应该是可以返回一个 Promise 的。<br>我们在 batcher 中存一个 Promise，里边是异步执行 fn 的操作。然后在 batcher 的返回值（即 batchedFn）中先用同步代码收集所有的参数数字，再在返回值中对上面的 Promise 执行一个 then。这个 then 就会被 Promiseall 并行执行，此时因为 fn 已经执行过，再从中 slice 值即可。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> batcher = <span class="function"><span class="params">f</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> nums = []</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(f(nums)))</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> start = nums.length</span><br><span class="line">    nums.push(...arr)</span><br><span class="line">    <span class="keyword">return</span> p.then(<span class="function">(<span class="params">res</span>)=&gt;</span>res.slice(start,start + arr.length))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本思路是这样，还有其他写法，比上面这个更容易理解一点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> batcher = <span class="function">(<span class="params">f</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> nums = [];</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    nums.push(...arr);</span><br><span class="line">    <span class="keyword">const</span> start = count++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start === <span class="number">0</span>) res = f(nums);</span><br><span class="line">        resolve(nums.splice(<span class="number">0</span>, arr.length));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="手写超时取消请求"><a href="#手写超时取消请求" class="headerlink" title="手写超时取消请求"></a>手写超时取消请求</h2><p>即实现 axios 中配置的 timeout 效果，当请求超时时报错并终止请求。也就是说，相当于实现了一个 Promise 的“中断”；<br>Promise 一旦改变状态就不能再更改。利用这一点，可以采用“抢跑”的方法，通过在异步任务之前 reject，阻止后面的 resolve 或 reject 的执行。</p>
<p>就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cancelFn = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> uploadFn = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    cancelFn = <span class="function">() =&gt;</span> reject(<span class="string">&quot;cancel&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(val);</span><br><span class="line">    &#125;, <span class="number">5000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果在外部执行 cancelFn，这个 Promise 就会被“中断”，resolve 的值就不会传出来。<br>利用这个方法，我们可以同时开启这个 upload 任务和一个定时器。当定时器到时时执行 cancel，就可以中断任务的执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cancelFn = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> uploadFn = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    cancelFn = <span class="function">() =&gt;</span> reject(<span class="string">&quot;cancel&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(val);</span><br><span class="line">    &#125;, <span class="number">5000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> countDown = <span class="function">(<span class="params">time</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(cancelFn, time);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uploadFn().then(<span class="built_in">console</span>.log);</span><br><span class="line">countDown(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<p>更好的方式是利用 Promise.race。因为 race 在一个 Promise 状态改变之后，另一个 Promise 的返回值会被忽略，即使另一个已经完成也不会再接受；因此可以让 upload 和倒计时任务在 Promise.race 中开启，这样如果倒计时完成并 reject，upload 就相当于被“中断”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cancelFn = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> uploadFn = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    cancelFn = <span class="function">() =&gt;</span> reject(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">5000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uploadTimeLimit = <span class="function">(<span class="params">limit</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (cancelFn) cancelFn();</span><br><span class="line">    &#125;, limit);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> upload = <span class="function">(<span class="params">val, timout</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Promise</span>.race([uploadFn(val), uploadTimeLimit(timout)])</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.error(err));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">upload(<span class="string">&quot;hello world&quot;</span>, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<h2 id="计时器相关"><a href="#计时器相关" class="headerlink" title="计时器相关"></a>计时器相关</h2><h3 id="setTimeout-递归调用校准"><a href="#setTimeout-递归调用校准" class="headerlink" title="setTimeout 递归调用校准"></a>setTimeout 递归调用校准</h3><p>js 的 setTimeout、setInterval 的执行是不准确的。由于 js 单线程的缘故，有些情况可能会导致实际的 timeout 比设定的长，或实际的 interval 比指定的 interval 长。</p>
<p>gui 渲染、同步代码执行、微任务执行都会造成 timeout 的不准确。因此可以实现一个基本的校准机制，即通过每次计算任务前后的事件差来更改 timeout 的时间</p>
<p>如下代码。当 doSomeWork 函数内有耗时比较长的代码（比如 react 更新）时，offset 就会有比较明显的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startTimer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span>;</span><br><span class="line">  doSomeWork();</span><br><span class="line">  <span class="keyword">const</span> post = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">const</span> offset = post - now;</span><br><span class="line">  timeout = <span class="built_in">setTimeout</span>(startTimer, <span class="number">1000</span> - offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用-setTimeout-实现-setInterval"><a href="#用-setTimeout-实现-setInterval" class="headerlink" title="用 setTimeout 实现 setInterval"></a>用 setTimeout 实现 setInterval</h3><p>原理：和上面的调用校准类似。我们递归调用 myInertval 函数，每次检查调用的时间差值：</p>
<ul>
<li>如果差值和 interval 的差值&lt;=0，说明定时时间到了，立即执行</li>
<li>如果差值&gt;0，说明还没到，那就用 setTimeout 延迟剩余时间执行。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pre = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInterval</span>(<span class="params">fn, interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">const</span> remain = interval - (now - pre);</span><br><span class="line">  <span class="keyword">if</span> (remain &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    fn();</span><br><span class="line">    pre = now;</span><br><span class="line">    myInterval(fn, interval);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      myInterval(fn, interval);</span><br><span class="line">    &#125;, remain);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myInterval(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<h2 id="手写-dayjs-时间格式化功能"><a href="#手写-dayjs-时间格式化功能" class="headerlink" title="手写 dayjs 时间格式化功能"></a>手写 dayjs 时间格式化功能</h2><p>原理：参考 dayjs 源码。核心其实是这个正则的匹配</p>
<p>其他功能考虑：</p>
<ul>
<li>增加更多模式字符串，比如 M、MMMM 等，以及对星期的支持</li>
<li>类似 dayjs 函数的功能，函数本身可以接收一个时间，将这个时间进行格式化</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatDate</span>(<span class="params">formateStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dateMatchRegexp = <span class="regexp">/Y&#123;2,4&#125;|M&#123;2&#125;|D&#123;2&#125;|H&#123;2&#125;|m&#123;2&#125;|s&#123;2&#125;|S&#123;2&#125;/g</span>;</span><br><span class="line">  <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">const</span> dateInfo = &#123;</span><br><span class="line">    <span class="attr">second</span>: date.getSeconds().toString(),</span><br><span class="line">    <span class="attr">minute</span>: date.getMinutes().toString(),</span><br><span class="line">    <span class="attr">hour</span>: date.getHours().toString(),</span><br><span class="line">    <span class="attr">day</span>: date.getDate().toString(),</span><br><span class="line">    <span class="attr">month</span>: date.getMonth().toString(),</span><br><span class="line">    <span class="attr">year</span>: date.getFullYear().toString(),</span><br><span class="line">    <span class="attr">week</span>: date.getDay().toString(),</span><br><span class="line">    <span class="attr">ms</span>: date.getMilliseconds().toString(),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> addZero = <span class="function">(<span class="params">str, len</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> newStr = str;</span><br><span class="line">    <span class="keyword">while</span> (newStr.length &lt; len) &#123;</span><br><span class="line">      newStr = <span class="string">&quot;0&quot;</span> + newStr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newStr;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> matches = &#123;</span><br><span class="line">    <span class="attr">YYYY</span>: dateInfo.year,</span><br><span class="line">    <span class="attr">YY</span>: dateInfo.year.slice(<span class="number">2</span>),</span><br><span class="line">    <span class="attr">MM</span>: addZero(dateInfo.month, <span class="number">2</span>),</span><br><span class="line">    <span class="attr">DD</span>: addZero(dateInfo.day, <span class="number">2</span>),</span><br><span class="line">    <span class="attr">HH</span>: addZero(dateInfo.hour, <span class="number">2</span>),</span><br><span class="line">    <span class="attr">mm</span>: addZero(dateInfo.minute, <span class="number">2</span>),</span><br><span class="line">    <span class="attr">ss</span>: addZero(dateInfo.second, <span class="number">2</span>),</span><br><span class="line">    <span class="attr">SS</span>: addZero(dateInfo.ms, <span class="number">4</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> formateStr.replace(dateMatchRegexp, <span class="function">(<span class="params">match</span>) =&gt;</span> matches[match]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(formatDate(<span class="string">&quot;YYYY-MM-DD HH:mm:ss:SS&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>如果类似 dayjs 可以接受一个时间，其实也很简单，就是用 new Date 初始化这个时间就好。<br>最好改成类的形式，方便初始化时间</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dayjs</span>(<span class="params">dateStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Dayjs(dateStr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dayjs</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">dateStr</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isValid(dateStr)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.date = <span class="keyword">new</span> <span class="built_in">Date</span>(dateStr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">isValid</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(str).toString() !== <span class="string">&quot;Invalid Date&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">formatDate</span>(<span class="params">formateStr</span>)</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(dayjs(<span class="string">&#x27;2002-08-08 08:08:08&#x27;</span>).formatDate(<span class="string">&#x27;YYYY-MM-DD&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="手写大文件分片上传"><a href="#手写大文件分片上传" class="headerlink" title="手写大文件分片上传"></a>手写大文件分片上传</h2><p>分片上传的核心是使用 Blob.slice 方法对文件对象进行分割，然后把分割的文件块整理上传。<br>文件块需要使用 formdata 封装，可以在请求头或 formdata 的数据中告知后端当前文件块是第几块，是否分片完毕。<br>如果需要确定进度，需要通过 xhr，还需要单独统计当前上传成功/总共的片数。</p>
<p>简单实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setProgress</span>(<span class="params">chunkList</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> eachChunkPercent = <span class="keyword">new</span> <span class="built_in">Array</span>(chunkList.length);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">percent, index</span>) </span>&#123;</span><br><span class="line">    eachChunkPercent[index] = percent;</span><br><span class="line">    <span class="keyword">const</span> fullPercent =</span><br><span class="line">      eachChunkPercent.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b) / eachChunkPercent.length;</span><br><span class="line">    <span class="built_in">console</span>.log(fullPercent);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sliceFileUpload</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fileChunkList = getFileChunkList(file);</span><br><span class="line">  <span class="keyword">const</span> requestFileChunkList = fileChunkList.map(<span class="function">(<span class="params">chunk, index, list</span>) =&gt;</span></span><br><span class="line">    request(createFormData(chunk), <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      setProgress(list)(e.loaded / e.total, index);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">await</span> MyPromiseMap(requestFileChunkList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFormData</span>(<span class="params">fileObj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fd = <span class="keyword">new</span> FormData();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(fileObj)) &#123;</span><br><span class="line">    fd.append(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFileChunkList</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> chunkSize = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">const</span> chunkAmount = <span class="built_in">Math</span>.floor(file.size / chunkSize) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> chunkedFileList = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; chunkAmount; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> end = start + chunkSize &gt; file.size ? file.size : start + chunkSize;</span><br><span class="line">    chunkedFileList.push(&#123;</span><br><span class="line">      <span class="attr">file</span>: file.slice(start, end),</span><br><span class="line">      <span class="attr">index</span>: i,</span><br><span class="line">      <span class="attr">isEnd</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">filename</span>: file.name,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  chunkedFileList[chunkedFileList.length - <span class="number">1</span>].isEnd = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> chunkedFileList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">data, url, onProgress</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">&quot;post&quot;</span>, url);</span><br><span class="line">    xhr.send(data);</span><br><span class="line">    xhr.setRequestHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;mutiply/form-data&quot;</span>);</span><br><span class="line">    xhr.onload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(xhr.response);</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.upload.onprogress = onProgress;</span><br><span class="line">    xhr.onerror = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>如果需要错误处理、断点续传的话就比较麻烦。<br>错误处理思路：把 promiseMap 内部的 promiseAll 实现替换成类似 promiseAllSettled 的形式，这样可以等把所有文件上传完之后再获取哪些成功、哪些失败。<br>然后再通过递归重传失败的文件列表即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sliceFileUpload</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!file.length) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> fileChunkList = getFileChunkList(file);</span><br><span class="line">  <span class="keyword">const</span> requestFileChunkList = fileChunkList.map(<span class="function">(<span class="params">chunk, index, list</span>) =&gt;</span></span><br><span class="line">    request(createFormData(chunk), <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      setProgress(list)(e.loaded / e.total, index);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> MyPromiseMapAllSettled(requestFileChunkList);</span><br><span class="line">  <span class="keyword">const</span> failed = res.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> ...)</span><br><span class="line">  <span class="keyword">await</span> sliceFileUpload(filed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="随机数相关问题"><a href="#随机数相关问题" class="headerlink" title="随机数相关问题"></a>随机数相关问题</h1><p>随机数的核心是利用<code>Math.random()</code>。<br>如果要取<code>[0, n)</code>上的数，就可以利用<code>Math.floor(Math.random() * n)</code>。注意 random 生成的范围不包括 1，所以很多情况下要取[1,n]，应该是<code>Math.floor(Math.random() * n) + 1</code><br>如果要取<code>[0,n]</code>，那就是<code>Math.floor(Math.random() * (n + 1))</code></p>
<h2 id="从数组中随机取一个元素"><a href="#从数组中随机取一个元素" class="headerlink" title="从数组中随机取一个元素"></a>从数组中随机取一个元素</h2><p>主要思路有两个：</p>
<ol>
<li>利用<code>Math.random()</code>从随机位置上取数。即现有一个从 0-9 的数组，然后用 random 随机一个位置取。</li>
<li>直接用<code>Math.random()*n</code>取 0-n 的数</li>
</ol>
<p>基本代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sample</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * arr.length)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="随机字符串"><a href="#随机字符串" class="headerlink" title="随机字符串"></a>随机字符串</h2><blockquote>
<p>random 接收一个整数作为随机数的个数，最多生成 8 个随机数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// &#x27;a839ac&#x27;</span><br><span class="line">random(6);</span><br><span class="line"></span><br><span class="line">// &#x27;8abc&#x27;</span><br><span class="line">random(4);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：</p>
<ol>
<li><p>（个人思路）一个从 a-z0-9 的数组，从中随机位置取数。即随机数决定位置</p>
</li>
<li><p>利用 ASCII 码。字母、数字的 ascii 码范围为[65,90] &amp;&amp; [97,122] &amp;&amp; [48,51]，因此可以取 0-62 的随机数（这三个范围大小和为 26+26+10=62），如果结果在 0-25，那就+65 成为大写字母；如果结果在 26-52，就成为小写字母，剩下的为数字，依次类推</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ASCII：</span></span><br><span class="line"><span class="comment">// 大写字母：65~90</span></span><br><span class="line"><span class="comment">// 小写字母：97~122</span></span><br><span class="line"><span class="comment">// 数字：48-57</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random_v1</span>(<span class="params">num: number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>(num)</span><br><span class="line">    .fill(<span class="number">0</span>)</span><br><span class="line">    .map(<span class="function">() =&gt;</span> <span class="built_in">String</span>.fromCharCode(generateAcsii()))</span><br><span class="line">    .join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateAcsii</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 生成 [65,90] &amp;&amp; [97,122] &amp;&amp; [48,51]</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">62</span>); <span class="comment">// [0,62]</span></span><br><span class="line">  <span class="keyword">if</span> (a &lt; <span class="number">26</span>) &#123;</span><br><span class="line">    <span class="comment">//  返回 大写字母 的 ASCII</span></span><br><span class="line">    <span class="keyword">return</span> a + <span class="string">&quot;A&quot;</span>.charCodeAt();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt;= <span class="number">26</span> &amp;&amp; a &lt; <span class="number">52</span>) &#123;</span><br><span class="line">    <span class="comment">//  返回 小写字母 的 ASCII</span></span><br><span class="line">    <span class="keyword">return</span> a - <span class="number">26</span> + <span class="string">&quot;a&quot;</span>.charCodeAt();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//  返回 数字 的 ASCII</span></span><br><span class="line">    <span class="keyword">return</span> a - <span class="number">52</span> + <span class="string">&quot;0&quot;</span>.charCodeAt();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>一个神奇的方法。随机取一个数，然后用<code>toString(36)</code>转为一个 36 进制的数即可。因为 36 进制的数一定会包含所有的字母和数字（进制的字母不区分大小写，因此如果考虑大小写就不行）</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> random = <span class="function">(<span class="params">n</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">Math</span>.random()</span><br><span class="line">    .toString(<span class="number">36</span>)</span><br><span class="line">    .slice(<span class="number">2</span>, <span class="number">2</span> + n);</span><br><span class="line"></span><br><span class="line">random();</span><br><span class="line"><span class="comment">// =&gt; &quot;c1gdm2&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="随机生成六位数的手机验证码-重复-不可重复"><a href="#随机生成六位数的手机验证码-重复-不可重复" class="headerlink" title="随机生成六位数的手机验证码(重复/不可重复)"></a>随机生成六位数的手机验证码(重复/不可重复)</h2><p>思路：</p>
<ul>
<li>重复的很好生成，按照取随机数的方法连续取 6 个就行。</li>
<li>不重复，方法可以是每次取一个数之后，就在可选数的数组中把这个数去掉，这样就一定不会重复。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomCode1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>].map(<span class="function">() =&gt;</span> random(<span class="number">9</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> randomCode2 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> selectIdx = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * numbers.length);</span><br><span class="line">    res.push(numbers[selectIdx]);</span><br><span class="line">    numbers.splice(selectIdx, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="洗牌函数-shuffle"><a href="#洗牌函数-shuffle" class="headerlink" title="洗牌函数 shuffle"></a>洗牌函数 shuffle</h2><p>洗牌函数的关键是利用随机数的概率，让数组中的每个数随机排列。<br>让每个数随机排列的方法有很多，比如利用<code>sort</code>，或者让随机两个数两两交换</p>
<blockquote>
<p>有一种洗牌算法如下：<br>第 N 项数字与前 N 项数字随机选一相互交换<br>第 N-1 项数字与前 N-1 项数字随机选一相互交换<br>…<br>第 2 项数字与前 2 项数字随机选一相互交换</p>
</blockquote>
<p>利用这种算法，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shuffle = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 从[0, i]中随机取一个数</span></span><br><span class="line">    <span class="keyword">const</span> tmp = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (i + <span class="number">1</span>));</span><br><span class="line">    [arr[tmp], arr[i]] = [arr[i], arr[tmp]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(arr);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还有一种更简单的，直接利用 sort 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shuffle = <span class="function">(<span class="params">arr</span>) =&gt;</span> arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure>

<h2 id="用-Rand5-实现-Rand7"><a href="#用-Rand5-实现-Rand7" class="headerlink" title="用 Rand5() 实现 Rand7()"></a>用 Rand5() 实现 Rand7()</h2><p>参考来源是 leetcode<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-rand10-using-rand7/">https://leetcode.cn/problems/implement-rand10-using-rand7/</a></p>
<blockquote>
<p>给定方法  rand7  可生成 [1,7] 范围内的均匀随机整数，试写一个方法  rand10  生成 [1,10] 范围内的均匀随机整数。<br>你只能调用  rand7()  且不能调用其他方法。请不要使用系统的  Math.random()  方法。</p>
</blockquote>
<p>题目和这个要求不太一样，不过方法是一样的。</p>
<p>思路：random5 生成 [0, 5]每个数的概率是 $\frac {1}{6}$， 使用两次 random 函数，相乘，找到等概率出现的 8 个数就可以，不满足的数据排除掉</p>
<p><img src="https://pic.imgdb.cn/item/62d16a42f54cd3f9378fe4bb.jpg"></p>
<p>从表中分析可以看到，恰好有 8 个数的出现次数都为 2，因此选这 8 个数就可以。</p>
<p>具体算法上，我们取两个随机数分为为行和列，可以得到具体的位置为<code>col + (row - 1) * 5</code>（即把上面的二维数组拉成一维）<br>然后我们只用取前 21 个数。因为这样，每个数取得的概率为 $\frac {3}{25}$，取 0-7 时就恰好为 $\frac {21}{25}$<br>（具体解析参考力扣）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rand7 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> row, col, idx;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    row = rand5();</span><br><span class="line">    col = rand5();</span><br><span class="line">    idx = col + (row - <span class="number">1</span>) * <span class="number">5</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (idx &gt; <span class="number">21</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> + ((idx - <span class="number">1</span>) % <span class="number">7</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="lodash-api"><a href="#lodash-api" class="headerlink" title="lodash api"></a>lodash api</h1><h2 id="lodash-get"><a href="#lodash-get" class="headerlink" title="lodash.get"></a>lodash.get</h2><p>描述：实现这样的一个功能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123; <span class="attr">a</span>: [&#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">3</span> &#125; &#125;] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt; 3</span></span><br><span class="line">get(object, <span class="string">&quot;a[0].b.c&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt; 3</span></span><br><span class="line">get(object, <span class="string">&#x27;a[0][&quot;b&quot;][&quot;c&quot;]&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt; 10086</span></span><br><span class="line">get(object, <span class="string">&quot;a[100].b.c&quot;</span>, <span class="number">10086</span>);</span><br></pre></td></tr></table></figure>

<p>其实就是分解字符串，然后从一个具体的对象中取值。因此思路也是先分解字符串，然后循环逐次取值即可。<br>具体处理上，最好先把括号全部去掉，全部转为<code>a.1.b.c</code>这样的形式，方便分解</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _get = <span class="function">(<span class="params">obj, str, val</span>) =&gt;</span> &#123;</span><br><span class="line">  str = str.replace(<span class="regexp">/\[(&quot;|&#x27;)?(\w+)(&quot;|&#x27;)?\]/g</span>, <span class="string">&quot;.$2&quot;</span>); <span class="comment">// 用 $2 来代表捕获到的内容</span></span><br><span class="line">  <span class="keyword">const</span> props = str.split(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> res = obj;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">of</span> props) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> res !== <span class="string">&quot;object&quot;</span>) <span class="keyword">break</span>;</span><br><span class="line">    res = res[prop];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="lodash-maxBy"><a href="#lodash-maxBy" class="headerlink" title="lodash.maxBy"></a>lodash.maxBy</h2><blockquote>
<p>类似 loadash 如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [&#123; <span class="attr">value</span>: <span class="number">6</span> &#125;, &#123; <span class="attr">value</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">value</span>: <span class="number">4</span> &#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt; &#123; value: 6 &#125;</span></span><br><span class="line">maxBy(data, <span class="function">(<span class="params">x</span>) =&gt;</span> x.value);</span><br></pre></td></tr></table></figure>

<p>如果最大的项有多个，则多个都返回，如下所示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [&#123; <span class="attr">value</span>: <span class="number">6</span> &#125;, &#123; <span class="attr">value</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">value</span>: <span class="number">4</span> &#125;, &#123; <span class="attr">value</span>: <span class="number">6</span> &#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt; [&#123; value: 6 &#125;, &#123; value: 6 &#125;]</span></span><br><span class="line">maxBy(data, <span class="function">(<span class="params">x</span>) =&gt;</span> x.value);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>lodash 的 xxxBy 函数基本都是类似的套路。当第二个参数是函数时，其实相当于对数组进行了一个 map。因此可以先把数组 map 一下，然后不改变序号的情况下，找到对应的值并返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxBy = <span class="function">(<span class="params">data, fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(data)) <span class="keyword">return</span> data;</span><br><span class="line">  <span class="keyword">const</span> pureData = data.map(fn);</span><br><span class="line">  <span class="keyword">let</span> maxIndex = [];</span><br><span class="line">  <span class="keyword">let</span> max = pureData.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> (pre &gt; cur ? pre : cur), -<span class="literal">Infinity</span>);</span><br><span class="line">  pureData.forEach(<span class="function">(<span class="params">num, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num === max) maxIndex.push(i);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (maxIndex.length === <span class="number">1</span>) <span class="keyword">return</span> data[maxIndex[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> idx <span class="keyword">of</span> maxIndex) &#123;</span><br><span class="line">      res.push(data[idx]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是这种方法比较低效。相对更好一点的方法是把数组直接当作<code>number[]</code>处理，只是对每个项用函数处理一下即可。<br>另外，类似这种相互比较的算法都可以考虑使用 reduce，尤其是第二个函数里，既然要得到数组，那就可以一开始是一个数组，不断返回数组的 concat 即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxBy = <span class="function">(<span class="params">list, keyBy</span>) =&gt;</span></span><br><span class="line">  list.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> (keyBy(x) &gt; keyBy(y) ? x : y)); <span class="comment">// 对x和y处理一下即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回多项</span></span><br><span class="line"><span class="keyword">const</span> maxBy = <span class="function">(<span class="params">list, keyBy</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> list.slice(<span class="number">1</span>).reduce(</span><br><span class="line">    <span class="function">(<span class="params">acc, x</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (keyBy(x) &gt; keyBy(acc[<span class="number">0</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> [x];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (keyBy(x) === keyBy(acc[<span class="number">0</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> [...acc, x];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;,</span><br><span class="line">    [list[<span class="number">0</span>]]</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="lodash-intersection"><a href="#lodash-intersection" class="headerlink" title="lodash.intersection"></a>lodash.intersection</h2><p>求数组交集。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt; [2]</span></span><br><span class="line">intersection([<span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt; [1, 2]</span></span><br><span class="line">intersection([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt; [1, 2]</span></span><br><span class="line">intersection([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<p>注意这题有可能要求多个数组的交集，所以要多考虑一层。</p>
<p>基本方法：先随便选一个数组，去重后作为基准，然后遍历剩下的数组，如果一个数字在剩下的数组中都出现过，就说明是交集。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> intersection = <span class="function">(<span class="params">...arrays</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> basic = [...new <span class="built_in">Set</span>([...arrays][<span class="number">0</span>]).values()];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> basic) &#123;</span><br><span class="line">    <span class="keyword">let</span> times = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> array <span class="keyword">of</span> arrays) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array.includes(num)) times++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (times === arrays.length) res.push(num);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>简化方法：利用 reduce，每次比较相邻的两个，求得交集后再传递给下一个继续求。</p>
<p>两个数组求交集的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只保留在a中包含的b中的元素</span></span><br><span class="line"><span class="comment">// 要去重，a中相同的数会被选多次</span></span><br><span class="line">[...new <span class="built_in">Set</span>(a.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> b.includes(item)))];</span><br></pre></td></tr></table></figure>

<p>结合 reduce：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> intersection = <span class="function">(<span class="params">...list</span>) =&gt;</span></span><br><span class="line">  list.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> [...new <span class="built_in">Set</span>(a.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> b.includes(item)))]);</span><br></pre></td></tr></table></figure>

<h2 id="lodash-keyBy"><a href="#lodash-keyBy" class="headerlink" title="lodash.keyBy"></a>lodash.keyBy</h2><p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [</span><br><span class="line">  &#123; <span class="attr">dir</span>: <span class="string">&quot;left&quot;</span>, <span class="attr">code</span>: <span class="number">97</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">dir</span>: <span class="string">&quot;right&quot;</span>, <span class="attr">code</span>: <span class="number">100</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">_.keyBy(array, <span class="function">(<span class="params">o</span>) =&gt;</span> <span class="built_in">String</span>.fromCharCode(o.code));</span><br><span class="line"><span class="comment">// =&gt; &#123; &#x27;a&#x27;: &#123; &#x27;dir&#x27;: &#x27;left&#x27;, &#x27;code&#x27;: 97 &#125;, &#x27;d&#x27;: &#123; &#x27;dir&#x27;: &#x27;right&#x27;, &#x27;code&#x27;: 100 &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>即传入一个函数，对每个对象进行函数的操作，得到的返回值作为新生成对象的键</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> keyBy = <span class="function">(<span class="params">arr, fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> vals = arr.map(fn);</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> vals) &#123;</span><br><span class="line">    res[val] = arr.find(<span class="function">(<span class="params">obj</span>) =&gt;</span> obj.id === val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="lodash-groupBy"><a href="#lodash-groupBy" class="headerlink" title="lodash.groupBy"></a>lodash.groupBy</h2><p>和 keyBy 类似，也是以某个值为标准，但是会把该键的相同值放入一个数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.groupBy([<span class="number">6.1</span>, <span class="number">4.2</span>, <span class="number">6.3</span>], <span class="built_in">Math</span>.floor);</span><br><span class="line"><span class="comment">// =&gt; &#123; &#x27;4&#x27;: [4.2], &#x27;6&#x27;: [6.1, 6.3] &#125;</span></span><br></pre></td></tr></table></figure>

<p>实现：把数组当成正常数组处理即可，只需要在处理具体值时调用 fn</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> groupBy = <span class="function">(<span class="params">arr, fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;;</span><br><span class="line">  arr.forEach(<span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res[fn(obj)]) res[fn(obj)].push(obj);</span><br><span class="line">    <span class="keyword">else</span> res[fn(obj)] = [obj];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="类算法题"><a href="#类算法题" class="headerlink" title="类算法题"></a>类算法题</h1><h2 id="压缩字符串"><a href="#压缩字符串" class="headerlink" title="压缩字符串"></a>压缩字符串</h2><p>Input: ‘aaaabbbccd’<br>Output: ‘a4b3c2d1’<br>代表 a 连续出现四次，b 连续出现三次，c 连续出现两次，d 连续出现一次</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt; a4b3c2</span></span><br><span class="line">encode(<span class="string">&quot;aaaabbbcc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt; a4b3a4</span></span><br><span class="line">encode(<span class="string">&quot;aaaabbbaaaa&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt; a2b2c2</span></span><br><span class="line">encode(<span class="string">&quot;aabbcc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>进阶：</p>
<ul>
<li>如果只出现一次，不编码数字，如 aaab -&gt; a3b</li>
<li>如果只出现两次，不进行编码，如 aabbb -&gt; aab3</li>
</ul>
<p>思路：用栈，每次向内放入字母时，如果和栈顶字母相同就统计次数但不放入，不同就把次数数字入栈，再放入新的字母。</p>
<p>如果考虑到只出现一次或两次不编码，只需要限制次数大于 1 或 2 才开始计数即可。或者还可以在正常生成之后，单独对出现的 1 或 2 进行处理。比如删掉所有的 1，把数字 2 替换成前面的一个字母等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> encode = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  stack.push(str[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">let</span> times = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= str.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack[stack.length - <span class="number">1</span>] !== str[i]) &#123;</span><br><span class="line">      <span class="comment">// if(times &gt; 1)  // 这里控制出现一次不编码</span></span><br><span class="line">      stack.push(times);</span><br><span class="line">      str[i] &amp;&amp; stack.push(str[i]);</span><br><span class="line">      times = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      times++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="给数字添加千分符"><a href="#给数字添加千分符" class="headerlink" title="给数字添加千分符"></a>给数字添加千分符</h2><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=&gt; &#x27;123&#x27;</span></span><br><span class="line">numberThousands(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt; &#x27;1,234,567&#x27;</span></span><br><span class="line">numberThousands(<span class="number">1234567</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>基本思路比较简单，从后向前每三位加一个逗号，再把可能出现的首位去掉就行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numberThousands = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  num = num.toString();</span><br><span class="line">  <span class="keyword">const</span> nums = num.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt === <span class="number">3</span>) &#123;</span><br><span class="line">      cnt = <span class="number">0</span>;</span><br><span class="line">      res.unshift(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    res.unshift(nums[i]);</span><br><span class="line">    cnt++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (res[<span class="number">0</span>] === <span class="string">&quot;,&quot;</span>) res.shift();</span><br><span class="line">  <span class="built_in">console</span>.log(res.join(<span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h2><blockquote>
<p>实现 countOfLetters</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">countOfLetters(<span class="string">&quot;A2B3&quot;</span>); <span class="comment">// &#123; A: 2, B: 3 &#125;</span></span><br><span class="line">countOfLetters(<span class="string">&quot;A(A3B)2&quot;</span>); <span class="comment">// &#123; A: 7, B: 2&#125;</span></span><br><span class="line">countOfLetters(<span class="string">&quot;C4(A(A3B)2)2&quot;</span>); <span class="comment">// &#123; A: 14, B: 4, C: 4 &#125;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>这道题在 leetcode 上有类似题目，不过那道题是方括号。<br>但是基本思路没有区别，同样是利用栈，入栈所有的数字、字母和左括号。如果遇到右括号，就出栈到前一个左括号，然后根据重复次数再次放入。</p>
<p>另外这道题还可以添加一个小步骤，就是如果发现数字和字母紧挨（没有括号的情况下发现数字），就把前面的字母重复数字遍即可。</p>
<p>最后整理字符，统计出现次数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> countOfLetters = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">const</span> valid = <span class="string">&quot;QWERTYUIOPASDFGHJKLZXCVBNM(&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> s = str[i];</span><br><span class="line">    <span class="keyword">if</span> (valid.includes(s)) &#123;</span><br><span class="line">      stack.push(s);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(s)) &#123;</span><br><span class="line">      <span class="comment">// 数字紧挨字母 直接把字母重复n遍</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Number</span>(s) - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        stack.push(stack[stack.length - <span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 对右括号的处理</span></span><br><span class="line">      <span class="keyword">const</span> times = +str[i + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">const</span> part = [];</span><br><span class="line">      <span class="keyword">while</span> (stack[stack.length - <span class="number">1</span>] !== <span class="string">&quot;(&quot;</span>) &#123;</span><br><span class="line">        part.unshift(stack.pop());</span><br><span class="line">      &#125;</span><br><span class="line">      stack.pop();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">        stack.push(part.join(<span class="string">&quot;&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 整理并统计次数</span></span><br><span class="line">  <span class="keyword">const</span> resTmp = stack.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> resTmp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj[s]) obj[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> obj[s]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(obj);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Promise-异步-相关题目"><a href="#Promise-异步-相关题目" class="headerlink" title="Promise/异步 相关题目"></a>Promise/异步 相关题目</h1><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;timer1&quot;</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;timer2&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;start&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;start&#x27;</span><br><span class="line">&#x27;timer1&#x27;</span><br><span class="line">&#x27;promise&#x27;</span><br><span class="line">&#x27;timer2&#x27;</span><br></pre></td></tr></table></figure>

<p>注意<code>promise</code>在<code>timer2</code>之前，因为<code>Promise.resolve().then</code>内的是微任务，和<code>timer2</code>的<code>setTimeout</code>宏任务相比要更优先。<br>即会先执行完第一个<code>setTimeout</code>内的代码，才会执行第二个，并且第一个内的代码执行期间，第二个<code>setTimeout</code>仍然是异步宏任务，并不会和第一个一起同时把回调放入宏任务队列。</p>
<h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>注意<code>reject</code>会直接跳到 <code>catch</code>，忽略过程中的 <code>then</code>；而 <code>catch</code> 如果有返回值，则还会递交给下一个 <code>then</code>，并不会彻底结束。</p>
<p>如果没有抛出错误，则 catch 中的代码不会被执行，catch 的返回值不会传递给后序的 then</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 这个2传递给下一个then</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>; <span class="comment">// 这部分代码不执行</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); <span class="comment">// 2</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<hr>
<p>另外，Promise 对于错误的验证机制是由 throw 手动或自动抛出的语句。如果直接在 then 中返回自己 new 的一个 Error，或者 resolve 一个，都被视作是普通对象而非错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;error!!!&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;then: &quot;</span>, res); <span class="comment">// &quot;then: &quot; &quot;Error: error!!!&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;catch: &quot;</span>, err); <span class="comment">// 不会输出</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="built_in">console</span>.err);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</span><br></pre></td></tr></table></figure>

<p><code>Promise</code> 的 <code>then</code> 中不能返回他自己，否则会报错。这点在手写 promise 中也体现过，进入 <code>then</code> 之后需要有一个判断，如果返回值是自己就会报错。</p>
<h2 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>).then(<span class="number">2</span>).then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>)).then(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p><code>.then</code> 或者 <code>.catch</code> 的参数期望是函数，传入非函数则会发生值透传。<br>透传是会将 <code>resolve</code> 的结果透传到第一个能接受的 <code>then</code> 里边，而并不会理会其他 <code>then</code> 或 <code>catch</code> 中的参数。如果一直没有，就会直接返回一个 <code>Promise</code> 对象，中间都不会处理。<br>从手写 promise 中可以看到，如果参数不是函数，就变成一个直接返回参数值的函数<code>(val)=&gt;val</code>，然后在下面的新<code>Promise</code>中直接返回上一个<code>resolve</code>值（即<code>this.value</code>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//判断参数是不是函数</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&quot;function&quot;</span> ? onFulfilled : <span class="function">(<span class="params">val</span>) =&gt;</span> val;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">let</span> returnValueFromThen = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>另外，即使发生返回值穿透，这些 then、catch 等还会被算作是一个微任务。也就是说这道题里，resolve 的 1 还需要经历 2 个微任务，在第三个时才会传入最后一个 then</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve(<span class="number">1</span>))</span><br><span class="line">  .then(<span class="built_in">console</span>.log) <span class="comment">// 1</span></span><br><span class="line">  .then(<span class="built_in">console</span>.log) <span class="comment">// 3</span></span><br><span class="line">  .then(<span class="built_in">console</span>.log) <span class="comment">// 5</span></span><br><span class="line">  .then(<span class="built_in">console</span>.log); <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="number">2</span>) <span class="comment">// 2</span></span><br><span class="line">  .then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>)) <span class="comment">// 4</span></span><br><span class="line">  .catch(<span class="number">4</span>) <span class="comment">// 6</span></span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res)); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<p>上面的打印顺序是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">undefined</span><br><span class="line">undefined</span><br><span class="line">undefined</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>注意看上面的序号，表示第几个被放入微任务队列的任务</p>
<h2 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">  .finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;finally2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;我是finally2返回的值&quot;</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;finally2后面的then函数&quot;</span>, res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;1&#x27;</span><br><span class="line">&#x27;finally2&#x27;</span><br><span class="line">&#x27;finally&#x27;</span><br><span class="line">&#x27;finally2后面的then函数&#x27; &#x27;2&#x27;</span><br></pre></td></tr></table></figure>

<p><code>finally</code>的特点：</p>
<ul>
<li>任何情况下都会调用，不管<code>fulfilled</code>还是<code>rejected</code></li>
<li>回调不接受参数，因此不能收到任何内部的值，也没法知道<code>Promise</code>最终的状态是<code>resolved</code>还是<code>rejected</code></li>
<li>返回的默认会是一个上一次的<code>Promise</code>对象的返回值，如果抛出的是一个异常则返回异常的<code>Promise</code>对象，也就是说如果<code>finally</code>位于中间，则他的返回值不会对其他<code>then</code>或<code>catch</code>有任何影响，相当于原封不动的传递。</li>
<li><code>finally</code>依然是一个微任务，和<code>then</code>和<code>catch</code>一样，按照微任务顺序执行</li>
</ul>
<h2 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(x);</span><br><span class="line">      <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runReject</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="string">`Error: <span class="subst">$&#123;x&#125;</span>`</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;, <span class="number">1000</span> * x)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.all([runAsync(<span class="number">1</span>), runReject(<span class="number">4</span>), runAsync(<span class="number">3</span>), runReject(<span class="number">2</span>)])</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1s后输出</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">// 2s后输出</span><br><span class="line">2</span><br><span class="line">Error: 2</span><br><span class="line">// 4s后输出</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p><code>Promise.all</code>的执行原则：</p>
<ol>
<li>所有任务并行执行，最终输出事件以最长任务为准；每个任务内部的同步代码会独立并行执行。</li>
<li>如果有一个任务<code>reject</code>或者抛出错误，就会触发<code>Promise.all</code>后面的<code>catch</code>，这时整个<code>Promise.all</code>状态变为<code>rejected</code>，不会再触发<code>then</code>；但是并不代表所有任务都不再执行，任务<strong>仍会继续</strong>执行，但不会有有效的返回结果。像上面的例子中虽然 3 秒时已经<code>rejected</code>，但是最后一个任务还是会执行，输出自己内部的<code>4</code>，并且不会再触发<code>then</code>或<code>catch</code></li>
</ol>
<h2 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 success&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;async1 end&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;srcipt start&quot;</span>);</span><br><span class="line">async1().then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;srcipt end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;script start&#x27;</span><br><span class="line">&#x27;async1 start&#x27;</span><br><span class="line">&#x27;promise1&#x27;</span><br><span class="line">&#x27;script end&#x27;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>await</code>紧挨的内容如果是普通代码，相当于<code>new Promise</code>内部的，其后的代码相当于<code>.then</code>；如果是<code>Promise</code>对象，则会等待这个<code>Promise resolve</code>并阻塞后面代码，如果该 Promise 没有 resolve 或 reject，就会一直在<code>pending</code>状态，一直阻塞。</p>
</blockquote>
<p>在<code>async1</code>中<code>await</code>后面的<code>Promise</code>是没有返回值的（没有 resolve），也就是它的状态始终是<code>pending</code>状态，因此相当于一直在 await，await，await 却始终没有响应…<br>所以在<code>await</code>之后的内容是不会执行的，也包括<code>async1</code>后面的 <code>.then</code>。</p>
<h2 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;async1 success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">    reject(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">async1().then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res));</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;async2&#x27;</span><br><span class="line">Uncaught (in promise) error</span><br></pre></td></tr></table></figure>

<p><code>await</code>之后的代码相当于被包裹在了一个<code>then</code>中，因此执行条件是<code>await</code>的<code>promise</code>被<code>resolve</code>；对应的，如果这个<code>promise</code>被<code>reject</code>，那么结果就是其后的代码都不会执行了，而是直接跳到 catch（如果没有 catch 就直接抛出错误）。<br>上面的代码相当于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">    reject(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1&#x27;</span>);</span><br><span class="line">    resolve(<span class="string">&#x27;async1 success&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>显然后面的两个<code>then</code>中代码都不会执行。</p>
<hr>
<p>但是如果使用<code>try catch</code>包裹并捕获错误，那么将会在 catch 中将错误立即处理，并且继续执行之后的代码。<br>所以这段代码会正常执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&quot;error!!!&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&quot;async1 success&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1().then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line">(<span class="string">&quot;error!!!&quot;</span>);</span><br><span class="line">(<span class="string">&quot;async1&quot;</span>);</span><br><span class="line">(<span class="string">&quot;async1 success&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="9"><a href="#9" class="headerlink" title="9."></a>9.</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;resolve3&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;timer1&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  resolve(<span class="string">&quot;resovle1&quot;</span>);</span><br><span class="line">  resolve(<span class="string">&quot;resolve2&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(p1);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;finally&quot;</span>, res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;resolve1&#x27;</span><br><span class="line">&#x27;finally&#x27; undefined</span><br><span class="line">&#x27;timer1&#x27;</span><br><span class="line">Promise&#123;&lt;resolved&gt;: undefined&#125;</span><br></pre></td></tr></table></figure>

<p>首先要说一下，<code>then</code>中执行完成后会紧接着把后面的下一个<code>then/finally/catch</code>放入微任务队列，如果连续接着很多 then 就会依次放入；这个过程中相当于微任务队列一直有任务，定时器等宏任务不会执行。<br>就比如本题中，虽然第一个<code>setTimeout</code>在同步阶段都已经被放入宏任务队列，但是仍会先执行<code>then</code>和<code>finally</code>中的代码，等这两个中的代码都被执行完后才会执行剩下的宏任务。</p>
<p>最后一个定时器打印出的 p1 其实是<code>.finally</code>的返回值，我们知道<code>.finally</code>的返回值如果在没有抛出错误的情况下默认会是上一个<code>Promise</code>的返回值，而这道题中.<code>finally</code>上一个<code>Promise</code>是<code>.then()</code>，但是这个<code>.then()</code>并没有返回值，所以 p1 打印出来的<code>Promise</code>的值会是<code>undefined</code>，如果你在定时器的下面加上一个<code>return 1</code>，则值就会变成 1。</p>
<h2 id="使用-Promise-实现红绿灯交替重复亮"><a href="#使用-Promise-实现红绿灯交替重复亮" class="headerlink" title="使用 Promise 实现红绿灯交替重复亮"></a>使用 Promise 实现红绿灯交替重复亮</h2><p>红灯 3 秒亮一次，黄灯 2 秒亮一次，绿灯 1 秒亮一次；如何让三个灯不断交替重复亮灯？</p>
<p>要求：用 Promise 实现</p>
<p>三个亮灯函数已经存在：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">red</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">green</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;green&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yellow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>延迟亮灯比较好实现，就是用 promise 包裹定时器，到时间就<code>resolve</code>并执行亮灯函数；<br>要让这三个不断亮灯，可以采用无限递归的方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">red</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">green</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;green&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yellow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> light = <span class="function">(<span class="params">timer, cb</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      cb();</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, timer);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> step = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> light(<span class="number">3000</span>, red);</span><br><span class="line">  <span class="keyword">await</span> light(<span class="number">2000</span>, yellow);</span><br><span class="line">  <span class="keyword">await</span> light(<span class="number">1000</span>, green);</span><br><span class="line">  <span class="keyword">await</span> step();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">step();</span><br></pre></td></tr></table></figure>

<p>最基本的 setTimeout 回调实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> light = <span class="function">(<span class="params">timer, cb</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>cb();timer)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> step = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  light(<span class="number">1000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    red()</span><br><span class="line">    light(<span class="number">1000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      yellow()</span><br><span class="line">      light(<span class="number">1000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        green()</span><br><span class="line">        step()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">step();</span><br></pre></td></tr></table></figure>

<h1 id="输出题"><a href="#输出题" class="headerlink" title="输出题"></a>输出题</h1><h2 id="1-args-和-arguments-的类型"><a href="#1-args-和-arguments-的类型" class="headerlink" title="1. args 和 arguments 的类型"></a>1. args 和 arguments 的类型</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAge(<span class="number">21</span>);</span><br></pre></td></tr></table></figure>

<p>输出：”object”</p>
<p>当<code>...arr</code>作为收集数组的值的表达式时，arr 的类型就是一个数组，比如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,...arr] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">// arr就是[2,3]这个数组</span></span><br></pre></td></tr></table></figure>

<p>作为参数也是一样，args 是一个参数组成的数组</p>
<p>另外，函数里有一个对象<code>arguments</code>，这个值是一个特殊的<code>Arguments</code>类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">arguments</span>));</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">111</span>); <span class="comment">// [object Arguments]</span></span><br></pre></td></tr></table></figure>

<p>Arguments 类型可以类比类数组对象。它的构造函数并不是 Array，因此不能直接调用数组方法，但是可以转为数组后使用。</p>
<h2 id="2-关于对象中嵌套函数的-this-绑定"><a href="#2-关于对象中嵌套函数的-this-绑定" class="headerlink" title="2. 关于对象中嵌套函数的 this 绑定"></a>2. 关于对象中嵌套函数的 this 绑定</h2><h3 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h3><p>代码如下，求输出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;window&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> person1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;person1&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person2 = &#123; <span class="attr">name</span>: <span class="string">&quot;person2&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">person1.foo()();</span><br><span class="line">person1.foo().call(person2);</span><br><span class="line">person1.foo.call(person2)();</span><br><span class="line"></span><br><span class="line">person1.bar().call(person2);</span><br><span class="line">person1.bar.call(person2)();</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window</span><br><span class="line">person2</span><br><span class="line">window</span><br><span class="line"></span><br><span class="line">person1</span><br><span class="line">person2</span><br></pre></td></tr></table></figure>

<p>解释：<br>首先，如果闭包是非箭头函数，则闭包和外部函数的执行上下文是不同的。也就是说我们可以通过分别对这两个函数调用 call，可以得到内外不同的 this 环境。<br>上面的输出按顺序 1-5 标号：</p>
<ol>
<li>输出 window，因为相当于直接调用的内部的这个匿名函数，这个函数是一个非箭头函数，并且没有显式绑定，因此默认绑定为 window</li>
<li>输出 person2，因为给内部的这个闭包绑定到了 person2 对象上</li>
<li>输出 window，因为没有给闭包指定 this，但是把 foo 函数的上下文设置到了 person2 上；类比下面的输出 5，箭头函数用到的 this 是外部的，这个“外部”恰好就是外层函数；而外层函数 bar 又被绑定到了 person2，因此这个闭包里的 this 就是 person2.</li>
<li>输出 person1，即 bar 内部的 this，指代 person1，因为对箭头函数调用 call 无效，不能改变其内部 this 指向</li>
<li>输出 person2，原因上面输出 2 解释过</li>
</ol>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><img src="https://pic1.imgdb.cn/item/63625c5116f2c2beb1f1a20b.jpg"></p>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">person1</span><br><span class="line">person2</span><br><span class="line"></span><br><span class="line">window</span><br><span class="line">window</span><br><span class="line"></span><br><span class="line">window</span><br><span class="line">window</span><br><span class="line">person2</span><br><span class="line"></span><br><span class="line">person1</span><br><span class="line">person2</span><br><span class="line">person1</span><br></pre></td></tr></table></figure>

<p>对构造函数来说，当构造函数完成构造之后，就和 new 绑定什么关系了。也就是说 person1 就相当于是一个普通的对象，后面的操作就是在 person1 这个对象上执行的，上下文都是 person1</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person1 = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;person1&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">foo1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    clg(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前说过 new 绑定优先级高于显式绑定，但是这句话的前提是针对构造函数的；也就是说，只有在 new 作用于构造函数时，并且构造函数用于构造时才会出现 new 优先级压过显式绑定。如果构造完成，new 就不会对实例中的 this 产生影响<br>即，即使有一个通过 bind 绑定的函数用 new 构造，那么函数中的 this 还是指向实例，而非绑定的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;obj0&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> Person1 = Person.bind(obj);</span><br><span class="line">Person1(<span class="string">&quot;obj1&quot;</span>); <span class="comment">// Person1的操作是把this.name修改，如果显式绑定上，那么this就是obj，调用这个函数就是修改obj.name</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// obj1  说明Person1中的this是obj，改变了obj的name属性</span></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person1(<span class="string">&quot;obj2&quot;</span>);</span><br><span class="line">person1.name; <span class="comment">// obj2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// obj1  new的调用并没有改变this，说明Person1中的this根本就不是之前绑定的obj，而是新实例person1</span></span><br></pre></td></tr></table></figure>

<p>如果 new 影响的不是构造函数，就不存在 new 绑定高于显式绑定的情况了。<br>因此在这个输出中，实际上就是对 person1 这个对象操作，和上一道题是一样的，<strong>person1 的这几个方法中的 this 并不会被强制绑定到 person1 上，仍然可以被 call 改变指向</strong>，只有 Person 构造函数里的几个 this 才是始终指向 person1</p>
<h3 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h3><p><img src="https://pic1.imgdb.cn/item/6362611e16f2c2beb1fba29d.jpg"></p>
<p>这道题其实和第一题是一样的。其实就是创建了一个对象，是 person 的一个属性；直接调用 obj 和 person.obj 是一样的</p>
<h2 id="输出题错题记录"><a href="#输出题错题记录" class="headerlink" title="输出题错题记录"></a>输出题错题记录</h2><h3 id="1-嵌套对象的引用问题：单独取出来嵌套对象的引用和原本的引用是冲突的"><a href="#1-嵌套对象的引用问题：单独取出来嵌套对象的引用和原本的引用是冲突的" class="headerlink" title="1. 嵌套对象的引用问题：单独取出来嵌套对象的引用和原本的引用是冲突的"></a>1. 嵌套对象的引用问题：单独取出来嵌套对象的引用和原本的引用是冲突的</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj;</span><br><span class="line"><span class="keyword">var</span> obj3 = obj.a;</span><br><span class="line">obj2.a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj3);</span><br><span class="line"><span class="comment">// 复原</span></span><br><span class="line">obj2.a = &#123; <span class="attr">b</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj3);</span><br><span class="line"><span class="comment">// 复原</span></span><br><span class="line">obj2.a.b = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj3);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;b:2&#125;</span><br><span class="line">&#123;b:2&#125;</span><br><span class="line">&#123;b:3&#125;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>obj3 和 obj.a 都是对对象<code>&#123;b:2&#125;</code>的索引。假如覆盖 obj.a 的值，那么相当于 obj.a 不再保持该对象的索引，只有 obj3 才保留；<br>但是由于修改的是 obj.a 的属性，并不会影响这个 obj.a 这个对象本身（即修改的是 obj 内的一个属性，这时已经和<code>&#123;b:2&#125;</code>这个对象没有关系了）。<br>如果是通过 obj.a.b 来修改<code>&#123;b:2&#125;</code>这个对象，那么会对 obj3 造成影响。反过来，如果修改 obj3，也会修改 obj.a 的值。因为 obj.a 和 obj3 这时都是<code>&#123;b:2&#125;</code>这个对象的索引。</p>
<p>注意好一点：对于嵌套的引用类型结构，如果取的是内部的嵌套对象，并不是复制，只是对这个子对象取了一个索引。如果通过新的索引或源对象的方式修改该子对象，都会修改对象本身。<br>如果是直接替换，那就相当于丢失了这个索引。</p>
<hr>
<h3 id="2-var-定义问题：函数定义在哪就从那哪查找，但实际的值是执行阶段确定的"><a href="#2-var-定义问题：函数定义在哪就从那哪查找，但实际的值是执行阶段确定的" class="headerlink" title="2. var 定义问题：函数定义在哪就从那哪查找，但实际的值是执行阶段确定的"></a>2. var 定义问题：函数定义在哪就从那哪查找，但实际的值是执行阶段确定的</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(fn, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果把var替换成let呢</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 // 第0秒</span><br><span class="line">3 // 第1秒</span><br><span class="line">3 // 第2秒</span><br><span class="line"></span><br><span class="line">// 如果换成let</span><br><span class="line">报错：i未定义</span><br></pre></td></tr></table></figure>

<p>这道题其实和那个 var 对于 setTimeout 的输出是一样的。即使把 fn 提取到外面，也是一样的。<br>因为 var 的变量提升，导致 i 每次执行都会更新顶层的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(fn, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：这里输出<strong>不是</strong>undefined。因为 i 在下面循环中被赋值；当 fn 执行时，i 已经被赋值为 3 了。这和 fn 在内部定义是完全一样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和上面是一样的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是之前错的地方。i 如果定义在 for 循环内部，那么它查找的时候会按照<code>for的块级作用域 -&gt; 外部作用域</code>这个顺序查找的，而直接定义在外部则是直接在<code>外部作用域</code>内查找。但是不管在哪里查找，对于 var 定义的变量来说，都是声明在最顶层的，并且当执行 fn 的时候 i 都是已经赋值的了。并不会出现 undefined 的情况。</p>
<p>如果是 let，那么只有 for 内部才有 i 这个变量。如果是把 fn 定义在外面，就会报错找不到 i，因为 i 不在外部作用域内（注意不是 TDZ，因为 i 根本不在外部作用域，不是 i 在声明之前被使用）</p>
<hr>
<h3 id="3-function-和-var-声明的覆盖问题"><a href="#3-function-和-var-声明的覆盖问题" class="headerlink" title="3. function 和 var 声明的覆盖问题"></a>3. function 和 var 声明的覆盖问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f a()</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>函数声明不会被 var 声明覆盖。因此这里函数声明可以声明成功，第一个 console.log 打印的是函数 a；<br>而后面 a=10 的语句相当于覆盖了函数 a 的声明。注意不是 var 定义变量的声明。</p>
<p>如果把 var 替换成 let，这里就会报错 a 已经被声明过了，不能再声明一个名字叫 a 的变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a; <span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-函数内参数重命名、赋值，以及函数参数默认值"><a href="#4-函数内参数重命名、赋值，以及函数参数默认值" class="headerlink" title="4. 函数内参数重命名、赋值，以及函数参数默认值"></a>4. 函数内参数重命名、赋值，以及函数参数默认值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">200</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">200</span><br></pre></td></tr></table></figure>

<p>函数内的变量理论上是不能重新声明的。如果使用 let、const 重新声明，则会直接报错；而如果使用 var，则不会显式报错，但声明会失败。<br>这里<code>var x = 200</code>相当于只执行了<code>x = 200</code>，<code>var x</code>这个并没有生效。因此第一个 log 打印的是参数的值而不是 var 的声明；第二个 log 打印的是赋值之后的 x</p>
<hr>
<h3 id="5-对象内箭头函数中-this-的指向"><a href="#5-对象内箭头函数中-this-的指向" class="headerlink" title="5. 对象内箭头函数中 this 的指向"></a>5. 对象内箭头函数中 this 的指向</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">global</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;inner&quot;</span>,</span><br><span class="line">    <span class="function"><span class="title">f1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">f2</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">f3</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">f4</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">f5</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> outer = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;outer&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">global</span>.bind(outer)();</span><br><span class="line">obj.f1();</span><br><span class="line">obj.f2();</span><br><span class="line">obj.f3();</span><br><span class="line">obj.f4()();</span><br><span class="line">obj.f5()();</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inner</span><br><span class="line">inner</span><br><span class="line">outer</span><br><span class="line">undefined</span><br><span class="line">inner</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ol>
<li>f1 和 f2 是相同的方式的不同写法，由于调用采用了隐式绑定，因此输出值为 obj 的 name</li>
<li>f3 是箭头函数。箭头函数是将 this 设置为外层的 this，注意这个“外层”，指的是上层执行上下文。也就是说，这个外层只能是函数或全局，而不是一个对象。</li>
</ol>
<p>什么意思呢，就是说箭头函数取的 this 应该是其外层函数内的 this，而不是外层对象内的 this。因此上面的 f3 取的是 global 函数内的 this，而不是 obj 对象的 this。<br>同理也适用于 f5，f5 的返回值这个箭头函数的“外层”指的是 f5 这个函数，因此执行这个箭头函数会从 f5 函数内取 this，即 obj（因为是通过<code>obj.f5</code>调用的，f5 内的 this 被设置为 obj）</p>
<ol start="3">
<li>f4 打印 undefined，因为这个函数相当于单独执行，但它有又没有去取外层的 this。</li>
</ol>
<h3 id="6-构造函数内的箭头函数"><a href="#6-构造函数内的箭头函数" class="headerlink" title="6. 构造函数内的箭头函数"></a>6. 构造函数内的箭头函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">this</span>.change = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.flag = <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.flag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">Test1.prototype.change = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.flag = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> test1 = <span class="keyword">new</span> Test1();</span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> Test();</span><br><span class="line">test.change();</span><br><span class="line">test1.change();</span><br><span class="line"><span class="built_in">console</span>.log(test.flag, test1.flag);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>这两个定义的效果是相同的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.change = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.flag = <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">this</span>.change = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.flag = <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 change，都可以修改 flag 的值。原因在于，第一个因为是箭头函数，所以内部的 this 就是 Test 函数的 this。当构造时，this 被设置为实例，因此构造函数内的 this 也是构造出的实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test = &#123;</span><br><span class="line">  <span class="attr">flag</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">change</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.flag = <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果是上面这个对象内的 change，显然不能实现。因为这里的 this 是指外层函数的 this，不会指向 test 对象，也不能绑定到 test 对象。<br>但是为什么在构造函数内就可以呢？还是因为箭头函数使用的是 Test 函数的 this，而构造时这个 this 被绑定为构造出的实例。<br>再具体一点，像下面这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">this</span>.change = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的this就是Test函数的this，是同一个值，因此改变这里的this就是改变实例</span></span><br><span class="line">    <span class="built_in">this</span>.flag = <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="keyword">const</span> testChange = test.change;</span><br><span class="line">testChange();</span><br><span class="line"><span class="built_in">console</span>.log(test.flag); <span class="comment">// true，修改成功</span></span><br></pre></td></tr></table></figure>

<p>可以看到即使把 change 方法从 test 中取出来，依旧可以让函数内部的 this 指向构造出的对象。这也就证明 new 绑定的优先级高于隐式绑定，并且 new 绑定之后即使不使用隐式绑定的调用方式依然可以保证 this 的指向。</p>
<p>再说回这个函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">this</span>.change = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Test内的this不会影响到这里，这里的this是change函数自己的</span></span><br><span class="line">    <span class="built_in">this</span>.flag = <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test = &#123;</span><br><span class="line">  <span class="attr">flag</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="function"><span class="title">change</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.flag = <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个就很好理解了，change 方法的调用就是和对象内调用一样。注意这里的 this 是不会像箭头函数那样和 Test 内的 this 绑定的，因此如果不使用隐式绑定，就会出错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="keyword">const</span> testChange = test.change;</span><br><span class="line">testChange(); <span class="comment">// window，即this没有绑定到test对象上</span></span><br></pre></td></tr></table></figure>

<p>总结来说，就是：</p>
<ul>
<li>new 会把构造函数内的 this 绑定到实例上，因此如果构造函数内有箭头函数，由于他们共享 this（箭头函数内的 this 本来就是构造函数内的），所以这个 this 一定是实例，不会绑定到其他对象上。</li>
<li>对于构造函数内定义的普通函数，函数内的 this 依然是自己的，不会被 new 执行影响；因此这些函数调用就需要进行绑定，否则会缺少指向。</li>
</ul>
<h3 id="7-作用域问题"><a href="#7-作用域问题" class="headerlink" title="7. 作用域问题"></a>7. 作用域问题</h3><p>还是上面那个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">this</span>.change = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(button.flag);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> button = <span class="keyword">new</span> test();</span><br><span class="line">button.change(); <span class="comment">// 输出：false</span></span><br></pre></td></tr></table></figure>

<p>这里似乎有个很奇怪的地方，为什么看起来 change 函数内的 button 是在其声明前调用的，但是依旧能正常输出 button？</p>
<p>这里纠正一个之前错误的点：作用域的查找单位是“层”，而不是“行”。也就是说，变量查找是以层为单位的，在本层查找不到，就到外层查找，而不用管这个变量到底在外层的哪里。<br>比如说：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">getName(); <span class="comment">// aaa</span></span><br></pre></td></tr></table></figure>

<p>当执行 getName 时，打印出的 name 就是外层的 name。<strong>注意这个“外层”，指的是整个外层的变量，和具体位置没关系，和先后顺序也没关系。</strong><br>即使 const 是在函数声明之后定义的，但依然不影响变量的查找。<br>只要 getName 函数的调用在 name 声明和赋值之后，就能取到正常的值。</p>
<p>另外，TDZ 也指的是执行时才会出现的作用域问题，而不是在作用域查找时才会出现。比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getName(); <span class="comment">// Cannot access &#x27;name&#x27; before initialization</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然 TDZ 和函数定义和变量定义的先后顺序没有关系，只和函数执行的前后有关系。</p>
<h3 id="8-函数的构造调用和直接调用的-this"><a href="#8-函数的构造调用和直接调用的-this" class="headerlink" title="8. 函数的构造调用和直接调用的 this"></a>8. 函数的构造调用和直接调用的 this</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Foo());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Foo());</span><br><span class="line"><span class="keyword">new</span> Foo().getName();</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window</span><br><span class="line">window</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>当构造函数直接返回一个对象时，new 构造函数的结果就是这个对象。不过有一个例外，就是返回 this 的情况。<br>按理来说 Foo 函数内的 this 指向 window，new Foo()应该返回 window 才对；但是 new Foo 同时也会把 this 指向创建的实例对象。因此 Foo 函数内的 this 实际是构造出的实例对象，返回的也是这个，而不是默认情况下的 window 或 undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// const this = &#123;&#125;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然 new Foo 能成功创建，因此 getName 方法也能正常执行。</p>
<h1 id="其他乱七八糟的题目"><a href="#其他乱七八糟的题目" class="headerlink" title="其他乱七八糟的题目"></a>其他乱七八糟的题目</h1><h2 id="通过-js-修改全局样式"><a href="#通过-js-修改全局样式" class="headerlink" title="通过 js 修改全局样式"></a>通过 js 修改全局样式</h2><p>可以通过<code>document.querySelectorAll(&quot;*&quot;)</code>获取所有元素，然后通过 getComputeStyle 获取每个元素样式，再通过<code>element.style</code>修改样式。</p>
<p>比如，把所有的背景白色修改为红色：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;*&quot;</span>).forEach(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (getComputedStyle(element).backgroundColor === <span class="string">&quot;rgba(0, 0, 0, 0)&quot;</span>) &#123;</span><br><span class="line">    element.style.backgroundColor = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注意最好先查看一下具体的值再做匹配。</p>
<h2 id="颜色单位互相转换"><a href="#颜色单位互相转换" class="headerlink" title="颜色单位互相转换"></a>颜色单位互相转换</h2><h3 id="16进制转rgb"><a href="#16进制转rgb" class="headerlink" title="16进制转rgb"></a>16进制转rgb</h3><p>方法就是把16进制的每2位通过parseInt转化为10进制的数即可。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hexToRgb</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> colorStrArr = color.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  colorStrArr.shift();<span class="comment">// 去掉开头的#</span></span><br><span class="line">  <span class="keyword">let</span> colors = colorStrArr.join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="comment">// 如果是简写，每个位置都要加倍一次</span></span><br><span class="line">  <span class="keyword">if</span>(colors.length === <span class="number">3</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> newColors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; colorStrArr.length;i++)&#123;</span><br><span class="line">      newColors[i * <span class="number">2</span>] = colorStrArr[i]</span><br><span class="line">      newColors[i * <span class="number">2</span> + <span class="number">1</span>] = colorStrArr[i]</span><br><span class="line">    &#125;</span><br><span class="line">    colors = newColors.join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> r = <span class="built_in">parseInt</span>(colors.slice(<span class="number">0</span>,<span class="number">2</span>),<span class="number">16</span>)</span><br><span class="line">  <span class="keyword">const</span> g = <span class="built_in">parseInt</span>(colors.slice(<span class="number">2</span>,<span class="number">4</span>),<span class="number">16</span>)</span><br><span class="line">  <span class="keyword">const</span> b = <span class="built_in">parseInt</span>(colors.slice(<span class="number">4</span>,<span class="number">6</span>),<span class="number">16</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`rgb(<span class="subst">$&#123;r&#125;</span>, <span class="subst">$&#123;g&#125;</span>, <span class="subst">$&#123;b&#125;</span>)`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="rgb转16进制"><a href="#rgb转16进制" class="headerlink" title="rgb转16进制"></a>rgb转16进制</h3><p>如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rgbToHex</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> regex = <span class="regexp">/\d+/g</span>;</span><br><span class="line">  <span class="keyword">const</span> matches = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> match;</span><br><span class="line">  <span class="keyword">while</span> ((match = regex.exec(color))) &#123;</span><br><span class="line">    matches.push(<span class="built_in">parseInt</span>(match[<span class="number">0</span>]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`#<span class="subst">$&#123;matches[<span class="number">0</span>].toString(<span class="number">16</span>).padEnd(<span class="number">2</span>, <span class="string">&quot;0&quot;</span>).toUpperCase()&#125;</span><span class="subst">$&#123;matches[<span class="number">1</span>]</span></span></span><br><span class="line"><span class="subst"><span class="string">    .toString(<span class="number">16</span>)</span></span></span><br><span class="line"><span class="subst"><span class="string">    .padEnd(<span class="number">2</span>, <span class="string">&quot;0&quot;</span>)</span></span></span><br><span class="line"><span class="subst"><span class="string">    .toUpperCase()&#125;</span><span class="subst">$&#123;matches[<span class="number">2</span>].toString(<span class="number">16</span>).padEnd(<span class="number">2</span>, <span class="string">&quot;0&quot;</span>).toUpperCase()&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的关键其实是用exec循环提取数字。然后转成16进制数即可。padEnd可以很方便地填充字符以保证2位数。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="/img/JS.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/11/blog8-react-source-code/"><img class="prev-cover" src="/img/react.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">react原理和源码学习——React天下第一！</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/12/OS/"><img class="next-cover" src="/img/OS.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统知识点总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/04/05/blog7-fe-engineering/" title="前端工程化总结"><img class="cover" src="/img/npm.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-05</div><div class="title">前端工程化总结</div></div></a></div><div><a href="/2022/07/24/fe-design-pattern/" title="设计模式学习总结"><img class="cover" src="/img/codes1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-24</div><div class="title">设计模式学习总结</div></div></a></div><div><a href="/2022/04/05/optimization/" title="优化问题总结"><img class="cover" src="/img/optimization.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-05</div><div class="title">优化问题总结</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/pinkstar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xing Ye</div><div class="author-info__description">a singleThreaded boy's blog</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/penghei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/penghei" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:632885485@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">A SingleThreaded Boy...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">手写题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-new"><span class="toc-number">1.1.</span> <span class="toc-text">手写 new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-const"><span class="toc-number">1.2.</span> <span class="toc-text">实现一个 const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-number">1.3.</span> <span class="toc-text">手写数组去重</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3"><span class="toc-number">1.4.</span> <span class="toc-text">手写数组扁平</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E6%95%B0%E7%BB%84%E5%88%86%E7%BB%84"><span class="toc-number">1.5.</span> <span class="toc-text">手写数组分组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-reduce"><span class="toc-number">1.6.</span> <span class="toc-text">手写 reduce</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.7.</span> <span class="toc-text">手写深拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E9%80%92%E5%BD%92"><span class="toc-number">1.7.1.</span> <span class="toc-text">基本递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%95%B0%E7%BB%84%E5%88%A4%E6%96%AD"><span class="toc-number">1.7.2.</span> <span class="toc-text">添加数组判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%BE%AA%E7%8E%AF%E8%B0%83%E7%94%A8"><span class="toc-number">1.7.3.</span> <span class="toc-text">避免循环调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%9B%B4%E5%A4%9A%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.4.</span> <span class="toc-text">检查更多类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E6%B7%B1%E6%AF%94%E8%BE%83"><span class="toc-number">1.8.</span> <span class="toc-text">手写深比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E9%98%B2%E6%8A%96-%E8%8A%82%E6%B5%81"><span class="toc-number">1.9.</span> <span class="toc-text">手写防抖&#x2F;节流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-number">1.10.</span> <span class="toc-text">手写柯里化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E6%87%92%E8%AE%A1%E7%AE%97%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.</span> <span class="toc-text">手写懒计算函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-Promise"><span class="toc-number">1.12.</span> <span class="toc-text">手写 Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-Promise"><span class="toc-number">1.12.1.</span> <span class="toc-text">基础 Promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#then-%E7%A9%BF%E9%80%8F"><span class="toc-number">1.12.2.</span> <span class="toc-text">then 穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-Api"><span class="toc-number">1.12.3.</span> <span class="toc-text">Promise Api</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-prototype-finally"><span class="toc-number">1.12.3.1.</span> <span class="toc-text">Promise.prototype.finally</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-all"><span class="toc-number">1.12.3.2.</span> <span class="toc-text">Promise.all</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-allSettled"><span class="toc-number">1.12.3.3.</span> <span class="toc-text">Promise.allSettled</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-race"><span class="toc-number">1.12.3.4.</span> <span class="toc-text">Promise.race</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-any"><span class="toc-number">1.12.3.5.</span> <span class="toc-text">Promise.any</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-map%E9%99%90%E5%88%B6%E5%B9%B6%E5%8F%91"><span class="toc-number">1.12.3.6.</span> <span class="toc-text">Promise.map限制并发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-async-pool"><span class="toc-number">1.13.</span> <span class="toc-text">手写 async pool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5-sum-add"><span class="toc-number">1.14.</span> <span class="toc-text">实现异步 sum&#x2F;add</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-call-apply-%E5%92%8C-bind"><span class="toc-number">1.15.</span> <span class="toc-text">手写 call apply 和 bind</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-instanceof"><span class="toc-number">1.16.</span> <span class="toc-text">手写 instanceof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-sleep-delay"><span class="toc-number">1.17.</span> <span class="toc-text">手写 sleep&#x2F;delay</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-compose-%E5%87%BD%E6%95%B0"><span class="toc-number">1.18.</span> <span class="toc-text">手写 compose 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E5%AF%B9%E8%B1%A1%E6%89%81%E5%B9%B3%E5%8C%96%E5%92%8C%E9%80%86%E6%89%81%E5%B9%B3%E5%8C%96"><span class="toc-number">1.19.</span> <span class="toc-text">手写对象扁平化和逆扁平化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%81%E5%B9%B3%E5%8C%96"><span class="toc-number">1.19.1.</span> <span class="toc-text">扁平化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E6%89%81%E5%B9%B3%E5%8C%96"><span class="toc-number">1.19.2.</span> <span class="toc-text">逆扁平化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E8%99%9A%E6%8B%9F-dom-%E8%BD%AC%E5%8C%96%E4%B8%BA%E7%9C%9F%E5%AE%9E-dom"><span class="toc-number">1.20.</span> <span class="toc-text">手写虚拟 dom 转化为真实 dom</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-JSON-stringify"><span class="toc-number">1.21.</span> <span class="toc-text">手写 JSON.stringify</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-LazyMan-%E7%B1%BB"><span class="toc-number">1.22.</span> <span class="toc-text">手写 LazyMan 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-LRUCache-%E7%B1%BB"><span class="toc-number">1.23.</span> <span class="toc-text">手写 LRUCache 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E7%B1%BB-Event"><span class="toc-number">1.24.</span> <span class="toc-text">手写发布&#x2F;订阅类 Event</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-batcher-%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97"><span class="toc-number">1.25.</span> <span class="toc-text">手写 batcher 实现异步任务队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E8%B6%85%E6%97%B6%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82"><span class="toc-number">1.26.</span> <span class="toc-text">手写超时取消请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8%E7%9B%B8%E5%85%B3"><span class="toc-number">1.27.</span> <span class="toc-text">计时器相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setTimeout-%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E6%A0%A1%E5%87%86"><span class="toc-number">1.27.1.</span> <span class="toc-text">setTimeout 递归调用校准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8-setTimeout-%E5%AE%9E%E7%8E%B0-setInterval"><span class="toc-number">1.27.2.</span> <span class="toc-text">用 setTimeout 实现 setInterval</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-dayjs-%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%8A%9F%E8%83%BD"><span class="toc-number">1.28.</span> <span class="toc-text">手写 dayjs 时间格式化功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E5%A4%A7%E6%96%87%E4%BB%B6%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0"><span class="toc-number">1.29.</span> <span class="toc-text">手写大文件分片上传</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">随机数相关问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E9%9A%8F%E6%9C%BA%E5%8F%96%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">2.1.</span> <span class="toc-text">从数组中随机取一个元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.2.</span> <span class="toc-text">随机字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%85%AD%E4%BD%8D%E6%95%B0%E7%9A%84%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81-%E9%87%8D%E5%A4%8D-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D"><span class="toc-number">2.3.</span> <span class="toc-text">随机生成六位数的手机验证码(重复&#x2F;不可重复)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%97%E7%89%8C%E5%87%BD%E6%95%B0-shuffle"><span class="toc-number">2.4.</span> <span class="toc-text">洗牌函数 shuffle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8-Rand5-%E5%AE%9E%E7%8E%B0-Rand7"><span class="toc-number">2.5.</span> <span class="toc-text">用 Rand5() 实现 Rand7()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lodash-api"><span class="toc-number">3.</span> <span class="toc-text">lodash api</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lodash-get"><span class="toc-number">3.1.</span> <span class="toc-text">lodash.get</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lodash-maxBy"><span class="toc-number">3.2.</span> <span class="toc-text">lodash.maxBy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lodash-intersection"><span class="toc-number">3.3.</span> <span class="toc-text">lodash.intersection</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lodash-keyBy"><span class="toc-number">3.4.</span> <span class="toc-text">lodash.keyBy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lodash-groupBy"><span class="toc-number">3.5.</span> <span class="toc-text">lodash.groupBy</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E7%AE%97%E6%B3%95%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">类算法题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.1.</span> <span class="toc-text">压缩字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%99%E6%95%B0%E5%AD%97%E6%B7%BB%E5%8A%A0%E5%8D%83%E5%88%86%E7%AC%A6"><span class="toc-number">4.2.</span> <span class="toc-text">给数字添加千分符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81"><span class="toc-number">4.3.</span> <span class="toc-text">字符串解码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Promise-%E5%BC%82%E6%AD%A5-%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE"><span class="toc-number">5.</span> <span class="toc-text">Promise&#x2F;异步 相关题目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1"><span class="toc-number">5.1.</span> <span class="toc-text">1.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2"><span class="toc-number">5.2.</span> <span class="toc-text">2.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3"><span class="toc-number">5.3.</span> <span class="toc-text">3.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4"><span class="toc-number">5.4.</span> <span class="toc-text">4.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5"><span class="toc-number">5.5.</span> <span class="toc-text">5.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6"><span class="toc-number">5.6.</span> <span class="toc-text">6.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7"><span class="toc-number">5.7.</span> <span class="toc-text">7.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8"><span class="toc-number">5.8.</span> <span class="toc-text">8.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9"><span class="toc-number">5.9.</span> <span class="toc-text">9.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Promise-%E5%AE%9E%E7%8E%B0%E7%BA%A2%E7%BB%BF%E7%81%AF%E4%BA%A4%E6%9B%BF%E9%87%8D%E5%A4%8D%E4%BA%AE"><span class="toc-number">5.10.</span> <span class="toc-text">使用 Promise 实现红绿灯交替重复亮</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">输出题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-args-%E5%92%8C-arguments-%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.1.</span> <span class="toc-text">1. args 和 arguments 的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E7%9A%84-this-%E7%BB%91%E5%AE%9A"><span class="toc-number">6.2.</span> <span class="toc-text">2. 关于对象中嵌套函数的 this 绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.2.1.</span> <span class="toc-text">普通对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">6.2.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.2.3.</span> <span class="toc-text">构造函数创建对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E9%A2%98%E9%94%99%E9%A2%98%E8%AE%B0%E5%BD%95"><span class="toc-number">6.3.</span> <span class="toc-text">输出题错题记录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B5%8C%E5%A5%97%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98%EF%BC%9A%E5%8D%95%E7%8B%AC%E5%8F%96%E5%87%BA%E6%9D%A5%E5%B5%8C%E5%A5%97%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E5%92%8C%E5%8E%9F%E6%9C%AC%E7%9A%84%E5%BC%95%E7%94%A8%E6%98%AF%E5%86%B2%E7%AA%81%E7%9A%84"><span class="toc-number">6.3.1.</span> <span class="toc-text">1. 嵌套对象的引用问题：单独取出来嵌套对象的引用和原本的引用是冲突的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-var-%E5%AE%9A%E4%B9%89%E9%97%AE%E9%A2%98%EF%BC%9A%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E5%9C%A8%E5%93%AA%E5%B0%B1%E4%BB%8E%E9%82%A3%E5%93%AA%E6%9F%A5%E6%89%BE%EF%BC%8C%E4%BD%86%E5%AE%9E%E9%99%85%E7%9A%84%E5%80%BC%E6%98%AF%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5%E7%A1%AE%E5%AE%9A%E7%9A%84"><span class="toc-number">6.3.2.</span> <span class="toc-text">2. var 定义问题：函数定义在哪就从那哪查找，但实际的值是执行阶段确定的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-function-%E5%92%8C-var-%E5%A3%B0%E6%98%8E%E7%9A%84%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98"><span class="toc-number">6.3.3.</span> <span class="toc-text">3. function 和 var 声明的覆盖问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%87%BD%E6%95%B0%E5%86%85%E5%8F%82%E6%95%B0%E9%87%8D%E5%91%BD%E5%90%8D%E3%80%81%E8%B5%8B%E5%80%BC%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">6.3.4.</span> <span class="toc-text">4. 函数内参数重命名、赋值，以及函数参数默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AF%B9%E8%B1%A1%E5%86%85%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD-this-%E7%9A%84%E6%8C%87%E5%90%91"><span class="toc-number">6.3.5.</span> <span class="toc-text">5. 对象内箭头函数中 this 的指向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%86%85%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.6.</span> <span class="toc-text">6. 构造函数内的箭头函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-number">6.3.7.</span> <span class="toc-text">7. 作用域问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E8%B0%83%E7%94%A8%E5%92%8C%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E7%9A%84-this"><span class="toc-number">6.3.8.</span> <span class="toc-text">8. 函数的构造调用和直接调用的 this</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E7%9A%84%E9%A2%98%E7%9B%AE"><span class="toc-number">7.</span> <span class="toc-text">其他乱七八糟的题目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-js-%E4%BF%AE%E6%94%B9%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F"><span class="toc-number">7.1.</span> <span class="toc-text">通过 js 修改全局样式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%9C%E8%89%B2%E5%8D%95%E4%BD%8D%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.2.</span> <span class="toc-text">颜色单位互相转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E8%BF%9B%E5%88%B6%E8%BD%ACrgb"><span class="toc-number">7.2.1.</span> <span class="toc-text">16进制转rgb</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rgb%E8%BD%AC16%E8%BF%9B%E5%88%B6"><span class="toc-number">7.2.2.</span> <span class="toc-text">rgb转16进制</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/30/react-priority/" title="使用Priority管理React组件渲染优先级"><img src="/img/priority.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用Priority管理React组件渲染优先级"/></a><div class="content"><a class="title" href="/2023/06/30/react-priority/" title="使用Priority管理React组件渲染优先级">使用Priority管理React组件渲染优先级</a><time datetime="2023-06-30T06:58:28.000Z" title="发表于 2023-06-30 14:58:28">2023-06-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/28/carousel-source-code/" title="轮播图是怎么动起来的——轮播图的基本原理和源码学习"><img src="/img/swiper.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="轮播图是怎么动起来的——轮播图的基本原理和源码学习"/></a><div class="content"><a class="title" href="/2023/05/28/carousel-source-code/" title="轮播图是怎么动起来的——轮播图的基本原理和源码学习">轮播图是怎么动起来的——轮播图的基本原理和源码学习</a><time datetime="2023-05-28T11:37:56.000Z" title="发表于 2023-05-28 19:37:56">2023-05-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/17/react-native/" title="React Native 学习"><img src="/img/rn.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React Native 学习"/></a><div class="content"><a class="title" href="/2023/05/17/react-native/" title="React Native 学习">React Native 学习</a><time datetime="2023-05-17T06:58:28.000Z" title="发表于 2023-05-17 14:58:28">2023-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/05/konva/" title="konva学习和原理浅析"><img src="/img/konva.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="konva学习和原理浅析"/></a><div class="content"><a class="title" href="/2023/03/05/konva/" title="konva学习和原理浅析">konva学习和原理浅析</a><time datetime="2023-03-05T09:23:35.000Z" title="发表于 2023-03-05 17:23:35">2023-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/16/react-router/" title="react-router使用及原理浅析"><img src="/img/react.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="react-router使用及原理浅析"/></a><div class="content"><a class="title" href="/2023/02/16/react-router/" title="react-router使用及原理浅析">react-router使用及原理浅析</a><time datetime="2023-02-16T10:06:32.000Z" title="发表于 2023-02-16 18:06:32">2023-02-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Xing Ye</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hello stranger!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>