<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>算法学习总结 | XingYeBlog</title><meta name="keywords" content="日常学习"><meta name="author" content="Xing Ye,632885485@qq.com"><meta name="copyright" content="Xing Ye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="算法复杂度时间复杂度时间复杂度是一个函数，它定性描述该算法的运行时间。 我们在软件开发中，时间复杂度就是用来方便开发者估算出程序运行的答题时间。 那么该如何估计程序运行时间呢，通常会估算算法的操作单元数量来代表程序消耗的时间，这里默认 CPU 的每个单元运行消耗的时间都是相同的。 假设算法的问题规模为 n，那么操作单元数量便用函数 f(n)来表示，随着数据规模 n 的增大，算法执行时间的增长率和">
<meta property="og:type" content="article">
<meta property="og:title" content="算法学习总结">
<meta property="og:url" content="http://example.com/2022/04/05/blog43-algorithms/index.html">
<meta property="og:site_name" content="XingYeBlog">
<meta property="og:description" content="算法复杂度时间复杂度时间复杂度是一个函数，它定性描述该算法的运行时间。 我们在软件开发中，时间复杂度就是用来方便开发者估算出程序运行的答题时间。 那么该如何估计程序运行时间呢，通常会估算算法的操作单元数量来代表程序消耗的时间，这里默认 CPU 的每个单元运行消耗的时间都是相同的。 假设算法的问题规模为 n，那么操作单元数量便用函数 f(n)来表示，随着数据规模 n 的增大，算法执行时间的增长率和">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/codes1.jpg">
<meta property="article:published_time" content="2022-04-05T08:01:22.000Z">
<meta property="article:modified_time" content="2022-08-02T10:39:14.536Z">
<meta property="article:author" content="Xing Ye">
<meta property="article:tag" content="日常学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/codes1.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2022/04/05/blog43-algorithms/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法学习总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-02 18:39:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/pinkstar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/codes1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XingYeBlog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法学习总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-05T08:01:22.000Z" title="发表于 2022-04-05 16:01:22">2022-04-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-02T10:39:14.536Z" title="更新于 2022-08-02 18:39:14">2022-08-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">77.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>301分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法学习总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><strong>时间复杂度是一个函数，它定性描述该算法的运行时间</strong>。</p>
<p>我们在软件开发中，时间复杂度就是用来方便开发者估算出程序运行的答题时间。</p>
<p>那么该如何估计程序运行时间呢，通常会估算算法的操作单元数量来代表程序消耗的时间，这里默认 CPU 的每个单元运行消耗的时间都是相同的。</p>
<p>假设算法的问题规模为 n，那么操作单元数量便用函数 f(n)来表示，随着数据规模 n 的增大，算法执行时间的增长率和 f(n)的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 O(f(n))。大 O 就是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度，这个数据量也就是常数项系数已经不起决定性作用的数据量。所以我们说的时间复杂度都是省略常数项系数的，是因为一般情况下都是默认数据规模足够的大，基于这样的事实，给出的算法时间复杂的的一个排行如下所示：</p>
<blockquote>
<p>O(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O(n^2)平方阶 &lt; O(n^3)立方阶 &lt; O(2^n)指数阶</p>
</blockquote>
<p>通常来说，O(n)表示的都是算法的最大复杂度；但是对于一些更常见的情况，往往表示的是最一般的情况。比如快排的复杂度最大是 $O(n^2)$ ，但我们通常都说是 $O(nlogn)$，因为后者是更普遍的情况。</p>
<h2 id="迭代时间复杂度"><a href="#迭代时间复杂度" class="headerlink" title="迭代时间复杂度"></a>迭代时间复杂度</h2><p>时间复杂度最基本的形式就是迭代形式的。<br>比如一个最简单的迭代：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这个迭代一定会执行 n 次，所以时间复杂度就是 O(n)</p>
<p>如果 i 每次不是加 1 这样的线性增长，而是其他变化，时间复杂度就会有所不同：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i *= <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个迭代实际上执行了<code>n/2</code>次，但是算法复杂度忽略参数，我们还是看作 O(n)<br>第二个迭代很明显每次执行都会 i*2，这时就是一个对数复杂度，即 $O(log_{2}n)$ （通常忽略底数）</p>
<h2 id="递归的时间复杂度"><a href="#递归的时间复杂度" class="headerlink" title="递归的时间复杂度"></a>递归的时间复杂度</h2><p>递归算法的时间复杂度本质上是要看: <strong>递归的次数 * 每次递归中的操作次数</strong>。<br>递归其实是另一种迭代，因此很多算法的递归形式其实和迭代形式的复杂度差不多。<br>比如计算 x 的 n 次方，用递归形式描述为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> x * fn1(x, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个递归一共执行了 n 次（到 0 停止），每一次都是一个乘法操作（O(1)），因此总体时间复杂度就是 O(n)</p>
<p>再比如，递归形式的二分查找：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.length &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(nums.length / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (target === nums[mid]) flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">    binarySearch(nums.slice(mid + <span class="number">1</span>), target);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    binarySearch(nums.slice(<span class="number">0</span>, mid - <span class="number">1</span>), target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为每次实际上只会进入两个递归中的一个，并且 mid 一直在取数组长度 n 的一半，所以时间复杂度也是 O(logn)</p>
<hr>
<p>但是不一定所有每次减半的递归复杂度都是 O(logn)；如果一个递归是几个 O(logn)一起出现，那就有可能回到 O(n)</p>
<p>比如还是上面的乘方题，如果写成这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (x % <span class="number">2</span> === <span class="number">1</span>) <span class="keyword">return</span> fn2(x, n / <span class="number">2</span>) * fn2(x, n / <span class="number">2</span>) * x;</span><br><span class="line">  <span class="keyword">return</span> fn2(x, n / <span class="number">2</span>) * fn2(x, n / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个写法实际上就是把 2 的整数倍次方的情况单独列出来了；看起来好像是每次都只取 n/2，但是实际上每次递归都会执行两次同时的递归，所以时间复杂度还是 O(n)<br><img src="https://pic.imgdb.cn/item/6291a6c309475431292a43c7.jpg"></p>
<p>如果提前把这个结果缓存，让递归只执行一次，那么就会是 O(logn)了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> val = fn2(x, n / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (x % <span class="number">2</span> === <span class="number">1</span>) <span class="keyword">return</span> val * val * x;</span><br><span class="line">  <span class="keyword">return</span> val * val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>有些递归会展开成二叉树或多叉树的形式，比如回溯相关的题目，以及部分用递归来解的动态规划。<br>一棵深度（按根节点深度为 1）为 k 的二叉树最多可以有 $2^k - 1$ 个节点</p>
<p>以斐波那契数列为例，最基本的不做任何优化的算法复杂度为 $O(2^n)$ ，就是最大的指数时间复杂度<br><img src="https://pic.imgdb.cn/item/6291bdb90947543129471d30.jpg"><br>产生这么大复杂度的主要原因是同时进行了两次递归，并且每个递归的次数其实并没有多少减少（还是 n 次）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> fibonacci(i - <span class="number">1</span>) + fibonacci(i - <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><blockquote>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
</blockquote>
<p>这道题是经典的解法简单、但是可以使用更好的方法优化的问题。<br>最简单的方式是通过双重循环遍历：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findTarget</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> a = <span class="number">0</span>; a &lt; nums.length; a++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> b = <span class="number">0</span>; b &lt; nums.length; b++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[a] + nums[b] === target) <span class="keyword">return</span> [a, b];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是可以通过“空间换时间，加法转减法”的方法优化这道题目。<br>思路是求和问题转化为求差问题, 每遍历到一个新数字的时候，都回到 <code>Map</code> 里去查询 <code>targetNum</code> 与该数的差值是否已经在前面的数字中出现过了。如果出现过显然就是结果；如果没有出现就记录当前数字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findTargetByMap</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  map.set(nums[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.has(target - nums[i])) &#123;</span><br><span class="line">      <span class="comment">// 如果目标数减去当前数在map中存在, 说明找到了</span></span><br><span class="line">      <span class="keyword">return</span> [i, map.get(target - nums[i])];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有找到, 则把该数放到map中</span></span><br><span class="line">      map.set(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两数之和还提供了一个重要的思路：既然两个数可以通过哈希表简化，那么三个数、四个数也可以（先计算两个数的和<code>sum1</code>并存到 map 中，再计算另外几个数的和并查找<code>target - sum1 === sum2</code>），本质上还是两个数的求和。</p>
<h2 id="合并有序数组"><a href="#合并有序数组" class="headerlink" title="合并有序数组"></a>合并有序数组</h2><blockquote>
<ol start="2">
<li>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</li>
</ol>
</blockquote>
<p>思路是使用两个指针（i、j）分别指向两个数组中的数字，然后两边同时遍历，比较两个指针所指的数字的大小关系，把较小的一个放入新数组，依次类推；<br>最终有一个数组会剩下一部分，再把这一部分截下来补在最后即可</p>
<blockquote>
<p>注意：双指针法用在涉及求和、比大小类的数组题目里时，大前提往往是：该数组必须有序。否则双指针根本无法帮助我们缩小定位的范围，压根没有意义。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatArray</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newArr = [];</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) &#123;</span><br><span class="line">    newArr.push(arr1[i] &lt; arr2[j] ? arr1[i++] : arr2[j++]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [...newArr, ...(i === arr1.length ? arr2.slice(j) : arr1.slice(i))];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三数求和"><a href="#三数求和" class="headerlink" title="三数求和"></a>三数求和</h2><blockquote>
<ol start="3">
<li>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</li>
</ol>
</blockquote>
<p>思路：</p>
<ol>
<li>首先先对数组排序；</li>
<li>然后固定一个元素<code>k</code>,然后双指针分别指向其后后面元素的第一个<code>k+1</code>和最后一个<code>length - 1</code>,按照两元素和的方法移动指针<ul>
<li>若三个数相加之和大于 0，说明右侧的数偏大了，右指针左移</li>
<li>若三个数相加之和小于 0，说明左侧的数偏小了，左指针右移</li>
</ul>
</li>
</ol>
<p>因为要求找到不重复的三元组，因此遍历期间两个指针处如果有重复的数字应该跳过；并且固定的元素也应该跳过重复</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">triNumberSum</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  nums = nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> cache = []; <span class="comment">// 存储防止重复</span></span><br><span class="line">  <span class="keyword">const</span> newArr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; nums.length - <span class="number">2</span>; k++) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果当前正在遍历的数字重复了就直接跳过</span></span><br><span class="line">    <span class="keyword">if</span> (cache.includes(nums[k])) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">const</span> sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">      <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 等于0得到结果</span></span><br><span class="line">        newArr.push([nums[i], nums[j], nums[k]]);</span><br><span class="line">        cache.push(nums[k]);</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 大于0说明右边大了</span></span><br><span class="line">        j--;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; i &amp;&amp; nums[j] === nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="comment">// 如果前一个数和这个数一样就继续向前，即跳过重复的</span></span><br><span class="line">          j--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 小于0说明左边小了</span></span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] === nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">          i++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>左右指针一起从两边往中间位置相互迫近，这样的特殊双指针形态，被称为“对撞指针”。<br><strong>有序</strong>和<strong>数组</strong>这样的关键词出现，就要考虑使用对撞指针</p>
</blockquote>
<h2 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h2><blockquote>
<p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。<br>示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p>
</blockquote>
<p>这道题的解法不是先平方再排序，而是通过双指针的形式原地 O(1)实现。</p>
<p>思路是，新创建一个数组，然后新数组从后往前存值；接下来循环：<br>比较左指针和右指针的数的平方值大小；将较大的一个数放入新数组，然后较大数的那边指针移动。</p>
<p>之所以从后向前存值，是因为负数的平方有可能超过正数，如果从前向后没法确定最小值是哪个。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortedSquares = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="built_in">Array</span>(nums.length);</span><br><span class="line">  <span class="keyword">while</span> (k &lt; res.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] ** <span class="number">2</span> &lt; nums[j] ** <span class="number">2</span>) &#123;</span><br><span class="line">      res[k++] = nums[i] ** <span class="number">2</span>;</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res[k++] = nums[j] ** <span class="number">2</span>;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><blockquote>
<p>给你一个数组 nums  和一个值 val，你需要<strong>原地</strong>移除<strong>所有</strong>数值等于  val  的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<p>这道题的思路是利用快慢指针；当走到目标元素时，让快指针先走到第一个不是目标元素的位置，然后将快指针所指的值替换到慢指针的位置即可。注意要保存两个指针之间的位置差</p>
<p>还有一点，遍历至少要完成所有元素的一次遍历；所以可以<strong>让慢指针延迟，而不是让快指针先走</strong>的方式；当快指针走到头时，遍历就完成了，此时慢指针恰好就是最后一个。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">val</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElement = <span class="function"><span class="keyword">function</span> (<span class="params">nums, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] !== val) &#123;</span><br><span class="line">      nums[k] = nums[i];</span><br><span class="line">      k++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> k;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/">https://leetcode.cn/problems/move-zeroes/</a></p>
<blockquote>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。<br>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p>
</blockquote>
<p>主要是学习一下移动数组的方式，这里直接写代码了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">arr, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt; arr.length; i++) &#123;</span><br><span class="line">      arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (nums[i] === <span class="number">0</span>) &#123;</span><br><span class="line">      move(nums, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] == <span class="literal">undefined</span>) nums[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/">https://leetcode.cn/problems/intersection-of-two-arrays/</a></p>
<blockquote>
<p>给定两个数组  nums1  和  nums2 ，返回 它们的交集  。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。<br>示例 1：<br>输入：nums1 = [1,2,2,1], nums2 = [2,2]<br>输出：[2]</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> intersection = <span class="function"><span class="keyword">function</span> (<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums1) &#123;</span><br><span class="line">    set.add(num);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (set.has(num)) res.add(num);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [res.values()];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="旋转数组（轮转数组）"><a href="#旋转数组（轮转数组）" class="headerlink" title="旋转数组（轮转数组）"></a>旋转数组（轮转数组）</h2><blockquote>
<p>给你一个数组，将数组中的元素向右轮转 k  个位置，其中  k  是非负数。<br>示例 1:<br>输入: nums = [1,2,3,4,5,6,7], k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右轮转 1 步: [7,1,2,3,4,5,6]<br>向右轮转 2 步: [6,7,1,2,3,4,5]<br>向右轮转 3 步: [5,6,7,1,2,3,4]</p>
</blockquote>
<p>这道题的暴力法可以把最后一个元素移到前面，然后执行 k 次就行。</p>
<p>但是还是有一个简单方法的：</p>
<ol>
<li>翻转整个数组</li>
<li>翻转前 K 个值</li>
<li>翻转后 K 个值</li>
</ol>
<p>最后就可以得到结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.length === <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (k === nums.length) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> swap = <span class="function">(<span class="params">arr, i, j</span>) =&gt;</span> ([arr[i], arr[j]] = [arr[j], arr[i]]);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">partReverse</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      swap(arr, i, j);</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> tmp = nums.reverse();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (k &gt; nums.length) &#123;</span><br><span class="line">    <span class="comment">// 注意处理K大于数组长度的情况</span></span><br><span class="line">    k = k % nums.length;</span><br><span class="line">  &#125;</span><br><span class="line">  partReverse(tmp, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">  partReverse(tmp, k, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h2><p>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。<br>比如说，给输入一个数组 nums，然后又要求给区间 nums[2..6] 全部加 1，再给 nums[3..9] 全部减 3，再给 nums[0..4] 全部加 2，最后问 nums 数组的值是什么？</p>
<p>差分数组的核心是 diff 数组。diff 数组和原数组可以互相转换，之间最重要的关系：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">nums[i] = nums[i - <span class="number">1</span>] + diff[i];</span><br><span class="line"></span><br><span class="line">diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>可以看到，diff 数组基本上特点是：</p>
<ul>
<li>表示当前位置的数和前一个位置的差</li>
<li>和原数组首位相同</li>
</ul>
<p>差分数组问题的解决方法，通常也就是对 diff 数组进行操作，再转回原来的数组。</p>
<blockquote>
<p>这样构造差分数组 diff，就可以快速进行区间增减的操作，如果你想对区间 <code>nums[i..j]</code> 的元素全部加 3，那么只需要让 <code>diff[i] += 3</code>，然后再让 <code>diff[j+1] -= 3</code> 即可<br>注意后面的范围是 j+1，可以理解为前缀和求区间时，不应该减掉区间的最后一个数 j，而是从最后一个数的下一个 j+1 剪掉。但是下面有一道题恰好是要从 j 开始减去。</p>
</blockquote>
<p>这个原理也比较好理解，手写推导一下就出来了。<code>diff[i] += 3</code> 意味着给 <code>nums[i..]</code> 所有的元素都加了 3，<code>diff[j+1] -= 3</code> 又意味着对于 <code>nums[j+1..]</code> 所有元素再减 3，综合起来就像前缀和一样，将 ij 之间的部分加了 3.</p>
<p>解决这类问题的通用模板：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建diff</span></span><br><span class="line"><span class="keyword">const</span> diff = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据推导公式得到diff具体的值</span></span><br><span class="line">diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">  diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据题目对某个范围的加减要求，对diff进行加减</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> update <span class="keyword">of</span> updates) &#123;</span><br><span class="line">  <span class="keyword">const</span> [start, end, inc] = update;</span><br><span class="line">  <span class="comment">// 从start到end之间的数字增加inc，</span></span><br><span class="line">  diff[start] += inc;</span><br><span class="line">  <span class="keyword">if</span> (end + <span class="number">1</span> &lt; length) diff[end + <span class="number">1</span>] -= inc; <span class="comment">// 如果end+1都超长了，就不再需要减</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再转换回基本数组即可</span></span><br><span class="line"><span class="keyword">const</span> res = [];</span><br><span class="line">res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">  res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>

<h3 id="区间加法"><a href="#区间加法" class="headerlink" title="区间加法"></a>区间加法</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-addition/">https://leetcode.cn/problems/range-addition/</a></p>
<blockquote>
<p>假设你有一个长度为  n  的数组，初始情况下所有的数字均为  0，你将会被给出  k​​​​​​​ 个更新的操作。<br>其中，每个操作会被表示为一个三元组：[startIndex, endIndex, inc]，你需要将子数组  A[startIndex … endIndex]（包括 startIndex 和 endIndex）增加  inc。<br>请你返回  k  次操作后的数组。</p>
</blockquote>
<p>这是差分数组的最基本题型，这里直接上代码了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">length</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">updates</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getModifiedArray = <span class="function"><span class="keyword">function</span> (<span class="params">length, updates</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> nums = <span class="keyword">new</span> <span class="built_in">Array</span>(length).fill(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> diff = [];</span><br><span class="line"></span><br><span class="line">  diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> update <span class="keyword">of</span> updates) &#123;</span><br><span class="line">    <span class="keyword">const</span> [start, end, inc] = update;</span><br><span class="line">    diff[start] += inc;</span><br><span class="line">    <span class="keyword">if</span> (end + <span class="number">1</span> &lt; length) diff[end + <span class="number">1</span>] -= inc;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="拼车"><a href="#拼车" class="headerlink" title="拼车"></a>拼车</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/car-pooling/">https://leetcode.cn/problems/car-pooling/</a></p>
<blockquote>
<p>车上最初有  capacity  个空座位。车   只能   向一个方向行驶（也就是说，不允许掉头或改变方向）<br>给定整数  capacity  和一个数组 trips ,  trip[i] = [numPassengers, from, to]  表示第 i 次旅行有  numPassengers  乘客，接他们和放他们的位置分别是  from  和  to 。这些位置是从汽车的初始位置向东的公里数。<br>当且仅当你可以在所有给定的行程中接送所有乘客时，返回  true，否则请返回 false。</p>
</blockquote>
<p>这道题有一点不太明显，但是如果考虑用一个数组 passengers[i]表示第 i 站时车上的人数，每次上下车都是对该数组一个区间内的增减，就很好理解了。</p>
<p>但是还是有不少坑：</p>
<ul>
<li>题目没给站数，因此直接取范围上限 1000</li>
<li>乘客到第 i 站时下车，意味着此时会立刻减去，而不是到下一站才减去。一站内可以允许乘客同时上下车，即使此时最大乘客数已经超出 capacity。因此后面的部分就应该是<code>to</code>而不是<code>to+1</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">trips</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">capacity</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> carPooling = <span class="function"><span class="keyword">function</span> (<span class="params">trips, capacity</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> passengers = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1001</span>).fill(<span class="number">0</span>); <span class="comment">// passengers[i]表示第i站时车上的人数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> diff = [...passengers];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> trip <span class="keyword">of</span> trips) &#123;</span><br><span class="line">    <span class="keyword">const</span> [num, <span class="keyword">from</span>, to] = trip;</span><br><span class="line">    diff[<span class="keyword">from</span>] += num;</span><br><span class="line">    <span class="keyword">if</span> (to &lt; <span class="number">1001</span>) diff[to] -= num;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">1001</span>; i++) &#123;</span><br><span class="line">    res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">    <span class="keyword">if</span> (res[i - <span class="number">1</span>] &gt; capacity) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="回文字符串"><a href="#回文字符串" class="headerlink" title="回文字符串"></a>回文字符串</h2><blockquote>
<ol>
<li>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。<br>示例：<br>输入: “abaca”<br>输出: True<br>解释: 你可以删除 c 字符。</li>
</ol>
</blockquote>
<p>思路：利用回文字符串的“对称性”，即字符串从两头分别遍历，每个字符都相等（直到两个遍历指针相碰）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> strArr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = strArr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strArr[i] === strArr[j]) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么放到这个题就是，现进行一次上面的操作，直到找到第一个不相等的字符串为止；</p>
<p>然后“跳过”这个字符，分别让左指针跳过当前正在指的字符、右指针跳过当前正在指的字符，然后判断跳过之后左右指针中间的字符段是否回文。</p>
<p>原理其实是，由于判断出现不同时，不知道是左边还是右边的那个字符不对，因此就让左右分别跳过，测试跳过之后中间部分是不是还能正常回文。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">palindrome</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> strArr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = strArr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strArr[i] === strArr[j]) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> isPalindrome(str.splice(i, <span class="number">1</span>)) &amp;&amp; isPalindrome(str.splice(j, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> strArr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = strArr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strArr[i] === strArr[j]) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><p>KMP 算法的讲解可以参考 <a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a><br>详细代码参考 <a target="_blank" rel="noopener" href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s2</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">KMP</span>(<span class="params">s1, s2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取next数组，这里就是最大前缀数组</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getNext</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [<span class="number">0</span>]; <span class="comment">// 第一项一定是0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">1</span>; k &lt; str.length; k++) &#123;</span><br><span class="line">      <span class="comment">//从第二个字母开始遍历</span></span><br><span class="line">      <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> j = k;</span><br><span class="line">      <span class="keyword">let</span> start = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">let</span> end = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; str.length - <span class="number">1</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        start += str[i++];</span><br><span class="line">        end += str[j--]; <span class="comment">// 因为end是从后向前拼的，应该倒转一下</span></span><br><span class="line">        <span class="keyword">if</span> (start === end.split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">          max = <span class="built_in">Math</span>.max(max, start.length);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      res.push(max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> str = s1.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> search = s2.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> next = getNext(search);</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 这里用while而不是用if，因为如果出现不匹配，应当是按照前缀数组next一个一个</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str[i] !== search[j]) &#123;</span><br><span class="line">      <span class="comment">// 如果j=0，说明子串第一项就不匹配，直接继续（只i++）</span></span><br><span class="line">      j = next[j - <span class="number">1</span>]; <span class="comment">// 回退的实际上是前一项的最大前后缀</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前匹配，继续</span></span><br><span class="line">    <span class="keyword">if</span> (str[i] === search[j]) &#123;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 匹配完成</span></span><br><span class="line">    <span class="keyword">if</span> (j === search.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> i - search.length + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>next 的计算还有一种的写法，利用前缀和后缀的最后一个字母不同时，回退前一个 next 值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNext</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> next = [<span class="number">0</span>]; <span class="comment">// 第一项一定是0</span></span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] !== s[j]) &#123;</span><br><span class="line">      j = next[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s[i] === s[j]) &#123;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    next[i] = j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重复子字符串"><a href="#重复子字符串" class="headerlink" title="重复子字符串"></a>重复子字符串</h2><blockquote>
<p>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。<br>输入: s = “abcabcabcabc”<br>输出: true<br>解释: 可由子串 “abc” 重复四次构成。 (或子串 “abcabc” 重复两次构成。)</p>
</blockquote>
<p>思路是利用 KMP 算法中的 next 数组。因为 next 数组判断的是最长公共前缀，那么 next 数组的最后一项就应该是前面的最长重复子串的长度的整数倍数。<br>即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getNext(&quot;abcdabcdabcd&quot;)</span><br><span class="line">(12) [0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure>

<p>8 这个值是<code>abcdabcd</code>的长度，这个长度重复两次就刚好是这个字符串。<br>然后让<code>12 - 8 = 4</code>，即除去公共串后，剩下还有多长；剩下的 4 可以整除 12，说明存在长度为 4 的重复子字符串。<br>因此公式为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">next.length % (next.length - next[next.length - <span class="number">1</span>]) === <span class="number">0</span> &amp;&amp;</span><br><span class="line">  next[next.length - <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 能整除，并且最后一项不为0，说明为true</span></span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> repeatedSubstringPattern = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getNext</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> next = [<span class="number">0</span>]; <span class="comment">// 第一项一定是0</span></span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] !== s[j]) &#123;</span><br><span class="line">        j = next[j - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (s[i] === s[j]) &#123;</span><br><span class="line">        j++;</span><br><span class="line">      &#125;</span><br><span class="line">      next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> next = getNext(s);</span><br><span class="line">  <span class="keyword">if</span> (s.length % (s.length - next[next.length - <span class="number">1</span>]) || !next[next.length - <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是这道题其实有更简单的两个解法，可以参考官方解法 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/">https://leetcode.cn/problems/repeated-substring-pattern/</a></p>
<p>简单写一下思路：</p>
<ol>
<li>解法 1：枚举，从第一个元素开始作为子串。假设子串长度为 n，那么 i 和 n+i 必然是相同的字符，否则就不是重复构成的。逐个增大 n，直到找到 str[i] === str[n+i]为止（i 需要从 0 到 n）；如果<code>n &gt;= len/2</code> 且还没有找到，就说明不能。</li>
<li>查找<code>s+s</code>去掉首位元素的中间部分有没有 s，这个方法的原理参考题解。最重要的在于提供了一个思路，就是<code>s+s</code>中间部分依次取 n 个字符可以得到 s 的多种“翻转”情况，比如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = acd</span><br><span class="line">s+s = acdacd</span><br><span class="line"></span><br><span class="line">排除首尾元素，中间部分用大小为 s.length 的滑动窗口取，就是s所有可能的翻转</span><br><span class="line"></span><br><span class="line">a(cda)cd ac(dac)d</span><br></pre></td></tr></table></figure>

<h2 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-prefix/">https://leetcode.cn/problems/longest-common-prefix/</a></p>
<blockquote>
<p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串  “”。<br>示例 1：<br>输入：strs = [“flower”,”flow”,”flight”]<br>输出：”fl”</p>
</blockquote>
<p>思路就是纵向比较同一个位置上的字符，如果出现不一样的就立刻返回结果，否则持续向结果数组中放入当前字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">strs</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestCommonPrefix = <span class="function"><span class="keyword">function</span> (<span class="params">strs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> lengths = strs.map(<span class="function">(<span class="params">str</span>) =&gt;</span> str.length);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.min(...lengths); i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> str <span class="keyword">of</span> strs) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!tmp || tmp === str[i]) tmp = str[i];</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> res.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(tmp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="列表序号"><a href="#列表序号" class="headerlink" title="列表序号"></a>列表序号</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/excel-sheet-column-number/submissions/">https://leetcode.cn/problems/excel-sheet-column-number/submissions/</a></p>
<blockquote>
<p>给你一个字符串  columnTitle ，表示 Excel 表格中的列名称。返回 该列名称对应的列序号  。<br>例如：</p>
<p>A -&gt; 1<br>B -&gt; 2<br>C -&gt; 3<br>…<br>Z -&gt; 26<br>AA -&gt; 27<br>AB -&gt; 28</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">columnTitle</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> titleToNumber = <span class="function"><span class="keyword">function</span> (<span class="params">columnTitle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> letters = columnTitle.split(<span class="string">&quot;&quot;</span>).reverse();</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> getNum = <span class="function">(<span class="params">letters</span>) =&gt;</span> letters.charCodeAt() - <span class="string">&quot;A&quot;</span>.charCodeAt();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; letters.length; i++) &#123;</span><br><span class="line">    sum += getNum(letters[i]) * <span class="number">26</span> ** i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="列表名称"><a href="#列表名称" class="headerlink" title="列表名称"></a>列表名称</h2><p>这道题就是上一道题的反向，也就是常见的进制转化题。</p>
<p>对于一般性的十进制转 n 进制题目，只需要不断地对十进制数 num 进行 % 运算取得最后一位，然后对 num 进行 / 运算，将已经取得的位数去掉，直到 num 为 0 即可。</p>
<p>一般性的进制转换题目无须进行额外操作，但是这道题的特点是进制是从 1 开始的（A 表示 1），而不是 0，所以必须要给十进制数字先-1，再 % 得到余数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">columnNumber</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> convertToTitle = <span class="function"><span class="keyword">function</span> (<span class="params">columnNumber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ans = [];</span><br><span class="line">  <span class="keyword">while</span> (columnNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> a0 = (columnNumber - <span class="number">1</span>) % <span class="number">26</span>; <span class="comment">// 这里是因为该进制是从1开始的而不是0</span></span><br><span class="line">    ans.push(<span class="built_in">String</span>.fromCharCode(a0 + <span class="string">&quot;A&quot;</span>.charCodeAt()));</span><br><span class="line">    columnNumber = <span class="built_in">Math</span>.floor((columnNumber - a0) / <span class="number">26</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ans.reverse();</span><br><span class="line">  <span class="keyword">return</span> ans.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="验证-IP-地址"><a href="#验证-IP-地址" class="headerlink" title="验证 IP 地址"></a>验证 IP 地址</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-ip-address/">https://leetcode.cn/problems/validate-ip-address/</a></p>
<p>这道题本身比较简单，但是要学习一个方法：<br>怎么检验一个字符是合法字符？（数字、字母等）<br>最简单粗暴的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> all = <span class="string">&quot;0123456789abcdef&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!all.includes(s)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">queryIP</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> validIPAddress = <span class="function"><span class="keyword">function</span> (<span class="params">queryIP</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> queryIP.includes(<span class="string">&quot;.&quot;</span>) ? IPv4(queryIP) : IPv6(queryIP);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IPv4</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = str.split(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  arr.forEach(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isNaN</span>(num)) flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Number</span>(num).toString().length !== num.length) flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (+num &gt; <span class="number">255</span>) flag = <span class="literal">false</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> flag ? <span class="string">&quot;IPv4&quot;</span> : <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IPv6</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = str.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> isLetter = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    str = str.toLowerCase();</span><br><span class="line">    <span class="keyword">const</span> all = <span class="string">&quot;0123456789abcdef&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!all.includes(s)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  arr.forEach(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num.length &gt; <span class="number">4</span> || num.length &lt; <span class="number">1</span>) flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!isLetter(num)) flag = <span class="literal">false</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> flag ? <span class="string">&quot;IPv6&quot;</span> : <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="合并有序链表"><a href="#合并有序链表" class="headerlink" title="合并有序链表"></a>合并有序链表</h2><blockquote>
<p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有结点组成的。</p>
</blockquote>
<p>有序链表的合成和有序数组的合并类似，都是用双指针依次遍历节点。</p>
<p>通过 LinkNode 新创建一个头节点，然后依次把两个链表中的节点比较、附加在这个新的头节点后面，形成的新链表就是有序链表。最后再把没连接上的多余部分加上去即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeTwoLists = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> head = <span class="keyword">new</span> LinkNode();</span><br><span class="line">  <span class="keyword">let</span> curr = head;</span><br><span class="line">  <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">      curr.next = l1;</span><br><span class="line">      l1 = l1.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      curr.next = l2;</span><br><span class="line">      l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  curr.next = l1 ? l1 : l2;</span><br><span class="line">  <span class="keyword">return</span> curr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="删除所有重复元素（dummy-节点）"><a href="#删除所有重复元素（dummy-节点）" class="headerlink" title="删除所有重复元素（dummy 节点）"></a>删除所有重复元素（dummy 节点）</h2><blockquote>
<p>给定一个排序链表，删除所有含有重复数字的结点，只保留原始链表中 没有重复出现的数字。</p>
</blockquote>
<p>这道题乍看起来比较简单，可以用一个 set 存储前面遍历过的数字，如果在 set 中找到，就把这些删去。</p>
<p>问题在于，这里要求删去所有节点，那么重复的这一组节点中的头一个节点就无法删去，因为不能获取到它前面的节点，就不能删去它</p>
<p>为了解决这个问题，设置一个位于整个链表头部的 dummy 节点，从 dummy 开始遍历（假设当前指针是 curr）：如果<code>curr.next.val === curr.next.next.val</code>，就用循环依次遍历到不相等的节点，然后把<code>curr.next</code>指过去即可。</p>
<p>dummy 节点的出现在这里主要是为了解决第一个节点就是重复节点的问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deleteDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 设定 dummy 指针，作为头节点的前一个虚拟节点</span></span><br><span class="line">  <span class="keyword">let</span> dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">  dummy.next = head;</span><br><span class="line">  <span class="keyword">let</span> cur = dummy; <span class="comment">// 从dummy开始，这样就解决了第一个就重复的情况</span></span><br><span class="line">  <span class="keyword">while</span> (cur.next &amp;&amp; cur.next.next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur.next.val === cur.next.next.val) &#123;</span><br><span class="line">      <span class="comment">// 若值重复，则记下这个值</span></span><br><span class="line">      <span class="keyword">let</span> val = cur.next.val;</span><br><span class="line">      <span class="comment">// 反复地排查后面的元素是否存在多次重复该值的情况</span></span><br><span class="line">      <span class="keyword">while</span> (cur.next &amp;&amp; cur.next.val === val) &#123;</span><br><span class="line">        <span class="comment">// 若有，则删除</span></span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 若不重复，则正常遍历</span></span><br><span class="line">      cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注意是dummy.next</span></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><blockquote>
<p>给定一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
</blockquote>
<p>快慢指针即设定两个指针，快指针在慢指针前面或者快指针一次走的步数比慢指针多；当快指针到达某个位置时，慢指针往往就是对应的解。</p>
<p>比如倒数 n 个节点，可以让快指针先走 n 步，然后两者一起往前走；当快指针走到最后一个节点时，慢指针所指向的就是倒数第 n 个</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> removeNthFromEnd = <span class="function"><span class="keyword">function</span> (<span class="params">head, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">  dummy.next = head;</span><br><span class="line">  <span class="keyword">let</span> fast = dummy;</span><br><span class="line">  <span class="keyword">let</span> slow = dummy;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!fast.next) <span class="keyword">return</span>;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (fast.next) &#123;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">  &#125;</span><br><span class="line">  slow.next = slow.next.next;</span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><blockquote>
<p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</p>
</blockquote>
<p>记住方法：</p>
<ol>
<li>使用 prev/curr/next 三个指针分别指向前一个、当前和后一个节点；其中 curr 是第一个节点，prev 可以是 null 或者 dummy</li>
<li>从 curr 指向的第一个节点开始，让当前节点的 next 指向 pre；</li>
<li>然后令<code>curr = next，prev = curr，next = next.next</code>，即依次向后移动，直到最后一个节点被反转</li>
<li>cur 节点是真正反转的节点，因此要遍历到最后一个；当 cur 成为 null 时，pre 就是最后一个节点</li>
</ol>
<blockquote>
<p>实际上并不需要 next 指针，因为直接用<code>curr.next</code>就可以，每次遍历都先获取<code>curr.next</code>并缓存一下，然后继续即可</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseList = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="literal">null</span>; <span class="comment">// 前节点</span></span><br><span class="line">  <span class="keyword">let</span> cur = head; <span class="comment">// 当前节点，从头节点开始</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = cur.next; <span class="comment">// 先缓存next</span></span><br><span class="line">    cur.next = pre;</span><br><span class="line">    pre = cur;</span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="部分反转一个链表"><a href="#部分反转一个链表" class="headerlink" title="部分反转一个链表"></a>部分反转一个链表</h2><blockquote>
<p>部分反转：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
</blockquote>
<p>核心方法和正常的反转链表一样，关键在于反转之后把反转的部分和其他的连起来。<br>其实就是先把反转部分的前节点和后节点存起来，反转完成后再连起来。</p>
<p><img src="https://pic.imgdb.cn/item/6266b3c3239250f7c528044f.jpg"></p>
<p>以这幅图为例，当 curr 指针遍历到 left 时，即开始遍历到区域时，就把节点 1 缓存下来（此时正好是 pre 指针指向的）；<br>随着遍历的进行，当结点 4 的指针反转后，此时 cur 指针就恰好指在结点 5 上，这时只需要把节点 2 指向 cur 即可。</p>
<p>另外，还需要记录反转区域内部的头尾节点（上面的 2、4 节点）；其中 4 节点恰好是遍历完的 pre，直接<code>leftHead.next = pre</code>即可；但是 2 节点需要提前缓存（下面代码中的 start），结束后让<code>start.next = cur</code>连接尾部。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseBetween = <span class="function"><span class="keyword">function</span> (<span class="params">head, m, n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义pre、cur，用leftHead来承接整个区间的前驱结点</span></span><br><span class="line">  <span class="keyword">let</span> pre, cur, leftHead;</span><br><span class="line">  <span class="keyword">const</span> dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">  <span class="comment">// dummy后继结点是头结点</span></span><br><span class="line">  dummy.next = head;</span><br><span class="line">  <span class="comment">// p是一个游标，用于遍历，最初指向 dummy</span></span><br><span class="line">  <span class="keyword">let</span> p = dummy;</span><br><span class="line">  <span class="comment">// p往前走 m-1 步，走到整个区间的前驱结点处</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    p = p.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 缓存这个前驱结点到 leftHead 里</span></span><br><span class="line">  leftHead = p;</span><br><span class="line">  <span class="comment">// start 是反转区间的第一个结点</span></span><br><span class="line">  <span class="keyword">let</span> start = leftHead.next;</span><br><span class="line">  <span class="comment">// pre 指向start</span></span><br><span class="line">  pre = start;</span><br><span class="line">  <span class="comment">// cur 指向 start 的下一个结点</span></span><br><span class="line">  cur = pre.next;</span><br><span class="line">  <span class="comment">// 开始重复反转动作</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = m; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = cur.next;</span><br><span class="line">    cur.next = pre;</span><br><span class="line">    pre = cur;</span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  leftHead 的后继结点此时为反转后的区间的第一个结点</span></span><br><span class="line">  leftHead.next = pre;</span><br><span class="line">  <span class="comment">// 将区间内反转后的最后一个结点 next 指向 cur</span></span><br><span class="line">  start.next = cur;</span><br><span class="line">  <span class="comment">// dummy.next 永远指向链表头结点</span></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="递归反转一个链表"><a href="#递归反转一个链表" class="headerlink" title="递归反转一个链表"></a>递归反转一个链表</h2><p>链表的递归实际上和树的递归很像。链表同样有自己的前序和后序遍历：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travarse</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">  <span class="comment">// 前序（正向遍历）</span></span><br><span class="line">  travarse(head.next);</span><br><span class="line">  <span class="comment">// 后序（反向遍历）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后序遍历实际上就是在倒着走一遍链表。如果能在反向遍历的过程中改变指针，就表现为反转链表了。</p>
<p>先上写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseList = <span class="function">(<span class="params">head</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!head || !head.next) <span class="keyword">return</span> head; <span class="comment">// 递归边界返回当前节点</span></span><br><span class="line">  <span class="keyword">const</span> last = reverseList(head.next); <span class="comment">// last相当于一直递归找到了最尾端的节点</span></span><br><span class="line">  <span class="comment">/* 这个时候的head实际上是倒数第二个节点 */</span></span><br><span class="line">  head.next.next = head; <span class="comment">// 让当前节点的后一个节点指向自己（反转紧邻的后面节点的方向）</span></span><br><span class="line">  head.next = <span class="literal">null</span>; <span class="comment">//本节点向后的指针删去</span></span><br><span class="line">  <span class="keyword">return</span> last; <span class="comment">// 理论上递归过程中不需要这个last，但是最后需要这个作为反转之后的头节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到这种写法有几个关键点：</p>
<ol>
<li>last 节点，虽然并没参与递归，但是需要最后作为头节点；</li>
<li>固定的两步</li>
</ol>
<ul>
<li><code>head.next.next = head;</code>：表示把后一个节点指向前一个（当前的）</li>
<li><code>head.next = null</code>：表示当前节点的后指针置空，因为链表已经反转了，原先的头节点变成了尾，因此就必须要置空。但是如果是部分反转，那么就不能设为空，因为还要和其他部分连起来。</li>
</ul>
<p>递归反转链表常见于部分反转，部分反转实际上就是更改递归边界即可。<br>比如反转前 k 个节点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseN = <span class="function">(<span class="params">head, k</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> after = <span class="literal">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k === <span class="number">1</span>) &#123;</span><br><span class="line">      after = head.next; <span class="comment">// 递归到位，然后将后驱节点存下来</span></span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> last = reverse(head.next, k - <span class="number">1</span>);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = after;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后，反转任意一个部分的链表，其实就是先递归到起始节点位置，然后以起始节点为第一个节点，执行上面的反转前 k 个节点，最后把返回值和前面的连起来就行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseMN = <span class="function">(<span class="params">head, m, n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (m === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> reverseN(head, n);</span><br><span class="line">  &#125;</span><br><span class="line">  head.next = reverseMN(head.next, m - <span class="number">1</span>, n - <span class="number">1</span>); <span class="comment">// 相当于往后走到了起始节点，然后m和n都对应-1（比如从2/4变为1/3这样）</span></span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="链表交叉"><a href="#链表交叉" class="headerlink" title="链表交叉"></a>链表交叉</h2><blockquote>
<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>
</blockquote>
<p>思路是这样：因为相交之前，两个链表长度不一样；所以可以先调整起始位置，让较长的链表向前移动几位，和较短的链表头节点并齐之后再开始遍历。<br>判断相交节点的方式是两个<strong>指针</strong>相同，注意不是值相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">headA</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">headB</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span> (<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getLen</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">      len++;</span><br><span class="line">      curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> lenA = getLen(headA);</span><br><span class="line">  <span class="keyword">const</span> lenB = getLen(headB);</span><br><span class="line">  <span class="keyword">let</span> startIndex = <span class="built_in">Math</span>.abs(lenA - lenB);</span><br><span class="line">  <span class="keyword">let</span> startA = headA;</span><br><span class="line">  <span class="keyword">let</span> startB = headB;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (lenA &gt; lenB) &#123;</span><br><span class="line">    startA = headA;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; startIndex; i++) &#123;</span><br><span class="line">      startA = startA.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lenA &lt; lenB) &#123;</span><br><span class="line">    startB = headB;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; startIndex; i++) &#123;</span><br><span class="line">      startB = startB.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (startA &amp;&amp; startB) &#123;</span><br><span class="line">    startA = startA.next;</span><br><span class="line">    startB = startB.next;</span><br><span class="line">    <span class="keyword">if</span> (startA === startB) flag = startA;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="判断回文链表"><a href="#判断回文链表" class="headerlink" title="判断回文链表"></a>判断回文链表</h2><blockquote>
<p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p>
</blockquote>
<p>这道题有几个思路：</p>
<ol>
<li>最朴实的方法，先快慢指针找到中间节点，然后从中间节点开始反转后面的链表，再双指针比较两个链表是否相等。</li>
<li>顺序输出转换成数组，然后判断数组是否回文。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> curr = head;</span><br><span class="line">  <span class="keyword">const</span> arr = [];</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    arr.push(curr.val);</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.join(<span class="string">&quot;&quot;</span>) === arr.reverse().join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>递归方法。先通过递归走到最后一个节点，在返回的途中和正向遍历一一比较。</li>
</ol>
<p>关键在于怎么一边利用递归反向遍历，一边同时还能正向遍历；<br>其实就是再设置一个指针，每次反向遍历一个位置时，就将这个指针指向的节点向后移一个。最终这两个指针都会走遍整个链表，中间过程中始终保持两个链表的值相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = head;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="literal">true</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    dfs(node.next);</span><br><span class="line">    <span class="keyword">if</span> (left.val !== node.val) res = <span class="literal">false</span>;</span><br><span class="line">    left = left.next;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(head);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个方法的时间复杂度并没有优化，但是提供了一种全新的思路，即如何同时从两个方向遍历同一个链表，期间还能互相比较。</p>
<h2 id="拆分链表"><a href="#拆分链表" class="headerlink" title="拆分链表"></a>拆分链表</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-list/">https://leetcode.cn/problems/partition-list/</a></p>
<blockquote>
<p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。<br>你应当 保留 两个分区中每个节点的初始相对位置。<br>输入：head = [1,4,3,2,5,2], x = 3<br>输出：[1,2,2,4,3,5]</p>
</blockquote>
<p>这道题其实就是把一个链表拆成两个部分，同时不改变相对顺序。<br>如果是数组的话就很简单，创建两个空数组，遍历时将比 x 小的放入一堆，比 x 大的放入另一队，最后再合并就行。</p>
<p>链表的原理类似，但是有几个注意点：</p>
<ul>
<li>需要 dummy 节点。这个很好理解，创建连接的空链表最好都要有 dummy，这个和合并有序链表时创建新链表先创建一个 dummy 的原因相同</li>
<li><strong>将原链表的节点拆出来后，一定注意要把这个节点的 next 置空</strong>。这点很重要，不然在最后的连接时就会出现问题。</li>
<li>最后链接的时候，前面的链表可能是空的（节点都比 x 大），但后面的一定不会（至少包括一个 x 所在的节点）。所以必须要 dummy 节点，不然不能把第二个链表的头节点挂在 null 上。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> partition = <span class="function"><span class="keyword">function</span> (<span class="params">head, x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> dummy1 = <span class="keyword">new</span> ListNode();</span><br><span class="line">  <span class="keyword">const</span> dummy2 = <span class="keyword">new</span> ListNode();</span><br><span class="line">  <span class="keyword">let</span> p = head;</span><br><span class="line">  <span class="keyword">let</span> p1 = dummy1;</span><br><span class="line">  <span class="keyword">let</span> p2 = dummy2;</span><br><span class="line">  <span class="keyword">while</span> (p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p.val &lt; x) &#123;</span><br><span class="line">      p1.next = p;</span><br><span class="line">      p1 = p1.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      p2.next = p;</span><br><span class="line">      p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意把拆出来的节点的next置空</span></span><br><span class="line">    <span class="keyword">const</span> tmp = p.next;</span><br><span class="line">    p.next = <span class="literal">null</span>;</span><br><span class="line">    p = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  p1.next = dummy2.next;</span><br><span class="line">  <span class="keyword">return</span> dummy1.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h2><blockquote>
<ol>
<li>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</li>
</ol>
</blockquote>
<p>比较基础的栈问题，先把左括号入栈，然后当遇见右括号时，根据预设的匹配关系出栈左括号，如果不匹配就返回 false</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isValid = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">const</span> str = s.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;[&quot;</span>, <span class="string">&quot;]&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>],</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s === <span class="string">&quot;(&quot;</span> || s === <span class="string">&quot;[&quot;</span> || s === <span class="string">&quot;&#123;&quot;</span>) &#123;</span><br><span class="line">      stack.push(s);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s === <span class="string">&quot;)&quot;</span> || s === <span class="string">&quot;]&quot;</span> || s === <span class="string">&quot;&#125;&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> top = stack.pop();</span><br><span class="line">      <span class="keyword">if</span> (s !== map.get(top)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!stack.length) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="“对对碰”消除"><a href="#“对对碰”消除" class="headerlink" title="“对对碰”消除"></a>“对对碰”消除</h2><blockquote>
<p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。<br>在 S 上反复执行重复项删除操作，直到无法继续删除。<br>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p>示例：</p>
<p>输入：”abbaca”<br>输出：”ca”<br>解释：例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。</p>
</blockquote>
<p>利用栈，把每一项一次入栈，如果有和栈顶元素相同的就把栈顶元素出栈</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.gif"></p>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> top = stack[stack.length - <span class="number">1</span>] || <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[i] === top) stack.pop();</span><br><span class="line">    <span class="keyword">else</span> stack.push(s[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="后缀表达式求值"><a href="#后缀表达式求值" class="headerlink" title="后缀表达式求值"></a>后缀表达式求值</h2><blockquote>
<p>根据 逆波兰表示法，求表达式的值。<br>有效的运算符包括 + , - , * , / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br>说明：<br>整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
<p>示例 1：<br>输入: [“2”, “1”, “+”, “3”, “ * “]<br>输出: 9<br>解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9<br>示例 2：<br>输入: [“4”, “13”, “5”, “/“, “+”]<br>输出: 6<br>解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</p>
</blockquote>
<p>后缀表达式是计算机常用的计算表达式的方法。<br>后缀表达式可以看作是一棵后序遍历的树，每个运算符都是中间节点，以运算符为根节点的子树是一个表达式的值；<br>因此可以通过这个思路引入栈，执行这样的操作：</p>
<ol>
<li>如果是数字，入栈</li>
<li>如果是运算符，就把栈顶的两个元素出栈，并通过运算符计算，结果入栈</li>
</ol>
<p>代码如下：</p>
<blockquote>
<p>注意这里有个坑：除法应该使用<code>Math.trunc</code>去掉小数部分，模拟 java 等语言中的整形运算。不能是<code>Math.floor</code>，因为处理负数时会向下取整。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">tokens</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> evalRPN = <span class="function"><span class="keyword">function</span> (<span class="params">tokens</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">&quot;+&quot;</span>, <span class="function">(<span class="params">a, b</span>) =&gt;</span> a * <span class="number">1</span> + b * <span class="number">1</span>],</span><br><span class="line">    [<span class="string">&quot;-&quot;</span>, <span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a],</span><br><span class="line">    [<span class="string">&quot;*&quot;</span>, <span class="function">(<span class="params">a, b</span>) =&gt;</span> b * a],</span><br><span class="line">    [<span class="string">&quot;/&quot;</span>, <span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="built_in">Math</span>.trunc(b / a)],</span><br><span class="line">  ]);</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">of</span> tokens) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!s.has(i)) &#123;</span><br><span class="line">      stack.push(i);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(s.get(i)(stack.pop(), stack.pop()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack.pop();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="单调栈和单调队列"><a href="#单调栈和单调队列" class="headerlink" title="单调栈和单调队列"></a>单调栈和单调队列</h2><p>单调栈顾名思义就是栈内元素从小到大或从大到小排列的栈。通常操作是在遍历数组的时候，将每个元素依次放入栈中，如果出现不符合单调栈单调特征的元素，就考虑把前面所有的数出栈，直到继续符合特征为止。</p>
<p>单调栈有两种遍历方式，可以正向遍历数组，也可以反向。</p>
<ul>
<li>正向遍历的结果输出通常在循环出栈的内部，因为只有出栈时才能得出计算值</li>
<li>反向遍历的结果输出在出栈外部，因为不出栈时，栈顶元素一般就是满足条件的元素，可以和当前元素计算得出结果<br>模板如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正向</span></span><br><span class="line"><span class="keyword">const</span> stack = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">  <span class="keyword">while</span> (stack.length &amp;&amp; nums[i] &gt;= stack[stack.length - <span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="comment">// 如果是递增栈就是&lt;=，看情况</span></span><br><span class="line">    <span class="keyword">const</span> val = stack.pop();</span><br><span class="line">    <span class="comment">// ... 结果处理</span></span><br><span class="line">  &#125;</span><br><span class="line">  stack.push(nums[i]); <span class="comment">// 或者是索引i，索引栈是一个很好用的思路</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反向</span></span><br><span class="line"><span class="keyword">const</span> stack = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">  <span class="keyword">while</span> (stack.length &amp;&amp; nums[i] &gt;= stack[stack.length - <span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="comment">// 如果是递增栈就是&lt;=，看情况</span></span><br><span class="line">    stack.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  res[i] = stack.length ? stack[stack.length - <span class="number">1</span>] : <span class="literal">null</span>; <span class="comment">// 依题意而定</span></span><br><span class="line">  stack.push(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更高温度（单调栈）"><a href="#更高温度（单调栈）" class="headerlink" title="更高温度（单调栈）"></a>更高温度（单调栈）</h3><blockquote>
<p>给定一个整数数组  temperatures ，表示每天的温度，返回一个数组  answer ，其中<code>answer[i]</code>  是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用  0 来代替。<br>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
</blockquote>
<p>思路：创建一个索引栈，用于记录索引。这个栈同时还是一个最小栈，即保持栈顶的元素始终是最小的。</p>
<p>确定一个<strong>单调递减的趋势</strong>，一旦有数字打破了这个趋势，也就说一个数字比它前面入栈的数字大，那就把它前面比他小的数字都出栈，并且用它的索引减去这些数字的索引，减去的值恰好就是对应的 answer。</p>
<blockquote>
<p>演示视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12t4y1274o/">https://www.bilibili.com/video/BV12t4y1274o/</a></p>
</blockquote>
<p>至于为什么栈中不直接放入温度而是存索引，是因为要得出的结果 ans 是每个元素的索引相加减得出的，并且也恰好是按照索引顺序摆放的。<br>索引栈是一个很好用的思维方式，可以尝试多用用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dailyTemperatures = <span class="function"><span class="keyword">function</span> (<span class="params">temperatures</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  stack[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> ans = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (</span><br><span class="line">      stack.length &amp;&amp;</span><br><span class="line">      temperatures[i] &gt; temperatures[stack[stack.length - <span class="number">1</span>]]</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">const</span> index = stack.pop();</span><br><span class="line">      ans[index] = i - index;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反向遍历</span></span><br><span class="line"><span class="keyword">var</span> dailyTemperatures = <span class="function"><span class="keyword">function</span> (<span class="params">temperatures</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = temperatures.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">while</span> (stack.length &amp;&amp; temperatures[i] &gt;= stack[stack.length - <span class="number">1</span>])</span><br><span class="line">      stack.pop();</span><br><span class="line">    res[i] = stack.length ? stack[stack.length - <span class="number">1</span>] - i : <span class="number">0</span>;</span><br><span class="line">    stack.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res[i];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="移掉-K-位数字（单调栈）"><a href="#移掉-K-位数字（单调栈）" class="headerlink" title="移掉 K 位数字（单调栈）"></a>移掉 K 位数字（单调栈）</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-k-digits/">https://leetcode.cn/problems/remove-k-digits/</a></p>
<blockquote>
<p>给你一个以字符串表示的非负整数  num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。<br>示例 1 ：<br>输入：num = “1432219”, k = 3<br>输出：”1219”<br>解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。</p>
</blockquote>
<p>首先要先考虑一个原理型的问题，什么情况下能保证数字更小？<br>比如两个数字 123a456 和 123b456，当位数相同时，显然若<code>a&lt;b</code>则<code>num1&gt;num2</code>。因此如果要保证一个数字尽可能小，就应该使每一位尽可能小。<br>将原数字挨个遍历，如果当前的数字比前面的数字小，就应该替换掉前面的。反之则不行，因为替换了一定会使整个数字变大。</p>
<p>从这里就可以看出，这道题实际上是一个单调栈问题，即保证单调栈内的数字始终要递增；但是也不完全是单调栈，因为还有一个重要的条件是删除的数字限制。<br>每一次从单调栈中 pop 值，就相当于一次删除，总删除次数就应该减 1。当删除次数用尽时，就不能再继续 pop 了。这时可能还剩下几个数字，也会一并放入栈中。最后的结果应该是<code>slice(0, n-k)</code>，即截取应该保留的部分。</p>
<p>最后还要注意全删掉和前导 0 的处理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeKdigits = <span class="function"><span class="keyword">function</span> (<span class="params">num, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> cnt = k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> num) &#123;</span><br><span class="line">    <span class="comment">// 单调栈的通常处理，逐个循环和栈顶元素比较</span></span><br><span class="line">    <span class="comment">// 当前数比栈顶元素小</span></span><br><span class="line">    <span class="comment">// 还有删除次数</span></span><br><span class="line">    <span class="comment">// 栈非空</span></span><br><span class="line">    <span class="keyword">while</span> (n &lt; stack[stack.length - <span class="number">1</span>] &amp;&amp; cnt &gt; <span class="number">0</span> &amp;&amp; stack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      stack.pop();</span><br><span class="line">      cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最后只取前面的部分，因为上面每个元素都会被遍历到，超出删除次数的部分不会删除，要在这里截掉</span></span><br><span class="line">  stack = stack.slice(<span class="number">0</span>, num.length - k);</span><br><span class="line">  <span class="keyword">while</span> (stack.length &gt; <span class="number">1</span> &amp;&amp; stack[<span class="number">0</span>] === <span class="string">&quot;0&quot;</span>) stack.shift();</span><br><span class="line">  <span class="keyword">return</span> stack.join(<span class="string">&quot;&quot;</span>) || <span class="string">&quot;0&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这道题可以借鉴思路的地方除了采用单调栈来比较大小，还有一点就是删除次数这个记录量。每一次从栈中 pop 就是一次删除</p>
<h3 id="去除重复字母"><a href="#去除重复字母" class="headerlink" title="去除重复字母"></a>去除重复字母</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicate-letters/">https://leetcode.cn/problems/remove-duplicate-letters/</a></p>
<blockquote>
<p>给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。<br>示例 1：<br>输入：s = “bcabc”<br>输出：”abc”</p>
</blockquote>
<p>这道题关键在于不仅要去重，还要考虑结果的字典序最小。</p>
<p>按照上一道题的思路，同样可以采用单调栈的形式，每次放入的字母字典序都应该尽可能的小，如果前面的字典序更大，就应该依次出栈。</p>
<p>而在控制删除次数方面，这道题有点不一样。上一道题有一个全局的最大删除次数 k，但是这道题必须考虑单个字母的情况，即每个字母都应该有自己的一个最大删除次数（即保证自己出现的次数最少要有一次）。</p>
<p>所以还需要一个 map，用来记录每个字母的出现次数作为最大删除次数，不能小于 1。每次出栈，都要把这个字母的删除次数减 1；如果删除次数为 1，即说明此时剩余串中只剩下一个该字母，那就不能删去，应该保留。</p>
<p>另外还需要一个 set 用于记录重复字母。当当前遍历到的字母在栈中已经有了，就应该跳过，并且仍需要从 map 中给这个字母删除次数-1。即使是跳过，也相当于是一个删除，因此还是需要对 map 处理。</p>
<p>这道题不需要最后的截取，因为去重的 visited 一定保证每个字母出现且仅出现一次，那么结果的长度一定是固定的。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicateLetters = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line">  <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> letter <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="comment">// 先记录每个字母的出现次数作为各自的最大删除次数</span></span><br><span class="line">    <span class="keyword">if</span> (!map.has(letter)) map.set(letter, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> map.set(letter, map.get(letter) + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> letter <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="keyword">if</span> (visited.has(letter)) &#123;</span><br><span class="line">      <span class="comment">// 重复的跳过</span></span><br><span class="line">      map.set(letter, map.get(letter) - <span class="number">1</span>); <span class="comment">// 跳过也相当于是删除</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (</span><br><span class="line">      letter &lt; stack[stack.length - <span class="number">1</span>] &amp;&amp; <span class="comment">// 当前字母字典序小于栈顶</span></span><br><span class="line">      map.get(stack[stack.length - <span class="number">1</span>]) &gt; <span class="number">1</span> &amp;&amp; <span class="comment">// 栈顶字母还能被删除</span></span><br><span class="line">      stack.length &gt; <span class="number">0</span> <span class="comment">// 非空栈</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// 给栈顶字母的删除次数-1</span></span><br><span class="line">      map.set(stack[stack.length - <span class="number">1</span>], map.get(stack[stack.length - <span class="number">1</span>]) - <span class="number">1</span>);</span><br><span class="line">      visited.delete(stack.pop()); <span class="comment">// 删除栈顶，并且从重复记录中去掉</span></span><br><span class="line">    &#125;</span><br><span class="line">    visited.add(letter);</span><br><span class="line">    stack.push(letter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h2><blockquote>
<p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。<br>滑动窗口大概长这样：<br>1 [3 -1 -3] 5 3 6 7<br>1 3 [-1 -3 5] 3 6 7<br>1 3 -1 [-3 5 3] 6 7<br>1 3 -1 -3 [5 3 6] 7<br>1 3 -1 -3 5 [3 6 7]</p>
</blockquote>
<p>基础思路是用一个双指针分别指向窗口的左和右，然后取得双指针之间的最大值放入结果.但是这个方法不好，因为实际上有很多已经判断过的数被重复比较</p>
<p>因此更好的思路是利用<strong>单调递减</strong>的<strong>双端队列</strong>，遍历把每个 nums 中的索引放入（还是索引，因为需要判断队列中的数字是否超出滑动窗口范围）</p>
<p>然后最重要的是和上面的最小栈类似，如果有比队尾数小的就放入；如果比队尾数大就依次出队，直到<code>队尾数&gt;=当前数</code>为止。因此队头的元素一定是本次遍历的最大值</p>
<p>遍历时从第一个开始，当遍历数到达 k 时，就相当于产生了第一个窗口，开始记录最大值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxSlidingWindow = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> deque = [];</span><br><span class="line">  <span class="keyword">const</span> answer = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果当前数比队尾数大，就依次出队</span></span><br><span class="line">    <span class="keyword">while</span> (deque.length &amp;&amp; nums[i] &gt; nums[deque[deque.length - <span class="number">1</span>]]) &#123;</span><br><span class="line">      deque.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    deque.push(i); <span class="comment">// 当前数的索引放入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队头元素的位置是否超过了滑动窗口的前沿（即 i + 1 - k）</span></span><br><span class="line">    <span class="keyword">if</span> (deque.length &amp;&amp; deque[<span class="number">0</span>] &lt; i + <span class="number">1</span> - k) &#123;</span><br><span class="line">      deque.shift();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当遍历数到达k时，开始记录最大值</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">      answer.push(nums[deque[<span class="number">0</span>]]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-string/">https://leetcode.cn/problems/decode-string/</a></p>
<blockquote>
<p>给定一个经过编码的字符串，返回它解码后的字符串。<br>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。<br>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。<br>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像  3a  或  2[4]  的输入。<br>示例 1：<br>输入：s = “3[a]2[bc]”<br>输出：”aaabcbc”</p>
</blockquote>
<p>思路：利用栈，逐个遍历字符串的每一项：</p>
<ul>
<li>如果是数字、左括号或者字母，入栈</li>
<li>如果是右括号，就出栈直到左括号为止，然后把之间的字母按照左括号前的数字作为倍数放入结果。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> decodeString = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isLetter = <span class="function">(<span class="params">s</span>) =&gt;</span></span><br><span class="line">    s.charCodeAt() &gt;= <span class="string">&quot;a&quot;</span>.charCodeAt() &amp;&amp; s.charCodeAt() &lt;= <span class="string">&quot;z&quot;</span>.charCodeAt();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; ) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = []; <span class="comment">// 每次执行res都应该清零，防止影响上一次的结果</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(s[i])) &#123;</span><br><span class="line">      <span class="comment">// 如果是数字，处理不止一位数的情况</span></span><br><span class="line">      <span class="keyword">let</span> num = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">while</span> (!<span class="built_in">isNaN</span>(s[i])) num += s[i++];</span><br><span class="line">      stack.push(+num);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">&quot;[&quot;</span> || isLetter(s[i])) &#123;</span><br><span class="line">      <span class="comment">// 左括号和字母入栈</span></span><br><span class="line">      stack.push(s[i]);</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">&quot;]&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 出栈到右括号</span></span><br><span class="line">        <span class="keyword">const</span> top = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (top === <span class="string">&quot;[&quot;</span>) <span class="keyword">break</span>;</span><br><span class="line">        str = top + str;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> times = stack.pop();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; times; j++) &#123;</span><br><span class="line">        <span class="comment">// 把中间的字符按照倍数放入</span></span><br><span class="line">        res.push(str);</span><br><span class="line">      &#125;</span><br><span class="line">      stack.push(res.join(<span class="string">&quot;&quot;</span>)); <span class="comment">// 注意，前面拼接好的还应该放回栈中，主要为了处理嵌套括号的情况。</span></span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (stack.length) &#123;</span><br><span class="line">    <span class="comment">// 剩余字母</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; stack.length; i++) res.push(stack[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h2><blockquote>
<ol start="4">
<li>用栈实现队列，只能使用栈的 push 和 pop 方法。</li>
</ol>
</blockquote>
<p>思路是用两个栈存储，正常的入队就是 push 到 stack1；但是每次出队时，将 stack1 中的元素依次出栈再入栈到 stack2 中，这样栈底元素就被取出了；此后再次入队仍然是到 stack1 中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stack1 = [];</span><br><span class="line">    <span class="built_in">this</span>.stack2 = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">enqueue</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stack1.push(val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">dequeue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.stack2.length) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.stack1.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>.stack2.push(<span class="built_in">this</span>.stack1.pop());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack2.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">peek</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.stack2.length) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.stack1.length; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>.stack2.push(<span class="built_in">this</span>.stack1.pop());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack2[<span class="built_in">this</span>.stack2.length - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack1.length + <span class="built_in">this</span>.stack2.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>基本思路是这样的：</p>
<ol>
<li>循环，然后逐个将字符放入窗口中</li>
<li><strong>根据窗口本身的状态</strong>，判断是否需要弹出窗口（缩小左边），然后循环弹出直到窗口本身满足状态</li>
<li>结束循环的条件通常是一个指针走到了其中一个序列的末尾。</li>
</ol>
<p>通常的格式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">slidingWindow</span>(<span class="params">s,t</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> queue = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; s.length;i++)&#123;</span><br><span class="line">    queue.push(s[i])<span class="comment">// 增大窗口通常是在循环中直接插入的，不需要单独一个循环</span></span><br><span class="line">    <span class="comment">// 一些更新</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="comment">/*弹出的条件，通常是窗口内部的状态*/</span>)&#123;</span><br><span class="line">      <span class="keyword">const</span> out = queue.shift()</span><br><span class="line">      <span class="comment">// 一些更新</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其实问题的关键就是判断窗口里边部分的状态是否满足结束条件或者弹出条件。<br>以字符串为例，常用的判断方式有：</p>
<ol>
<li>用两个对象分别统计当前窗口中的字符数量 window 和目标的字符数量 need，如果匹配就记录，其他时候弹出直到不匹配为止；</li>
<li>直接判断窗口内和目标是否相等（字符串或数组）</li>
<li>记录一个 a-z 26 个字符的出现次数的数组，<strong>如果两个字符串之间除了顺序之外完全相同，那么这两个数组也一定是完全相同的</strong>，用于判断顺序不一致时的子序列。</li>
</ol>
<h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutation-in-string/">https://leetcode.cn/problems/permutation-in-string/</a></p>
<blockquote>
<p>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。<br>示例 1：<br>输入：s1 = “ab” s2 = “eidbaooo”<br>输出：true<br>解释：s2 包含 s1 的排列之一 (“ba”).</p>
</blockquote>
<p>这道题的思路是这样：首先确定一个滑动窗口，然后逐个将字符放入窗口中，（当滑动窗口大小够的时候）比较窗口的字符是否满足条件（即判断窗口内的字符串和目标字符串 s1 是否相等）。如果相等就直接返回 true，不相等就把窗口中的第一个字符弹出（保证窗口大小始终和 s1 大小相等），然后继续添加下一个并判断。</p>
<p>但是这个问题在于判断字符相等，因为求得是字符串的<strong>排列</strong>而非子序列，因此它是连续但并不按顺序的，所以不能直接比较判断字符串相等（太耗时）。<br>这里提供了一个思路是记录 a-z 的 26 个字符的出现次数的数组，<strong>如果两个字符串之间除了顺序之外完全相同，那么这两个数组也一定是完全相同的</strong>。因此就可以在每次遍历中当前字符++，并把超出窗口大小的字符–即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> checkInclusion = <span class="function"><span class="keyword">function</span> (<span class="params">s1, s2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">26</span>).fill(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">26</span>).fill(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> s1) &#123;</span><br><span class="line">    target[s.charCodeAt() - <span class="string">&quot;a&quot;</span>.charCodeAt()]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> isEqual = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i] !== b[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; s2.length) &#123;</span><br><span class="line">    now[s2[i].charCodeAt() - <span class="string">&quot;a&quot;</span>.charCodeAt()]++;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= s1.length - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isEqual(now, target)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        now[s2[i - s1.length + <span class="number">1</span>].charCodeAt() - <span class="string">&quot;a&quot;</span>.charCodeAt()]--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这道题还有可能的几个变种：</p>
<ol>
<li>s1 就是 s2 的子串，不会变顺序：在判断阶段直接比较窗口的字符串和目标串即可，比较简单</li>
<li>s1 是 s2 的子序列，即不一定连续：用一个 now 对象（表示当前字符数量，按照<code>&#123;A:1,B:2,C:0&#125;</code>这种形式）表示当前记录次数，用同样的 target 对象表示目标，窗口每次增大都判断是否满足条件，满足就为 true；</li>
<li>判断 s1 在 s2 中出现的最短序列（<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/%EF%BC%89%EF%BC%9A%E6%9C%80%E9%9A%BE%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E8%A6%81%E8%AE%A1%E7%AE%97%E6%9C%80%E7%9F%AD%E6%83%85%E5%86%B5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E7%9C%8B%E8%A7%A3%E6%9E%90%E3%80%82">https://leetcode.cn/problems/minimum-window-substring/）：最难的情况，要计算最短情况，建议直接看解析。</a></li>
</ol>
<h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><blockquote>
<p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
</blockquote>
<p>同样的滑动窗口题，弹出条件是窗口有重复字符，把窗口左边的循环弹出直到不重复为止。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> queue = [];</span><br><span class="line">  <span class="keyword">const</span> isRepeat = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [...new <span class="built_in">Set</span>([...arr]).values()].length !== arr.length;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    queue.push(s[i]);</span><br><span class="line">    <span class="keyword">while</span> (isRepeat(queue)) &#123;</span><br><span class="line">      queue.shift();</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">Math</span>.max(res, queue.length);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">https://leetcode.cn/problems/find-all-anagrams-in-a-string/</a></p>
<p><img src="https://pic.imgdb.cn/item/628bc6f00947543129baa39b.jpg"></p>
<p>这个题的思路和前面的差不多：滑动窗口大小固定，然后每次增加一个并弹出一个，判断内部的字符是否满足</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">p</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findAnagrams = <span class="function"><span class="keyword">function</span> (<span class="params">s, p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> index = [];</span><br><span class="line">  <span class="keyword">const</span> len = p.length;</span><br><span class="line">  <span class="keyword">const</span> A = <span class="string">&quot;a&quot;</span>.charCodeAt();</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">window</span> = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">26</span>).fill(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> need = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">26</span>).fill(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> p) &#123;</span><br><span class="line">    need[s.charCodeAt() - A]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> isEqual = <span class="function">(<span class="params">arr1, arr2</span>) =&gt;</span> arr1.join(<span class="string">&quot;&quot;</span>) === arr2.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="built_in">window</span>[s[i].charCodeAt() - A]++;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= len - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isEqual(<span class="built_in">window</span>, need)) index.push(i - len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">window</span>[s[i - len + <span class="number">1</span>].charCodeAt() - A]--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h2><p>二分查找问题的基本框架：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">nums,target</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> right = nums.length - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(...<span class="comment">/*通常是left &lt;= right*/</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> mid = left + <span class="built_in">Math</span>.floor((right - left) / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums[mid] ===  target)&#123;</span><br><span class="line">      <span class="keyword">return</span> ...</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">      right = ... <span class="comment">// 这里通常是mid - 1，相当于把右边界变为中值的左边一个数</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">      left = ... <span class="comment">// 通常是mid + 1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分查找也可以写成递归形式，但是一般不需要<br>二分查找的关键就是几个细节：</p>
<ol>
<li>while 循环的边界。因为这个边界表示的是没有查找到之后的退出条件，因此要保证<code>right - left</code>区域内的空间为 0，即当 left&gt;=right 时退出。</li>
</ol>
<ul>
<li><code>left &lt;= right</code> ，对应<code>[left, right]</code>的左右都闭区间，因此 right 的初始值应该是<code>nums.length-1</code>（right 要去到具体的值）。这个时候的退出条件就是<code>left&gt;right</code>，即完全没有交集</li>
<li><code>left &lt; right</code>，对应<code>[left,right)</code>的左闭右开区间，这时是不取 right 的值的，因此 right 应该是<code>nums.length</code>。所以当<code>left===right</code>就可以退出了，终止的条件是 left == right，此时搜索区间 <code>[left, left)</code> 为空<br>大多数情况下都选择第一种，方便理解。</li>
</ul>
<ol start="2">
<li>mid+1 和 mid-1，这两个情况都是因为 mid 已经排除了，因此自然不需要 mid 这一项。除非有一个特殊情况，就是需要左右边界的数，可以继续取 mid 表示边界位置。</li>
</ol>
<h2 id="二分查找的边界"><a href="#二分查找的边界" class="headerlink" title="二分查找的边界"></a>二分查找的边界</h2><p>对于有重复数字的二分查找，需要找到其最左边或者最右边的值；</p>
<blockquote>
<p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。<br>如果数组中不存在目标值 target，返回  [-1, -1]。</p>
</blockquote>
<p>一个方法是，先找到目标数，然后循环找到其左右边界并返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> searchRange = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> res = [-<span class="number">1</span>, -<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">const</span> mid = left + <span class="built_in">Math</span>.floor((right - left) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] === target) &#123;</span><br><span class="line">      <span class="keyword">let</span> index = mid;</span><br><span class="line">      <span class="keyword">while</span> (nums[index] === target) &#123;</span><br><span class="line">        res[<span class="number">0</span>] = index--;</span><br><span class="line">      &#125;</span><br><span class="line">      index = mid;</span><br><span class="line">      <span class="keyword">while</span> (nums[index] === target) &#123;</span><br><span class="line">        res[<span class="number">1</span>] = index++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是这种方法不能保证二分查找的对数时间复杂度。并且如果特殊的测试用例下，两个边界离得特别远，就会趋近于线性遍历的复杂度。</p>
<p>因此更合适的方法，还是通过控制左右边界实现。</p>
<p>基本思路：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">  <span class="keyword">let</span> mid = left + <span class="built_in">Math</span>.floor((right - left) / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (nums[mid] === target) &#123;</span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 查找右边界的话</span></span><br><span class="line">    <span class="comment">// left = mid + 1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br></pre></td></tr></table></figure>

<p>找到 target 时不要立即返回，而是缩小「搜索区间」的上界 right，在区间 <code>[left, mid)</code> 中继续搜索。又因为左闭右开的特点，找到的位置 mid 实际上会被排除；那么剩下的查找无论怎么找都一定是小于等于 target 的，因此就会一直向左走直到左边界。向右的话同理</p>
<h2 id="寻找峰值"><a href="#寻找峰值" class="headerlink" title="寻找峰值"></a>寻找峰值</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-peak-element/">https://leetcode.cn/problems/find-peak-element/</a></p>
<blockquote>
<p>峰值元素是指其值严格大于左右相邻值的元素。<br>给你一个整数数组  nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。<br>你可以假设  nums[-1] = nums[n] = -∞ 。<br>你必须实现时间复杂度为 O(log n) 的算法来解决此问题。<br>示例 1：<br>输入：nums = [1,2,3,1]<br>输出：2<br>解释：3 是峰值元素，你的函数应该返回其索引 2。</p>
</blockquote>
<p>思路：基本解法很简单，但是这道题其实可以用二分查找优化。<br>因为只需要找出一个峰值就可以，所以可以只找一边。首先先计算一个中间值 mid</p>
<ul>
<li>如果 右边 &gt; 中间值 &gt; 左边 ，那就在右边查找，即相当于取右边的值为新的 left</li>
<li>如果 左边 &lt; 中间值 &lt; 右边，在左边查找</li>
<li>如果 左 &lt; 中间 &gt; 右，说明找到了。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findPeakElement = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.length === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> len = nums.length;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">const</span> mid = left + <span class="built_in">Math</span>.floor((right - left) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (mid === <span class="number">0</span>) nums[mid - <span class="number">1</span>] = -<span class="literal">Infinity</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid === len - <span class="number">1</span>) nums[len] = -<span class="literal">Infinity</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &gt; nums[mid - <span class="number">1</span>] &amp;&amp; nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[mid - <span class="number">1</span>] &amp;&amp; nums[mid] &lt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[mid - <span class="number">1</span>] &amp;&amp; nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt;= nums[mid - <span class="number">1</span>] &amp;&amp; nums[mid] &lt;= nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h2><blockquote>
<p>整数数组 nums 按升序排列，数组中的值 互不相同 。<br>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为  [4,5,6,7,0,1,2] 。<br>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回  -1 。<br>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。<br>示例 1：<br>输入：nums = [4,5,6,7,0,1,2], target = 0<br>输出：4</p>
</blockquote>
<p>这道题 O(log n)肯定是二分查找了。但是这里的特点是，数组有一部分被改变位置了，并不是完全有序的数组。</p>
<p>思路如下：</p>
<p>首先还是计算 mid，计算出来的 mid 和两边有两种情况：</p>
<ul>
<li><p>左边有序，右边无序，判断方式是右边的最后一个元素 nums[nums.length-1]是不是小于 mid，如果小于就说明一定是右边的部分乱序</p>
<ul>
<li><p>这种情况下，如果<code>target &lt; mid &amp;&amp; target &gt; nums[0]</code>，即刚好在左边<strong>并且不会比最左的元素小</strong>，就直接<code>right = mid - 1</code></p>
<blockquote>
<p>注意这里<code>target &gt; nums[0]</code>很重要，因为如果一个数即使比 mid 小，但它比最左边的还要小，那就不能在左边找了。右边也是同理</p>
</blockquote>
</li>
<li><p>如果<code>target &gt; mid</code>，说明在乱序的右边，则<code>left = mid+1</code>，然后再执行一遍上面的步骤</p>
</li>
</ul>
</li>
<li><p>右边有序，左边无序，同理判断 nums[0]和 mid 大小，如果前者大于后者就说明无序</p>
<ul>
<li>处理和上面同理</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (len === <span class="number">1</span> || len === <span class="number">2</span>) <span class="keyword">return</span> nums.indexOf(target);</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = len - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(left + (right - left) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] === target) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= nums[mid]) &#123;</span><br><span class="line">      <span class="comment">// 左边顺序</span></span><br><span class="line">      <span class="keyword">if</span> (target &gt;= nums[<span class="number">0</span>] &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">        <span class="comment">// 注意这里target可能会和第一项相等</span></span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 左边乱序</span></span><br><span class="line">      <span class="keyword">if</span> (target &lt;= nums[nums.length - <span class="number">1</span>] &amp;&amp; target &gt; nums[mid]) &#123;</span><br><span class="line">        <span class="comment">// 同理也可能是最后一项</span></span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="按权重随机选择"><a href="#按权重随机选择" class="headerlink" title="按权重随机选择"></a>按权重随机选择</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/random-pick-with-weight/">https://leetcode.cn/problems/random-pick-with-weight/</a></p>
<blockquote>
<p>给你一个 下标从 0 开始 的正整数数组  w ，其中  w[i] 代表第 i 个下标的权重。<br>请你实现一个函数  pickIndex ，它可以 随机地 从范围 [0, w.length - 1] 内（含 0 和 w.length - 1）选出并返回一个下标。选取下标 i  的 概率 为 w[i] / sum(w) 。<br>例如，对于 w = [1, 3]，挑选下标 0 的概率为 1 / (1 + 3) = 0.25 （即，25%），而选取下标 1 的概率为 3 / (1 + 3) = 0.75（即，75%）。</p>
</blockquote>
<p>这道题本质上是一个前缀和+二分查找的问题，具体解析可以参考<a target="_blank" rel="noopener" href="https://labuladong.github.io/algo/2/19/29/">https://labuladong.github.io/algo/2/19/29/</a></p>
<p>最开始的思路是创建一个数组，按照每个元素的大小控制其出现次数。比如当前值是 5，那就在新数组中出现 5 次。总的数组大小就是所有数之和。<br>但是当和非常大时就会出问题。</p>
<p>因此可以秉持这种思路，但是不采用具体生成数组的方法，而是用前缀和模拟一个区间</p>
<p><img src="https://pic.imgdb.cn/item/62d53f65f54cd3f93739f99e.jpg"></p>
<p>这样在区间内任意选取一个随机数，再通过<strong>二分查找左边界</strong>的形式找到最近的对应的前缀和（相当于落在了这个范围内），就可以对应到相应的数字上去。</p>
<p>其中有几个关键点：</p>
<ul>
<li>随机数的选取范围：应该是<code>random * sum + 1</code>，即范围从<code>[0-n]</code>变为<code>[1-n+1]</code>。之所以要加 1，主要是选取时考虑具体的点而不是区间，选取的概率分布也是在点上而不是区间上。比如说 w=[1,3,2,1]，那么 7 = （1 + 3 + 2 + 1）恰好是 7 个数，即 1-7，如果是 0-7 多了个 0 就不对了。</li>
<li>二分查找的使用：不能直接使用二分查找找，因为随机数大概率不会匹配到具体的值，而只是匹配一个范围。因此需要的是返回左边界的二分查找。至于为什么是左边界，可以参考下面的解释：<br><img src="https://pic.imgdb.cn/item/62d54130f54cd3f9373c4726.jpg"></li>
</ul>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">w</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.w = w;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">pickIndex</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> prefix = [<span class="built_in">this</span>.w[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">this</span>.w.length; i++) &#123;</span><br><span class="line">      prefix[i] = prefix[i - <span class="number">1</span>] + <span class="built_in">this</span>.w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意随机数+1</span></span><br><span class="line">    <span class="comment">// 原因是这样：比如说w=[1,3,2,1]，那么7 = （1 + 3 + 2 + 1）恰好是7个数，即1-7，如果是0-7多了个0就不对了。</span></span><br><span class="line">    <span class="comment">// 也就是说应该考虑具体的点而不是区间，选取的概率分布也是在点上而不是区间上。</span></span><br><span class="line">    <span class="keyword">const</span> random = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * prefix[prefix.length - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = prefix.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">      <span class="keyword">const</span> mid = left + <span class="built_in">Math</span>.floor((right - left) / <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (prefix[mid] &lt; random) &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prefix[mid] &gt; random) &#123;</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在-D-天内送达包裹的能力"><a href="#在-D-天内送达包裹的能力" class="headerlink" title="在 D 天内送达包裹的能力"></a>在 D 天内送达包裹的能力</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/">https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/</a></p>
<blockquote>
<p>传送带上的包裹必须在 days 天内从一个港口运送到另一个港口。<br>传送带上的第 i  个包裹的重量为  weights[i]。每一天，我们都会按给出重量（weights）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。<br>返回能在 days 天内将传送带上的所有包裹送达的船的最低运载能力。</p>
</blockquote>
<p>这道题看起来和二分查找没有任何关系。但是这类问题经过分析可以发现，基本满足一个大概的趋势：能形成单调的、有平台的函数，即大概是这个样子：<br><img src="https://pic.imgdb.cn/item/62d574c7f54cd3f9377a1b2c.jpg"></p>
<p>而对于这道题，我们设横坐标表示单次运载能力 x，纵坐标表示需要运送的天数 y，那显然这两者成反比例。并且，由于不是连续的，所以一定会出现多个 x 对应一个 y 的情况，也就是“平台”</p>
<p><img src="https://pic.imgdb.cn/item/62d5753ff54cd3f9377ac173.jpg"></p>
<p>看到这个平台，就应该想到要用二分查找的左边界或右边界去求最大/最小值了。</p>
<p>换句话说，这道题其实是在“搜索”一个值（船的运载能力），这个值能够满足条件（即满足限定的时间内把所有货物运走），并且不只是能满足，还得是最小的。那么就可以先找到一个能满足的，然后按照二分查找的左边界，找到最小能满足的那个值，就是结果。</p>
<p>因此代码主要分为两部分：</p>
<ol>
<li>二分查找部分，先计算出一个值作为运载能力，然后计算这个值下的需要的天数。如果天数多于限定的，说明这个值小了，应该改变左边界；反之亦然</li>
<li>计算所需天数部分，根据上面二分查找的值计算所需天数</li>
</ol>
<p>其中，计算天数的逻辑如下：<br>遍历所有包裹的重量，依次相加。如果超重，就需要延后一天（超重的这个包裹不能算上），即天数+1；然后把当天的包裹重量和清零，再继续计算。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shipWithinDays = <span class="function"><span class="keyword">function</span> (<span class="params">weights, days</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="built_in">Math</span>.max(...weights);</span><br><span class="line">  <span class="keyword">let</span> right = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> w <span class="keyword">of</span> weights) right += w;</span><br><span class="line">  <span class="keyword">if</span> (left === right) <span class="keyword">return</span> left;</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// 初始的左边界应该是最大的货物重量，右边界应该是总重量</span></span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> result = getDay(weights, mid); <span class="comment">// 这里把先计算出的mid传入，测试能不能保证在限制内完成</span></span><br><span class="line">    <span class="keyword">if</span> (result &gt; days) &#123;</span><br><span class="line">      <span class="comment">// 如果需要的天数大于限制，就应该增加运输量，即增大mid</span></span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 反之就减小</span></span><br><span class="line">      right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> left;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> getDay = <span class="function"><span class="keyword">function</span> (<span class="params">weights, limit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> day = <span class="number">1</span>; <span class="comment">// 需要的天数</span></span><br><span class="line">  <span class="keyword">let</span> cur = <span class="number">0</span>; <span class="comment">// 当前运送的包裹重量和</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> weight <span class="keyword">of</span> weights) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur + weight &gt; limit) &#123;</span><br><span class="line">      day++;</span><br><span class="line">      cur = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cur += weight;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此二分查找相关的题目核心在于“查找”，而不是“二分”。如果一道题是在一个区间内查找最值，并且能满足上面所说的函数，就可以尝试用这种方法。</p>
<h2 id="爱吃香蕉的珂珂"><a href="#爱吃香蕉的珂珂" class="headerlink" title="爱吃香蕉的珂珂"></a>爱吃香蕉的珂珂</h2><blockquote>
<p>珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有  piles[i]  根香蕉。警卫已经离开了，将在 h 小时后回来。<br>珂珂可以决定她吃香蕉的速度 k （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  <br>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。<br>返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。</p>
</blockquote>
<p>这道题和上面那道基本套路都是一样的。</p>
<p>思路还是先确定一个范围，然后利用二分查找的左边界，找到可以满足的最小值。由题意，k 和吃掉的时间 t 成反比。那么可以先从确定的范围内计算一个 mid 作为 k，计算这个 k 下吃掉所有香蕉所需的时间 t，和 h 比较，如果大了就改变左边界，反之亦然。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minEatingSpeed = <span class="function"><span class="keyword">function</span> (<span class="params">piles, h</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> right = piles.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor((right + left) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> hours = piles.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre + <span class="built_in">Math</span>.ceil(cur / mid), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hours &gt; h) &#123;</span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> left;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树问题的基本递归思路"><a href="#二叉树问题的基本递归思路" class="headerlink" title="二叉树问题的基本递归思路"></a>二叉树问题的基本递归思路</h2><p>二叉树问题基本上都离不开递归和遍历；<br>而递归实际上有两种，一种是单纯只递归，比如基本的递归遍历方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  dfs(node.left);</span><br><span class="line">  dfs(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种递归只有在边界条件才会返回，因此一般常用于彻底的遍历，比如路径问题。<br>在思考方式上，这种递归可以看作是只有一个左右节点的树的遍历。常常把操作放置在两个递归的<code>dfs()</code>前面、中间或后面，对应不同的时刻：</p>
<ul>
<li>前面：该节点已经遍历到，但其子节点还没开始遍历，可以进行记录该节点值、判断临界条件等操作</li>
<li>中间：只遍历了左子树，一般很少放在这里，除非是为了中序遍历</li>
<li>后面：该节点和其子树都被完全遍历。站在最顶层调用栈的角度上，这时整棵树已经遍历完毕；可以在这里显式返回一个值，这个值将会是上面每个 dfs 都会返回的值；也可以执行一些<strong>回溯</strong>相关的操作，比如路径问题中在这里让当前节点出栈、回溯问题中在这里返回上一层等等</li>
</ul>
<hr>
<p>另一种递归是显式的返回值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = dfs(node.left);</span><br><span class="line">  <span class="keyword">let</span> right = dfs(node.right);</span><br><span class="line">  <span class="keyword">return</span> node.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时前面两个递归的 dfs 也会产生有效的返回值，并且返回的值就是最末端的返回值。</p>
<p>注意要以“递归的方式思考问题”，不要把上面两个 dfs 看成复杂的调用栈，而是只把他们当作左节点和右节点的调用结果即可。</p>
<blockquote>
<p>这种遍历方式能够生效的最重要一点是：<strong>左右递归调用结果</strong>（<strong>当前节点</strong>有时候也会）都会参与返回值的运算</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = dfs(node.left);</span><br><span class="line">  <span class="keyword">let</span> right = dfs(node.right);</span><br><span class="line">  <span class="keyword">return</span> node.val + <span class="built_in">Math</span>.max(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就会把当前节点的值和左右子节点中较大的值加起来。由于自底向上的每次返回都用到了 left 和 right，因此数值就是从下向上连续的，left 和 right 可以看作是左右子树的计算结果。</p>
<p>再比如，常见的方法之一是利用返回布尔值进行一些判断。比如基本的递归搜索一个值，找到了则返回 true</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和搜索相关的问题是少都要考虑这个写法，这是最基本的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">root, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> search(root.left, val) || search(root.right, val) || root.val === val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里返回值综合了两个遍历的结果和当前节点的值，只要有一个符合条件就返回 true，即找到一个就返回 true。</p>
<p>当函数参数不止有节点这一个参数时，当前节点值还可以放入参数中。比如<code>路径总和1</code>这个题，就是通过每次递减一个当前节点值来实现。</p>
<p>还可以有条件的返回不同的值；这种方法常见于偏运算，比如只计算左叶子和这种问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = dfs(node.left);</span><br><span class="line">  dfs(node.right);</span><br><span class="line">  sum += left;</span><br><span class="line">  <span class="keyword">if</span> (!node.left &amp;&amp; !node.right) <span class="keyword">return</span> node.val;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只有当节点为叶子节点时才会返回有效的值，相当于是在遍历之中设置了回溯条件。</p>
<h2 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><ol>
<li>将根节点入栈</li>
<li>出栈，输出该节点，然后将该节点的子节点入栈，先右后左；这样出栈的顺序就是先左后右，符合先序遍历的<code>左-&gt;右-&gt;中</code>顺序</li>
<li>后续依次类推</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> preorder = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  stack.push(root);</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = stack.pop();</span><br><span class="line">    res.push(node.val);</span><br><span class="line">    <span class="keyword">if</span> (node.right) stack.push(node.right);</span><br><span class="line">    <span class="keyword">if</span> (node.left) stack.push(node.left);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><ol>
<li>同样是先入栈根节点</li>
<li>出栈，将该节点的输出插入到结果队列的头部（unshift），这样结果数组相当于是反向；然后将子节点入栈，先左后右</li>
<li>以此类推</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> postorderIterate = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">  stack.push(root);</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = stack.pop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相当于把结果数组反向了</span></span><br><span class="line">    res.unshift(node.val);</span><br><span class="line">    <span class="comment">// 因为结果数组反向,这里也要变一下</span></span><br><span class="line">    <span class="keyword">if</span> (node.left) stack.push(node.left);</span><br><span class="line">    <span class="keyword">if</span> (node.right) stack.push(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>中序遍历根另外两者都不一样，因为先序和后序都是通过出栈一个元素作为根节点，然后把它的左右子元素入栈。但是中序遍历的顺序是<code>左-&gt;中-&gt;右</code>，也就说必须有从<code>左</code>回到其父元素<code>中</code>的过程。</p>
<ol>
<li>从根节点开始迭代取左子元素，每迭代一次就入栈一个元素，直到最左端位置</li>
<li>出栈一个元素，输出结果，然后取该节点的右节点再次迭代。因为这时的出栈元素如果有右节点，说明就是一个父元素，相当于<code>中</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inorderIterate = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">  stack.push(root);</span><br><span class="line">  <span class="keyword">let</span> curr = root;</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">      stack.push(curr);</span><br><span class="line">      curr = curr.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curr = stack.pop();</span><br><span class="line">    res.push(curr.val);</span><br><span class="line">    curr = curr.right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><ol>
<li>设置一个队列，将根元素入队</li>
<li>出队队头元素并输出，把这个元素的子元素全部入队。重复这个过程，直到把上一步的所有入队元素都出队并输出；这里需要先缓存上一步时队列的长度，然后遍历这个长度直到上一层的元素都依次执行该过程。</li>
<li>依次类推</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> levelOrder = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> queue = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  queue.push(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = queue.length;</span><br><span class="line">    <span class="comment">// 相当于每次执行到这里就是新的一层</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> node = queue.shift();</span><br><span class="line">      res.push(node.val);</span><br><span class="line">      <span class="keyword">if</span> (node.left) queue.push(node.left);</span><br><span class="line">      <span class="keyword">if</span> (node.right) queue.push(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><blockquote>
<p><img src="https://pic.imgdb.cn/item/62675aab239250f7c5499cac.jpg"></p>
</blockquote>
<p>思路：以递归的方式，遍历树中的每一个结点，并将每一个结点的左右孩子进行交换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> invertTree = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">let</span> left = invertTree(root.left);</span><br><span class="line">  <span class="keyword">let</span> right = invertTree(root.right);</span><br><span class="line">  root.left = right;</span><br><span class="line">  root.right = left;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>翻转二叉树是这种非尾递归思想的重要体现之一；通过递归先一直到边界（即叶子节点）为止，然后返回该节点给上一层的<code>left</code>；再同理把<code>right</code>交给上一层，在上一层中进行交换，就完成了自下而上的第一次交换，后续同理。</p>
<p>比如一个通常的遍历是这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  dfs(node.left);</span><br><span class="line">  dfs(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的遍历只会在遇到边界时返回。如果我们在最后显式返回某一个值（一般就是本次递归的参数传入的节点），每一个递归就相当于拿到了其上一层的返回值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> node;</span><br><span class="line">  <span class="keyword">let</span> left = dfs(node.left); <span class="comment">// left是当前node的左子树的根节点</span></span><br><span class="line">  <span class="keyword">let</span> right = dfs(node.right); <span class="comment">// 右子树</span></span><br><span class="line">  <span class="keyword">return</span> node; <span class="comment">// 返回本节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到了 left 和 right，从递归的思维来看，实际上就是拿到了任一个节点的左右子树（不用考虑反复递归的多层，只考虑一层即可）。所以我们可以进行一些操作，比如上面的交换节点。</p>
<p>如果最简单的二叉树（只有三个节点）可以执行，那么任何情况下的二叉树都可以执行。因此这类问题可以先从最简单的考虑。如果最简单的情况可以保证递归的完整，那么之后的逻辑就不用考虑递归的内部，而是只把递归当成一个“取值”的步骤，正常处理其他逻辑。</p>
<h2 id="BST（二叉搜索树）"><a href="#BST（二叉搜索树）" class="headerlink" title="BST（二叉搜索树）"></a>BST（二叉搜索树）</h2><h3 id="BST-的特点"><a href="#BST-的特点" class="headerlink" title="BST 的特点"></a>BST 的特点</h3><ul>
<li>BST 的基本特点是一个根节点的左子树上的所有值一定比该节点小，右子树的所有值一定比该节点大</li>
<li>BST 的中序遍历会返回一个从小到大的顺序排列，可以利用这一点做很多事，比如求最值等等。</li>
</ul>
<h3 id="BST-基本操作"><a href="#BST-基本操作" class="headerlink" title="BST 基本操作"></a>BST 基本操作</h3><p>查找：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">root, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (root.val === n) <span class="keyword">return</span> root;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; n) search(root.left, n);</span><br><span class="line">  <span class="keyword">else</span> search(root.right, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">root, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; root.val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root.left) root.left = <span class="keyword">new</span> TreeNode(n);</span><br><span class="line">    <span class="keyword">else</span> insert(root.left, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root.right) root.right = <span class="keyword">new</span> TreeNode(n);</span><br><span class="line">    <span class="keyword">else</span> insert(root.right, n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除：</p>
<p>删除节点的函数要返回参数 root，因为执行函数的返回值实际上是“替换子树”的效果，也是上面说的非尾递归的形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeNode</span>(<span class="params">root, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">  <span class="keyword">if</span> (root.val === n) &#123;</span><br><span class="line">    <span class="comment">// 如果n和当前节点值相等，即找到了要删除的节点</span></span><br><span class="line">    <span class="keyword">if</span> (root.left &amp;&amp; !root.right) &#123;</span><br><span class="line">      <span class="comment">//如果只有左子树，就把左子树中最大的值替换过来，并把这个节点删掉</span></span><br><span class="line">      root.val = findMax(root.left);</span><br><span class="line">      root.left = removeNode(root.left, findMax(root.left));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!root.left &amp;&amp; !root.right) &#123;</span><br><span class="line">      <span class="comment">// 没有左右子树，直接删去</span></span><br><span class="line">      root = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//只有右子树或者左右子树都有的情况，找到右子树最小的值并替换删去</span></span><br><span class="line">      root.val = findMin(root.right);</span><br><span class="line">      root.right = removeNode(root.right, findMin(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; n) &#123;</span><br><span class="line">    <span class="comment">// 如果没找到且小于，找左子树</span></span><br><span class="line">    root.left = removeNode(root.left, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    root.right = removeNode(root.right, n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最后一定要返回经过修改后的root</span></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找最大最小实际上就是找最左最右的值</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">findMax</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root.right) root = root.right;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">findMin</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root.left) root = root.left;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="验证是否是有效-BST"><a href="#验证是否是有效-BST" class="headerlink" title="验证是否是有效 BST"></a>验证是否是有效 BST</h2><p>即验证树是否保证<code>左 &lt; 中 &lt; 右</code></p>
<p>注意不能单独把左子节点提出来判断是不是小于本节点，因为这样相当于只判断了一层（紧挨着的左子节点），而不是整颗左子树</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isValidBST = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">root, minValue, maxValue</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 若是空树，则合法</span></span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt;= minValue || root.val &gt;= maxValue) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 接下来要遍历左子树，那就把当前节点的值作为最大值传入，保证左子树的值不大于当前节点。右子树同理</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      dfs(root.left, minValue, root.val) &amp;&amp; dfs(root.right, root.val, maxValue)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化最小值和最大值为极小或极大</span></span><br><span class="line">  <span class="keyword">return</span> dfs(root, -<span class="literal">Infinity</span>, <span class="literal">Infinity</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>还有一种方法是利用二叉搜素树的中序遍历，如果遍历的过程中不是有序的（每次和前一个值做对比），就说明不是有效。</p>
<h2 id="有序数组转-BST"><a href="#有序数组转-BST" class="headerlink" title="有序数组转 BST"></a>有序数组转 BST</h2><blockquote>
<p>把有序数组转为平衡二叉树</p>
</blockquote>
<p>思路类似二分查找,把中间的数作为根节点”提起来”,然后范围二分为<code>[low,mid)</code>和<code>(mid,high]</code>分别给左右子树</p>
<p><img src="https://pic.imgdb.cn/item/62677250239250f7c582b679.jpg"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortedArrayToBST = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> buildBST(<span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buildBST</span>(<span class="params">low, high</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(low + (high - low) / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//注意这个地方需要low+...,因为不一定是从0开始的,需要low+计算值才是真正的中间值</span></span><br><span class="line">    <span class="keyword">const</span> curr = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    curr.left = buildBST(low, mid - <span class="number">1</span>);</span><br><span class="line">    curr.right = buildBST(mid + <span class="number">1</span>, high);</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>buildBST</code>方法还可以接收一个分割好的数组:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildBST</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!arr.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 这里取arr.length / 2,这样偶数元素中间值就会划分到偏后一位,防止arr.slice(0, mid - 1)在有元素的时候仍截取到空数组</span></span><br><span class="line">  <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> TreeNode(arr[mid]);</span><br><span class="line">  node.left = buildBST(arr.slice(<span class="number">0</span>, mid));</span><br><span class="line">  node.right = buildBST(arr.slice(mid + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造最大二叉树"><a href="#构造最大二叉树" class="headerlink" title="构造最大二叉树"></a>构造最大二叉树</h4><blockquote>
<p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：<br>二叉树的根是数组中的最大元素。<br>左子树是通过数组中最大值左边部分构造出的最大二叉树。<br>右子树是通过数组中最大值右边部分构造出的最大二叉树。<br>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p>
</blockquote>
<p>构造最大二叉树的思路就是在构造二叉树时，把中间节点置为数组中的最大值即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> constructMaximumBinaryTree = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> buildBST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buildBST</span>(<span class="params">nums, low, high</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> maxVal = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> maxIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = low; i &lt;= high; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; maxVal) &#123;</span><br><span class="line">        maxVal = nums[i];</span><br><span class="line">        maxIndex = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> curr = <span class="keyword">new</span> TreeNode(maxVal);</span><br><span class="line">    <span class="built_in">console</span>.log(maxVal);</span><br><span class="line">    curr.left = buildBST(nums, low, maxIndex - <span class="number">1</span>);</span><br><span class="line">    curr.right = buildBST(nums, maxIndex + <span class="number">1</span>, high);</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="判断平衡二叉树"><a href="#判断平衡二叉树" class="headerlink" title="判断平衡二叉树"></a>判断平衡二叉树</h2><p>平衡二叉树，即一个节点的左右子树高度差不能大于 1。</p>
<p>思路就是递归遍历每一个节点，计算每隔节点的左右子树高度差，如果有一个节点高度差大于 1，整体就失去平衡。</p>
<p>第一种方法是计算和遍历分开，计算节点高度是单独的方法，而遍历采用先序遍历的方式。<br>获取节点高度的方式是分别递归左右子树，每返回一次高度都会+1，最终会以左右子树中较高的为结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isBalanced = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  dfs(root);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> left = getNodeHeight(root.left);</span><br><span class="line">    <span class="keyword">let</span> right = getNodeHeight(root.right);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(left - right) &gt; <span class="number">1</span>) flag = <span class="literal">false</span>;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getNodeHeight</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(getNodeHeight(node.left), getNodeHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更好的解决方法是遍历的同时就计算高度，在递归函数末尾返回上一步得到的左右高度中较大一个+1</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isBalanced2 = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  dfs(root);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> left = dfs(root.left);</span><br><span class="line">    <span class="keyword">const</span> right = dfs(root.right);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(left - right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(left, right) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><blockquote>
<p>构造平衡二叉树.给你一棵二叉搜索树，请你返回一棵平衡后的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。</p>
</blockquote>
<p>思路就是<strong>中序遍历</strong>获取数的数组形式,然后用上面的有序数组转为平衡二叉树方法即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> balanceBST = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> nums = [];</span><br><span class="line"></span><br><span class="line">  inorder(root);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inorder</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    inorder(node.left);</span><br><span class="line">    nums.push(node.val);</span><br><span class="line">    inorder(node.right);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tree = buildBST(nums);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buildBST</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> TreeNode(arr[mid]);</span><br><span class="line">    node.left = buildBST(arr.slice(<span class="number">0</span>, mid));</span><br><span class="line">    node.right = buildBST(arr.slice(mid + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tree;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="比较两棵二叉树"><a href="#比较两棵二叉树" class="headerlink" title="比较两棵二叉树"></a>比较两棵二叉树</h2><blockquote>
<p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
</blockquote>
<p>思路：递归比较两棵树的左、右子树即可。如果两棵树完全相等，则 p 和 q 应当是完全相同的，只要有一个对不上就是 false</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isSameTree = <span class="function"><span class="keyword">function</span> (<span class="params">p, q</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((q &amp;&amp; !p) || (p &amp;&amp; !q) || p.val !== q.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树轴对称"><a href="#二叉树轴对称" class="headerlink" title="二叉树轴对称"></a>二叉树轴对称</h2><blockquote>
<p>给你一个二叉树的根节点 root，检查它是否轴对称。</p>
</blockquote>
<p>这道题和翻转二叉树思路近似，从<code>root.left</code>和<code>root.right</code>分开，分别递归比较左子树的右节点和右子树的左节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">p, q</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> ((!p &amp;&amp; q) || (!q &amp;&amp; p) || p.val !== q.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><blockquote>
<p>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
</blockquote>
<p>这道题就是求节点高度，递归遍历每一个节点，每次遍历都给返回值+1，并选择左右子树中较大的一个。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = maxDepth(root.left);</span><br><span class="line">  <span class="keyword">let</span> right = maxDepth(root.right);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这道题还有一个变种，就是求一个节点的最小深度。注意最小深度仍然是到叶子节点的，不能在空节点就停下，因此需要判断左右子节点的高度，不为 0 才返回：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minDepth = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = minDepth(root.left);</span><br><span class="line">  <span class="keyword">let</span> right = minDepth(root.right);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (left === <span class="number">0</span> &amp;&amp; right &gt; <span class="number">0</span>) <span class="keyword">return</span> right + <span class="number">1</span>; <span class="comment">// 左节点为空</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; <span class="number">0</span> &amp;&amp; right === <span class="number">0</span>) <span class="keyword">return</span> left + <span class="number">1</span>; <span class="comment">// 右节点为空</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Math</span>.min(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>关于深度问题，其实还有一个更合适和通用的解法，就是利用 BFS 层序遍历。因为层序可以保证一层一层的往下走，那么走到第一个叶子节点就可以得到最小深度，最后走完就可以得到最大深度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minmaxDepth = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> queue = [];</span><br><span class="line">  queue.push(root);</span><br><span class="line">  <span class="keyword">let</span> depth = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = queue.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> top = queue.shift();</span><br><span class="line">      <span class="keyword">if</span> (!top.left &amp;&amp; !top.right) <span class="keyword">return</span> depth; <span class="comment">// 最小深度就在这里返回</span></span><br><span class="line">      <span class="keyword">if</span> (top.right) queue.push(top.right);</span><br><span class="line">      <span class="keyword">if</span> (top.left) queue.push(top.left);</span><br><span class="line">    &#125;</span><br><span class="line">    depth++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> depth; <span class="comment">// 最大深度就遍历完之后返回</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的路径问题"><a href="#二叉树的路径问题" class="headerlink" title="二叉树的路径问题"></a>二叉树的路径问题</h2><p>这里可以参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-ii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-oo63/">https://leetcode-cn.com/problems/path-sum-ii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-oo63/</a></p>
<p>路径问题可以分为两大类</p>
<ul>
<li>自顶向下，从某一个节点(不一定是根节点)，从上向下寻找路径，到某一个节点(不一定是叶节点)结束。方法类似，在每次遍历中记录路径，当遍历到合适条件时输出结果，再在每次递归的最尾端执行复原操作（比如出栈、总和减去当前值等等）。</li>
</ul>
<blockquote>
<p>其实这就是回溯，回溯问题本质也是在遍历一棵树并记录路径。回溯部分（状态的恢复）就位于后序遍历位置，状态改变则位于先序位置</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (临界条件) &#123;</span><br><span class="line">    res.push(path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  path.push(node.val);</span><br><span class="line">  dfs(node.left);</span><br><span class="line">  dfs(node.right);</span><br><span class="line">  path.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>

<p>如果要求有路径和，一般是把目标值放在最顶端，然后自顶向下每次遍历都减去当前节点值，直到减为 0 或者其他临界条件为止。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node, sum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  path.push(node.val);</span><br><span class="line">  sum -= node.val;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">    res.push(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dfs(node.left, sum);</span><br><span class="line">  dfs(node.right, sum);</span><br><span class="line">  path.pop();</span><br><span class="line">&#125;</span><br><span class="line">dfs(root, targetNum);</span><br></pre></td></tr></table></figure>

<ul>
<li>非自顶向下：就是从任意节点到任意节点的路径，不需要自顶向下。<br>这种一般比较麻烦，除了从上到下的基本顺序，还有可能是横着的甚至倒着的路径。</li>
</ul>
<p>这类题目一般解题思路如下：<br>设计一个辅助函数 maxpath，调用自身求出以一个节点为根节点的左侧最长路径 left 和右侧最长路径 right，那么经过该节点的最长路径就是 <code>left+right</code><br>接着只需要从根节点开始 dfs,不断比较更新全局变量即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = -<span class="literal">Infinity</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxPath</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = maxPath(node.left);</span><br><span class="line">  <span class="keyword">let</span> right = maxPath(node.right);</span><br><span class="line">  res = <span class="built_in">Math</span>.max(res, node.val + left + right);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(left, right) + node.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>left,right 代表的含义要根据题目所求设置，比如最长路径、最大路径和等等</li>
<li>全局变量 res 的初值设置是 0 还是<code>-Infinity</code>要看题目节点是否存在负值，如果存在就用<code>-Infinity</code>，否则就是 0</li>
</ol>
<h3 id="路径问题-1（目标和）"><a href="#路径问题-1（目标和）" class="headerlink" title="路径问题 1（目标和）"></a>路径问题 1（目标和）</h3><blockquote>
<p>给你二叉树的根节点 root 和一个表示目标和的整数  targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和  targetSum 。如果存在，返回 true ；否则，返回 false</p>
</blockquote>
<p>路径问题最基本的一道题，好好背就完事了。<br>思路就是：把总和依次相减下来，每到一个节点就减去当前节点的值，直到叶子节点判断是否等于叶子节点的值，<br>如果等于说明一路上减去的值加起来正好就是 targetSum</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasPathSum = <span class="function"><span class="keyword">function</span> (<span class="params">root, targetSum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (!root.left &amp;&amp; !root.right) &#123;</span><br><span class="line">    <span class="keyword">return</span> targetSum === root.val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    hasPathSum(root.left, targetSum - root.val) ||</span><br><span class="line">    hasPathSum(root.right, targetSum - root.val)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另外一个方法是先序遍历时判断，思路差不多：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasPathSum = <span class="function"><span class="keyword">function</span> (<span class="params">root, targetSum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node, num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!node.left &amp;&amp; !node.right &amp;&amp; num === node.val) flag = <span class="literal">true</span>;</span><br><span class="line">    dfs(node.left, num - node.val);</span><br><span class="line">    dfs(node.right, num - node.val);</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(root, targetSum);</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="路径问题-2（具体路径）"><a href="#路径问题-2（具体路径）" class="headerlink" title="路径问题 2（具体路径）"></a>路径问题 2（具体路径）</h3><p>这道题是上一个的升级版，要求求出具体路径</p>
<p>思路在上面的解析中已经有过，就是记录路径，在递归结束时弹出当前节点，并在条件合适时记录路径。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pathSum = <span class="function"><span class="keyword">function</span> (<span class="params">root, targetSum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> path = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  dfs(root, targetSum);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node, sum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!node.left &amp;&amp; !node.right &amp;&amp; sum === node.val) &#123;</span><br><span class="line">      res.push([...path, node.val]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path.push(node.val);</span><br><span class="line">    dfs(node.left, sum - node.val);</span><br><span class="line">    dfs(node.right, sum - node.val);</span><br><span class="line">    path.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="路径问题-3（任意节点开始）"><a href="#路径问题-3（任意节点开始）" class="headerlink" title="路径问题 3（任意节点开始）"></a>路径问题 3（任意节点开始）</h3><blockquote>
<p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
</blockquote>
<p>这道题有两种解法，最好想的就是二重递归：</p>
<ul>
<li>第一重递归遍历所有节点</li>
<li>然后对于每个节点，执行路径问题 1 的算法</li>
</ul>
<p>方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pathSum = <span class="function"><span class="keyword">function</span> (<span class="params">root, sum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">0</span>, <span class="number">1</span>]]);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    prefix += node.val;</span><br><span class="line">    <span class="keyword">if</span> (map.has(prefix - sum)) &#123;</span><br><span class="line">      res += map.get(prefix - sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!map.has(prefix)) map.set(prefix, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> map.set(prefix, map.get(prefix) + <span class="number">1</span>);</span><br><span class="line">    dfs(node.left);</span><br><span class="line">    dfs(node.right);</span><br><span class="line">    prefix -= node.val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> prefix = <span class="number">0</span>;</span><br><span class="line">  dfs(root);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还有一种方法是使用<strong>前缀和</strong>，但是比较麻烦，没太看懂，参考<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-iii/solution/lu-jing-zong-he-iii-by-leetcode-solution-z9td/">https://leetcode-cn.com/problems/path-sum-iii/solution/lu-jing-zong-he-iii-by-leetcode-solution-z9td/</a></p>
<blockquote>
<p>前缀和还是先搞清一维数组的前缀和把</p>
</blockquote>
<h3 id="最大路径和"><a href="#最大路径和" class="headerlink" title="最大路径和"></a>最大路径和</h3><blockquote>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。<br>路径和 是路径中各节点值的总和。<br>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。<br>同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点</p>
</blockquote>
<p>这个是上面说的非自顶向下的典型例题，方法也是参考那个的，但是稍有改动：</p>
<ul>
<li>节点有负值，加上一个负值会对最大路径和起到反作用，因此如果左右路径和为负数就不选取（即取 0，和空节点的情况一样）</li>
<li><code>路径</code> 一定是先上升（ 0 ～ n 个）节点, 到达顶点, 后下降（ 0 ～ n 个）节点；因此表现出来就是<code>node.val + left + right</code></li>
</ul>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxPathSum = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = -<span class="literal">Infinity</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">maxPath</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="built_in">Math</span>.max(maxPath(node.left), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> right = <span class="built_in">Math</span>.max(maxPath(node.right), <span class="number">0</span>);</span><br><span class="line">    res = <span class="built_in">Math</span>.max(res, node.val + left + right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(left, right) + node.val;</span><br><span class="line">  &#125;</span><br><span class="line">  maxPath(root);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树左叶子之和"><a href="#二叉树左叶子之和" class="headerlink" title="二叉树左叶子之和"></a>二叉树左叶子之和</h2><blockquote>
<p>计算给定二叉树的所有左叶子之和。</p>
</blockquote>
<p>注意是左叶子，因此不能包括树枝节点；所以可以利用遍历找到包含左叶子的节点，加上这个节点即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sumOfLeftLeaves = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left) sum += root.left.val;</span><br><span class="line">    dfs(node.left);</span><br><span class="line">    dfs(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(root);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树最值"><a href="#二叉树最值" class="headerlink" title="二叉树最值"></a>二叉树最值</h2><p>怎么求一个二叉树的最值？</p>
<p>对于一个普通的二叉树，求最大值的方法就是简单的递归：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(dfs(node.left), dfs(node.right), node.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是 BST，BST 的一个特点的<strong>中序排列的输出结果是一个递增序列</strong>。即第 n 次到输出位置时，恰好是第 n 个最小的数字。<br>如果希望是一个倒序的输出，调换两个递归的位置即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  dfs(node.left);</span><br><span class="line">  res.push(node.val);</span><br><span class="line">  dfs(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><blockquote>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>
<p>思路：记住满足条件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lson = dfs(root.left, p, q);</span><br><span class="line"><span class="keyword">const</span> rson = dfs(root.right, p, q);</span><br><span class="line">(lson &amp;&amp; rson) ||</span><br><span class="line">  ((root.val === p.val || root.val === q.val) &amp;&amp; (lson || rson));</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ol start="0">
<li>首先明确递归的返回值：指<strong>在该树中是否存在 p 或者 q 的一个或多个</strong></li>
<li>如果 p 和 q 分别位于左子树和右子树中，那么<code>lson &amp;&amp; rson</code>一定为 true，说明两边至少包含 p 和 q 的一个；</li>
<li>如果 p 或 q 的一个是当前节点本身，那么值肯定相等，并且自己的左子树和右子树至少要有一个包含另一个节点。</li>
</ol>
<p>判断之后，最后返回的值应该是：</p>
<ol>
<li>判断自己和这个 p 和 q 之一是否相等，因为如果有一个相等就必然为 true（一定包含 q 或 p）</li>
<li>判断自己的子树情况，即<code>lson || rson</code>，因为递归条件是只要有一个包含就行，因此两个有一个为 true 就行</li>
</ol>
<p>最终代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="function"><span class="keyword">function</span> (<span class="params">root, p, q</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ans;</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">root, p, q</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> lson = dfs(root.left, p, q);</span><br><span class="line">    <span class="keyword">const</span> rson = dfs(root.right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      (lson &amp;&amp; rson) ||</span><br><span class="line">      ((root.val === p.val || root.val === q.val) &amp;&amp; (lson || rson))</span><br><span class="line">    ) &#123;</span><br><span class="line">      ans = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lson || rson || root.val === p.val || root.val === q.val;</span><br><span class="line">  &#125;;</span><br><span class="line">  dfs(root, p, q);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="从前序遍历和中序遍历构造二叉树"><a href="#从前序遍历和中序遍历构造二叉树" class="headerlink" title="从前序遍历和中序遍历构造二叉树"></a>从前序遍历和中序遍历构造二叉树</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>
<p>思路：</p>
<ul>
<li>前序遍历的第一个节点是整个二叉树的根元素</li>
<li>中序遍历从根元素划分，左右两半数组恰好是左右子树的中序遍历</li>
</ul>
<p>因此通过前序遍历划分左右子树的前序、先序遍历，再依次递归即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">preorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">inorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span> (<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!inorder.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">const</span> tmp = preorder[<span class="number">0</span>]; <span class="comment">// 前序的第一项，即根元素</span></span><br><span class="line">  <span class="keyword">const</span> mid = inorder.indexOf(tmp); <span class="comment">// 获取根元素所在的位置</span></span><br><span class="line">  <span class="comment">// 因为前序和中序的左右子树长度一定一样，所以preorder也可以用mid+1划分</span></span><br><span class="line">  root.left = buildTree(preorder.slice(<span class="number">1</span>, mid + <span class="number">1</span>), inorder.slice(<span class="number">0</span>, mid));</span><br><span class="line">  root.right = buildTree(preorder.slice(mid + <span class="number">1</span>), inorder.slice(mid + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">https://leetcode.cn/problems/merge-two-binary-trees/</a></p>
<blockquote>
<p>给你两棵二叉树： root1 和 root2 。<br>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。</p>
</blockquote>
<p>（其实我也不知道是怎么过的）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeTrees = <span class="function"><span class="keyword">function</span> (<span class="params">root1, root2</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node1, node2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node1 &amp;&amp; !node2) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!node1 &amp;&amp; node2) <span class="keyword">return</span> node2;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node1 &amp;&amp; !node2) <span class="keyword">return</span> node1;</span><br><span class="line"></span><br><span class="line">    node1.val += node2.val;</span><br><span class="line">    node1.left = dfs(node1.left, node2.left);</span><br><span class="line">    node1.right = dfs(node1.right, node2.right);</span><br><span class="line">    <span class="keyword">return</span> node1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dfs(root1, root2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的双指针（前指针）"><a href="#二叉树的双指针（前指针）" class="headerlink" title="二叉树的双指针（前指针）"></a>二叉树的双指针（前指针）</h2><p>二叉树问题的解决（尤其是二叉搜素树）可以遍历成一个数组，然后用对数组的操作方式操作。因为数组通常可以比较方便的访问前后的值；<br>实际上不需要额外的内存空间，也可以直接在二叉树问题遍历时取得前一个值。<br>方法就是利用中序遍历：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!node) <span class="keyword">return</span></span><br><span class="line">  dfs(node.left)</span><br><span class="line">  <span class="keyword">if</span>(!pre)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  pre = node</span><br><span class="line">  dfs(node.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此可以利用这个方法解决（尤其是二叉搜索树）一些可能需要通过转成数组的问题。</p>
<h3 id="二叉搜素树的众数"><a href="#二叉搜素树的众数" class="headerlink" title="二叉搜素树的众数"></a>二叉搜素树的众数</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/solution/">https://leetcode.cn/problems/find-mode-in-binary-search-tree/solution/</a></p>
<blockquote>
<p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。<br>如果树中有不止一个众数，可以按 任意顺序 返回。</p>
</blockquote>
<p>利用上面的方法，因为二叉搜索树的中序遍历一定是从小到大的有序数组，因此可以完全按照数组的方式去做。<br>数组中怎么求众数？定义一个出现次数的变量，前一个数等于后一个，就给出现次数+1；如果出现次数大于最大出现次数，就把最大出现次数更新；如果等于最大出现次数，就把数字放入最大出现次数的数字的数组中。<br>二叉树同理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findMode = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root.left &amp;&amp; !root.right) <span class="keyword">return</span> [root.val];</span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> maxTimes = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> maxNumbers = [];</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    dfs(node.left);</span><br><span class="line">    <span class="keyword">if</span> (pre &amp;&amp; pre.val === node.val) &#123;</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cnt = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt; maxTimes) &#123;</span><br><span class="line">      maxTimes = cnt;</span><br><span class="line">      maxNumbers.length = <span class="number">0</span>;</span><br><span class="line">      maxNumbers.push(node.val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt === maxTimes) &#123;</span><br><span class="line">      maxNumbers.push(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">    pre = node;</span><br><span class="line">    dfs(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(root);</span><br><span class="line">  <span class="keyword">return</span> maxNumbers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的回溯"><a href="#二叉树的回溯" class="headerlink" title="二叉树的回溯"></a>二叉树的回溯</h2><p>回溯问题是一个多叉树的遍历问题，所以<strong>二叉树也一定可以回溯，并且也能通过回溯实现从下向上的遍历</strong>。<br>上面讲过，二叉树的回溯位置就是在后序遍历之后，即这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 状态改变</span></span><br><span class="line">  dfs(node.left);</span><br><span class="line">  dfs(node.right);</span><br><span class="line">  <span class="comment">//...回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如说这道找出二叉树中所有路径的题<code>https://leetcode.cn/problems/binary-tree-paths/</code>，需要遍历所有节点，并且统计从根节点到该节点的路径。显然这就是一个回溯问题，解法也是回溯的思路：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 注意这里到叶子节点就要停止了，因为到null就停下会统计很多不是从根节点到叶子节点的路径</span></span><br><span class="line">  <span class="keyword">if</span> (!node.left &amp;&amp; !node.right) &#123;</span><br><span class="line">    res.push([...path, node.val]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  path.push(node.val);</span><br><span class="line">  node.left &amp;&amp; dfs(node.left);</span><br><span class="line">  node.right &amp;&amp; dfs(node.right);</span><br><span class="line">  path.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那怎么实现从下到上的遍历呢？其实就是在后序遍历的位置做处理就好。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  dfs(node.left);</span><br><span class="line">  dfs(node.right);</span><br><span class="line">  <span class="comment">// 这里的node一定是从二叉树底部向上的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以上面那道最近公共祖先的题目，实际上就是利用了这个原理，从下向上判断，那么判断出来的第一个符合公共节点的当然就是最近的。</p>
<h2 id="二叉树的序列化和反序列化"><a href="#二叉树的序列化和反序列化" class="headerlink" title="二叉树的序列化和反序列化"></a>二叉树的序列化和反序列化</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/</a></p>
<p>这道题的题干比较复杂，简单来说就是把二叉树输出成一个字符串（序列化），然后再把这个字符串转成二叉树（反序列化）<br>序列化和反序列应该是对应的。如果序列化是先序遍历，那么反序列应该采取相同的识别方式。这里有几个注意点：</p>
<ol>
<li>序列化不能只输出有效值。对于 null 也需要输出，否则反序列化不能识别哪些地方应该是 null。输出 null 只需要在递归边界时记录一个<code>&#39;null&#39;</code>即可，这时不仅是只有一个单子树的另一边会变成 null，叶子节点也会多出两个为 null 的节点。</li>
<li>反序列化的思路：不能采取之前的分治法，因为这里要求构建的二叉树应该完全和序列化的相同。可以有下面这个思路：</li>
<li>设置一个指针，依次从前到后走遍序列化的每一项</li>
<li>如果当前指向的值是 null，那么就返回 null，让指针+1</li>
<li>如果不是 null，创建节点，左右子节点分别是继续递归的返回值。<br>这个思路中，节点的选择依赖于指针。每次递归都会使指针向前走一项，因此按照先序遍历的特点，按顺序一定是<code>根-&gt;左-&gt;右</code>的顺序，恰好可以构建</li>
</ol>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="keyword">var</span> serialize = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> nodes = [];</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">      nodes.push(<span class="string">&quot;null&quot;</span>); <span class="comment">// 注意这里每个null都要输出</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nodes.push(node.val);</span><br><span class="line">    dfs(node.left);</span><br><span class="line">    dfs(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(root);</span><br><span class="line">  <span class="keyword">return</span> nodes.join(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="keyword">var</span> deserialize = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> nodes = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 不需要参数，每走一步p++，相当于取到下一个应该的位置上去</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">traverse</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes[p] === <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">      p++;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> TreeNode(nodes[p++]);</span><br><span class="line">    node.left = traverse();</span><br><span class="line">    node.right = traverse();</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> traverse();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这道题关键是反序列化的思路，如何从一个先序遍历得到的数组还原二叉树</p>
<h2 id="不同的二叉搜索树-II"><a href="#不同的二叉搜索树-II" class="headerlink" title="不同的二叉搜索树 II"></a>不同的二叉搜索树 II</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">https://leetcode.cn/problems/unique-binary-search-trees-ii/</a></p>
<p>这道题的前置问题 不同的二叉搜索树 在动态规划部分，其中第二种解法稍微改一改就可以得到这道题的解。</p>
<p>一样的思路，设<code>dfs(left,right)</code>返回一个数组，数组的每一项都是节点数量为<code>right-left</code>时可能的子树（就是具体的子树）。在每个递归内部都设置一个 i 从 left 到 right 遍历，分别得到左右子树的结果数组，然后二重循环这两个数组，得到的左右子树的所有组合就是当前 left 和 right 下的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> generateTrees = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> [<span class="literal">null</span>];</span><br><span class="line">    <span class="keyword">const</span> trees = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> leftNodes = dfs(left, i - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">const</span> rightNodes = dfs(i + <span class="number">1</span>, right);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> left <span class="keyword">of</span> leftNodes) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> right <span class="keyword">of</span> rightNodes) &#123;</span><br><span class="line">          <span class="keyword">const</span> node = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">          node.left = left;</span><br><span class="line">          node.right = right;</span><br><span class="line">          trees.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> trees;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dfs(<span class="number">1</span>, n);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="回溯问题的基本思路"><a href="#回溯问题的基本思路" class="headerlink" title="回溯问题的基本思路"></a>回溯问题的基本思路</h2><blockquote>
<p>回溯问题常见于题目中这样要求：找出所有情况、找出所有排列组合、遍历所有情况、走过所有格子等等。</p>
</blockquote>
<p>参考<br><a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB%E5%A4%A7%E7%BA%B2%E5%A6%82%E4%B8%8B">https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB%E5%A4%A7%E7%BA%B2%E5%A6%82%E4%B8%8B</a></p>
<p>上面的回溯说到回溯问题的基本模板是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xxx</span>(<span class="params">入参</span>) </span>&#123;</span><br><span class="line">  前期的变量定义、缓存等准备工作</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义路径栈</span></span><br><span class="line">  <span class="keyword">const</span> path = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进入 dfs</span></span><br><span class="line">  dfs(起点)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义 dfs</span></span><br><span class="line">  <span class="function"><span class="title">dfs</span>(<span class="params">递归参数</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(到达了递归边界) &#123;</span><br><span class="line">      结合题意处理边界逻辑，往往和 path 内容有关</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里也可能不是for，如果是两三个明确的情况 ，直接递归也有可能，视题意决定</span></span><br><span class="line">    <span class="keyword">for</span>(遍历坑位的可选值) &#123;</span><br><span class="line">      path.push(当前选中值)</span><br><span class="line">      dfs(添加一些改变的参数)</span><br><span class="line">      path.pop()<span class="comment">// 这里让已经选中的值退出，相当于树回退一层</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上这并不是一种生硬的模板，而是对应了回溯问题的基本形状：<strong>迭代表示同一层的横向展开，递归表示纵向的遍历</strong></p>
<p>根据前面 dfs 的经验，我们把递归只看成是一个简单的访问语句：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">dfs</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  递归边界</span><br><span class="line">  <span class="keyword">for</span>(i)&#123;</span><br><span class="line">    path.push(当前选中值)</span><br><span class="line">    访问第(i+<span class="number">1</span>)个</span><br><span class="line">    path.pop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，迭代的部分实际上就是将所有情况横向展开，也就是<strong>树的分叉</strong>；迭代几次也就对应根节点展开了几个枝；这也是通过限制迭代次数从而避免重复的原因。</p>
<blockquote>
<p><img src="https://pic.imgdb.cn/item/626a9a55239250f7c5e9286e.jpg"><br>迭代实际上就是这部分</p>
</blockquote>
<p>而递归则是<strong>纵向</strong>的延伸；和二叉树问题类似，递归的每一项可以看作是一个子节点的产生，而递归语句旁边的<code>path.push</code>和<code>path.pop</code>操作也正是对应了递归路径的记录和回溯。回溯的关键并不是循环，而是结尾的<code>pop()</code>，也就是状态的恢复；</p>
<p>理解了这两个地方，就可以理解各种其他问题中<strong>去重</strong>的方式和原因。</p>
<h3 id="去重方法的选择"><a href="#去重方法的选择" class="headerlink" title="去重方法的选择"></a>去重方法的选择</h3><p>首先，根据回溯问题的类型不同，去重的选择也不一样。大致分为四种类型的回溯：</p>
<ol>
<li><strong>组合问题</strong>。<br>组合问题的特点是顺序不同的序列不能重复出现，即不能出现<code>[1,2]</code>和<code>[2,1]</code>这样“回头”的情况。因此，组合问题基本上都需要利用 begin 限制起始位置保证去重，即方法 1；<br>具体来说，分为以下几种情况（都要求不能有重复组合）：</li>
</ol>
<ul>
<li>从一个集合中选组合，且集合没有重复元素：最基本的情况，begin 去重即可。</li>
<li>从一个集合中选组合，但集合有重复元素：给数组排序，并用第三种去重。</li>
<li>从一个集合中选组合，集合没有重复元素，但一个元素可以用多次：每次递归传 i 而不是 i+1，这样就可以一直用一个数。</li>
<li>从多个集合中选组合：不能用 begin，起始必须是 0，每层选取的集合要重新计算（每层不一样）</li>
</ul>
<ol start="2">
<li><strong>分割问题</strong>。<br>分割问题不需要去重，核心思想是分割出来的部分符合条件之后，把分割之后的再传下去继续分割。</li>
<li><strong>子集问题</strong>。<br>子集和组合是一类问题，去重方式是一样的。只是子集需要对每个节点都统计。<br>子集问题的集合内部如果没有重复元素，那子集之间一定不会重复。反之，就需要第三种方法去重。<br>另外子集问题有一类特殊的题，即子序列问题。这种要求数组不能排序，但是又要使用第三种方法去重；方法是每层创建一个 used 数组记录本层的重复情况，用 used 数组代替<code>visited[i-1]</code>即可。（参考递增子序列）</li>
<li><strong>排列问题</strong>。<br>排列问题元素顺序可以改变，因此不能通过 begin 限制起始，而要使用 visited 限制<strong>同一颗树下</strong>的元素不会纵向重复。如果排列问题的内部元素有重复但是总体不能有重复（比如允许<code>[1,2,2]</code>但不允许出现两个<code>[1,2,2]</code>），就也要考虑最后一种去重方法。<br>排列问题的分类：</li>
</ol>
<ul>
<li>从一个集合中选排列，且集合没有重复元素：最基本的情况，用 visited 去重保证一个元素不被使用多次即可。</li>
<li>从一个集合中选排列，但集合有重复元素：给数组排序，并用第三种去重；注意要同时使用第三种和 visited</li>
<li>从一个集合中选排列，集合没有重复元素，但一个元素可以用多次：去掉 visited 数组限制即可</li>
</ul>
<h3 id="去重的几种方法"><a href="#去重的几种方法" class="headerlink" title="去重的几种方法"></a>去重的几种方法</h3><ol>
<li><p>所选序列是否重复按照出现次数区分，即不希望“回头”，即不能出现<code>[1,2]</code>和<code>[2,1]</code>这样“回头”的情况。<br>这种通常限制迭代的<strong>起始位置</strong>。比如说组合问题 I，从数组<code>[1,2,3,4]</code>中选择 2 之后，就不希望再回头到 1 了，而是只从 3、4 以及之后的数中选。<br><img src="https://img-blog.csdnimg.cn/20201123195223940.png"></p>
<p><strong>对于组合问题</strong>（排列和子集问题有特殊情况），这种方式一般是针对<strong>同一个集合</strong>内部取值的情况。如果像电话号码的字母组合那道题这种不同集合中取值的，就不需要。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">val, begin</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//递归边界</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = begin; i &lt; xxx.length; i++) &#123;</span><br><span class="line">    path.push();</span><br><span class="line">    dfs(val, i + <span class="number">1</span>); <span class="comment">// i作为下一个的begin</span></span><br><span class="line">    path.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>纵向不能重复；限制同一结果中元素出现个数，比如全排列问题，不允许一个元素使用多次。<br>每次迭代到一个元素时，如果该元素已经被记录访问过，就会跳到下一个元素。注意这种方法是去重<strong>垂直</strong>方向的，即 visited 数组横向独立、纵向统一。<br>这种方法只适用于排列问题；</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//递归边界</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; xxx.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">      path.push();</span><br><span class="line">      visited[i] = <span class="literal">true</span>;</span><br><span class="line">      dfs(val); <span class="comment">// i作为下一个的begin</span></span><br><span class="line">      path.pop();</span><br><span class="line">      visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>横向不能重复，限制所有结果中相同值的重复，即不能有<code>[[1,2,2],[1,2,2]]</code>这样两个相同的元素，但是元素内部仍然可以重复。</li>
</ol>
<p>判断方法条件为：<code>nums[i] === nums[i - 1]</code>和<code>i &gt; 0</code>，以及<code>visited[nums[i - 1]] === false</code>，满足这三个条件时就应当跳过。</p>
<ul>
<li><code>nums[i] === nums[i - 1]</code>：当前值和前一个不能相同，即横向规定不能有重复值</li>
<li><code>visited[nums[i - 1]] === false</code>：这个很重要，是判断上一个条件是横向重复还是纵向重复；因为上一个条件既有可能是横向重复，也可以是纵向的重复；因此当这个条件为 true 时，即上一个值已经被访问过了，说明是纵向重复；反之则是横向重复。<strong>该条件===true 判断纵向重复，==false 判断横向重复</strong></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/626ab4ee239250f7c5375bd0.jpg"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">//！！！一定要先排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//递归边界</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; xxx.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 注意visited应该存的是序号！！！</span></span><br><span class="line">    <span class="keyword">if</span> (!visited[i - <span class="number">1</span>] &amp;&amp; nums[i] === nums[i - <span class="number">1</span>] &amp;&amp; i &gt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">      <span class="comment">// 如果是排列问题，就还需要这个判断</span></span><br><span class="line">      visited[i] = <span class="literal">true</span>;</span><br><span class="line">      dfs(val); <span class="comment">// i作为下一个的begin</span></span><br><span class="line">      path.pop();</span><br><span class="line">      visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者综合第一种 begin 的方式；当<code>i &gt; begin</code>时，相当于当前遍历的位置是其他同层元素，和<code>visited[nums[i - 1]] === false</code>效果相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; begin &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意第三种去重方法判断的前提是数组<strong>必须有序</strong>。如果无序的情况下，就不能用<code>nums[i] === nums[i - 1]</code>这种形式了，因为相同是数肯定不相邻<br>所以应该采用一个<strong>每次递归（也就是每一层）都会更新的 set</strong>，用 set 存储本层的重复数字，然后判断<code>set.has()</code>就可以。参考下面的递增子序列题目</p>
</blockquote>
<h3 id="特殊回溯问题"><a href="#特殊回溯问题" class="headerlink" title="特殊回溯问题"></a>特殊回溯问题</h3><p>回溯问题的模板不一定都是递归+迭代这种类型的。有些情况下并不需要迭代。<br>迭代的核心目标是<strong>把所有情况都放入递归中执行一次</strong>，以达到遍历所有情况的目的；当一个回溯问题只有少数几种（通常是两种）情况时，就不需要迭代来遍历了。同样，如果递归的情况不能通过迭代线性展开（比如岛屿问题），也不需要。<br>总之回溯问题的核心部分其实还是<strong>递归</strong>和<strong>状态恢复</strong>，其他的地方都是在为这两个核心提供帮助。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">...</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(...) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 状态改变</span></span><br><span class="line">  <span class="keyword">if</span>(...) dfs(...)</span><br><span class="line">  <span class="keyword">else</span> dfs(...)</span><br><span class="line">  <span class="comment">// 状态恢复</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h2><h3 id="基本全排列"><a href="#基本全排列" class="headerlink" title="基本全排列"></a>基本全排列</h3><blockquote>
<p>给定一个没有重复数字的序列，返回其所有可能的全排列。<br>示例：<br>输入: [1,2,3]<br>输出: [<br>[1,2,3],<br>[1,3,2],<br>[2,1,3],<br>[2,3,1],<br>[3,1,2],<br>[3,2,1]<br>]</p>
</blockquote>
<p>像全排列这样的穷举，或者有一定限制的穷举，都可以用 DFS、递归回溯的思想。</p>
<p>这类问题的特点都是，穷举之中有不变化的部分；比如全排列问题不变的是三个数字的位置。三个位置可能是 1/2/3 任意一个数字，这样就可以构建出一个树：<br><img src="https://pic.imgdb.cn/item/6266c1cc239250f7c554635b.jpg"></p>
<p>然后按照树的先序遍历方式，就可以得到结果。当然并不需要构造一棵树。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> permute = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存数组的长度</span></span><br><span class="line">  <span class="keyword">const</span> len = nums.length;</span><br><span class="line">  <span class="comment">// curr 变量用来记录当前的排列内容</span></span><br><span class="line">  <span class="keyword">const</span> curr = [];</span><br><span class="line">  <span class="comment">// res 用来记录所有的排列顺序</span></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="comment">// visited 用来避免重复使用同一个数字</span></span><br><span class="line">  <span class="keyword">const</span> visited = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 定义 dfs 函数，入参是坑位的索引（从 0 计数）</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">nth</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 若遍历到了不存在的坑位（第 len+1 个），则触碰递归边界返回</span></span><br><span class="line">    <span class="keyword">if</span> (nth === len) &#123;</span><br><span class="line">      <span class="comment">// 此时前 len 个坑位已经填满，将对应的排列记录下来</span></span><br><span class="line">      res.push(curr.slice());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查手里剩下的数字有哪些</span></span><br><span class="line">    <span class="comment">// 循环套递归是常见的形式,循环的作用就是让DFS过程能&quot;返回&quot;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="comment">// 若 nums[i] 之前没被其它坑位用过，则可以理解为“这个数字剩下了”</span></span><br><span class="line">      <span class="keyword">if</span> (!visited[nums[i]]) &#123;</span><br><span class="line">        <span class="comment">// 给 nums[i] 打个“已用过”的标</span></span><br><span class="line">        visited[nums[i]] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 将nums[i]推入当前排列</span></span><br><span class="line">        curr.push(nums[i]);</span><br><span class="line">        <span class="comment">// 基于这个排列继续往下一个坑走去</span></span><br><span class="line">        dfs(nth + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// nums[i]让出当前坑位</span></span><br><span class="line">        curr.pop();</span><br><span class="line">        <span class="comment">// 下掉“已用过”标识</span></span><br><span class="line">        visited[nums[i]] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从索引为 0 的坑位（也就是第一个坑位）开始 dfs</span></span><br><span class="line">  dfs(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码很奇怪的地方是有一个“循环套递归”，并且递归的前后恰好是入栈、出栈结果的时候。</p>
<p>其实这正是这类题的“模板解法”。在递归产生的不同函数上下文中，每个的遍历次数不同。<br>以这道题为例，当 dfs 执行到第三个时，前两个的上下文的遍历次数分别是 1、2；这时当第三个返回时，上一个的循环还会执行一次，就相当于从树的底部“退回”了一个位置，并把 3 这个数字让了出来。</p>
<p>因此这类穷举相关的题目有一个通用模板，遇到这种问题可以先试着套一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xxx</span>(<span class="params">入参</span>) </span>&#123;</span><br><span class="line">  前期的变量定义、缓存等准备工作</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义路径栈</span></span><br><span class="line">  <span class="keyword">const</span> path = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进入 dfs</span></span><br><span class="line">  dfs(起点)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义 dfs</span></span><br><span class="line">  <span class="function"><span class="title">dfs</span>(<span class="params">递归参数</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(到达了递归边界) &#123;</span><br><span class="line">      结合题意处理边界逻辑，往往和 path 内容有关</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里也可能不是 for，视题意决定</span></span><br><span class="line">    <span class="keyword">for</span>(遍历坑位的可选值) &#123;</span><br><span class="line">      path.push(当前选中值)</span><br><span class="line">      处理坑位本身的相关逻辑,一般就是递归</span><br><span class="line">      path.pop()<span class="comment">// 这里让已经选中的值退出，相当于树回退一层</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全排列-2（剪枝）"><a href="#全排列-2（剪枝）" class="headerlink" title="全排列 2（剪枝）"></a>全排列 2（剪枝）</h3><blockquote>
<p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。<br>示例 1：<br>输入：nums = [1,1,2]<br>输出：<br>[[1,1,2],<br>[1,2,1],<br>[2,1,1]]</p>
</blockquote>
<p>这个题和全排列 1 的区别在于，每个结果允许数组内的数字重复，即给定的 nums 中有重复的数字。<br>因此这是一个横向剪枝的问题，即在保证一个数字不会纵向重复的情况下，进行横向剪枝去掉可能重复的组合。<br><img src="https://pic.imgdb.cn/item/628108d109475431293e2fd6.png"></p>
<p>利用上面说的去重的第三种方法即可。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permuteUnique = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> curr = []; <span class="comment">// 当前排列</span></span><br><span class="line">  <span class="keyword">const</span> res = []; <span class="comment">// 结果数组</span></span><br><span class="line">  <span class="keyword">const</span> visit = &#123;&#125;;</span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">  dfs(<span class="number">0</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index === nums.length) &#123;</span><br><span class="line">      res.push([...curr]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>] &amp;&amp; !visit[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (!visit[i]) &#123;</span><br><span class="line">        visit[i] = <span class="literal">true</span>;</span><br><span class="line">        curr.push(nums[i]);</span><br><span class="line">        dfs(index + <span class="number">1</span>);</span><br><span class="line">        curr.pop();</span><br><span class="line">        visit[i] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><h3 id="基本组合问题"><a href="#基本组合问题" class="headerlink" title="基本组合问题"></a>基本组合问题</h3><blockquote>
<p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。<br>示例:<br>输入: n = 4, k = 2<br>输出:<br>[<br>[2,4],<br>[3,4],<br>[2,3],<br>[1,2],<br>[1,3],<br>[1,4],<br>]</p>
</blockquote>
<p>最基本的组合问题，当递归次数等于 k 时记录即可。<br>因为同一个位置上的数字不能用多次，因此需要纵向剪枝；并且同样开头的数字也只能统计一次，所以需要起始序号剪枝。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combine = <span class="function"><span class="keyword">function</span> (<span class="params">n, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> curr = [];</span><br><span class="line">  <span class="keyword">const</span> nums = [];</span><br><span class="line">  <span class="keyword">const</span> visit = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// 创建数组</span></span><br><span class="line">    nums[i] = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> times = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">nth, begin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nth === k) &#123;</span><br><span class="line">      res.push([...curr]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = begin; i &lt; nums.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!visit[i]) &#123;</span><br><span class="line">        curr.push(nums[i]);</span><br><span class="line">        visit[i] = <span class="literal">true</span>;</span><br><span class="line">        times++;</span><br><span class="line">        dfs(times, i);</span><br><span class="line">        times--;</span><br><span class="line">        visit[i] = <span class="literal">false</span>;</span><br><span class="line">        curr.pop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h3><blockquote>
<p>给你一个 无重复元素 的整数数组  candidates 和一个目标整数  target ，找出 candidates  中可以使数字和为目标数  target 的 所有   不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。<br>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p>
</blockquote>
<p>基本组合问题，设定一个 sum 变量每次传入，每次加上当前值，当 sum 值等于 target 时记录。</p>
<p>因为同一个数可以选多次，因此纵向不需要剪枝，只需要起始序号剪枝即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">candidates</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combinationSum = <span class="function"><span class="keyword">function</span> (<span class="params">candidates, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> curr = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">sum, begin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">      res.push([...curr]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = begin; i &lt; candidates.length; i++) &#123;</span><br><span class="line">      curr.push(candidates[i]);</span><br><span class="line">      sum += candidates[i];</span><br><span class="line">      dfs(sum, i);</span><br><span class="line">      sum -= candidates[i];</span><br><span class="line">      curr.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="组合总和-2"><a href="#组合总和-2" class="headerlink" title="组合总和 2"></a>组合总和 2</h3><blockquote>
<p>给定一个候选人编号的集合  candidates  和一个目标数  target ，找出  candidates  中所有可以使数字和为  target  的组合。<br>candidates  中的每个数字在每个组合中只能使用   一次  。解集不能包含重复的组合。</p>
</blockquote>
<p>显然和上一个的区别在于每个数字在每个组合中只能使用一次，但是每个组合中允许重复数字，最终结果不允许有重复组合；</p>
<p>因此使用第三种剪枝就可以</p>
<p>这道题有一个特殊的解法，就是使用一个 prev 变量保存前一个的值；如果前一个值和当前<code>candidates[i]</code>相等，就直接跳过。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">candidates</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combinationSum2 = <span class="function"><span class="keyword">function</span> (<span class="params">candidates, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> curr = [];</span><br><span class="line">  <span class="keyword">const</span> visited = &#123;&#125;;</span><br><span class="line">  candidates.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">sum, begin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">      res.push([...curr]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> prev = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = begin; i &lt; candidates.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (candidates[i] === prev) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//这里使用第三种剪枝也可以</span></span><br><span class="line">      <span class="comment">// if (candidates[i] === candidates[i-1] &amp;&amp; i &gt; begin &amp;&amp; !visited[i - 1]) continue</span></span><br><span class="line">      <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">        visited[i] = <span class="literal">true</span>;</span><br><span class="line">        curr.push(candidates[i]);</span><br><span class="line">        sum += candidates[i];</span><br><span class="line">        prev = candidates[i];</span><br><span class="line">        dfs(sum, i);</span><br><span class="line">        sum -= candidates[i];</span><br><span class="line">        curr.pop();</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/</a></p>
<blockquote>
<p>给定一个仅包含数字  2-9  的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br>示例 1：<br>输入：digits = “23”<br>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]</p>
</blockquote>
<p>这道题和前面的题有一点不一样的地方，主要在于每层取值取的是不同集合中的元素。<br>前面的大多数组合、排列问题都是在一个数组中进行的，因此取值只用考虑遍历这一个数组即可；但是这道题每次都应该是取下一个字符串中的任意值。所以思路需要变通一下：</p>
<ol>
<li>设定数字到字母的映射关系</li>
<li>每次回溯根据数字的第 i 个，确定本次要遍历的字符串；比如示例的 23，相当于先遍历 abc，再遍历 def。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">digits</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> letterCombinations = <span class="function"><span class="keyword">function</span> (<span class="params">digits</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (digits === <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">const</span> dic = [</span><br><span class="line">    <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;def&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">    <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">    <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">    <span class="string">&quot;wxyz&quot;</span>,</span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">if</span> (digits.length === <span class="number">1</span>) <span class="keyword">return</span> dic[+digits].split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> path = [];</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">idx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idx === digits.length) &#123;</span><br><span class="line">      res.push(path.join(<span class="string">&quot;&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> str = dic[digits[idx]]; <span class="comment">// 关键在这一步，每层的遍历对象不是同一个集合</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line">      path.push(s);</span><br><span class="line">      dfs(idx + <span class="number">1</span>);</span><br><span class="line">      path.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h2><h3 id="基本子集问题"><a href="#基本子集问题" class="headerlink" title="基本子集问题"></a>基本子集问题</h3><blockquote>
<p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的不重复子集</p>
</blockquote>
<p>首先先按照树形思维构建；这道题中不变的部分是是否选中某个数字。</p>
<p>比如选中 1、不选 2、选中 3，那么结果就是[1,3]，依次类推就是所有选择。树的两个叶子分别代表选或不选该层对应的数字，每一层恰好就是这个数字。</p>
<p><img src="https://pic.imgdb.cn/item/6266c73d239250f7c5647e11.jpg"></p>
<p>按照上面的模板，可以尝试构建如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> subsets = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ans = [];</span><br><span class="line">  <span class="keyword">const</span> curr = [];</span><br><span class="line"></span><br><span class="line">  dfs(<span class="number">0</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 每次进入，都意味着组合内容更新了一次，故直接推入结果数组</span></span><br><span class="line">    ans.push(curr.slice());</span><br><span class="line">    <span class="comment">// 从当前数字的索引开始，遍历 nums</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 这是当前数字存在于组合中的情况</span></span><br><span class="line">      curr.push(nums[i]);</span><br><span class="line">      <span class="comment">// 基于当前数字存在于组合中的情况，进一步 dfs</span></span><br><span class="line">      dfs(i + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 这是当前数字不存在与组合中的情况</span></span><br><span class="line">      curr.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意这道题虽然有显式的递归边界（遍历三层），但是其实并不需要，因为循环直接从当前的 index（即树的层数）开始，跳过了前面的情况。</p>
<p>如果我们再给这个解法显式加上一个递归条件，比如规定<code>curr.length &lt; k</code>，这就是一种“回溯”，即到达某种情况后就提前返回，并不是每次都遍历完。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> combine = <span class="function"><span class="keyword">function</span> (<span class="params">n, k</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化结果数组</span></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="comment">// 初始化组合数组</span></span><br><span class="line">  <span class="keyword">const</span> subset = [];</span><br><span class="line">  <span class="comment">// 进入 dfs，起始数字是1</span></span><br><span class="line">  dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义 dfs 函数，入参是当前遍历到的数字</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (subset.length === k) &#123;</span><br><span class="line">      res.push(subset.slice());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从当前数字的值开始，遍历 index-n 之间的所有数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="comment">// 这是当前数字存在于组合中的情况</span></span><br><span class="line">      subset.push(i);</span><br><span class="line">      <span class="comment">// 基于当前数字存在于组合中的情况，进一步 dfs</span></span><br><span class="line">      dfs(i + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 这是当前数字不存在与组合中的情况</span></span><br><span class="line">      subset.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回结果数组</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h3><blockquote>
<p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是 2。<br>示例:</p>
<p>输入: [4, 6, 7, 7]<br>输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</p>
</blockquote>
<p>这道题有两个关键点：</p>
<ol>
<li>数组不能排序，所以不能直接使用第三种去重，需要用一个每层都会更新的 set 去重；</li>
<li>要求必须是递增序列，所以可以让元素大于 path 的最后一个元素时才继续，否则之间跳过。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findSubsequences = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> path = [];</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">nth</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path.length &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">      res.push([...path]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nth &gt;= nums.length) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = nth; i &lt; nums.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; set.has(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (path.length &gt;= <span class="number">1</span> &amp;&amp; nums[i] &lt; path[path.length - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">      set.add(nums[i]);</span><br><span class="line">      path.push(nums[i]);</span><br><span class="line">      dfs(i + <span class="number">1</span>);</span><br><span class="line">      path.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="划分-K-个相等的子集"><a href="#划分-K-个相等的子集" class="headerlink" title="划分 K 个相等的子集"></a>划分 K 个相等的子集</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/">https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/</a></p>
<blockquote>
<p>给定一个整数数组   nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。<br>示例 1：<br>输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4<br>输出： True<br>说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。</p>
</blockquote>
<p>这道题可以站在两个角度思考，即站在每个数字上，或者每个要放数字的桶上（即 k 个桶，要放进去数字）。</p>
<ul>
<li>对于每个数字，可能放进任何一个桶中。那么就应该遍历数组中的数字，尝试放到每个桶中；<ul>
<li>如果当前这个数字加上桶内的值超过了 sum/k，就跳过这个桶找下一个</li>
<li>如果没超过，就加上这个数字，然后遍历下一个数字<br>最后当所有数字都遍历完之后，检查是否每个桶的和都是 sum/k 即可。<br>因此这种思路下应该在外层递归遍历数字，内层循环遍历每个桶。因为每个数字都需要从第一个桶开始尝试，所以不存在数字重复的问题，即不需要去重等操作</li>
</ul>
</li>
<li>对于每个桶，需要遍历 nums 中的所有数字，决定是否把当前数字装进桶中；当装满一个桶之后，还要装下一个桶，直到所有桶都装满为止。<ul>
<li>如果当前数字加上桶内和小于 sum/k，就加上该数字，然后递归下一个桶</li>
<li>如果超过 sum/k 就继续找下一个数字<br>即递归遍历每个桶，循环遍历每个数字。这时就要考虑数字的重复情况了。对于数组中的数字（某个位置），一旦放入一个桶就一定不能再放入另一个桶，因此每次放入一个数字都要记录是否被选中。</li>
</ul>
</li>
</ul>
<p>这里给出第一种思路的解法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canPartitionKSubsets = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> sum = nums.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line">  <span class="keyword">const</span> target = sum / k;</span><br><span class="line">  <span class="keyword">const</span> buckets = <span class="keyword">new</span> <span class="built_in">Array</span>(k).fill(<span class="number">0</span>);</span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a); <span class="comment">// 排序能减少时间复杂度，尽可能让大的数先进入桶，这样会加快总体进度</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index === nums.length) &#123;</span><br><span class="line">      flag = buckets.reduce(</span><br><span class="line">        <span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre &amp;&amp; cur === target,</span><br><span class="line">        buckets[<span class="number">0</span>] === target</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (buckets[i] + nums[index] &gt; target) <span class="keyword">continue</span>;</span><br><span class="line">      buckets[i] += nums[index];</span><br><span class="line">      dfs(index + <span class="number">1</span>);</span><br><span class="line">      buckets[i] -= nums[index];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="分割问题"><a href="#分割问题" class="headerlink" title="分割问题"></a>分割问题</h2><p>分割问题是变种的回溯问题；常见回溯问题一般是记录路径，累加求值；但是分割问题通常是把字符串分割递归下去。<br>具体来说，分割问题的通常思路如下：</p>
<ol>
<li>在迭代中，从某一项开始取前 i 个字符</li>
<li>判断该字符是否符合要求</li>
</ol>
<ul>
<li>不符合，继续迭代</li>
<li>符合，把分割后剩下的串传递下去。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">str, times</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (临界条件) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> part = str.slice(<span class="number">0</span>, i);</span><br><span class="line">    <span class="keyword">if</span> (isValid(part)) &#123;</span><br><span class="line">      curr.push(part);</span><br><span class="line">      dfs(str.slice(i + <span class="number">1</span>)); <span class="comment">// 把分割后剩下的继续递归分割</span></span><br><span class="line">      curr.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于回溯分割和动态规划分割的区别：<br>回溯分割可以针对绝大多数分割情况，但是动态规划分割一般只能用于给定分割结果的统计。<br>比如给定一个字符串和要分割成的几个子串，可以把要分割的字串作为物品，每个字符作为背包容量计算，每次分割一部分字符串和子串匹配。</p>
</blockquote>
<h3 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h3><blockquote>
<p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。<br>返回 s 所有可能的分割方案。<br>示例: 输入: “aab” 输出: [ [“aa”,”b”], [“a”,”a”,”b”] ]</p>
</blockquote>
<p>思路：先切割子串，对每个子串判断回文，如果回文就记录。</p>
<p>关键是切割字串的方法。切割子串思路和回溯记录路径类似：</p>
<ol>
<li>遍历每一项，把整个子串先从头到最后一个切割</li>
<li>如果子串是回文串，就记录，并且把<strong>切割之后剩下的部分</strong>递归下去。<br>思路可以参考这张图：<br><img src="https://pic.imgdb.cn/item/6281198609475431297e2c6e.jpg"></li>
</ol>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> partition = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> curr = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> visit = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str === <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">      res.push([...curr]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> part = str.slice(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (isPalindrome(part)) &#123;</span><br><span class="line">        curr.push(part);</span><br><span class="line">        dfs(str.slice(i + <span class="number">1</span>));</span><br><span class="line">        curr.pop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dfs(s);</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> strArr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> j = strArr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (strArr[i] === strArr[j]) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="有效-ip-地址"><a href="#有效-ip-地址" class="headerlink" title="有效 ip 地址"></a>有效 ip 地址</h3><blockquote>
<p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。<br>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。<br>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#49;&#x39;&#50;&#46;&#49;&#x36;&#x38;&#64;&#49;&#46;&#49;">&#49;&#x39;&#50;&#46;&#49;&#x36;&#x38;&#64;&#49;&#46;&#49;</a>“ 是 无效的 IP 地址。<br>示例 1：<br>输入：s = “25525511135”<br>输出：[“255.255.11.135”,”255.255.111.35”]</p>
</blockquote>
<p>思路和分割回文串类似，先从头开始分割，如果分割到符合单个 IP 的情况，就存下来并把后面的继续递归。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> restoreIpAddresses = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> curr = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">str, times</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str === <span class="string">&quot;&quot;</span> &amp;&amp; times === <span class="number">4</span>) &#123;</span><br><span class="line">      res.push(curr.join(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> part = str.slice(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (times &gt;= <span class="number">4</span>) part = str.slice(i + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (isValid(part)) &#123;</span><br><span class="line">        curr.push(part);</span><br><span class="line">        times++;</span><br><span class="line">        dfs(str.slice(i + <span class="number">1</span>), times);</span><br><span class="line">        times--;</span><br><span class="line">        curr.pop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(s, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isValid</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      str !== <span class="string">&quot;&quot;</span> &amp;&amp;</span><br><span class="line">      <span class="built_in">Number</span>(str) &lt;= <span class="number">255</span> &amp;&amp;</span><br><span class="line">      <span class="built_in">Number</span>(str).toString().length === str.length</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="把数字翻译成字符串"><a href="#把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a>把数字翻译成字符串</h3><blockquote>
<p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。<br>示例 1:<br>输入: 12258<br>输出: 5<br>解释: 12258 有 5 种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi”</p>
</blockquote>
<p>一个分割问题，分割方法和回文串一样；关键在于分割之后的数字要小于 26 才能记录。<br>因为只需要知道次数，所以只需要记录次数就行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">num</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> translateNum = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> nums = num.toString();</span><br><span class="line">  <span class="keyword">if</span> (nums.length === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length === <span class="number">0</span>) &#123;</span><br><span class="line">      cnt++;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> part = str.slice(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> ((+part).toString().length !== part.length) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (+part &lt; <span class="number">26</span> &amp;&amp; +part &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        dfs(str.slice(i + <span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(nums);</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="岛屿问题"><a href="#岛屿问题" class="headerlink" title="岛屿问题"></a>岛屿问题</h2><p>岛屿问题有个有趣的思考方式，即对题目反过来分析。<br>比如求封闭岛屿数量，那就先求不封闭的数量，然后把不封闭的淹掉；求子岛屿的数量，那就先求不是子岛屿的数量，然后把不是子岛屿的淹掉。<br>总之题干如果条件不好直接用，就可以试着反过来，把反过来的去掉，就可以得到正的。</p>
<h3 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h3><blockquote>
<p>给你一个由  ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;character[][]&#125;</span> <span class="variable">grid</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numIslands = <span class="function"><span class="keyword">function</span> (<span class="params">grid</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> islands = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> m = grid[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">const</span> n = grid.length;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= n || j &gt;= m) <span class="keyword">return</span>; <span class="comment">// 超出边界</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] === <span class="string">&quot;0&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 遍历到的是0就回溯</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这道题的关键就在这里,遍历之后直接就把这一个变为0</span></span><br><span class="line">    <span class="comment">// 这样既完成了去重,同时下面统计岛屿数量时,遍历过的一整块都会变成&#x27;0&#x27;</span></span><br><span class="line">    grid[i][j] = <span class="string">&quot;0&quot;</span>;</span><br><span class="line"></span><br><span class="line">    dfs(i + <span class="number">1</span>, j);</span><br><span class="line">    dfs(i, j + <span class="number">1</span>);</span><br><span class="line">    dfs(i - <span class="number">1</span>, j);</span><br><span class="line">    dfs(i, j - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">      <span class="comment">// 从每个点开始执行一次递归</span></span><br><span class="line">      <span class="comment">// 因为遍历过的地方会置0，因此实际上只会调用 岛屿数量 次dfs</span></span><br><span class="line">      <span class="keyword">if</span> (grid[i][j] === <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">        dfs(i, j);</span><br><span class="line">        islands++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> islands;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="最大岛屿面积"><a href="#最大岛屿面积" class="headerlink" title="最大岛屿面积"></a>最大岛屿面积</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-area-of-island/">https://leetcode.cn/problems/max-area-of-island/</a></p>
<p>和上一道题类似</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">grid</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxAreaOfIsland = <span class="function"><span class="keyword">function</span> (<span class="params">grid</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> m = grid[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">const</span> n = grid.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= n || j &gt;= m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    grid[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里+1的方法类似二叉树计算深度的方法；遍历该点四周，并加上当前点的面积（就是1）</span></span><br><span class="line">    <span class="keyword">return</span> dfs(i + <span class="number">1</span>, j) + dfs(i, j + <span class="number">1</span>) + dfs(i - <span class="number">1</span>, j) + dfs(i, j - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (grid[i][j] === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> area = dfs(i, j);</span><br><span class="line">        max = max &gt; area ? max : area;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="封闭岛屿数量"><a href="#封闭岛屿数量" class="headerlink" title="封闭岛屿数量"></a>封闭岛屿数量</h3><blockquote>
<p>二维矩阵 grid  由 0 （土地）和 1 （水）组成。岛是由最大的 4 个方向连通的 0  组成的群，封闭岛是一个   完全 由 1 包围（左、上、右、下）的岛。<br>请返回 封闭岛屿 的数目。</p>
</blockquote>
<p>这道题其实就是岛屿数量的改动。封闭岛屿的数量 = 岛屿数量 - 靠边的岛屿数量，因此只要减去靠边岛屿，得到的剩下岛屿数量就是总岛屿数量。<br>实际上计算岛屿数量就是在“淹没”一个独立的岛屿，一次 dfs 执行完成之后，一块岛屿就被完全淹没了。因此可以选择把所有靠边的岛屿（grid[0][j]、grid[i][0]等）都淹没掉，再计算剩下的即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">grid</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> closedIsland = <span class="function"><span class="keyword">function</span> (<span class="params">grid</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> islands = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> m = grid[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">const</span> n = grid.length;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= n || j &gt;= m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[i][j] = <span class="number">1</span>;</span><br><span class="line">    dfs(i + <span class="number">1</span>, j);</span><br><span class="line">    dfs(i, j + <span class="number">1</span>);</span><br><span class="line">    dfs(i - <span class="number">1</span>, j);</span><br><span class="line">    dfs(i, j - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">    <span class="comment">// 淹掉上下边界</span></span><br><span class="line">    dfs(<span class="number">0</span>, j);</span><br><span class="line">    dfs(n - <span class="number">1</span>, j);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// 淹掉左右边界</span></span><br><span class="line">    dfs(i, <span class="number">0</span>);</span><br><span class="line">    dfs(i, m - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (grid[i][j] === <span class="number">0</span>) &#123;</span><br><span class="line">        dfs(i, j);</span><br><span class="line">        islands++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> islands;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/">https://leetcode.cn/problems/generate-parentheses/</a></p>
<blockquote>
<p>数字 n  代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。<br>示例 1：<br>输入：n = 3<br>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]</p>
</blockquote>
<blockquote>
<p>这道题第一眼看上去没想到用回溯，而是想到判断括号有效用到的栈。但是这种需要找到<strong>所有组合</strong>的题目，一般都是回溯。</p>
</blockquote>
<p>思路和上面的回溯有点不一样，递归的时候需要判断当前放入括号是否合理。关键就在于，怎么判断当前应该放入哪个括号。</p>
<ul>
<li>首先左括号和右括号各自的数量都不能大于 n</li>
<li>其次，为了右括号能和左括号匹配，右括号的数量不能大于左括号</li>
</ul>
<p>所以在回溯过程中，要记录左右括号的数量，满足上面的条件再加入。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> generateParenthesis = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">str, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length === <span class="number">2</span> * n) &#123;</span><br><span class="line">      res.push(str);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; n) dfs(str + <span class="string">&quot;(&quot;</span>, left + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">if</span> (right &lt; left) dfs(str + <span class="string">&quot;)&quot;</span>, left, right + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>这些算法没什么好说的，记就完事了。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bubbleSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j + <span class="number">1</span>] &lt; nums[j]) swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>冒泡排序的最优解,即时间复杂度 O(n)；<br>对应完全有序的情况，这时只需要遍历一次</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> betterBubbleSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j + <span class="number">1</span>] &lt; nums[j]) swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 如果发生一次交换就破功了</span></span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果一次都没有交换,说明数组有序,直接返回,这时只遍历了一次</span></span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span> nums;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>冒泡排序的复杂度：</p>
<ul>
<li>最好时间复杂度：它对应的是数组本身有序这种情况。在这种情况下，我们只需要作比较（n-1 次），而不需要做交换。时间复杂度为 O(n)</li>
<li>最坏时间复杂度： 它对应的是数组完全逆序这种情况。在这种情况下，每一轮内层循环都要执行，重复的总次数是 n(n-1)/2 次，因此时间复杂度是 O(n^2)</li>
<li>平均时间复杂度： O(n^2)</li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>循环遍历数组，每次都找出当前范围内的最小值，把它放在当前范围的头部；然后缩小排序范围，继续重复以上操作，直至数组完全有序为止。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selectionSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; arr.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">        minIndex = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, minIndex, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>选择排序的复杂度都是 O(n^2)</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序所有的操作都基于一个这样的前提：当前元素前面的序列是有序的。基于这个前提，从后往前去寻找当前元素在前面那个序列里的正确位置；</p>
<p>即把当前选中的元素和前面的依次比较，如果小于前面的元素，就把前面的元素往后移一位，直到大于前面元素为止。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insertionSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = i;</span><br><span class="line">    tmp = nums[i];</span><br><span class="line">    <span class="keyword">while</span> (tmp &lt; nums[j - <span class="number">1</span>] &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>最好时间复杂度：它对应的数组本身就有序这种情况。此时内层循环只走一次，整体复杂度取决于外层循环，时间复杂度就是一层循环对应的 O(n)。</li>
<li>最坏时间复杂度：它对应的是数组完全逆序这种情况。此时内层循环每次都要移动有序序列里的所有元素，因此时间复杂度对应的就是两层循环的 O(n^2)</li>
<li>平均时间复杂度：O(n^2)</li>
</ul>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>将数组拆分成两个部分，然后分别单独排序，最后合并。因此拆分过程实际上是类似二叉树的递归遍历，递归边界是数组只有一个元素的时候，直接返回该元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并两个有序数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeArr</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> newArr = [];</span><br><span class="line">  <span class="keyword">while</span> (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) &#123;</span><br><span class="line">    arr1[i] &lt; arr2[j] ? newArr.push(arr1[i++]) : newArr.push(arr2[j++]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [...newArr, i === arr1.length - <span class="number">1</span> ? arr2.slice(j) : arr1.slice(i)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mergeSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">  <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(nums.length / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> left = mergeSort(nums.slice(<span class="number">0</span>, mid));</span><br><span class="line">  <span class="keyword">const</span> right = mergeSort(nums.slice(mid));</span><br><span class="line">  <span class="keyword">return</span> mergeArr(left, right);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>归并排序的时间复杂度是 <code>O(nlog(n))</code></p>
<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>快速排序会将原始的数组筛选成较小和较大的两个子数组，然后递归地排序两个子数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> quickSort = <span class="function">(<span class="params">nums, left = <span class="number">0</span>, right = nums.length - <span class="number">1</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">  <span class="comment">// ！！！！！！！！！！！！！！</span></span><br><span class="line">  <span class="comment">// 注意这里不能只求一个序号！！！！！！！！！</span></span><br><span class="line">  <span class="comment">// 必须是得到具体的中间值，因为后面数组会变化，中间值如果是个序号会变，排序会出错！！！！！</span></span><br><span class="line">  <span class="comment">// 即必须是nums[Math.floor(left + (right - left) / 2)]</span></span><br><span class="line">  <span class="comment">// 不能只是Math.floor(left + (right - left) / 2)</span></span><br><span class="line">  <span class="keyword">let</span> divider = nums[<span class="built_in">Math</span>.floor(left + (right - left) / <span class="number">2</span>)];</span><br><span class="line">  <span class="keyword">let</span> i = left;</span><br><span class="line">  <span class="keyword">let</span> j = right;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (nums[i] &lt; divider) i++;</span><br><span class="line">    <span class="keyword">while</span> (nums[j] &gt; divider) j--;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">      swap(nums, i, j);</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (left &lt; i - <span class="number">1</span>) quickSort(nums, left, i - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (i &lt; right) quickSort(nums, i, right);</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>拆分一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left = <span class="number">0</span>, right = arr.length - <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> lineIndex = partition(arr, left, right);</span><br><span class="line">    <span class="keyword">if</span> (left &lt; lineIndex - <span class="number">1</span>) quickSort(arr, left, lineIndex - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (lineIndex &lt; right) quickSort(arr, lineIndex, right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> pivotValue = arr[<span class="built_in">Math</span>.floor(left + (right - left) / <span class="number">2</span>)];</span><br><span class="line">  <span class="keyword">let</span> i = left;</span><br><span class="line">  <span class="keyword">let</span> j = right;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[i] &lt; pivotValue) i++;</span><br><span class="line">    <span class="keyword">while</span> (arr[j] &gt; pivotValue) j--;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">      swap(arr, i, j);</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">  [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>partition 函数还有一种写法，个人感觉第二种写法更合适一点，对于下面的快速选择算法也能更好兼容：</p>
<p>这里 partition 函数先选择了最左边的数为基准（而非中间数），然后排序这个数右边的所有元素。最后再把这个元素放进顺序正确的位置即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortArray = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left = <span class="number">0</span>, right = arr.length - <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="keyword">const</span> p = partition(arr, left, right);</span><br><span class="line">      quickSort(arr, left, p - <span class="number">1</span>);</span><br><span class="line">      quickSort(arr, p + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pivotValue = arr[left];</span><br><span class="line">    <span class="keyword">let</span> i = left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> j = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">      <span class="keyword">while</span> (arr[i] &lt;= pivotValue &amp;&amp; i &lt; right) i++;</span><br><span class="line">      <span class="keyword">while</span> (arr[j] &gt; pivotValue &amp;&amp; j &gt; left) j--;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(arr, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, left, j);</span><br><span class="line">    <span class="comment">// 这里返回j是因为j会停在排好序的位置上，而i则会走过一位</span></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">    [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  quickSort(nums);</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>假设数组元素个数为 N，那么二叉树每一层的元素个数之和就是 O(N)；分界点分布均匀的理想情况下，树的层数为 O(logN)，所以理想的总时间复杂度为 O(NlogN)。<br><img src="https://pic.imgdb.cn/item/62dbac38f54cd3f937aa09b4.jpg"><br>如果数组极端情况（已经正序或倒序排序），也就是说每次选择的这个分区点无法将数组一分为二，每次得到的 p 都是 left+1，那么构成的二叉树就会很极端的单向延伸，即一共要走 N 层，并且每层都需要对 N、N-1、N-2…个数排序，即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">N + (N - 1) + (N - 2) + ... + 1 = O(N^2)</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/62dbac43f54cd3f937aa5108.jpg"></p>
<p>为了防止这种极端情况，应该考虑排序之前用洗牌算法把数组随机化一下，或者在 partition 开始选择 pivotValue 时选择随机的一个数</p>
<h2 id="TOP-K-问题"><a href="#TOP-K-问题" class="headerlink" title="TOP K 问题"></a>TOP K 问题</h2><blockquote>
<p>给你一个数组，求这个数组中的第 K 个最大元素。<br>需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
</blockquote>
<p>这道题的思路有好几种：</p>
<ol>
<li>利用大根堆，只要把堆的数据结构建立好，依次取 K 次就可以。但是问题在于 js 很难用大根堆<br>实际上就是一个数组，详细解释可以参考 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/xie-gei-qian-duan-tong-xue-de-ti-jie-yi-kt5p2/">https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/xie-gei-qian-duan-tong-xue-de-ti-jie-yi-kt5p2/</a></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">arr, i, j</span>) =&gt;</span> ([arr[i], arr[j]] = [arr[j], arr[i]]);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findKthLargest = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> size = nums.length;</span><br><span class="line">  buildMaxHeap(nums, size);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = nums.length - <span class="number">1</span>; i &gt;= nums.length - k + <span class="number">1</span>; i--) &#123;</span><br><span class="line">    swap(nums, <span class="number">0</span>, i);</span><br><span class="line">    size--;</span><br><span class="line">    heapify(nums, <span class="number">0</span>, size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buildMaxHeap</span>(<span class="params">nums, size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(size / <span class="number">2</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      heapify(nums, i, size);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">heapify</span>(<span class="params">nums, i, size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> mid = i;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; size &amp;&amp; nums[left] &gt; nums[mid]) &#123;</span><br><span class="line">      mid = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; size &amp;&amp; nums[right] &gt; nums[mid]) &#123;</span><br><span class="line">      mid = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mid !== i) &#123;</span><br><span class="line">      swap(nums, mid, i);</span><br><span class="line">      heapify(nums, mid, size);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>快速选择算法，即“快排的二分查找版本”。利用快排的 partition 函数，这个函数会确定一个元素的确定位置，并返回这个元素的正确位置。那么我们就可以这样：</li>
<li>先通过 partition 计算出一个位置 p，然后判断 p 和要找的 TopK 的 k 的大小关系。比如现在有 10 个元素，计算的 p=5，说明从小到大第 5 个元素已经排好位置；如果选择第二大的元素，那么 k=10-2=8，即从小到大第 8 个元素。这时<code>p&lt;k</code>，说明应该在 p 的右边继续查找</li>
<li>设置新的边界，类似二分查找一样，即<code>left=p+1</code>，或<code>right=p-1</code>，直到<code>p=n-k</code>为止。这个过程可以是递归，也可以是二分查找那样的循环</li>
</ol>
<p>代码如下：</p>
<blockquote>
<p>注意这里的 partition 应该选择第二种，第一种会在边界出现奇奇怪怪的 bug，不建议选</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findKthLargest = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> swap = <span class="function">(<span class="params">arr, i, j</span>) =&gt;</span> &#123;</span><br><span class="line">    [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pivotValue = arr[left];</span><br><span class="line">    <span class="keyword">let</span> i = left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> j = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">      <span class="keyword">while</span> (arr[i] &lt;= pivotValue &amp;&amp; i &lt; right) i++;</span><br><span class="line">      <span class="keyword">while</span> (arr[j] &gt; pivotValue &amp;&amp; j &gt; left) j--;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(arr, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, left, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">  k = nums.length - k;</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">const</span> p = partition(nums, left, right);</span><br><span class="line">    <span class="built_in">console</span>.log(p, nums);</span><br><span class="line">    <span class="keyword">if</span> (p === k) &#123;</span><br><span class="line">      <span class="keyword">return</span> nums[p];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p &lt; k) &#123;</span><br><span class="line">      left = p + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right = p - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote>
<p>动态规划（dynamic programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。<br>用动态规划解决问题时，要遵循三个重要步骤：</p>
<ol>
<li>定义子问题；</li>
<li>实现要反复执行来解决子问题的部分；</li>
<li>识别并求解出基线条件。</li>
</ol>
</blockquote>
<p>动态规划的题目有几个关键的特征：</p>
<ol>
<li>要求你给出达成某个目的的解法个数</li>
<li>不要求你给出每一种解法对应的具体路径</li>
<li>题目要求中有“最值”，即最优解；</li>
<li>一个解的得出依赖于前一个解，依次依赖迭代</li>
</ol>
<p>这样的问题，往往可以用动态规划进行求解</p>
<p>动态规划的题目可能很难理解，如果有实在理解不了的可以先记下来</p>
<h2 id="爬楼梯问题"><a href="#爬楼梯问题" class="headerlink" title="爬楼梯问题"></a>爬楼梯问题</h2><blockquote>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
</blockquote>
<p>倒着思考问题,如果要到达 n 阶的方法为<code>f(n)</code>种,从第 n 阶退一层的方法就是<code>f(n-1)</code>或<code>f(n-2)</code>种,即<code>f(n) = f(n-1) + f(n-2)</code> ,然后依次类推,直到<code>f(1)</code>和<code>f(2)</code>返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> climbStairs = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 树形思考问题,这里相当于两个子节点</span></span><br><span class="line">  <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面这个解法会有很多重复的,比如<code>f(n-2)</code>的下一层会包含<code>f(n-3)</code>,这个值可能被多次计算<br>可以考虑 Map 缓存计算过的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> climbStairsCached = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">return</span> climbStairs(n);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">climbStairs</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.has(n)) <span class="keyword">return</span> map.get(n);</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> res = climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">    map.set(n, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上这种在递归的过程中，不断保存已经计算出的结果，从而避免重复计算的手法，叫做记忆化搜索。</p>
<p>真正的动态规划，是一个自底向上的过程。它要求我们站在已知的角度，通过定位已知和未知之间的关系，一步一步向前推导，进而求解出未知的值。</p>
<p>由上面的关系，可以推出状态转移方程为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n-1) + f(n-2)</span><br><span class="line">且</span><br><span class="line">f(1) = 1</span><br><span class="line">f(2) = 2</span><br></pre></td></tr></table></figure>

<p>把这个方程放到循环中，就可以解出来了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> climbStairsDynamic = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> f = [];</span><br><span class="line">  f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  f[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt; n; i++) &#123;</span><br><span class="line">    f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此动态规划的关键就是推出状态转移方程，只要方程能得出，丢到迭代里边就可以计算了。</p>
<h2 id="跳跃问题"><a href="#跳跃问题" class="headerlink" title="跳跃问题"></a>跳跃问题</h2><h3 id="跳跃游戏-I"><a href="#跳跃游戏-I" class="headerlink" title="跳跃游戏 I"></a>跳跃游戏 I</h3><blockquote>
<p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个下标。</p>
</blockquote>
<p>这道题目本质上应该算是贪心解法，但是这里其实用动态规划也能解。<br>思路是这样：设<code>dp[i]</code>表示表示当前位置<code>i</code>能跳到的最远位置，dp[i]的变化有几种情况：</p>
<ol start="0">
<li>首先计算当前位置的序号+nums[i]值<code>maxLen</code>，表示从当前位置起跳，能到达的最远位置。但是该位置不一定可达，因此需要一些方法判断是否可达。</li>
<li>如果<code>maxLen</code>小于 dp[i-1]，说明当前位置能跳到的最远距离包括在前面的范围之内，不用更新。同理如果<code>maxLen</code>大于 dp[i-1]就应该更新</li>
<li>如果当前位置的序号 i 比 dp[i-1]大，说明该位置无法到达，直接返回 false</li>
<li>如果遍历完都没返回，就说明可达，返回 true</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> canJump = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(nums.length).fill(<span class="number">0</span>); <span class="comment">// dp[i]表示当前位置能跳到的最远位置</span></span><br><span class="line">  dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> maxLen = i + nums[i];</span><br><span class="line">    <span class="keyword">if</span> (i &gt; dp[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>], maxLen);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(dp);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="跳跃游戏-II"><a href="#跳跃游戏-II" class="headerlink" title="跳跃游戏 II"></a>跳跃游戏 II</h3><p>在上一题的基础上，假设一定可以达到最后位置，求最少跳跃次数。<br>我们可以利用上一题的结果。上一题其实告知了我们数组中的哪些元素可以到达某个位置的元素，即从开始向这个元素的位置遍历，当 dp[i] &gt;= i 时，其后的所有位置都可以经过一次跳跃到达该元素。因此在这些元素中遍历找出一个之前跳跃次数最小的，加 1 即可。<br>设 dp2[i]表示能到达 i 位置的最小跳跃次数，dp2[i]应该等于前面所有能一次跳到该位置的元素的 dp2 的最小值+1</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> jump = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(nums.length).fill(<span class="number">0</span>);</span><br><span class="line">  dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> maxLen = i + nums[i];</span><br><span class="line">    dp[i] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>], maxLen);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">  dp.forEach(<span class="function">(<span class="params">num, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= nums.length) start = i;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* line */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dp2 = <span class="keyword">new</span> <span class="built_in">Array</span>(nums.length).fill(<span class="number">0</span>); <span class="comment">// dp2[i]表示到达i的最小跳跃次数</span></span><br><span class="line">  dp2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> mindp2 = <span class="literal">Infinity</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dp[j] &lt; i) <span class="keyword">continue</span>; <span class="comment">// j位置的元素到达不了当前元素，不考虑</span></span><br><span class="line">      <span class="comment">// 注意上面是dp，即判断是否能到达；下面是真正迭代的dp2</span></span><br><span class="line">      mindp2 = <span class="built_in">Math</span>.min(mindp2, dp2[j]); <span class="comment">// 找到dp2的最小值，即跳跃次数的最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp2[i] = mindp2 + <span class="number">1</span>; <span class="comment">// 最少跳跃次数+1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(dp2);</span><br><span class="line">  <span class="keyword">return</span> dp2[dp2.length - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>还有一种贪心的思路，即每次跳跃的是当前能跳跃的范围内的那部分中，能到达最远的距离。<br>解释一下就是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[2,3,1,1,4]</span><br><span class="line"></span><br><span class="line">1. 从第一个数2开始，能到达的范围是后两个位置3和1。</span><br><span class="line">2. 计算每个位置的nums[j]+j，得到最大值。比如这里分别得到3+1=4 1+2=3，并且3&gt;0+2（即比当前已经覆盖的范围远），选择最大值3，也就是第二个位置作为下一个起跳点。</span><br><span class="line">3. 再从3跳，这时发现3 + 1 = 4 === arr.length-1，所以直接返回跳跃次数+1就可以到了</span><br><span class="line"></span><br><span class="line">第二步中最重要的是计算跳跃最大值，不只是nums[j]的值，还应该算上本来的位置。可能会有特殊情况即：</span><br><span class="line">范围内的每个位置的nums[j]+j都小于本来就已经覆盖的范围，那就直接跳到最后一个位置。比如[5,1,2,3,4]这个数组，显然第一步能覆盖的范围比后面的都远，那就直接跳到最后一个就可以了</span><br><span class="line">其他情况就是计算出最远能覆盖的范围的那个位置，再跳到那个位置即可</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jump = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.length === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> jumps = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; ) &#123;</span><br><span class="line">    <span class="keyword">const</span> end = i + nums[i];</span><br><span class="line">    <span class="keyword">if</span> (end &gt;= nums.length - <span class="number">1</span>) <span class="keyword">return</span> jumps + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> maxIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> maxEnd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt;= end; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j] + j &gt;= maxEnd) &#123;</span><br><span class="line">        maxEnd = nums[j] + j;</span><br><span class="line">        maxIndex = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxEnd &gt; end) i = maxIndex;</span><br><span class="line">    <span class="keyword">else</span> i = end;</span><br><span class="line">    jumps++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> jumps;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最少硬币找零"><a href="#最少硬币找零" class="headerlink" title="最少硬币找零"></a>最少硬币找零</h2><blockquote>
<p>给定不同面额的硬币 coins 和一个总金额 amount。<br>编写一个函数来计算可以凑成总金额所需的 最少 的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
</blockquote>
<p>站在已经凑成的角度上思考问题，如果从已经凑成的结果中取走一个硬币，就会有以下的情况：<br><img src="https://pic.imgdb.cn/item/626789ea239250f7c5c0b9d6.jpg"></p>
<p>借此可以推出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n表示amount，f(n)表示凑成n金额所需的最少硬币数量</span><br><span class="line"></span><br><span class="line">f(n) = Math.min(f(n-c1)+1,f(n-c2)+1,f(n-c3)+1......f(n-cn)+1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>放入循环：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getCoinsDynamic = <span class="function">(<span class="params">coins, amount</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> f = [];</span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">    f[i] = <span class="literal">Infinity</span>;</span><br><span class="line">    <span class="comment">// 这个循环相当于是 f[n] = Math.min(f(n-coin1),f(n-coin2),...,f(n-coinn))</span></span><br><span class="line">    <span class="comment">// 由于coin数量不确定,因此两两比较每个f(n)和f(n-coin)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> coin <span class="keyword">of</span> coins) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= coin) f[i] = <span class="built_in">Math</span>.min(f[i], f[i - coin] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (f[amount] === <span class="literal">Infinity</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> f[amount];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这道题实际上是一个完全背包问题。我们把 coins 看作物品价值，要凑成的 amount 看作是重量，即求 coins 的组合，使得凑得 amount 的数量最小。<br>可以设 dp[j]表示凑得 amount 的最小硬币个数，那么用一维数组表示的递推式就应该是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = min(dp[j], dp[j - coins[i]] + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>如果给这道题换一个问题，即问你要凑出 amount 的硬币有多少种，其实就是对上面式子的小改进</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] += dp[j - coins[i]];</span><br></pre></td></tr></table></figure>

<h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h2><blockquote>
<p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。<br>示例 :<br>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。<br>说明: 你可以假设 n 不小于 2 且不大于 58</p>
</blockquote>
<p>思路：对于一个数 i，可能的拆分方式有两种：</p>
<ol>
<li>从 j 到 i 遍历，即<code>j * (i - j)</code></li>
<li>因为<code>i - j</code>可能也能拆分（比如 6 可以再拆成 3*3），因此可能是<code>i - j</code>拆分的<code>最大乘积 * j</code></li>
</ol>
<p>状态转移方程：<br>设<code>dp[i]</code>表示数字 i 拆分得到的最大乘积</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = Math.max(dp[i - j] * j, j * (i - j))</span><br></pre></td></tr></table></figure>

<p>实际实现应该取 j 从 1 到 i 遍历得到的<code>dp[i]</code>最大值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> integerBreak = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = [];</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// dp[i]有两种情况,一种是拆分成两个数的,最大值为max(...[j * (i - j)]),即从1到i遍历j,计算拆分成两个数的最大值</span></span><br><span class="line">  <span class="comment">// 另一种情况是可能拆成多个数,即j * dp[i - j],即拆分i-j.</span></span><br><span class="line">  <span class="comment">// 这里不能拆分j,即不能dp[j] * dp[i - j],因为这样最少都是四个数相乘</span></span><br><span class="line">  <span class="comment">// dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      dp[i] = <span class="built_in">Math</span>.max(dp[i], (i - j) * j, dp[i - j] * j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">https://leetcode.cn/problems/unique-binary-search-trees/</a></p>
<blockquote>
<p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p>
</blockquote>
<p>这道题看着像是二叉树问题，但实际上是一道动态规划。写一个式子就懂了<br>设 dp[i]表示 n=i 时的二叉树个数，那么 dp[1]和 dp[2]应该很容易得出。<br>接下来是 dp[3]，dp[3]的二叉树可以<strong>根据头节点是哪个数</strong>分为这几种情况：</p>
<ul>
<li>元素 1 为头结点搜索树的数量 = 右子树有 2 个元素的搜索树数量 * 左子树有 0 个元素的搜索树数量</li>
<li>元素 2 为头结点搜索树的数量 = 右子树有 1 个元素的搜索树数量 * 左子树有 1 个元素的搜索树数量</li>
<li>元素 3 为头结点搜索树的数量 = 右子树有 0 个元素的搜索树数量 * 左子树有 2 个元素的搜索树数量<br><img src="https://img-blog.csdnimg.cn/20210107093129889.png"><br>所以得到了递推关系：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">3</span>] = dp[<span class="number">0</span>] * dp[<span class="number">2</span>] + dp[<span class="number">1</span>] * dp[<span class="number">1</span>] + dp[<span class="number">2</span>] * dp[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">dp[n] = dp[<span class="number">0</span>]*dp[n-<span class="number">1</span>] + dp[<span class="number">1</span>]*dp[n-<span class="number">2</span>] +...+dp[n-<span class="number">1</span>]*dp[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 那么对于每个n都是</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">  sum += dp[i-<span class="number">1</span>] * dp[n-i]</span><br><span class="line">&#125;</span><br><span class="line">dp[n] = sum</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还需要得到前面的每个n才能推出现在的n，因此要从dp[2]开始一直算到dp[n]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>;j &lt; i;j++)&#123;</span><br><span class="line">    sum += dp[j-<span class="number">1</span>] * dp[i-j]</span><br><span class="line">  &#125;</span><br><span class="line">  dp[n] = sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numTrees = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">1</span>);</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">      sum += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i] = sum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>还有一种思路，我认为是更适合二叉树问题的一种思路，就是用递归解决。并且这个思路也适用于这道题的 II 版。</p>
<p>还是秉持上面的思路，如果有一个五个节点的数组，那么定中间一个节点为根节点，剩下的部分有几种组合？</p>
<p><img src="https://pic.imgdb.cn/item/62db865ff54cd3f937b95c7d.jpg"></p>
<p>其实也就是[1,2]和[4,5]这两个组合的数量的积。那么就可以从第一个节点开始，分别选择每个节点作为中间节点，然后递归计算剩下的左右部分的组合数量，相乘即可得到。</p>
<p>设递归函数<code>dfs(left, right)</code>表示左子树大小为 left，右子树大小为 right 的树的种数。那么对于整个数组的一部分来说，显然以其中一个节点为根节点的树的数量应该等于<code>dfs(left, i - 1) * dfs(i + 1, right)</code>，其中 i 表示从 left 到 right 的一个数，即从 left 到 right 的区间中依次选一个作为根节点，然后全部加起来。</p>
<p>另外，这种思路不会出现重复导致数量增多的情况，因为同样长度的数组，left 和 right 不可能重复；而 left 和 right 重复的时候，数组长度又肯定不会一样。<br>但是仍然需要记录，否则会导致复杂度过高。显然当数组长度固定时，对应的树的数量应该是确定的。因此我们可以把该数组长度对应的树的数量记录下来，减少计算量。</p>
<blockquote>
<p>这么来想其实这道题和爬楼梯问题很像，只是爬楼梯只能走一步或两步；而这道题的两个子树数量可以任意组合。</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numTrees = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> visited = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(n), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="literal">null</span>));</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> trees = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (visited[left - <span class="number">1</span>][right - <span class="number">1</span>]) <span class="keyword">return</span> visited[left - <span class="number">1</span>][right - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">      trees += dfs(left, i - <span class="number">1</span>) * dfs(i + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    visited[left - <span class="number">1</span>][right - <span class="number">1</span>] = trees;</span><br><span class="line">    <span class="keyword">return</span> trees;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dfs(<span class="number">1</span>, n);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="不同路径问题"><a href="#不同路径问题" class="headerlink" title="不同路径问题"></a>不同路径问题</h2><blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？<br><img src="https://img-blog.csdnimg.cn/20210110174033215.png"></p>
</blockquote>
<p>机器人移动经过的是二维数组，因此对于每一个节点来说，必然会有水平和竖直两种方向上的两组路径，即只需要记录左边和上边来的路径数（因为是从左向右遍历，因此不需要统计右和下）<br><img src="https://pic.imgdb.cn/item/6273a6e40947543129d857e0.jpg"></p>
<p>因此设<code>dp[i][j]</code>为经过点<code>(i,j)</code>的路径最大值，并且该值一定是由其水平和竖直推出的，即<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code></p>
<p><img src="https://img-blog.csdnimg.cn/20201209113631392.png"></p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePaths = <span class="function"><span class="keyword">function</span> (<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(n), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(m));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; m - <span class="number">1</span>; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="下降路径最小和"><a href="#下降路径最小和" class="headerlink" title="下降路径最小和"></a>下降路径最小和</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-falling-path-sum/submissions/">https://leetcode.cn/problems/minimum-falling-path-sum/submissions/</a></p>
<blockquote>
<p>给你一个 n x n 的 方形 整数数组  matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。<br>下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。</p>
</blockquote>
<p>设 dp[i][j]表示位于[i][j]的元素最小下降路径和，显然等于上面一层相邻的三个元素之间的最小值的递推。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">matrix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minFallingPathSum = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="built_in">Array</span>.from(</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Array</span>(matrix.length),</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(matrix[<span class="number">0</span>].length)</span><br><span class="line">  );</span><br><span class="line">  dp[<span class="number">0</span>] = [...matrix[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">      dp[i][j] =</span><br><span class="line">        matrix[i][j] +</span><br><span class="line">        <span class="built_in">Math</span>.min(</span><br><span class="line">          dp[i - <span class="number">1</span>][j - <span class="number">1</span>] || <span class="literal">Infinity</span>,</span><br><span class="line">          dp[i - <span class="number">1</span>][j] || <span class="literal">Infinity</span>,</span><br><span class="line">          dp[i - <span class="number">1</span>][j + <span class="number">1</span>] || <span class="literal">Infinity</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.min(...dp[dp.length - <span class="number">1</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h2><blockquote>
<p>给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。<br>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
</blockquote>
<p><img src="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif"></p>
<p>这道题不是标准的动态规划题，但是可以用动态规划解。<br>思路是通过二维数组，设<code>dp[i][j]</code>为第 i 行、第 j 个数字的值，那么显然</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j] + dp[i - 1][j-1]</span><br></pre></td></tr></table></figure>

<p>然后每行计算的时候，都初始化行首和行尾的元素值为 1</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">numRows</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> generate = <span class="function"><span class="keyword">function</span> (<span class="params">numRows</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = [[<span class="number">1</span>]];</span><br><span class="line">  <span class="keyword">const</span> res = [...dp];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">    dp[i] = [];</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(dp[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="背包类问题"><a href="#背包类问题" class="headerlink" title="背包类问题"></a>背包类问题</h2><h3 id="背包问题基本思路"><a href="#背包问题基本思路" class="headerlink" title="背包问题基本思路"></a>背包问题基本思路</h3><p>背包类问题的特点是暴力解法一般都是常见的回溯，但是回溯的复杂度又太高，也不好剪枝优化，用动态规划能代替这种回溯。<br>并不是所有的回溯问题都可以用背包的思路来解。通常背包问题的特点是：</p>
<ol>
<li>一个数组或一些序列，要从中<strong>求和</strong>或者找组合。</li>
<li>对于数组中的元素，有“选”或者“不选”两种情况，即符合回溯问题的思路；</li>
</ol>
<p>如果不是这类问题，通常就要进行一些转化。比如分目标和和最后一块石头这两道题，看起来都不太能看出来是符合这类问题的，需要对问题转化一下，变成“几个数求和得到某个数”这样的问题就可以用背包解决。</p>
<p>01 背包问题解决的通用思路：</p>
<ol>
<li>每行设为数组中的每个元素，即从<code>[0,i]</code>中任意选；一般初始化的时候会把第一行设置好，所以实际上是从前两个数开始的。（有时候也可以定义成前 i 个，则对应的值应该是<code>arr[i-1]</code>，这时 i=1 表示的就是第一个数而不是[0,1]这样第一和第二个数）</li>
<li>每列设为从 0 到目标值的连续自然数。比如想计算凑出值 m，就从 0 开始到 m 每一个连续的整数都是一列。</li>
<li>计算时每个 dp 大多数情况都是<code>dp[i-1][j]</code>和<code>dp[i-1][j-arr[i]]</code>推出来的，可能会有：</li>
</ol>
<ul>
<li>计算值，比如确保不大于 j 的值或者最大值，就取 j&gt;=nums[i]时，<code>dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-nums[i]])</code>，表示选或不选当前数 nums[i]两种情况；如果<code>j&lt;nums[i]</code>，一般就保持值不变</li>
<li>计算组合次数或多少种，一般是<code>dp[i][j] = dp[i-1][j]+dp[i-1][j-nums[i]]</code>，因为求组合的一般是两种情况都可以，取一个和</li>
<li>计算能不能确切满足的，比如刚好等于 j，一般是<code>dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]]</code>，选或不选只要有一个能成立就行。或者还是用第一种计算最值，如果最值等于当前值，就是可以刚好相等。</li>
</ul>
<ol start="4">
<li>最后的结果基本上都是最右下角的。</li>
</ol>
<p>因此，背包类问题的最难的地方在于怎么把问题转化为类似背包的“选或不选”</p>
<p>关于初始化数组大小和范围问题：</p>
<ul>
<li>列的大小一般是目标数+1，比如要求和为 5，那么就应该是<code>new Array(5+1)</code></li>
<li>行的大小一般是遍历的总元素个数 len+1</li>
<li>j 一般表示的是从 0 到 j，所以一般初始化就定义好第一列，遍历从第二列(j = 1)开始。特殊情况不能确定第一列的也可以从第一列开始。</li>
<li>i 一般表示从 0 到 i 的数，i=0 一般表示的是第一个数；<ul>
<li>如果能确定第一个行的情况就初始化，遍历过程中的元素为 nums[i]，相当于跳过了第一个数。</li>
<li>如果不能确定第一行就不初始化，遍历过程中的元素为 nums[i-1]，相当于考虑第一个数。</li>
</ul>
</li>
</ul>
<h3 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h3><blockquote>
<p>有 n 件物品，物品体积用一个名为 w 的数组存起来，物品的价值用一个名为 value 的数组存起来；<br>每件物品的体积用 w[i] 来表示，每件物品的价值用 value[i] 来表示。现在有一个容量为 c 的背包<br>问你如何选取物品放入背包，才能使得背包内的物品总价值最大？</p>
</blockquote>
<blockquote>
<p>首先先考虑一个问题，假如不用动态规划，这道题怎么解？<br>其实背包问题本质上就是一个回溯问题，给定了一个空间，我们可以遍历任意物品的组合（单个物品不能重复），如果超重了就剔除最后一个记录并返回。<br>背包问题动态规划的目的其实也是在实现这个回溯。尤其是数组中的 i，表示从<code>[0,i]</code>中任选几个物品，这个看起来就和一般动态规划不太一样，根本原因就是它在模拟一种“组合”。</p>
</blockquote>
<p>设<code>dp[i][j]</code> 表示从下标为<code>[0-i]</code>的物品里任意取，放进容量为 j 的背包，价值<strong>总和最大</strong>是多少。(记住 i 和 j 的含义)</p>
<p>我们假设每个物品重量和价值关系如下:</p>
<table>
<thead>
<tr>
<th></th>
<th>weight</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>物品 0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>物品 1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>物品 2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody></table>
<p>那么得到的 dp 数组就是这样的：<br><img src="https://img-blog.csdnimg.cn/20210110103003361.png"></p>
<p>然后需要确定递推公式。我们可以这样理解，对于每一个即将要放入背包的物品 i ，可能有两种情况：</p>
<ol>
<li>当前背包容量不够（没有空余或者空余小于当前物品重量），放不下（背包不是一开始就是最大的，而是从 0 开始一个一个遍历上来的）</li>
<li>当前背包容量够，并且空余大于等于当前物品重量</li>
</ol>
<p>这两种情况恰恰是对应两个公式：</p>
<ol>
<li>不够放下该物品 i，所以直接无视掉，依旧取之前的值。这个“之前的值”，就是<strong>背包容量不变，并且不放物品 i</strong>的值，体现为<code>dp[i - 1][j]</code>。<code>dp[i-1]</code>表示的含义是，当前物品没有放入，那么就还是上一个或上面几个物品放入的情况。</li>
<li>能放下物品 i，这时候就选择放入物品 i，并且加上物品 i 的价值。但是注意这里并不是直接在<code>dp[i - 1][j]</code>的基础上加，而是取<code>dp[i - 1][j - weight[i]]</code>；原因是这样：</li>
</ol>
<p>比如计算<code>dp[1][3]</code>，如下图<br><img src="https://img-blog.csdnimg.cn/20210110103244701.png"></p>
<p>这时<code>dp[i - 1][j] = dp[0][3]</code>，即不放入物品 1，那么背包中仍旧只有一个物品 0，价值为 15<br>如果放入物品 1，我们就需要知道一个特殊的情况，即<strong>空余空间足够，但并未放入</strong>的情况。即<code>dp[i - 1][j - weight[i]] = dp[0][0]</code>：这时什么都没有放入，背包空余大小为 3，足够放入重量为 3 的物品 1。最后加上物品 1 的价值 20，得到最终值</p>
<p>如果不找到有足够空间的情况，那么本次的<code>j</code>之前可能会有其他情况，比如一个比物品 i 重量小的已经放入，但是没有填满，并且去掉这个小物品是可以放入该物品 i 的。应当避免的就是这种情况。</p>
<p>结合上面两种情况，其实就是在比较“选不选物品 i”；选和不选之间取出一个最大值，成为当前的结果。</p>
<p>状态转移方程为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure>

<p>核心遍历代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; weight.length; i++) &#123;</span><br><span class="line">  <span class="comment">// 遍历物品</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= size; j++) &#123;</span><br><span class="line">    <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">if</span> (j &lt; weight[i])</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j]; <span class="comment">// 如果当前容量都小于物品i的重量，那肯定不用放入</span></span><br><span class="line">    <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testweightbagproblem</span>(<span class="params">wight, value, size</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = wight.length;</span><br><span class="line">  <span class="keyword">const</span> dp = array.from(<span class="keyword">new</span> <span class="built_in">Array</span>(len + <span class="number">1</span>), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(size).fill(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= size; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j &lt; weight[i])</span><br><span class="line">        <span class="comment">// 如果当前容量都小于物品i的重量，那肯定不用放入</span></span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">      <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dp[len][size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>背包问题是一类问题的代替解法，即部分求组合、子集的<strong>回溯</strong>问题。实际上背包问题的暴力解法就是回溯求所有组合，满足大小要求的计算价值取最大即可。<br>典型案例可以参考下一道题</p>
</blockquote>
<h4 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h4><p>在状态转移过程中，每一行的 dp 状态值都只与其正上方和左方的状态值有关，因此可对状态空间 dp 进一步优化</p>
<p>实际上，滚动数组是将原先的二维数组拆成了一层一层的数组，实际的遍历量没有改变。每次都是对这个数组进行更新；</p>
<p><strong>dp 定义</strong>：设 dp[j]表示：容量为 j 的背包，所背的物品价值可以最大为 dp[j]</p>
<p><img src="https://img-blog.csdnimg.cn/20210110103614769.png"></p>
<p><strong>原理</strong>：比如上面这个图中的红框，当物品 2 遍历的时候（还没更新），从后向前遍历的红框位置的 dp[j]还是物品 1 对应的最后一个元素，也就是相当于 dp[i-1][j]；同理 dp[j-w[i]]也是物品 1 的那列的元素，即相当于 dp[i-1]j-w[i]]。这才是能压缩的根本原因，也是为什么每次更新都需要 j 从大到小遍历。</p>
<p>j 的遍历下限是 w[i]，也就是最远能更新的位置。这时因为在二维数组中如果 j 小于 w[i]，那必然取得是 dp[i-1][j]，相当于 dp[j]，也就是不改变；因此在一维数组中根本就不需要更新 j 小于 w[i]的部分。</p>
<p><strong>初始化</strong>：常见的初始化是全部初始化为 0，然后对 dp[0]单独处理。一般计算次数、组合数的题目 dp[0]都是 1，如果是取最大值的一般 dp[0]是 0.</p>
<p><strong>遍历</strong>：刚刚说过每个数组的 j 都必须从后向前，所以内层对 j 的遍历应该是从最后一个元素到 w[i]。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> len = weight.length;</span><br><span class="line"><span class="keyword">const</span> dp = <span class="built_in">Array</span>(size + <span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = size; j &gt;= weight[i - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">    dp[j] = <span class="built_in">Math</span>.max(dp[j], value[i - <span class="number">1</span>] + dp[j - weight[i - <span class="number">1</span>]]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[size];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另外，倒序遍历是为了保证物品 i 只被放入一次。如果正序遍历，那么物品 0 就会被重复加入多次。<br>这句话怎么理解呢？<br>刚刚说过，倒序遍历的时候前面的值还没被更新，相当于是上一个数组的结果。但是正序遍历的时候每次取得的 dp[j-w[i]]就是本数组更新的结果。<br>比如数组第一项是放入一个物品，第二项的 dp[j-w[i]]刚好是第一项，那么再加一个 value[i]，就相当于 dp[j]+2*value[i]，也就是把物品 0 放入了两次。</p>
</blockquote>
<h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h3><blockquote>
<p>给你一个 只包含正整数 的 非空 数组  nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。<br>示例 1：<br>输入：nums = [1,5,11,5]<br>输出：true<br>解释：数组可以分割成 [1, 5, 5] 和 [11] 。</p>
</blockquote>
<p>这道题乍一看像回溯问题，即找到一个组合，使得和恰好为综合的一半即可。<br>但是回溯问题做出来会超时，要么就需要很复杂的剪枝。因此可以考虑动态规划。<br>上面的背包问题说过，背包问题是一类问题的解法，就是这种<strong>组合相关的回溯问题</strong>；注意不是所有的回溯都可以这样解，一般来说只有组合等不限制个数的才可以。</p>
<p>还有一点不一样的是，背包问题的 j 只是一个限制，即最大空间不能大于 j；但是这里要求是值必须等于 j，<strong>所以 dp 内部的值建议用布尔值表示能不能满足（能不能等于 j），而不是最大和为多少。</strong></p>
<p>设 dp[i][j]表示从 0 到 i 的数字任意选，和能不能等于 j。因此这里 dp 应该是一个布尔值数组。注意 j 和 i 都是序号，但是 j 同时充当数字和的效果，而 i 需要 nums[i]取值。<br>和背包问题类似，dp 也有两个递推方向：</p>
<ul>
<li>如果<code>j &gt;= nums[i]</code>，说明当前数字至少可以放入一个 nums[i]，那么只要<code>dp[i - 1][j]</code>和<code> dp[i - 1][j - nums[i]]</code>有一个为 true 就行。这个地方在背包问题中是求较大值，这里其实原理一样，即选择放入数字 nums[i]或者不放</li>
<li>else，说明当前 j 完全不能放入数字 nums[i]，那它必然还是等于<code>dp[i - 1][j]</code></li>
</ul>
<p>初始化：</p>
<ul>
<li>首先<code>j = 0</code>时，说明要选数字使和为 0，那肯定都能满足（一个都不选），所以第一数列都为 true</li>
<li>对于第一行，意思是只选第一个数字能使得和等于哪个 j，显然就是找到<code>j === nums[0]</code>那一项，这时只选一个第一个数就可以满足。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> canPartition = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> _sum = nums.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line">  <span class="keyword">if</span> (_sum % <span class="number">2</span> !== <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> target = _sum / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dp[i][j]表示从0到i的数选几个是否能使和等于j</span></span><br><span class="line">  <span class="keyword">const</span> dp = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(nums.length), <span class="function">() =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Array</span>(target).fill(<span class="literal">false</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= target; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j &gt;= nums[i]) dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - nums[i]];</span><br><span class="line">      <span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>][target];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还有一种设置 dp 的方法，更好理解一些。<br>设 dp[j]表示[0,i]的元素组合，得到的和的<strong>不大于 j 的最大值</strong>；如果 dp[j] === j，就说明不大于 j 的最大值刚好可以是 j，也就是满足了题目的“相等要求”。最后只需要返回<code>dp[dp.length-1] === nums[nums.length - 1]</code>就可以。</p>
<p>这种方法实际上还是在算组合最大值，只是判断最大值是不是恰好等于 j。从逻辑上来说更好理解一些</p>
<h3 id="最后一块石头的重量-II"><a href="#最后一块石头的重量-II" class="headerlink" title="最后一块石头的重量 II"></a>最后一块石头的重量 II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/">https://leetcode.cn/problems/last-stone-weight-ii/</a></p>
<blockquote>
<p>有一堆石头，用整数数组  stones 表示。其中  stones[i] 表示第 i 块石头的重量。<br>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为  x 和  y，且  x &lt;= y。那么粉碎的可能结果如下：</p>
<p>如果  x == y，那么两块石头都会被完全粉碎；<br>如果  x != y，那么重量为  x  的石头将会完全粉碎，而重量为  y  的石头新重量为  y-x。<br>最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。</p>
</blockquote>
<p>这道题目关键在于怎么能转化成背包问题，实际上解决起来比较简单。<br>一堆数字每一次都从中取两个，取出来的求差再放入数组，最后反复求得最小值。实际上每组取出来的石头并没有消失，而是变成差的形式放入了数组。<br>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[31,26,33,21,40]</span><br><span class="line">1: 40-21   [19,26,31,33]</span><br><span class="line">2: 31-(40-21)   [12,26,33]</span><br><span class="line">3: 33-(31-(40-21))   [21,26]</span><br><span class="line">4: 26-(33-(31-(40-21)))   [5]</span><br><span class="line">总： (26+31+21) - (40+33)</span><br></pre></td></tr></table></figure>

<p>可以看出，最后的结果实际上就是<strong>把石头分成重量相近的两堆，求出他们的差的最小值</strong>。这样就和上面的分割等和子集基本一样了</p>
<p>我们设 dp[i][j]表示从 0 到 i 的石头中选，石头重量不超过 j 时的最大重量。由于要尽可能达到差最小，所以以综合的一半为基准，j 的上限就是 sum/2；这里重量不需要完全相等于 j，因此其实更像背包原始问题，只需要找到小于等于 j 时的最大重量即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">stones</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lastStoneWeightII = <span class="function"><span class="keyword">function</span> (<span class="params">stones</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _sum = stones.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line">  <span class="keyword">const</span> tar = <span class="built_in">Math</span>.floor(_sum / <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(tar);</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(stones.length), <span class="function">() =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Array</span>(tar + <span class="number">1</span>).fill(<span class="number">0</span>)</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// dp[i][j]表示从0到i石头中选，石头重量不超过j时的最大重量。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = stones[<span class="number">0</span>]; j &lt; dp[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = stones[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; dp[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">      dp[i][j] = <span class="built_in">Math</span>.max(</span><br><span class="line">        dp[i - <span class="number">1</span>][j] || <span class="number">0</span>,</span><br><span class="line">        dp[i - <span class="number">1</span>][j - stones[i]] + stones[i] || <span class="number">0</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(_sum - <span class="number">2</span> * dp[dp.length - <span class="number">1</span>][dp[<span class="number">0</span>].length - <span class="number">1</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h3><blockquote>
<p>给你一个整数数组 nums 和一个整数 target 。<br>向数组中的每个整数前添加  ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：<br>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。<br>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p>
</blockquote>
<p>这道题用回溯做很简单，甚至不需要任何剪枝就可以完成。</p>
<p>动态规划解法有点特殊，不是很好想。因为这个回溯并不是组合问题，而是排列问题，需要转成背包问题适合的组合问题。<br>需要推导一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假设 a + b + c + d = sum</span><br><span class="line">a + b - c - d = sum - 2(c + d) = target</span><br><span class="line"></span><br><span class="line">(c+d) = (sum - target) / 2   这就是负数部分的值</span><br><span class="line">(a+b) = (sum + target) / 2   这是正数部分的值</span><br></pre></td></tr></table></figure>

<p>所以其实还是一个分组问题，和上面的分石头类似。<br>这个问题可以转化成：从数组中的前 i 个数任意取，能凑成<code>(a+b)</code>（<code>c+d</code>也可以）的<strong>方案数量</strong>。</p>
<blockquote>
<p>还要注意这道题是求方案。最大差别在于 dp 的意义，所以初始化和求每个 dp 值都要改变。<br>前面几个题的 dp 值都是最大值或者最接近的值（最大价值、最接近的重量、确切的数），并且由于要求的是最接近 j（或者等于 j）的值，所以一半都是求较大值 max 的形式。<br>但是求方案的题目和路径类似，需要的是几种方案的叠加，即中间的计算应该是加法而不是求较大者。</p>
</blockquote>
<p>设 dp[i][j]表示从数组中的前 i 个数任意取，能凑成和为 j 的方案数量。<br>由于是方案数量，所以<code>dp[0][0]</code>应该为 1（第一个数要凑成 0，只有一种方案就是不选），其他的全部初始化为 0（实际上整个第一列都应该是 1）</p>
<blockquote>
<p>注意这道题还有一个很大的不同：j=0 这一项必须有，并且 j 要从 0 开始遍历。<br>因为和是有可能等于 0 的，并且如果有多个 0，[i][0]还可可能有很多种，所以必须从 0 开始遍历。因此 j 的范围应该是[j, tar]<br>另外，这里表示的是“前 i 个数”，而不是<code>[0,i]</code>中选。后者通常从 i=1 开始时，就隐式把第一个数抛弃了，然后在初始化的时候考虑只选第一个数的情况。上面三道题都是这种方式。但是这道题我们不能在初始化的时候就确定第一行，还是因为有 0 的原因。所以取具体的数需要 nums[i-1]</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findTargetSumWays = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = nums.length;</span><br><span class="line">  <span class="keyword">const</span> sum = nums.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line">  <span class="keyword">const</span> tar = (<span class="number">1</span> / <span class="number">2</span>) * (sum + target); <span class="comment">// 正数那部分的和</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Math</span>.floor(tar) !== tar || tar &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dp[i][j]表示从前i个数中选，凑成和为j的数字的**方案数量**</span></span><br><span class="line">  <span class="keyword">const</span> dp = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(len + <span class="number">1</span>), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(tar + <span class="number">1</span>).fill(<span class="number">0</span>));</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 注意这里i是从1开始的，但是实际上选数字应该是从0号开始，所以下面都需要i-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; dp[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">      <span class="comment">// 如果要凑的数字比当前可选的数字大，说明才可以选，否则一定不能选</span></span><br><span class="line">      <span class="keyword">if</span> (j &gt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]]; <span class="comment">// 方案 = 不选当前数字 + 选当前数字。注意关键在于这里是加法而不是取较大</span></span><br><span class="line">      &#125; <span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(dp);</span><br><span class="line">  <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>][dp[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><blockquote>
<p>有 n 件物品，物品体积用一个名为 w 的数组存起来，物品的价值用一个名为 value 的数组存起来；<br>每件物品的体积用 w[i] 来表示，每件物品的价值用 value[i] 来表示，<strong>每个物品数量无限</strong>。现在有一个容量为 c 的背包<br>问你如何选取物品放入背包，才能使得背包内的物品总价值最大？</p>
</blockquote>
<p>完全背包和 01 背包最大的区别在于每个物品的数量没有限制，也就是说一个物品可以被取多次。<br>完全背包和 01 背包的定义没有区别,dp[i][j]仍然表示从[0,i]中选择物品，放入到容量为 j 的背包中的最大价值<br>但是完全背包中的每个值都可以选择多次，<strong>每个物品不是“选或不选”，而是“选几个”</strong>；相当于增加了一个选择数量的变量<br>比如 01 背包中选择一个物品时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = Math.max(dp[i-1][j], dp[i][j - w[i]] + value[i])</span><br></pre></td></tr></table></figure>

<p>这里其实默认了这个物品最多只能选一个<br>而完全背包就是考虑多个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = Math.max(dp[i-1][j],</span><br><span class="line">                    dp[i][j - 1*w[i]] + 1*value[i],</span><br><span class="line">                    dp[i][j - 2*w[i]] + 2*value[i],</span><br><span class="line">                    ...,</span><br><span class="line">                    dp[i][j - k*w[i]] + k*value[i]</span><br><span class="line">                    )</span><br></pre></td></tr></table></figure>

<p>如果想直接解决完全背包，就需要再加入一个循环遍历 k，这样就成了三重循环，复杂度太高。</p>
<p>在 01 背包中提到过，如果内部数组从小到大遍历（“小”是指 w[i]而不是从 0 开始），相当于每个物品被添加了多次。所以可以考虑使用完全背包的一维表达式。</p>
<p><img src="https://img-blog.csdnimg.cn/20210126104510106.jpg"></p>
<p>完全背包的遍历有两种:</p>
<ul>
<li>如果求组合数就是外层 for 循环遍历物品，内层 for 遍历背包</li>
<li>如果求排列数就是外层 for 遍历背包，内层 for 循环遍历物品</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求组合：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= weight.length; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = weight[i]; j &lt;= bagWeight; j++) &#123;</span><br><span class="line">    dp[j] = <span class="built_in">Math</span>.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求排列：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= bagWeight; j++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; weight.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= weight[i]) &#123;</span><br><span class="line">      dp[j] = <span class="built_in">Math</span>.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个遍历顺序有什么区别呢？<br>完全背包的 dp[j]依赖于前面的计算出的本数组的 dp[j]，所以只需要计算某个 dp[j]时保证前面是有效元素就可以。</p>
<p>先遍历物品的话，背包里的物品是依次改变的。<br>而对于物品来说，一定是有序的，因为物品 2 不可能出现在物品 1 之前，只可能有[1,2]这样的组合而不可能有[2,1]这样的。<br><img src="https://img-blog.csdnimg.cn/20210126104529605.jpg"></p>
<p>如果是先遍历背包，相当于是竖着一列一列更新，比如红框 45 接下来就要更新的是另一个物品 2 中的下一个元素。<br>这时<br><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210729234011.png"></p>
<blockquote>
<p>其他问题的内部迭代：</p>
<ul>
<li>组合、排列问题：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] += dp[j - nums[i]];</span><br></pre></td></tr></table></figure>

<ul>
<li>存在问题：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = dp[j] || dp[j - nums[i]];</span><br></pre></td></tr></table></figure>

<ul>
<li>最值问题：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = min(dp[j], dp[j - nums[i]] + <span class="number">1</span>);</span><br><span class="line">dp[j] = max(dp[j], dp[j - nums[i]] + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="零钱兑换-II"><a href="#零钱兑换-II" class="headerlink" title="零钱兑换 II"></a>零钱兑换 II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-2/">https://leetcode.cn/problems/coin-change-2/</a></p>
<blockquote>
<p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。<br>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。<br>假设每一种面额的硬币有无限个。</p>
</blockquote>
<p>这道题是上面的零钱兑换的变种，实际上就是把求最少硬币个数变成求组合个数。<br>因为一个零钱可以取无数次，所以是一个典型的完全背包问题。套入完全背包的<code>dp[i][j]= dp[i−1][j] + dp[i][j−w[i]]</code>即可。</p>
<p>设 dp[i][j]表示要凑成总面额为 j 的硬币组合种数，显然第一列（凑成 0）全都是 1，其他的都是 0.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">amount</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">coins</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> change = <span class="function"><span class="keyword">function</span> (<span class="params">amount, coins</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = coins.length;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(len + <span class="number">1</span>), <span class="function">() =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Array</span>(amount + <span class="number">1</span>).fill(<span class="number">0</span>)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; dp[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j &gt;= coins[i - <span class="number">1</span>]) &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - coins[i - <span class="number">1</span>]];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(dp);</span><br><span class="line">  <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>][dp[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这道题的一维数组形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> change = <span class="function">(<span class="params">amount, coins</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="built_in">Array</span>(amount + <span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = coins[i]; j &lt;= amount; j++) &#123;</span><br><span class="line">      dp[j] += dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="组合问题-IV"><a href="#组合问题-IV" class="headerlink" title="组合问题 IV"></a>组合问题 IV</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/">https://leetcode.cn/problems/combination-sum-iv/</a></p>
<blockquote>
<p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</p>
</blockquote>
<p>这道题每个元素可重复选择，因此是一个完全背包；但是又是一个排列问题，所以需要稍微改进一下</p>
<blockquote>
<p>组合不强调顺序，(1,5)和(5,1)是同一个组合；排列强调顺序，(1,5)和(5,1)是两个不同的排列。<br>如果求组合数就是外层 for 循环遍历物品，内层 for 遍历背包，<strong>并且内部应该是反向的</strong><br>如果求排列数就是外层 for 遍历背包，内层 for 循环遍历物品，内部正向</p>
</blockquote>
<p>所以需要把物品 nums 放在内部遍历。<br>注意这种排列的问题，用二维数组已经解不了了，必须用一维数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combinationSum4 = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(target + <span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= nums[j]) &#123;</span><br><span class="line">        dp[i] += dp[i - nums[j]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(dp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h3><blockquote>
<p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。<br>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。<br>示例 1：<br>输入: s = “leetcode”, wordDict = [“leet”, “code”]<br>输出: true<br>解释: 返回 true 因为 “leetcode” 可以由 “leet” 和 “code” 拼接成。</p>
</blockquote>
<p>这道题和回溯中的分割回文串很像，只不过题干说的是“组合”，实际上也可以对字符串进行分解。<br>因此这道题其实有好几个思路：</p>
<ol>
<li>组合 wordDict 中的单词，找到匹配的。计算量最大，基本上会超时</li>
<li>分割 s，每次分割的结果在 wordDict 中查验，如果有就记录并把剩余字符串继续回溯检查。参考上面分割回文串的方法</li>
<li>动态规划，完全背包，把字符串看作是列，每列刚好对应一个字符；每行对应一个 wordDict 中的单词。每次迭代取前面一部分，然后判断是不是符合 wordDict[i]即可。</li>
</ol>
<p>设 dp[i]表示截止到位置 i 的字符串，能不能匹配到 wordDict 中的单词。显然这是一个 boolean 数组，并且 dp[0]表示截止到位置 0，也就是空串，对应不选，所以为 true.（这里有点强行解释了，但是第一项一般是不为 0 或者 false 的，要不然后面就不好算了）</p>
<p>至于遍历顺序，其实两种都可以。但是题解上建议是外层遍历字符，内层遍历单词，因为一个串的匹配应该是从前到后一个个查找的，想多来说更合理更好想一点。</p>
<p>下面是动态规划的代码。内部实际上就是常见的匹配 dp 的形式（<code>dp[i] || dp[i - weight[i]]</code>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">wordDict</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> wordBreak = <span class="function"><span class="keyword">function</span> (<span class="params">s, wordDict</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(s.length + <span class="number">1</span>).fill(<span class="literal">false</span>);</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; wordDict.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        i &gt;= wordDict[j].length &amp;&amp;</span><br><span class="line">        s.slice(i - wordDict[j].length, i) === wordDict[j]</span><br><span class="line">      ) &#123;</span><br><span class="line">        dp[i] = dp[i] || dp[i - wordDict[j].length];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票-I"><a href="#买卖股票-I" class="headerlink" title="买卖股票 I"></a>买卖股票 I</h2><blockquote>
<p>给定一个数组 prices ，它的第  i 个元素  prices[i] 表示一支给定股票第 i 天的价格。<br>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。<br>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。<br>示例 1：<br>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</p>
</blockquote>
<p>设 dp[i]表示第 i 天持有股票的现金。<br>为了区分在某一天购入和售出，设置两个状态表示在改天持有和不持有股票：</p>
<ul>
<li>dp[i][0]表示在第 i 天持有股票。<strong>持有</strong>股票表示两种可能：<ul>
<li>今天购买了股票，那么现在剩余的现金就是<code>-price[i]</code></li>
<li>今天没有购买，保持昨天的状态，即<code>dp[i-1][0]</code></li>
</ul>
</li>
<li>dp[i][1]表示在第 i 天不持有股票，同理：<ul>
<li>今天售出了股票，那么剩余现金就是 当天的股票价格 price[i]和前一天的持有金钱的差值；又因为 dp[i][0]一定是小于等于 0，因此实际上是<code>price[i] + dp[i-1][0]</code>。<br>并且，<code>dp[i-1][0]</code>本身是由前面推出来的，因此一定在这天之前是购买成本最小的情况。</li>
<li>今天没有售出，即保持<code>dp[i - 1][1]</code></li>
</ul>
</li>
</ul>
<p>因此实际上 dp 是两个动态规划的组合。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0] = Math.max(dp[i-1][0],-price[i])</span><br><span class="line"></span><br><span class="line">dp[i][1] = Math.max(dp[i-1][1],price[i] + dp[i-1][0])</span><br></pre></td></tr></table></figure>

<p>最终结果取<code>dp[price.length - 1][1]</code>就是最大值。</p>
<p><img src="https://pic.imgdb.cn/item/6281dbeb09475431290d7d2e.jpg"></p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">prices</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span> (<span class="params">prices</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = [[-prices[<span class="number">0</span>], <span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">    dp[i] = [];</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], prices[i] + dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票-II"><a href="#买卖股票-II" class="headerlink" title="买卖股票 II"></a>买卖股票 II</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/</a></p>
<p>这道题和上一道题的唯一区别在于：dp[i][0]的推导有一点点不一样。<br>因为上一道题购买的时候一定是不持有现金的，因此必然是<code>-prices[i]</code>；但是本题购买的时候可能是已经持有现金了，所以就需要把值变为<code>dp[i][1] - prices[i]</code>。<br>即</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i][<span class="number">1</span>] - prices[i]);</span><br><span class="line"></span><br><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], price[i] + dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>带入代码得：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">prices</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span> (<span class="params">prices</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = [[-prices[<span class="number">0</span>], <span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">    dp[i] = [];</span><br><span class="line">    dp[i][<span class="number">1</span>] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], prices[i] + dp[i - <span class="number">1</span>][<span class="number">0</span>]); <span class="comment">// 注意顺序稍微改了一下</span></span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i][<span class="number">1</span>] - prices[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票含冷冻期"><a href="#买卖股票含冷冻期" class="headerlink" title="买卖股票含冷冻期"></a>买卖股票含冷冻期</h2><blockquote>
<p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>示例: 输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p>
</blockquote>
<h2 id="打家劫舍-I"><a href="#打家劫舍-I" class="headerlink" title="打家劫舍 I"></a>打家劫舍 I</h2><blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。<br>示例 1： 输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。<br>示例 2： 输入：[2,7,9,3,1] 输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p>
</blockquote>
<p>这道题的关键在于怎么考虑“不偷相邻家”的问题。<br>设 dp[i]表示偷到第 i 家时的最高金额，那么就会有两种情况：</p>
<ol>
<li>选择偷第 i 家，那么前一个就不能被偷，也就是说要从第一个开始遍历，直到前一家的前一个停止（<code>j&lt;i-1</code>），找到一个最大值，再加上这一家的 nums</li>
<li>选择不偷第 i 家，那么就保持 dp[i-1]即可。</li>
</ol>
<p>当数组长度小于等于 2 时，可以直接取最大值，所以数组至少要有三项才能开始推；<br>初始化全 0，开始偷东西时至少从第一项或第二项开始，所以应该初始化 dp[0]和 dp[1];</p>
<ul>
<li>dp[0]表示偷到第一家时的金额，应该是 nums[0]；</li>
<li>dp[1]应该取 max(dp[0],dp[1])，即如果第二项比第一项大，那就不偷第一项了，直接从第二项开始。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rob = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 设dp[i]表示截止到第i个房屋偷窃到的最大金额</span></span><br><span class="line">  <span class="keyword">if</span> (nums.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">Math</span>.max(...nums);</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(nums.length).fill(<span class="number">0</span>);</span><br><span class="line">  dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">  dp[<span class="number">1</span>] = <span class="built_in">Math</span>.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      max = <span class="built_in">Math</span>.max(max, dp[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>], max);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>回到一开始的问题，怎么去判断邻家的问题？<br>其实就是在偷的时候做出改变：如果选择要偷，那一定不考虑临近的一个。不偷的时候则不需要刻意避开。<br>也就是说，遍历给偷指定了一个“范围”，即考虑偷这个范围内的，但是具体偷哪个则需要选出最大值决定。<br>其实这道题也就是最长上升子序列的“不可相邻”版。</p>
<h2 id="打家劫舍-II"><a href="#打家劫舍-II" class="headerlink" title="打家劫舍 II"></a>打家劫舍 II</h2><blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。<br>示例 1：<br>输入：nums = [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</p>
</blockquote>
<p>这道题不一样之处在于头尾相邻，但是也只是头尾相邻，其他情况和第一种完全一样</p>
<p>之前思考过可以偷过一遍之后再转一圈再偷一遍，但是自己想想是不可能的，第二圈再偷任何一家都是至少有一个偷过的相邻的，如果有没偷过相邻的那一定在第一遍就偷过了。因此只需要考虑一次遍历就够了。</p>
<p>如果第一家偷过的话，最后一家就一定不偷；如果从第二家开始，就一定要包含最后一家。<br>那怎么判断第一家还是第二家偷了呢？之前考虑判断<code>dp[1] === nums[0]</code>，如果是就说明偷了第一家；但是这个方法在第一家和第二家一样的时候就不能用了。<br>因此应该从序号入手，计算两次，第一次是直接从 nums[1]开始；第二次从 nums[0]开始，到了倒数第二项就结束即可。最后取两个的较大值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rob = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> result1 = robRange(nums, <span class="number">0</span>, n - <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> result2 = robRange(nums, <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(result1, result2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> robRange = <span class="function">(<span class="params">nums, start, end</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (end === start) <span class="keyword">return</span> nums[start];</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="built_in">Array</span>(nums.length).fill(<span class="number">0</span>);</span><br><span class="line">  dp[start] = nums[start];</span><br><span class="line">  dp[start + <span class="number">1</span>] = <span class="built_in">Math</span>.max(nums[start], nums[start + <span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start + <span class="number">2</span>; i &lt;= end; i++) &#123;</span><br><span class="line">    dp[i] = <span class="built_in">Math</span>.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[end];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><blockquote>
<p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
</blockquote>
<p>用 <code>f(i)</code>代表以第 i 个数结尾的「连续子数组的最大和」,可得方程为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(i)=max&#123;f(i−1)+nums[i],nums[i]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也就是以第 i 个数结尾的最大和，有可能是加上第 i 个数的结果，也有可能是只有第 i 个数的结果。因为<code>f(i)</code>代表以第 i 个数结尾的,因此必须要包含当前数(即<code>nums[i]</code>)；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxChildArr = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> f = [];</span><br><span class="line">  f[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    f[i] = <span class="built_in">Math</span>.max(f[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(...f);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>如果要求是一个最大子序列呢？即不要求连续数组</p>
<p>其实就是改一下方程为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">1</span>] + nums[i]);</span><br></pre></td></tr></table></figure>

<p>因为这样每一项都可以选择其前面的某一项和，当自己为正时就加上自己即可。<br>而如果要求必须是子数组，那么一旦不合适就应该抛弃前面的子数组，重新以自己为起点创建数组。</p>
<h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><blockquote>
<p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
</blockquote>
<p>假设最长序列长度为<code>f(i)</code>,这道题不适合倒推得出方程,而是通过正向思考<br>对于每一个数字,如果前面还有比它小的一个数字或一组数字,就可以组合成一个序列;<br>那么可以执行两次遍历,遍历每个数字,每次迭代都遍历<strong>这个数字前面的所有数字</strong>,如果有比它小的就加入序列长度，直到找到该项之前的、比该项小的数字个数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lengthOfLIS = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> f = [];</span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    f[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">        <span class="comment">//注意这里不是要f[i] 与 f[j] + 1进行比较，而是取f[j] + 1的最大值。</span></span><br><span class="line">        f[i] = <span class="built_in">Math</span>.max(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(...f);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>核心代码写成这样也可以：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">  f[i] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">      <span class="comment">// 取f[j] + 1的最大值。</span></span><br><span class="line">      tmp = tmp + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  f[i] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长连续递增子序列"><a href="#最长连续递增子序列" class="headerlink" title="最长连续递增子序列"></a>最长连续递增子序列</h2><blockquote>
<p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p>
</blockquote>
<p>这道题和上面的最大区别在于“连续”，即序列是连续的。<br>因此同样设<code>dp[i]</code>表示以 i 结尾的最长连续递增序列的长度，但是<code>dp[i]</code>此时只能由<code>dp[i - 1]</code>推出，即<code>dp[i] = dp[i - 1] + 1</code>。</p>
<p>遍历整个数组，如果当前数<code>nums[i]</code>比前面的数大，就更新<code>dp[i]</code>，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findLengthOfLCIS = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = [];</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">    dp[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    res = res &gt; dp[i] ? res : dp[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最长公共子数组"><a href="#最长公共子数组" class="headerlink" title="最长公共子数组"></a>最长公共子数组</h2><blockquote>
<p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。<br>示例：<br>输入： A: [1,2,3,2,1] B: [3,2,1,4,7] 输出：3 解释：长度最长的公共子数组是 [3, 2, 1] 。</p>
</blockquote>
<p>类似这种的公共问题，一定是取二维数组<code>dp[i][j]</code>，并且两个维度分别对应一个数组。<br>这里<code>dp[i][j]</code>表示：以下标<code>i - 1</code>为结尾的 A，和以下标<code>j - 1</code>为结尾的 B，最长重复子数组长度为<code>dp[i][j]</code>。<br>当<code>A[i - 1] === B[j - 1]</code>相等的时候，<code>dp[i][j] = dp[i - 1][j - 1] + 1</code></p>
<blockquote>
<p>这里取<code>i-1</code>和<code>j-1</code>主要是为了方便计算，直接取 i、j 也可以，但是要提前初始化<code>dp[i][0]</code>和 dp<code>[0][j]</code></p>
</blockquote>
<p>dp 数组的结构如下，状态的更新是斜向的，即 dp[i][j]总是由左上方的 dp[i - 1][j - 1]更新而来</p>
<p><img src="https://img-blog.csdnimg.cn/2021011215282060.jpg"></p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> findLength = <span class="function">(<span class="params">A, B</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// A、B数组的长度</span></span><br><span class="line">  <span class="keyword">const</span> [m, n] = [A.length, B.length];</span><br><span class="line">  <span class="comment">// dp数组初始化，都初始化为0</span></span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m + <span class="number">1</span>).fill(<span class="number">0</span>).map(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>));</span><br><span class="line">  <span class="comment">// 初始化最大长度为0</span></span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="comment">// 遇到A[i - 1] === B[j - 1]，则更新dp数组</span></span><br><span class="line">      <span class="keyword">if</span> (A[i - <span class="number">1</span>] === B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新res</span></span><br><span class="line">      res = dp[i][j] &gt; res ? dp[i][j] : res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历完成，返回res</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><blockquote>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。<br>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。<br>若这两个字符串没有公共子序列，则返回 0。<br>示例 1:<br>输入：text1 = “abcde”, text2 = “ace” 输出：3 解释：最长公共子序列是 “ace”，它的长度为 3。<br>示例 2: 输入：text1 = “abc”, text2 = “abc” 输出：3 解释：最长公共子序列是 “abc”，它的长度为 3。<br>示例 3: 输入：text1 = “abc”, text2 = “def” 输出：0 解释：两个字符串没有公共子序列，返回 0。</p>
</blockquote>
<p>这道题是上一个公共子数组的序列版本。<br>还是设 dp[i][j]表示 text1[i-1]和 text2[j-1]之间的最长公共子序列长度。</p>
<ul>
<li>当 text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以 dp[i][j] = dp[i - 1][j - 1] + 1;</li>
<li>如果 text1[i - 1] 与 text2[j - 1]不相同，注意这里和子数组的处理不一样。因为子数组要求必须连续，所以如果有不同就之间抛弃就行；但是子序列可以不连续，所以需要在前一个的结果上“继承”。对于双序列来说，就不能只考虑一个，要同时考虑两个 text 都缩一个的情况，即 dp[i-1][j]和 dp[i][j-1]的较大值<br><img src="https://img-blog.csdnimg.cn/20210204115139616.jpg"></li>
</ul>
<p>整体结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210210150215918.jpg"></p>
<p>可以看到，对于这种双数组的动态规划，如果理解不来就可以画表来看看。通常子序列长度问题都要考虑两边分别“缩一个”然后继承。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">text1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">text2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestCommonSubsequence = <span class="function"><span class="keyword">function</span> (<span class="params">text1, text2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [len1, len2] = [text1.length, text2.length];</span><br><span class="line">  <span class="comment">// dp[i][j]表示text1[i-1]和text[j-1]之间的最长公共子序列长度</span></span><br><span class="line">  <span class="keyword">const</span> dp = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(len1 + <span class="number">1</span>), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(len2 + <span class="number">1</span>).fill(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; dp[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (text1[i - <span class="number">1</span>] === text2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[i][j] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>][dp[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h2><blockquote>
<p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。<br>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。<br>示例 1： 输入：s = “abc”, t = “ahbgdc” 输出：true</p>
</blockquote>
<p>这道题用双指针就能很快解决，但是用动态规划也可以，并且可以引出下一道题的类似思路。</p>
<p>用动态规划的话思路和<em>最长公共子数组</em>这道题类似，同样取二维数组 dp[i][j]，表示以下标<code>i - 1</code>结尾的字符串 s 和下标<code>j - 1</code>结尾的字符串 t 之间的子序列长度。</p>
<p>那么就会有两种情况：</p>
<ol>
<li>如果<code>s[i-1]===t[j-1]</code>，那么子序列长度加 1，即<code>dp[i][j] = dp[i - 1][j - 1] + 1</code>；（即下标 i-2 和 j-2 的串的子序列长度+1）</li>
<li>如果<code>s[i-1]!==t[j-1]</code>，那么子序列长度不变，即<code>dp[i][j] = dp[i][j - 1]</code>。注意这里相当于 s 串不变，但 t 串向前走了，应该删去当前元素，所以是下标 i-1 的串和下标 j-2 的串子序列长度。</li>
</ol>
<p>因此可以得到方程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[i-1]===t[j-1]</span></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s[i-1]!==t[j-1]</span></span><br><span class="line">dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>最终结果只需要返回最右下角的元素即可。</p>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isSubsequence = <span class="function">(<span class="params">s, t</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// s、t的长度</span></span><br><span class="line">  <span class="keyword">const</span> [m, n] = [s.length, t.length];</span><br><span class="line">  <span class="comment">// dp全初始化为0</span></span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m + <span class="number">1</span>).fill(<span class="number">0</span>).map(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="comment">// 更新dp[i][j]，两种情况</span></span><br><span class="line">      <span class="keyword">if</span> (s[i - <span class="number">1</span>] === t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历结束，判断dp右下角的数是否等于s的长度</span></span><br><span class="line">  <span class="keyword">return</span> dp[m][n] === m ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于这种两个序列判断公共的问题，通常的解法都是利用二维数组；<br>而递推关系一般是两种情况得出的，可以类比双指针解法</p>
</blockquote>
<h2 id="不同子序列"><a href="#不同子序列" class="headerlink" title="不同子序列"></a>不同子序列</h2><blockquote>
<p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。<br>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
</blockquote>
<p>这个题和上面的题思路大致不变，因为都是在找公共子序列；<br>但是这个题是让你找到 s 有几种方法删除元素可以得到 t</p>
<p>同样设 dp[i][j]为 对于 i-1 结尾的 s 和 j-1 结尾的 t，t 在 s 中出现的个数。</p>
<p>那么会有同样的两种情况：</p>
<ol>
<li><p>如果<code>s[i-1]===t[j-1]</code>，此时<code>dp[i][j] = dp[i - 1][j - 1] + dp[i-1][j]</code>。这个的关键在于，后者表示 s 串中除去当前元素的判断结果，是因为对于如果已经匹配上的两个串，<strong>s 串向后走不管多少位都不会减少之前 t 串已经出现的次数</strong>。因此不应该是+1，而是加上之前匹配的次数。</p>
</li>
<li><p>如果<code>s[i-1]!==t[j-1]</code>，<code>dp[i][j] = dp[i-1][j]</code>，和上面原因一样，只有之前匹配的次数结果。</p>
</li>
</ol>
<p>得到方程为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line"></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br></pre></td></tr></table></figure>

<p>注意初始化：</p>
<ul>
<li>dp[i][0]表示从以 i 结尾的串 s 中找到空字串。那么选取方法就只有一种，即一个都不选，或者说是全部删除</li>
<li>dp[0][i]表示从空串中找到非空串，显然不可能，都为 0</li>
<li>dp[0][0]表示空串找空串，为 1</li>
</ul>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">t</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numDistinct = <span class="function"><span class="keyword">function</span> (<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="built_in">Array</span>.from(<span class="built_in">Array</span>(s.length + <span class="number">1</span>), <span class="function">() =&gt;</span> <span class="built_in">Array</span>(t.length + <span class="number">1</span>).fill(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= s.length; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= t.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i - <span class="number">1</span>] === t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dp[s.length][t.length];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="回文子串数量"><a href="#回文子串数量" class="headerlink" title="回文子串数量"></a>回文子串数量</h2><blockquote>
<p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。<br>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。<br>示例 1：<br>输入：”abc” 输出：3 解释：三个回文子串: “a”, “b”, “c”</p>
</blockquote>
<p>回文子串类型的动态规划数组 dp 一般都是这样设置的：<br>设 dp[i][j]表示字符串 i 和 j 之间的串<strong>是不是回文串</strong>，如果是就是 ture，不是就是 false。注意这里的值是布尔值，算是一个特例。（回文子串相关的都可以这么取）<br>因此主要判断两端的字符是不是相等，因此有几种情况：</p>
<ol>
<li>s[i] === s[j]，说明两端字符相等</li>
</ol>
<ul>
<li><code>i === j</code>，即同一个字符，为 true</li>
<li><code>|i - j| === 1</code>，说明是两个相邻的字符，即回文串的中心字符是偶数个，这种当然也是 true</li>
<li>其他情况，即 i 和 j 之间还包含其他字符串。因此需要判断两者之间的部分是不是，即判断<code>dp[i + 1][j - 1]</code>是否为 true</li>
</ul>
<ol start="2">
<li>s[i] !== s[j]，肯定是 false</li>
</ol>
<p>由此可以得到公式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] === s[j]) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i === j || <span class="built_in">Math</span>.abs(i - j) &lt;= <span class="number">1</span>) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> dp[i][j] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>这里注意因为 dp[i][j]是从 dp[i + 1][j - 1]推出来的，因此一定要从下向上、从左向右遍历。<br>即从 dp[s.length - 1][0]开始，i 递减。从字符串角度来说，就是从最右边的元素作为中间元素，一直到最左边元素为止，相当于每个字符都作为中心统计了一次回文子串数量。<br>回文子串的题基本都是这么遍历的，即 i 从第一列最后一项开始到第一项；初始化也只需要全部初始化一次即可。</p>
<p>并且对于回文子串问题，模拟出来的矩阵只有右上角才是有意义的，即 j &gt;= i，右指针在左指针的右边才有意义。<br><img src="https://img-blog.csdnimg.cn/20210121171059951.jpg"><br>上图中，对角线表示同一个字符，也就是 i=j 的情况；右上角都是 j&gt;i，表示 i 和 j 之间的部分是不是回文串。</p>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countSubstrings = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(s.length), <span class="function">() =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Array</span>(s.length).fill(<span class="literal">false</span>)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = s.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt;= s.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i] === s[j]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i === j || j - i &lt;= <span class="number">1</span>) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (dp[i][j]) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><blockquote>
<p>给你一个字符串 s，找到 s 中最长的回文子串。</p>
</blockquote>
<p>这道题的思路其实和找到回文子串数量的方式差不多，先判断是否存在回文子串，再在每一次遍历时更新最长字串即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = [];</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> max = -<span class="literal">Infinity</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = s.length; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    dp[i] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; s.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i] === s[j]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i === j || <span class="built_in">Math</span>.abs(i - j) === <span class="number">1</span>) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; max) &#123;</span><br><span class="line">        max = j - i + <span class="number">1</span>;</span><br><span class="line">        res = s.slice(i, j + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>当然这道题本质上没有这么麻烦，不用动态规划，直接用双指针也能解决，并且耗时更短，更有效</p>
<p>思路其实和双指针近似。我们考虑并计算每个位置上，以该位置为中心、向两边扩散的最长回文串长度，再遍历每个位置，求得最长长度即可。</p>
<p>但是还需要注意一点：最基本的回文子串长度可能是 1 或 2，也就是说<strong>整个回文串的总长度可能是奇数也可能是偶数</strong>。如果回文串的长度为奇数，则它有一个中心字符；如果回文串的长度为偶数，则可以认为它有两个中心字符。</p>
<p>因此求任一个位置的最长回文串长度时，就需要考虑两个指针的起始位置。如果相同就是奇数长度回文串，如果不同且相邻就是偶数长度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">palindromeLen</span>(<span class="params">str, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; str.length &amp;&amp; str[left] === str[right]) &#123;</span><br><span class="line">    len++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于整个字符串的任意位置 i，要考虑<code>left=right=i</code>和<code>left=i,right=i+1</code>两种情况下的值。</p>
<blockquote>
<p>注意这道题要求的是具体的回文串，而不是长度</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">palindromeLen</span>(<span class="params">str, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; str.length &amp;&amp; str[left] === str[right]) &#123;</span><br><span class="line">      left--;</span><br><span class="line">      right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时left和right都是超出了一个，也就是恰好不相同的位置，向内各走一个就是回文串</span></span><br><span class="line">    <span class="comment">// slice 留前不留后，因此right就是向内走一个位置，但left不是，还需要+1</span></span><br><span class="line">    <span class="keyword">return</span> str.slice(left + <span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> s1 = palindromeLen(s, i, i);</span><br><span class="line">    <span class="keyword">const</span> s2 = palindromeLen(s, i, i + <span class="number">1</span>);</span><br><span class="line">    str = str.length &gt; s1.length ? str : s1;</span><br><span class="line">    str = str.length &gt; s2.length ? str : s2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-subsequence/">https://leetcode.cn/problems/longest-palindromic-subsequence/</a></p>
<blockquote>
<p>给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。<br>示例 1: 输入: “bbbab” 输出: 4 一个可能的最长回文子序列为 “bbbb”。<br>示例 2: 输入:”cbbd” 输出: 2 一个可能的最长回文子序列为 “bb”。</p>
</blockquote>
<p>思路和上面的回文子串差不多，分开判断<code>s[i] === s[j]</code>;</p>
<ul>
<li>如果相等，<code>dp[i][j] = dp[i + 1][j - 1] + 2;</code>，这里可以不考虑 i、j 重合的情况</li>
<li>如果不相等，不能直接缩小范围，要测试一下只加上左边和只加上右边能不能构成回文；</li>
</ul>
<p>注意这里和上一道题不一样，因为上一道题只用考虑中间的是不是回文串，是就记录，不是就不记录，如果单独考虑反而会重复。</p>
<blockquote>
<p>比如字符串”bbbab”，当 i 指向第一个 b，j 指向 a 时，两者不相等，如果缩小右边的一个位置就有”bbb”；但是其实本来 j 就会走过这一串，这样统计反而重复了</p>
</blockquote>
<p>而这里需要的是前一个的最长回文子序列长度，除了复用两边都减去的情况，还必须要考虑两边各减一个的情况</p>
<blockquote>
<p>比如字符串”bbbab”，当 i 指向第一个 b，j 指向 a 时，两者不相等，同理缩小左右分别得到”bbb”和”bba”，因为是统计长度，因此不存在重复的可能，dp[i][j]一定取得是范围内设法得到的的最大值。</p>
</blockquote>
<p>模拟：<br><img src="https://img-blog.csdnimg.cn/20210127151452993.jpg"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestPalindromeSubseq = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(s.length), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(s.length).fill(<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = s.length; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; s.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i] === s[j]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i === j) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(i - j) &lt;= <span class="number">1</span>) dp[i][j] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[i][j] = <span class="built_in">Math</span>.max(dp[i][j - <span class="number">1</span>], dp[i + <span class="number">1</span>][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(dp);</span><br><span class="line">  <span class="keyword">return</span> dp[<span class="number">0</span>][dp[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最大正方形"><a href="#最大正方形" class="headerlink" title="最大正方形"></a>最大正方形</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximal-square/">https://leetcode.cn/problems/maximal-square/</a></p>
<p>思路：设 dp[i][j]表示以(i,j)为右下角的正方形大小。那么显然 dp[i][j]可以从其左、上、斜上三个方向推出来。</p>
<ul>
<li>首先三个位置必须都是 1，否则当前 dp[i][j]最多只能是 1</li>
<li>满足上一条之后，dp[i][j]应该是三个中 <code>(根号下最小值+1)^2</code>。比如三个值分别是 4、9、16，那么最多只能和 4 所在的那个位置凑成一个 3*3 的正方形。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;character[][]&#125;</span> <span class="variable">matrix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maximalSquare = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [m, n] = [matrix.length, matrix[<span class="number">0</span>].length];</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(m), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      dp[<span class="number">0</span>][j] = +matrix[<span class="number">0</span>][j];</span><br><span class="line">      dp[i][<span class="number">0</span>] = +matrix[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (matrix[i] &amp;&amp; matrix[i][j] !== <span class="string">&quot;0&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &amp;&amp; dp[i][j - <span class="number">1</span>] &amp;&amp; dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">          dp[i][j] =</span><br><span class="line">            (<span class="built_in">Math</span>.sqrt(</span><br><span class="line">              <span class="built_in">Math</span>.min(+dp[i - <span class="number">1</span>][j], +dp[i][j - <span class="number">1</span>], +dp[i - <span class="number">1</span>][j - <span class="number">1</span>])</span><br><span class="line">            ) +</span><br><span class="line">              <span class="number">1</span>) **</span><br><span class="line">            <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> dp[i][j] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      max = <span class="built_in">Math</span>.max(max, dp[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最长递增子序列的个数"><a href="#最长递增子序列的个数" class="headerlink" title="最长递增子序列的个数"></a>最长递增子序列的个数</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence/">https://leetcode.cn/problems/number-of-longest-increasing-subsequence/</a><br>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<br>这道题很重要，是双数组动态规划的重要例题！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</p>
<blockquote>
<p>给定一个未排序的整数数组  nums ，  返回最长递增子序列的个数  。<br>注意   这个数列必须是 严格 递增的。<br>示例 1:<br>输入: [1,3,5,4,7]<br>输出: 2<br>解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。</p>
</blockquote>
<p>思路：用两个数组 dp 和 cnt 分别记录最长递增子序列的长度和数量。</p>
<ul>
<li>dp 比较好算，dp[i]就是从 0 到 i 的最大值+1</li>
<li>cnt 的变化依赖 dp；由于 cnt 表示的是第 i 个位置上的最长递增子序列数量，那么 cnt 就会有两种情况：<ul>
<li>当当前 dp 被更新，即此时 0 到 i 中有一个位置的长度比当前 dp 大，说明最长递增子序列的长度增加了；如果只是增加长度，那么数量不会发生改变，即 cnt[i] = cnt[j]。</li>
<li>当 dp 不变（dp[i] = dp[j] + 1），即找到了两个相同长度的递增子序列，那么此时就应该把这个位置上的 cnt[j]和当前的 cnt[i]加起来。</li>
</ul>
</li>
<li>最后，找到 dp 中最大的值，然后在 dp 中遍历出现最大值的位置，对应到 cnt 的出现次数，就是这个最大序列值的出现次数，全部加起来即可。</li>
</ul>
<p>这里的关键就是这个 cnt 数组的动态规划计算，什么时候 cnt 应该变化<br>以上面的[1,3,5,4,7]为例：</p>
<ol>
<li>当 i = 4，j = 2，j 走到 5 这个位置上，dp[i]被更新为 4</li>
<li>当 j = 3，也就是走到 4 这个位置上时，这时发现之前计算的最长子序列长度又出现了一次（4），说明 5 和 4 都可以和 7 构成最长序列。那么显然就应该加上这个位置的 cnt。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findNumberOfLIS = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="built_in">Array</span>(len).fill(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> count = <span class="built_in">Array</span>(len).fill(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[j] + <span class="number">1</span> &gt; dp[i]) &#123;</span><br><span class="line">          dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">          count[i] = count[j];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[j] + <span class="number">1</span> === dp[i]) &#123;</span><br><span class="line">          count[i] += count[j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...dp);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[i] === max) &#123;</span><br><span class="line">      <span class="comment">// 在 dp 中遍历出现最大值的位置</span></span><br><span class="line">      res += count[i]; <span class="comment">// 对应到 cnt 的出现次数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="欢乐数"><a href="#欢乐数" class="headerlink" title="欢乐数"></a>欢乐数</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/">https://leetcode.cn/problems/happy-number/</a></p>
<blockquote>
<p>编写一个算法来判断一个数 n 是不是快乐数。<br>「快乐数」  定义为：</p>
<p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<br>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。<br>如果这个过程 结果为  1，那么这个数就是快乐数。</p>
</blockquote>
<p>这道题的关键是，不能化为 1 的数会一直重复其计算结果，所以如果发现重复，就说明不是欢乐数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isHappy = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>];</span><br><span class="line">  <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getHappy</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      sum += nums[num % <span class="number">10</span>];</span><br><span class="line">      num = <span class="built_in">Math</span>.floor(num / <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> init = getHappy(n);</span><br><span class="line">  <span class="keyword">while</span> (init !== <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (set.has(init)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> set.add(init);</span><br><span class="line">    init = getHappy(init);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="四数之和-II"><a href="#四数之和-II" class="headerlink" title="四数之和 II"></a>四数之和 II</h2><blockquote>
<p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：<br>0 &lt;= i, j, k, l &lt; n<br>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/">https://leetcode.cn/problems/4sum-ii/</a></p>
<p>这道题可以这样想：</p>
<ol>
<li>首先，先考虑两个数组的情况。怎么在两个数组中计算相加为 0 的数的个数？其中一个方法是，用一个 map 存储一个数组的数字出现个数（键为数字，值为出现次数），然后再遍历另一个数组，检查其中是否有当前数字的相反数。如果有，就让总个数加上这个数字的值（即出现次数）。</li>
<li>那么对于四个数组也是一样的：我们把前两个看作一个数组，计算他们每一项的和，再计算出上面说的这个 map；然后遍历后两个数组，后两个的和如果有 map 中的相反数，就取出来统计即可。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> len = nums1.length;</span><br><span class="line"><span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = nums1[i] + nums2[j];</span><br><span class="line">    <span class="keyword">if</span> (!map.has(sum)) map.set(sum, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> map.set(sum, map.get(sum) + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">    <span class="keyword">const</span> sum = nums3[i] + nums4[j];</span><br><span class="line">    <span class="keyword">if</span> (map.has(-sum) &amp;&amp; map.get(-sum) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      cnt += map.get(sum);</span><br><span class="line">      map.set(sum, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cnt;</span><br></pre></td></tr></table></figure>

<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><p>贪心的核心思维是“局部最优推整体最优”，和动态规划的核心思维一致。因此大多数贪心能解的题，动态规划也能解。<br>但是贪心还有一个思维，就是“最多”，或者“最大”这种思维。这个是动态规划不具备的。</p>
<p>比如说我们从一堆钱中限制取的次数，求能去到的最多的钱数，那肯定是每次都取这堆钱中最大面额的，才能在限定次数中取得总值最大的。</p>
<h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><blockquote>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>示例: 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6</p>
</blockquote>
<p>这道题用动态规划能解，但是这里要考虑的是贪心解法。</p>
<p>贪心贪的是什么呢？实际上就是保证和始终要增大；如果一组连续的和为负数，就应该立即抛弃，从下一个数开始。<br>具体来说，就是一个数字<code>nums[i]+sum&lt;0</code>，就直接记录 sum 并令 sum=0 然后继续从下一个遍历，否则持续累加 sum</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = -<span class="literal">Infinity</span>;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    count += nums[i];</span><br><span class="line">    <span class="keyword">if</span> (count &gt; result) &#123;</span><br><span class="line">      result = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="K-次取反后最大化的数组和"><a href="#K-次取反后最大化的数组和" class="headerlink" title="K 次取反后最大化的数组和"></a>K 次取反后最大化的数组和</h2><blockquote>
<p>给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）</p>
<p>以这种方式修改数组后，返回数组可能的最大和。</p>
<p>示例 1：</p>
<p>输入：A = [4,2,3], K = 1<br>输出：5<br>解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。</p>
</blockquote>
<p>这道题的思路就是：</p>
<ul>
<li>如果有负数，那就优先把绝对值最大的负数取反</li>
<li>如果没有负数，就把绝对值最小的正数取反</li>
</ul>
<p>具体实现，其实就是给数组排序，然后每次把第一个元素取反即可。因为每次排序之后第一个元素一定是最应该取反的（要么是最小的负数，要么是最小的正数）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> largestSumAfterKNegations = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    nums[<span class="number">0</span>] = -nums[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre + cur);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/">https://leetcode.cn/problems/non-overlapping-intervals/</a></p>
<blockquote>
<p>给定一个区间的集合  intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠  。<br>示例 1:<br>输入: intervals = [[1,2],[2,3],[3,4],[1,3]]<br>输出: 1<br>解释: 移除 [1,3] 后，剩下的区间没有重叠。</p>
</blockquote>
<p>这道题有一种解法是之前说过的，就是先按照 start 排序，再依次遍历，把每个 start &lt; 前一个 end 的数组删掉，最后剩下的就是无重叠区间的个数。</p>
<p>这里提供另外一种解法，更像贪心的思路，即按照 end 排序，大概是这样：<br><img src="https://labuladong.github.io/algo/images/interval/1.gif"></p>
<p>也就是说，每次删除的是 start 小于最小 end 的区间，逐个更新最小 end，最后就可以得到结果。</p>
<p>这个思路还可以用于解决<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/%E8%BF%99%E9%81%93%E9%A2%98%EF%BC%8C%E5%85%B6%E5%AE%9E%E9%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E6%80%9D%E8%B7%AF%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%82">https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/这道题，其实都是一个思路的问题。</a></p>
<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><h2 id="为运算表达式设计优先级"><a href="#为运算表达式设计优先级" class="headerlink" title="为运算表达式设计优先级"></a>为运算表达式设计优先级</h2><blockquote>
<p>给你一个由数字和运算符组成的字符串  expression ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以 按任意顺序 返回答案。<br>生成的测试用例满足其对应输出值符合 32 位整数范围，不同结果的数量不超过 104 。<br>示例 1：<br>输入：expression = “2-1-1”<br>输出：[0,2]<br>解释：<br>((2-1)-1) = 0<br>(2-(1-1)) = 2</p>
</blockquote>
<p>这道题其实是一个加括号的问题。<br>比如说，<code>2-1-1</code>可能由几种加括号的方法，根据括号的层数：</p>
<ul>
<li>一层括号，也就是没有嵌套，可以是<code>(2-1)-1</code>或者<code>2-(1-1)</code></li>
<li>两层括号，<code>((2-1)-1)</code>或<code>(2-(1-1))</code></li>
</ul>
<p>后面还有多层的括号。<br>括号的层数可能有很多，但是我们不需要考虑多个括号的情况，只需要考虑一层括号的划分，然后把划分出来的括号内部再进行划分，最后直到没有运算符只有数字为止。这就是分治的思想。</p>
<p>一层括号的划分可以根据运算符，每个运算符都可以作为一个分界线，两边作为不同的表达式，分别计算这两个表达式，再求值即可。这个思路有点像二叉树的处理，递归计算两个表达式的值，返回值，然后只考虑本层的计算结果即可。<br>因此整体思路如下：</p>
<ol>
<li>遍历字符串，每个运算符都进行一次分割成左表达式和右表达式</li>
<li>递归计算左右表达式的值。这里本来的函数就是接收一个表达式并计算可能的结果，那么递归得到的左右表达式也是一个结果数组，表示所有可能的值</li>
<li>对两个数组的值依次遍历，再根据本层的运算符计算得到值，放入 res 数组。</li>
</ol>
<blockquote>
<p>注意这里应该是交叉计算。<br>举个例子 <code>2*3-4*5</code><br>如果分割成 <code>2 * (3-4*5)</code>这种形式，那么右半部分应该有两个计算结果[-17, -5]<br>所以这里实际上是两种情况，<code>2*(3-(4*5))</code>和<code>2*((3-4)*5))</code>，因此要交叉计算[2]和[-17, -5]，得到所有情况</p>
</blockquote>
<ol start="4">
<li>返回 res 数组</li>
</ol>
<p>递归边界是表达式没有找到运算符，说明只是一个数字，那么直接返回包含这个数字的 res 数组就行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">expression</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> diffWaysToCompute = <span class="function"><span class="keyword">function</span> (<span class="params">expression</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = []; <span class="comment">// 每一层都不一样，每一层都是本层表达式的可能计算结果</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; expression.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> char = expression[i];</span><br><span class="line">    <span class="keyword">if</span> (char === <span class="string">&quot;+&quot;</span> || char === <span class="string">&quot;*&quot;</span> || char === <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 根据运算符分割左右表达式</span></span><br><span class="line">      <span class="comment">/****** 分 ******/</span></span><br><span class="line">      <span class="keyword">const</span> leftExp = expression.split(<span class="string">&quot;&quot;</span>).splice(<span class="number">0</span>, i).join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      <span class="keyword">const</span> rightExp = expression</span><br><span class="line">        .split(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        .splice(i + <span class="number">1</span>)</span><br><span class="line">        .join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      <span class="comment">/* 这里我们不用考虑下一层是怎么计算表达式的，只需要把本层处理好，即分割和合并两个步骤 */</span></span><br><span class="line">      <span class="keyword">const</span> left = diffWaysToCompute(leftExp); <span class="comment">// 递归计算左表达式，返回是一个res数组，即表达式的可能计算结果</span></span><br><span class="line">      <span class="keyword">const</span> right = diffWaysToCompute(rightExp); <span class="comment">// 同理</span></span><br><span class="line">      <span class="comment">/****** 治 ******/</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">of</span> left) &#123;</span><br><span class="line">        <span class="comment">// 因为left和right都是结果数组，可以按照运算符拼接</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> b <span class="keyword">of</span> right) &#123;</span><br><span class="line">          <span class="keyword">if</span> (char === <span class="string">&quot;+&quot;</span>) res.push(a + b);</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (char === <span class="string">&quot;-&quot;</span>) res.push(a - b);</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (char === <span class="string">&quot;*&quot;</span>) res.push(a * b);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果只有一个数字，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (res.length === <span class="number">0</span>) res.push(+expression);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p>BFS 的其实就是树的层序遍历，在树那一章也有讲到过。<br>BFS 的基本框架：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BFS</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> queue = [];</span><br><span class="line">  queue.push(第一项);</span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = queue.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> top = queue.shift();</span><br><span class="line">      处理top相关的操作;</span><br><span class="line">      queue.push(top的子节点);</span><br><span class="line">    &#125;</span><br><span class="line">    level++; <span class="comment">// 层数++</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的 BFS 有明显的“层”，每次弹出是以层为单位的，一层一层弹出。</p>
<p>还有一种是图遍历中的 BFS，每次以单个节点为单位，会对队列本次弹出的部分做拼接再放回队列。这种广泛用于图的遍历、迷宫路径等问题，详细算法参考下面的图的遍历的章节。</p>
<hr>
<p>BFS 解决问题求出的一定是<strong>最短路径</strong>，也就是到达目标的最短方法。<br>因此，如果看到题目要求是最短，并且是组合、排列之类的可以用回溯解决的，就可以考虑一下 BFS。</p>
<p>BFS 的关键在于找出 top 的子节点，也就是理顺父子节点的关系。<br>在解决大多数组合和排列问题时，DFS 通常是一个一个的拼接，但是 BFS 一般是先得到一个序列，然后依次替换每个值，再把新值做类似的替换。因为 BFS 实际上是在横向遍历一棵树，因此通常是一开始就确定了。<br>BFS 的其他类似用途：走迷宫，迷宫最短路径，替换单词变成另外一个单词等，本质就是让你在一幅「图」中找到从起点 start 到终点 target 的最近距离，相当于是在“数次数”</p>
<h2 id="打开转盘锁"><a href="#打开转盘锁" class="headerlink" title="打开转盘锁"></a>打开转盘锁</h2><blockquote>
<p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有 10 个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为  ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。<br>锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。<br>列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。<br>字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。<br>示例 1:<br>输入：deadends = [“0201”,”0101”,”0102”,”1212”,”2002”], target = “0202”<br>输出：6<br>解释：<br>可能的移动序列为 “0000” -&gt; “1000” -&gt; “1100” -&gt; “1200” -&gt; “1201” -&gt; “1202” -&gt; “0202”。<br>注意 “0000” -&gt; “0001” -&gt; “0002” -&gt; “0102” -&gt; “0202” 这样的序列是不能解锁的，<br>因为当拨动到 “0102” 时这个锁就会被锁定。</p>
</blockquote>
<p>这道题其实可以先考虑怎么遍历所有组合。<br>有 DFS 和 BFS 两种方式：</p>
<ul>
<li>DFS 法：迭代 0-9，组合到 4 个数字就记录；并且每次新的数都应该是上一个连续的</li>
<li>BFS 法：直接对’0000’计算，一个’0000’拨动之后可能有 8 种情况，即 “1000”, “9000”, “0100”, “0900”… 共 8 种密码。按照这个分支进行 BFS。</li>
</ul>
<p>因为这道题要考虑最短距离，也就是最少拨动次数，因此应该采用 BFS。</p>
<p>思路：</p>
<ol>
<li>首先将’0000’放入队列，然后出队，把 0000 的子元素放入；这里考虑的子元素实际上就是<strong>拨动一次</strong>的可能情况，也就是<code>&quot;1000&quot;, &quot;9000&quot;, &quot;0100&quot;, &quot;0900&quot;...</code>这样的 8 种情况。</li>
<li>按照 BFS 的方法，依次放入并处理重复的情况（比如’1000’不能再走回’0000’，会死循环）；如果遇到 deadends 中的元素就跳过本次循环，相当于这个树枝下面的路就堵死了。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">deadends</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> openLock = <span class="function"><span class="keyword">function</span> (<span class="params">deadends, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> minus = <span class="function">(<span class="params">str, idx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 选一位+1</span></span><br><span class="line">    <span class="keyword">const</span> tmp = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (tmp[idx] === <span class="string">&quot;0&quot;</span>) &#123;</span><br><span class="line">      tmp[idx] = <span class="string">&quot;9&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tmp[idx] = (+tmp[idx] - <span class="number">1</span>).toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> add = <span class="function">(<span class="params">str, idx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (tmp[idx] === <span class="string">&quot;9&quot;</span>) &#123;</span><br><span class="line">      tmp[idx] = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tmp[idx] = (+tmp[idx] + <span class="number">1</span>).toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> queue = [];</span><br><span class="line">  <span class="keyword">let</span> times = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>(deadends); <span class="comment">// 一开始就把deadends放入visited，就不用后续过滤了</span></span><br><span class="line">  queue.push(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (deadends.includes(<span class="string">&quot;0000&quot;</span>)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = queue.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> top = queue.shift();</span><br><span class="line">      <span class="keyword">if</span> (target === top) <span class="keyword">return</span> times;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; top.length; j++) &#123;</span><br><span class="line">        <span class="comment">// 遍历字符串的每一位，分别+1或-1</span></span><br><span class="line">        <span class="keyword">const</span> pre = minus(top, j);</span><br><span class="line">        <span class="keyword">if</span> (!visited.has(pre)) &#123;</span><br><span class="line">          visited.add(pre);</span><br><span class="line">          queue.push(pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> next = add(top, j);</span><br><span class="line">        <span class="keyword">if</span> (!visited.has(next)) &#123;</span><br><span class="line">          visited.add(next);</span><br><span class="line">          queue.push(next);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    times++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="图相关算法"><a href="#图相关算法" class="headerlink" title="图相关算法"></a>图相关算法</h1><h2 id="课程表问题（有向图的成环判断）"><a href="#课程表问题（有向图的成环判断）" class="headerlink" title="课程表问题（有向图的成环判断）"></a>课程表问题（有向图的成环判断）</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule/">https://leetcode.cn/problems/course-schedule/</a></p>
<blockquote>
<p>你这个学期必须选修 numCourses 门课程，记为  0  到  numCourses - 1 。<br>在选修某些课程之前需要一些先修课程。 先修课程按数组  prerequisites 给出，其中  prerequisites[i] = [ai, bi] ，表示如果要学习课程  ai 则 必须 先学习课程   bi 。<br>例如，先修课程对  [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。<br>请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。<br>输入：numCourses = 2, prerequisites = [[1,0]]<br>输出：true<br>解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</p>
</blockquote>
<p>这道题其实就是在判断是否存在循环依赖的情况，如果存在就不能正常修完课程。<br>数组 prerequisites 给出的关系，实际上就是这样一个有向图：</p>
<p><img src="https://pic.imgdb.cn/item/62dc0e8cf54cd3f937153d79.jpg"></p>
<p>我们需要做的，就是先构建这个图，然后判断这个图中有没有循环依赖，即有没有成环。</p>
<p>那么最简单的思路，就是通过 DFS 遍历整个图，如果有一个地方成环，就返回 false</p>
<p>当然首先还是要构建一个图，绝大多数情况下都采用邻接表的形式。设一个 map，<strong>key 为节点，value 为依赖于这个节点的其他节点</strong>，即该节点的后续节点。遍历的过程中通过<code>map[key]</code>就可以得到该节点连接的后续节点（因为是有向图，所以一定是后驱的节点）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canFinish = <span class="function"><span class="keyword">function</span> (<span class="params">numCourses, prerequisites</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prerequisite <span class="keyword">of</span> prerequisites) &#123;</span><br><span class="line">    <span class="keyword">const</span> [cur, pre] = prerequisite; <span class="comment">// cur表示当前课，pre表示当前课依赖的课</span></span><br><span class="line">    <span class="keyword">if</span> (!map.has(pre)) &#123;</span><br><span class="line">      map.set(pre, [cur]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      map.set(pre, [...map.get(pre), cur]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="keyword">const</span> onPath = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> hasCycle = <span class="literal">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (onPath.has(node)) &#123;</span><br><span class="line">      hasCycle = <span class="literal">true</span>; <span class="comment">// 如果本次路径path包含走过的节点，就说明成环了</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意这里的条件还有visited.has(node)</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">undefined</span> || hasCycle || visited.has(node)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    visited.add(node);</span><br><span class="line">    onPath.add(node);</span><br><span class="line">    <span class="keyword">const</span> neighbours = map.get(node); <span class="comment">// neighbours是后继节点数组</span></span><br><span class="line">    <span class="keyword">if</span> (neighbours &amp;&amp; neighbours.length) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> neighbour <span class="keyword">of</span> neighbours) &#123;</span><br><span class="line">        dfs(neighbour);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    onPath.delete(node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从每个节点开始都走一遍</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">    dfs(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> !hasCycle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第二种方法是 BFS，稍微麻烦一点，需要利用到有向图的特征，即入度和出度的概念。<br>对于每一个节点，依赖于它的课程可以被看作是由它指向外部的箭头，被它依赖的课程可以看作是指向它的箭头。一个课程如果入度不为 0，说明要修该课程就必须先修其他某个课，因此不能直接修这个课。同理，如果入度为 0 就可以立即修这门课。<br>一门课的入度可以减少，当它依赖的课被修完之后，这门课的入度就会-1，直到减为 0 就可以立即修这门课了。<br>整体来说就是这样一个思路：</p>
<ul>
<li>构建一个图</li>
<li>让入度为 0 的课入列，它们是能直接选的课。</li>
<li>然后逐个出列，出列代表着课被选，需要减小相关课的入度。“相关课”就是这门课的后继节点，也就是从邻接表<code>map[node]</code>得到的</li>
<li>如果相关课的入度新变为 0，安排它入列、再出列……直到没有入度为 0 的课可入列。</li>
</ul>
<p>另外，还需要一个数组记录每个节点的入度。每次增减入度都会对该数组操作，如果入度减为 0，就可以放入队列中。<br>每出队一门课，就相当于修了这门课，我们可以得到这门课的具体节点。而成环的课不会被修到。用一个 count 记录修课的数量，如果最终数量达到 numCourses，就说明可以修完。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canFinish = <span class="function"><span class="keyword">function</span> (<span class="params">numCourses, prerequisites</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> inDegrees = <span class="keyword">new</span> <span class="built_in">Array</span>(numCourses).fill(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prerequisite <span class="keyword">of</span> prerequisites) &#123;</span><br><span class="line">    <span class="keyword">const</span> [cur, pre] = prerequisite; <span class="comment">// cur表示当前课，pre表示依赖的课</span></span><br><span class="line">    inDegrees[cur]++;</span><br><span class="line">    <span class="keyword">if</span> (!map.has(pre)) &#123;</span><br><span class="line">      map.set(pre, [cur]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      map.set(pre, [...map.get(pre), cur]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 队列中始终都是入度为的节点，出队表示修了该门课</span></span><br><span class="line">  <span class="keyword">const</span> queue = [];</span><br><span class="line">  <span class="comment">// 先把所有入度为0的入队</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inDegrees[i] === <span class="number">0</span>) queue.push(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> top = queue.shift();</span><br><span class="line">    <span class="comment">// 获取到该门课的后继课</span></span><br><span class="line">    <span class="keyword">const</span> lessons = map.get(top);</span><br><span class="line">    count++; <span class="comment">// 这里其实可以得到完整的修课顺序</span></span><br><span class="line">    <span class="keyword">if</span> (lessons &amp;&amp; lessons.length) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> lesson <span class="keyword">of</span> lessons) &#123;</span><br><span class="line">        <span class="comment">// 只要遍历到某门课，就给这门课的入度-1，减为0就可以入队</span></span><br><span class="line">        <span class="keyword">if</span> (--inDegrees[lesson] === <span class="number">0</span>) queue.push(lesson);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count === numCourses;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>这道题的第二题，即课程表 II，就是在这个基础上，返回合适的修课顺序即可。这种把相互依赖的有向图转化为一个正确遍历顺序的算法叫做<strong>拓扑排序</strong></p>
<p>下面就是第二题的代码，其实就是记录了路径而已</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findOrder = <span class="function"><span class="keyword">function</span> (<span class="params">numCourses, prerequisites</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> inDegrees = <span class="keyword">new</span> <span class="built_in">Array</span>(numCourses).fill(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prerequisite <span class="keyword">of</span> prerequisites) &#123;</span><br><span class="line">    <span class="keyword">const</span> [cur, pre] = prerequisite;</span><br><span class="line">    inDegrees[cur]++;</span><br><span class="line">    <span class="keyword">if</span> (!map.has(pre)) &#123;</span><br><span class="line">      map.set(pre, [cur]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      map.set(pre, [...map.get(pre), cur]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> queue = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inDegrees[i] === <span class="number">0</span>) queue.push(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> top = queue.shift();</span><br><span class="line">    <span class="keyword">const</span> lessons = map.get(top);</span><br><span class="line">    res.push(top); <span class="comment">// 这里记录路径</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (lessons &amp;&amp; lessons.length) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> lesson <span class="keyword">of</span> lessons) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--inDegrees[lesson] === <span class="number">0</span>) queue.push(lesson);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count === numCourses ? res : [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然第二题也有 dfs 解法，其实也是在第一题的基础上记录路径、判断成环。</p>
<p>实际上 dfs 每次递归，只要不在 onPath 和 visited 中，就是该路径的合理经过节点。因此每次在判断完 onPath 和 visited 通过之后就可以记录下来，最后会形成走过的路径。<br><strong>DFS 实现的拓扑排序，是在后序位置记录路径，再将路径反转</strong>。至于原因可以参考这个树：<br><img src="https://pic.imgdb.cn/item/62dc1d0bf54cd3f937721930.jpg"><br>一个节点只有依赖的所有节点遍历过，才能遍历该节点。对于这个数来说，从下向上看，每个节点只有等到其子节点都遍历过，才能遍历该节点。因此后序遍历的结果其实就是把这个图中的箭头全部反过来的合理排序；那么如果把后序遍历的结果 reverse，就是合理的拓扑排序结果</p>
<blockquote>
<p>不一定需要翻转，如果建图时，邻接表中每个节点 key 的 value 是该节点的前驱节点而不是后继节点，即表示依赖于而不是被依赖的节点数组，就不需要翻转</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findOrder = <span class="function"><span class="keyword">function</span> (<span class="params">numCourses, prerequisites</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prerequisite <span class="keyword">of</span> prerequisites) &#123;</span><br><span class="line">    <span class="keyword">const</span> [cur, pre] = prerequisite; <span class="comment">// cur表示当前课，pre表示依赖的课</span></span><br><span class="line">    <span class="keyword">if</span> (!map.has(pre)) &#123;</span><br><span class="line">      map.set(pre, [cur]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      map.set(pre, [...map.get(pre), cur]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="keyword">const</span> onPath = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="keyword">const</span> path = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> hasCycle = <span class="literal">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注意这里应该先改变hasCycle，否则可能导致visited中有该节点，而还没来得及更改成环就直接跳过</span></span><br><span class="line">    <span class="keyword">if</span> (onPath.has(node)) &#123;</span><br><span class="line">      hasCycle = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasCycle || visited.has(node)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    visited.add(node);</span><br><span class="line">    onPath.add(node);</span><br><span class="line">    <span class="keyword">const</span> neighbours = map.get(node) || [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> neighbour <span class="keyword">of</span> neighbours) &#123;</span><br><span class="line">      dfs(neighbour);</span><br><span class="line">    &#125;</span><br><span class="line">    path.push(node); <span class="comment">// 后序位置记录节点</span></span><br><span class="line">    onPath.delete(node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">    dfs(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hasCycle ? [] : path.reverse();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><p>二分图的定义：二分图的顶点集可分割为两个互不相交的子集，图中每条边依附的两个顶点都分属于这两个子集，且两个子集内的顶点不相邻。<br>换句话说就是，二分图图的每个边都可以做到该边的左右两个顶点颜色不同。如果不能做到，就不是二分图</p>
<p><img src="https://pic.imgdb.cn/item/62dccf2af54cd3f937e052e0.jpg"></p>
<p>二分图的问题主要就是判断是否是二分图，以及判断可能的二分法。<br>先来说二分图的判定，主要思路就是遍历一遍图，一边遍历一边染色，看看能不能用两种颜色给所有节点染色，且相邻节点的颜色都不相同。<br>在遍历过程中（DFS），每次先判断某个顶点的邻居是否被遍历过。</p>
<ul>
<li>如果没遍历过，就给邻居染上不同颜色。可以用一个布尔值数组表示某个顶点的颜色，这样就可以直接令<code>colors[neighbors] = !colors[node]</code>即可</li>
<li>如果遍历过，就判断邻居颜色和自己是否相同。一旦相同就说明不是二分图</li>
</ul>
<p>初始化可以考虑一个全为 true 的 colors 数组，用于表示每个元素的颜色；</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isBipartite = <span class="function"><span class="keyword">function</span> (<span class="params">graph</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 邻接表图</span></span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">    map.set(i, [...graph[i]]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="comment">// color为true和false的区别</span></span><br><span class="line">  <span class="keyword">const</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(graph.length).fill(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">let</span> isBipartite = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isBipartite || visited.has(node)) <span class="keyword">return</span>;</span><br><span class="line">    visited.add(node);</span><br><span class="line">    <span class="keyword">const</span> neighbours = map.get(node) || [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> neighbour <span class="keyword">of</span> neighbours) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!visited.has(neighbour)) &#123;</span><br><span class="line">        <span class="comment">// 给邻居染上不同颜色</span></span><br><span class="line">        colors[neighbour] = !colors[node];</span><br><span class="line">        dfs(neighbour);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果颜色相同就说明不是二分</span></span><br><span class="line">        <span class="keyword">if</span> (colors[neighbour] === colors[node]) isBipartite = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">    dfs(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isBipartite;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="特殊数据结构"><a href="#特殊数据结构" class="headerlink" title="特殊数据结构"></a>特殊数据结构</h1><h2 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表是一类可以很快查找数据的顺序存储结构。对于数组来说查找一个定值的最快速度也是 O(logn)，但是哈希表可以做到 O(1).</p>
<p>哈希表的实现原理就是通过一个 key 来快速确定存储的 value 的位置。通常数组只有一个顺序索引，而哈希表会用生成的唯一的哈希值作为索引。当查找一个数据时，通过转换为哈希值的形式就可以快速找到对应的值。</p>
<p>转换哈希值的函数叫做哈希函数。</p>
<p>举个例子，比如要存储学校里所有学生的姓名到一个哈希表中：</p>
<p><img src="https://pic.imgdb.cn/item/62d3b2f0f54cd3f9373aaf38.jpg"></p>
<p>通过哈希函数转换之后，得到的结果就可以存在表中。</p>
<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>常见的哈希函数有：（x 表示原本的值）</p>
<ul>
<li>除留取余法：<code>H(x) = x % p</code>，p 一般取不超过 s 的最大质数</li>
<li>直接定址法：<code>H(x) = a * x + b</code>，线性确定地址，比较简单的定址方法，但是可能比较浪费空间</li>
<li>折叠法、平方取中法、数字分析法：都是对数字型的键或哈希值操作，得到地址。</li>
</ul>
<h3 id="哈希冲突（哈希碰撞）"><a href="#哈希冲突（哈希碰撞）" class="headerlink" title="哈希冲突（哈希碰撞）"></a>哈希冲突（哈希碰撞）</h3><p>当哈希表的大小没那么大，或者哈希函数的特点决定的，会导致计算出的地址相同。这时就会产生哈希冲突。</p>
<p>比如 H(x) = x % 5 这种算法，6 和 11 都会计算出 1,此时就会产生冲突</p>
<p>哈希碰撞有两种解决方法：</p>
<ul>
<li>拉链法（链接地址法）：就是将重复的元素按照链表拉成一链，放在冲突的地址后面。<br><img src="https://pic.imgdb.cn/item/62d3b6b1f54cd3f937403ed5.jpg"></li>
<li>线性探测法：向后找一个地址，放下冲突的数据。前提是哈希表的大小要大于总数据量</li>
</ul>
<h3 id="js-实现哈希表"><a href="#js-实现哈希表" class="headerlink" title="js 实现哈希表"></a>js 实现哈希表</h3><p>基本哈希表的实现类似于手动实现一个类似 Map 的数据结构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashMap</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">size = <span class="number">10</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.table = <span class="keyword">new</span> <span class="built_in">Array</span>(size); <span class="comment">// 类似map的二维数组</span></span><br><span class="line">    <span class="built_in">this</span>.maxLen = size;</span><br><span class="line">    <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 哈希函数</span></span><br><span class="line">  <span class="function"><span class="title">hashFunction</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> code = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line">      code += s.charCodeAt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里哈希值的计算只是一种方式</span></span><br><span class="line">    <span class="comment">//  除留取余法</span></span><br><span class="line">    <span class="keyword">return</span> code % <span class="built_in">this</span>.maxLen;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">key, val</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> hashKey = <span class="built_in">this</span>.hashFunction(key);</span><br><span class="line">    <span class="comment">// 考虑哈希冲突</span></span><br><span class="line">    <span class="comment">// 如果当前位置已经有值，就线性查找下一个有空的地方</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>.table[hashKey] != <span class="literal">undefined</span> &amp;&amp; <span class="built_in">this</span>.table[hashKey][<span class="number">0</span>] !== key) &#123;</span><br><span class="line">      hashKey++;</span><br><span class="line">      <span class="keyword">if</span> (hashKey &gt;= <span class="built_in">this</span>.maxLen) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;无可用空间&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.table[hashKey] = [key, val];</span><br><span class="line">    <span class="built_in">this</span>.size++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> hashKey = <span class="built_in">this</span>.hashFunction(key);</span><br><span class="line">    <span class="comment">// get时同理，如果当前位置的值对应的键（table[hashKey][0]）不是要查找的key，就顺序向后找</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>.table[hashKey] != <span class="literal">undefined</span> &amp;&amp; <span class="built_in">this</span>.table[hashKey][<span class="number">0</span>] !== key) &#123;</span><br><span class="line">      hashKey++;</span><br><span class="line">      <span class="keyword">if</span> (hashKey &gt;= <span class="built_in">this</span>.maxLen) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.table[hashKey][<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">has</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.get(key) === <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">delete</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.has(key)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> hashKey = <span class="built_in">this</span>.hashFunction(key);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>.table[hashKey] != <span class="literal">undefined</span> &amp;&amp; <span class="built_in">this</span>.table[hashKey][<span class="number">0</span>] !== key) &#123;</span><br><span class="line">      hashKey++;</span><br><span class="line">      <span class="keyword">if</span> (hashKey &gt;= <span class="built_in">this</span>.maxLen) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.table[hashKey];</span><br><span class="line">    <span class="built_in">this</span>.size--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>常见的堆结构实际上是最小/最大二叉堆的形式。<br>二叉堆本质是一个完全二叉树，在具体数据结构上，我们用一个数组表示：</p>
<p><img src="https://pic.imgdb.cn/item/62d3d2bef54cd3f9376dbc36.jpg"></p>
<p>而最小/最大二叉堆就是对这个堆的排序。<br>最小二叉堆的定义是：每个节点都不大于其左子和右子节点的完全二叉树。因此实现上主要考虑把数组调整达到这个目的。</p>
<p>最小二叉堆的实现：</p>
<ol>
<li>首先以一个数组为基础结构。对于任意一个位置上的节点，可以得到其左子节点和右子节点以及父节点的位置</li>
</ol>
<ul>
<li>左子节点：2i-1</li>
<li>右子节点：2i+1</li>
<li>父节点：(i-1)/2</li>
</ul>
<ol start="2">
<li>当插入一个值时，首先先将其 push 到数组最尾端。然后从这个位置开始自下向上调整：</li>
</ol>
<ul>
<li>如果当前值比其父节点值大，就保持不动</li>
<li>如果比父元素小，就和父元素交换位置，然后再从父元素位置开始，继续向上调整，直到确保最小堆的结构特点</li>
</ul>
<ol start="3">
<li>对于调整完毕的二叉堆，堆顶元素一定是最小值。如果要找第二小的值，可以将堆顶值 shift，然后将堆尾元素 unshift 到堆顶，再从上向下进行调整。从上向下调整称作“堆化”，是二叉堆最重要的实现。在堆排序，初始化完成数组后，每一次堆化都会得到当前数组中最小的值。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.heap = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getLeftChildIndex</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">1</span> &gt;= <span class="built_in">this</span>.heap.length ? <span class="literal">null</span> : <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getRightChildIndex</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">2</span> &gt;= <span class="built_in">this</span>.heap.length ? <span class="literal">null</span> : <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getParentIndex</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> index === <span class="number">0</span> ? <span class="literal">null</span> : <span class="built_in">Math</span>.floor((index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">swap</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">    [<span class="built_in">this</span>.heap[a], <span class="built_in">this</span>.heap[b]] = [<span class="built_in">this</span>.heap[b], <span class="built_in">this</span>.heap[a]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.heap.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.heap.push(value);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.heap.push(value);</span><br><span class="line">    <span class="built_in">this</span>.shiftUp(<span class="built_in">this</span>.heap.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">min</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.heap.length === <span class="number">0</span> ? <span class="literal">null</span> : <span class="built_in">this</span>.heap[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">pop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.heap.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> removedValue = <span class="built_in">this</span>.heap.shift();</span><br><span class="line">      <span class="built_in">this</span>.heap.unshift(<span class="built_in">this</span>.heap.pop()); <span class="comment">// 把底部元素插入根</span></span><br><span class="line">      <span class="built_in">this</span>.heap.length &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">this</span>.shiftDown(<span class="number">0</span>); <span class="comment">// 从上向下调整</span></span><br><span class="line">      <span class="keyword">return</span> removedValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向上调整</span></span><br><span class="line">  <span class="function"><span class="title">shiftUp</span>(<span class="params">currIndex</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> parentIndex = <span class="built_in">this</span>.getParentIndex(currIndex); <span class="comment">// 获取父节点位置</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.heap[currIndex] &gt; <span class="built_in">this</span>.heap[parentIndex] || currIndex &lt;= <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 如果当前比父节点大就不动</span></span><br><span class="line">    <span class="built_in">this</span>.swap(currIndex, parentIndex); <span class="comment">// 交换父节点和当前节点</span></span><br><span class="line">    <span class="built_in">this</span>.shiftUp(parentIndex); <span class="comment">// 递归传入父节点位置，直到整个堆调整完毕</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向上的非递归版本</span></span><br><span class="line">  <span class="function"><span class="title">shiftUp</span>(<span class="params">currIndex</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>.heap[currIndex] &lt; <span class="built_in">this</span>.heap[parentIndex] &amp;&amp; currIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.swap(currIndex, <span class="built_in">this</span>.getParentIndex(currIndex));</span><br><span class="line">      currIndex = <span class="built_in">this</span>.getParentIndex(currIndex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向下调整</span></span><br><span class="line">  <span class="function"><span class="title">shiftDown</span>(<span class="params">currIndex</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> leftIndex = <span class="built_in">this</span>.getLeftChildIndex(currIndex); <span class="comment">// 获取左右子元素索引</span></span><br><span class="line">    <span class="keyword">const</span> rightIndex = <span class="built_in">this</span>.getRightChildIndex(currIndex);</span><br><span class="line">    <span class="comment">// 如果当前元素比左右子元素大，选择左右元素较小的一个交换并递归</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="built_in">this</span>.heap[currIndex] &gt; <span class="built_in">this</span>.heap[leftIndex] ||</span><br><span class="line">      <span class="built_in">this</span>.heap[currIndex] &gt; <span class="built_in">this</span>.heap[rightIndex]</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">const</span> tmpIndex =</span><br><span class="line">        <span class="built_in">this</span>.heap[leftIndex] &gt; <span class="built_in">this</span>.heap[rightIndex] ? rightIndex : leftIndex;</span><br><span class="line">      <span class="built_in">this</span>.swap(currIndex, tmpIndex);</span><br><span class="line">      <span class="built_in">this</span>.shiftDown(tmpIndex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序实际上是利用了堆的原理，但是并不需要一个完整的堆数据结构。</p>
<p>堆排序主要的步骤有两个：</p>
<ol>
<li>构建大顶堆。</li>
<li>依次把大顶堆的最大的数和最后一个数交换，然后继续处理前面的数，直到全部有序为止。如图所示：<br><img src="https://pic.imgdb.cn/item/62d3e6d5f54cd3f9378e981a.jpg"><br>每次得到堆顶的最大数，把这个数放到数组后面，然后再对前面的数排序，最后就可以得到一个升序数组。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">arr, a, b</span>) =&gt;</span> ([arr[a], arr[b]] = [arr[b], arr[a]]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大顶堆的shiftDown</span></span><br><span class="line"><span class="comment">// 注意参数必须要限制heapSize，即只处理堆的一部分而不是全部，后面排序好的部分不再参与</span></span><br><span class="line"><span class="keyword">const</span> heapify = <span class="function">(<span class="params">heap, index, heapSize = heap.length</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> left = <span class="number">2</span> * index + <span class="number">1</span> &gt; heapSize ? <span class="literal">null</span> : <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> right = <span class="number">2</span> * index + <span class="number">2</span> &gt; heapSize ? <span class="literal">null</span> : <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里后面都是大于号，如果是小顶堆换成小于号就行</span></span><br><span class="line">  <span class="keyword">if</span> (heap[left] &gt; heap[index] || heap[right] &gt; heap[index]) &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp = heap[left] &gt; heap[right] ? left : right;</span><br><span class="line">    swap(heap, tmp, index);</span><br><span class="line">    heapify(heap, tmp, heapSize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> heapSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 首先构建大顶堆。</span></span><br><span class="line">  <span class="comment">// 从第一个非子元素开始，从上向下原地建堆</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    heapify(arr, i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    swap(arr, <span class="number">0</span>, len); <span class="comment">// 交换第一个元素和最后一个范围内的元素</span></span><br><span class="line">    len--; <span class="comment">// 范围缩短，因为最后一个元素此时已经是最大</span></span><br><span class="line">    heapify(arr, <span class="number">0</span>, len); <span class="comment">//处理范围内的</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Top-K"><a href="#Top-K" class="headerlink" title="Top K"></a>Top K</h3><p>有了上一步堆排序，其实 Top K 问题也就很好解决了。</p>
<p>如果要求前 K 个最大的数，只需要在上面的基础上限制循环次数为 k 即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其他代码不变</span></span><br><span class="line"><span class="keyword">const</span> TopK = <span class="function">(<span class="params">arr, k</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    heapify(arr, i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">    swap(arr, <span class="number">0</span>, len);</span><br><span class="line">    len--;</span><br><span class="line">    heapify(arr, <span class="number">0</span>, len);</span><br><span class="line">    res.push(arr[arr.length - i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果是 K 个最小的数，就需要反过来，从小顶堆得到。<br>小顶堆和大顶堆的唯一区别：把 heapify 函数中的大于号和小于号统一换个方向就行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> heapify = <span class="function">(<span class="params">heap, index, heapSize = heap.length</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> left = <span class="number">2</span> * index + <span class="number">1</span> &gt; heapSize ? <span class="literal">null</span> : <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> right = <span class="number">2</span> * index + <span class="number">2</span> &gt; heapSize ? <span class="literal">null</span> : <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从这里后面的全换成小于号</span></span><br><span class="line">  <span class="keyword">if</span> (heap[left] &lt; heap[index] || heap[right] &lt; heap[index]) &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp = heap[left] &lt; heap[right] ? left : right;</span><br><span class="line">    swap(heap, tmp, index);</span><br><span class="line">    heapify(heap, tmp, heapSize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图的表示方法：</p>
<ul>
<li><p>邻接矩阵：最直观，但是比较浪费空间<br><img src="https://pic.imgdb.cn/item/62d3ff7df54cd3f937b234a0.jpg"></p>
</li>
<li><p>邻接表：省空间，常用方法</p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/62d3ff89f54cd3f937b2464c.jpg"></p>
<ul>
<li>关联矩阵：矩阵的行表示顶点，列表示边，如果一个顶点和两个边连接则表示为 1，否则是 0。<br>常用于于边的数量比顶点多的情况，节省内存</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/62d40024f54cd3f937b32634.jpg"></p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>js 实现邻接表表示图主要通过 map，map 中的每一项的键是一个顶点，值是相连的顶点组成的链表（这里用有序数组）<br>同时还需要一个记录所有节点的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">isDirected = <span class="literal">false</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.isDirected = isDirected; <span class="comment">// 有向图</span></span><br><span class="line">    <span class="built_in">this</span>.vertices = []; <span class="comment">// 所有顶点</span></span><br><span class="line">    <span class="built_in">this</span>.adjList = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 邻接表</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加顶点</span></span><br><span class="line">  <span class="function"><span class="title">addVertex</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.vertices.includes(v)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.vertices.push(v);</span><br><span class="line">      <span class="built_in">this</span>.adjList.set(v, []); <span class="comment">// 邻接表的每一项的值都是一个数组,包含和该节点相邻的其他节点</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加边,参数是两个顶点</span></span><br><span class="line">  <span class="function"><span class="title">addEdge</span>(<span class="params">v, w</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.adjList.has(v)) <span class="built_in">this</span>.addVertex(v);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.adjList.has(w)) <span class="built_in">this</span>.addVertex(w);</span><br><span class="line">    <span class="built_in">this</span>.adjList.get(v).push(w); <span class="comment">// v顶点的邻接数组加入w</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isDirected) <span class="built_in">this</span>.adjList.get(w).push(v); <span class="comment">// 如果是无向图,w也需要</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>邻接表在大多数题目对应的都是有向图，其中每个节点 key 表示有出度的节点，而只有入度的节点一般不会在 key 中；每个节点 key 对应的的 value 都是该节点的后继节点，即依赖于该节点的节点。<br>比如这样一幅图，邻接表应该这样表示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的序号就是key，即节点0-3</span></span><br><span class="line"><span class="keyword">const</span> graph = [[<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">3</span>], [<span class="number">4</span>]];</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/62dcd7cff54cd3f937140a44.jpg"></p>
<p>如果是无向图，就可以看作是双向图，这时连接两边的两个节点都应该存在，即节点 key 应当包含每个节点，并且 value 是自己相连的全部节点，而不只是单向的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> graph = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>图的遍历和树基本相似，主要的两种方法同样是 DFS 和 BFS。</p>
<p>但是注意的是，图是有可能包含环的。因此必须要考虑避免环的情况，已经访问过的节点不能再次访问。</p>
<p>图的 BFS 遍历：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BFS</span>(<span class="params">graph, start</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> adjList = graph.adjList; <span class="comment">// 邻接表</span></span><br><span class="line">  <span class="keyword">const</span> queue = [];</span><br><span class="line">  queue.push(start);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> u = queue.shift();</span><br><span class="line">    <span class="keyword">if</span> (visited.has(u)) <span class="keyword">continue</span>;</span><br><span class="line">    visited.add(u);</span><br><span class="line">    <span class="keyword">const</span> neighbors = adjList.get(u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> w <span class="keyword">of</span> neighbors) &#123;</span><br><span class="line">      queue.push(w);</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果希望通过 BFS 记录路径，就不能这样写。queue 中不应该只是每个节点，而是<strong>到该节点为止前面走过的路径</strong>，也就应该是一个数组。每次 shift 得到一组路径，这组路径的最后一项就是当前走到的位置，以这一项为基准再获取其相邻的节点，拼接放入数组。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BFS</span>(<span class="params">graph</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> n = graph.length;</span><br><span class="line">  <span class="comment">// 队列的每一项表示到该节点为止走过的路径数组</span></span><br><span class="line">  <span class="keyword">const</span> queue = [[<span class="number">0</span>]];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> top = queue.shift();</span><br><span class="line">    <span class="comment">// 每一项是一个数组，这个数组的最后一项就是当前走到的那个节点last</span></span><br><span class="line">    <span class="keyword">const</span> last = top[top.length - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 获取last的相邻节点，依次遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> neighbour <span class="keyword">of</span> graph[last]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="comment">/*走到终点*/</span>)&#123;</span><br><span class="line">        res.push([...top, neighbour]);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 没走到终点，继续添加当前项的相邻节点到queue中</span></span><br><span class="line">        <span class="comment">// 这里push的是一个新数组，也就是在当前路径的基础上又添加了新的一步</span></span><br><span class="line">        <span class="comment">// 比如原先的路径是[[0,1]]，1和2、3相邻，那么这里就相当于把[0,1]弹出，然后再追加为[[0,1,2],[0,1,3]]。</span></span><br><span class="line">        queue.push([...top, neighbour]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DFS 遍历：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DFS</span>(<span class="params">graph, start</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> adjList = graph.adjList;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="comment">// visited记录的是总共走过的节点，即不论是从哪个节点开始的，只要该节点走过就进入visited</span></span><br><span class="line">  <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="comment">// path记录的是当前这个路径下走过的节点，即本次走过的路径，判断成环时是必要的</span></span><br><span class="line">  <span class="comment">// 如果要记录走过的路径，path也会记录</span></span><br><span class="line">  <span class="keyword">const</span> path = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (visited.has(node)) <span class="keyword">return</span>;</span><br><span class="line">    visited.add(node);</span><br><span class="line">    path.add(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以在这里得到走过的路径</span></span><br><span class="line">    <span class="comment">// 先序位置记录路径</span></span><br><span class="line">    <span class="comment">// if(...)&#123;</span></span><br><span class="line">    <span class="comment">//   paths.push([...path])</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出节点</span></span><br><span class="line">    res.push(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> neis = adjList.get(node);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> neighbor <span class="keyword">of</span> neighbors) &#123;</span><br><span class="line">      dfs(neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// path在遍历完之后需要删除，相当于本次走过了，下次重新统计，类似回溯</span></span><br><span class="line">    <span class="comment">// 这里是拓扑排序记录路径的地方（后序位置记录路径）</span></span><br><span class="line">    path.delete(node);</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(start);</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外还有一点，很多题的 DFS 都需要从每个顶点作为起点遍历图，即类似这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(...)&#123;</span><br><span class="line">  dfs(node[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果题目明确指明起点，显然就从起点开始就行。否则其他大多数需要走遍完整图的算法（拓扑排序、二分图、并查集等）都需要这样遍历</p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集是解决图论中「动态连通性」问题的。即，图可能有多个节点，这些节点之间的连接可以看作是一种连通。图的每个节点之间可能相互连通，也可能孤立成小岛</p>
<p><img src="https://pic.imgdb.cn/item/62dce9c1f54cd3f937811caa.jpg"></p>
<p>比如在这个图中，有两个独立的“小岛”，那么我们就可以称该图的连通分量数目为 2。如果把 2 和 3 连接起来变成一整个图，连通分量就会变为 1。处理连通分量动态变化的数据结构就叫做并查集</p>
<p>并查集的结构本质是一个森林，即若干个独立的图的结合。在实际的数据结构实现上，可以通过数组实现并查集。基本数据结构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">n</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.count = n;</span><br><span class="line">    <span class="built_in">this</span>.parent = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 连通p和q</span></span><br><span class="line">  <span class="function"><span class="title">union</span>(<span class="params">p, q</span>)</span> &#123;&#125;</span><br><span class="line">  <span class="comment">// 检查p和q的连通性</span></span><br><span class="line">  <span class="function"><span class="title">connected</span>(<span class="params">p, q</span>)</span> &#123;&#125;</span><br><span class="line">  <span class="comment">// 找到p的根节点</span></span><br><span class="line">  <span class="function"><span class="title">find</span>(<span class="params">p</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要特点如下：</p>
<ul>
<li>设定树的每个节点有一个指针指向其父节点，如果是根节点的话，这个指针指向自己。具体来说，通过一个 parent 数组用来记录每个节点的父节点。初始化每个节点的父节点都指向自己</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/62dceafef54cd3f937890fac.jpg"></p>
<ul>
<li>如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上。这样，如果节点 p 和 q 连通的话，它们一定拥有相同的根节点</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/62dceb0ff54cd3f937897cd5.jpg"></p>
<ul>
<li>优化层面，连接和检查连接的算法都依赖于 find，因此 find 的时间复杂度会影响整个的复杂度。find 函数的基本操作是逐个向上遍历查找父节点，显然如果树高越小，find 就查找的越快。因此应该尽可能减少树的高度<br><img src="https://pic.imgdb.cn/item/62dcecc4f54cd3f937946fce.jpg"></li>
</ul>
<p>并查集代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">n</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.count = n;</span><br><span class="line">    <span class="built_in">this</span>.parent = []; <span class="comment">// parent[i]表示节点i的父节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">this</span>.parent[i] = i; <span class="comment">// 每个节点初始化是自己的父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">union</span>(<span class="params">p, q</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取p和q的根节点</span></span><br><span class="line">    <span class="keyword">const</span> [rootP, rootQ] = [<span class="built_in">this</span>.find(p), <span class="built_in">this</span>.find(q)];</span><br><span class="line">    <span class="keyword">if</span> (rootP === rootQ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 连通两棵树：一个的根节点的父节点设置为另一个的根节点即可</span></span><br><span class="line">    <span class="built_in">this</span>.parent[rootP] = rootQ;</span><br><span class="line">    <span class="built_in">this</span>.count--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">connected</span>(<span class="params">p, q</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断两个节点的根节点是否相同</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.find(p) === <span class="built_in">this</span>.find(q);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">find</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 基本算法是找到根节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.parent[node] !== node) &#123;</span><br><span class="line">      <span class="comment">// 如果当前节点不是自己的父节点，说明不是根节点，就继续递归</span></span><br><span class="line">      <span class="comment">// 每次递归都把当前节点向上挂载一层，直到根节点</span></span><br><span class="line">      <span class="comment">// 因此所有最后的节点都会直接连在根节点上，通过parent[node]就可以直接得到根节点</span></span><br><span class="line">      <span class="built_in">this</span>.parent[node] = <span class="built_in">this</span>.find(<span class="built_in">this</span>.parent[node]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.parent[node];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="其他类型题目"><a href="#其他类型题目" class="headerlink" title="其他类型题目"></a>其他类型题目</h1><h2 id="圆圈中最后剩下的数字"><a href="#圆圈中最后剩下的数字" class="headerlink" title="圆圈中最后剩下的数字"></a>圆圈中最后剩下的数字</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</a></p>
<p>这道题的最佳解法是数学解法，但是用循环链表暴力计算也可以得出，只是会超时。<br>这里先放上会超时的代码，如果不考虑超时的话这个写法是没问题的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListNode</span>(<span class="params">val, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.val = val || <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">this</span>.next = next || <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> createLinkList = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">let</span> p = head;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> listNode = <span class="keyword">new</span> ListNode(i);</span><br><span class="line">    p.next = listNode;</span><br><span class="line">    p = p.next;</span><br><span class="line">  &#125;</span><br><span class="line">  p.next = head;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">last</span>: p, head &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">m</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lastRemaining = <span class="function"><span class="keyword">function</span> (<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; head, last &#125; = createLinkList(n);</span><br><span class="line">  <span class="keyword">let</span> p = head;</span><br><span class="line">  <span class="keyword">let</span> prev = last;</span><br><span class="line">  <span class="keyword">let</span> cnt = n;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; (m &gt; cnt ? m % cnt : m); i++) &#123;</span><br><span class="line">      prev = p;</span><br><span class="line">      p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    prev.next = prev.next.next;</span><br><span class="line">    p = prev.next;</span><br><span class="line">    cnt--;</span><br><span class="line">    <span class="keyword">if</span> (p === prev) <span class="keyword">return</span> p.val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="字符串乘法"><a href="#字符串乘法" class="headerlink" title="字符串乘法"></a>字符串乘法</h2><blockquote>
<p>给定两个以字符串形式表示的非负整数  num1  和  num2，返回  num1  和  num2  的乘积，它们的乘积也表示为字符串形式。<br>注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p>
</blockquote>
<p>这个题不是很难，但是很麻烦。思路就是把成绩拆成先个位数相乘，然后末尾加上若干个 0（表示十位数百位数这样），最后再加起来</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (num1 == <span class="number">0</span> || num2 == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> addZero = <span class="function">(<span class="params">str, amount, dire = <span class="string">&quot;back&quot;</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> arr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; amount; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dire === <span class="string">&quot;back&quot;</span>) arr.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> arr.unshift(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mult1 = <span class="function">(<span class="params">str, num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> acc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = str.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">let</span> val = <span class="built_in">Math</span>.floor((acc + str[i] * num) % <span class="number">10</span>);</span><br><span class="line">    acc = <span class="built_in">Math</span>.floor((acc + str[i] * num) / <span class="number">10</span>);</span><br><span class="line">    res.unshift(val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (acc !== <span class="number">0</span>) res.unshift(acc);</span><br><span class="line">  <span class="keyword">return</span> res.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">str1, str2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [len1, len2] = [str1.length, str2.length];</span><br><span class="line">  <span class="keyword">const</span> len = <span class="built_in">Math</span>.max(len1, len2);</span><br><span class="line">  <span class="keyword">if</span> (len1 &gt; len2) &#123;</span><br><span class="line">    str2 = addZero(str2, len1 - len2, <span class="string">&quot;front&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len1 &lt; len2) &#123;</span><br><span class="line">    str1 = addZero(str1, len2 - len1, <span class="string">&quot;front&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> acc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">let</span> val = <span class="built_in">Math</span>.floor(</span><br><span class="line">      (acc + <span class="built_in">Number</span>(str1[i] || <span class="number">0</span>) + <span class="built_in">Number</span>(str2[i] || <span class="number">0</span>)) % <span class="number">10</span></span><br><span class="line">    );</span><br><span class="line">    acc = <span class="built_in">Math</span>.floor((acc + <span class="built_in">Number</span>(str1[i] || <span class="number">0</span>) + <span class="built_in">Number</span>(str2[i] || <span class="number">0</span>)) / <span class="number">10</span>);</span><br><span class="line">    res.unshift(val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (acc !== <span class="number">0</span>) res.unshift(acc);</span><br><span class="line">  <span class="keyword">return</span> res.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum = <span class="string">&quot;0&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> longerNum = num1.length &gt; num2.length ? num1 : num2;</span><br><span class="line"><span class="keyword">const</span> shoterNum = num1.length &lt;= num2.length ? num1 : num2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = shoterNum.length - <span class="number">1</span>, i = <span class="number">0</span>; j &gt;= <span class="number">0</span>; j--, i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = mult1(longerNum, shoterNum[j]);</span><br><span class="line">  res = addZero(res, i);</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  sum = add(sum, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br></pre></td></tr></table></figure>

<h2 id="旋转一个矩阵"><a href="#旋转一个矩阵" class="headerlink" title="旋转一个矩阵"></a>旋转一个矩阵</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-image/">https://leetcode.cn/problems/rotate-image/</a></p>
<blockquote>
<p>给定一个 n × n 的二维矩阵  matrix 表示一个图像。请你将图像顺时针旋转 90 度。<br>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
</blockquote>
<p>这个题其实关键在于思路，思路有了代码很好写。<br>思路就是：一个矩阵顺时针旋转 90°，就相当于先按照从左上到右下的对角线两两交换值，然后再两两交换对应的列即可（比如第一列和第四列，第二列和第三列这样）。<br>如果是逆时针，就把对角线变成右上到左下即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">matrix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> m = matrix.length;</span><br><span class="line">  <span class="keyword">const</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="comment">// 注意这里j从i开始，否则就会又转回去了</span></span><br><span class="line">      [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n / <span class="number">2</span>; j++) &#123;</span><br><span class="line">      [matrix[i][j], matrix[i][n - j - <span class="number">1</span>]] = [</span><br><span class="line">        matrix[i][n - j - <span class="number">1</span>],</span><br><span class="line">        matrix[i][j],</span><br><span class="line">      ];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="简化路径"><a href="#简化路径" class="headerlink" title="简化路径"></a>简化路径</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/simplify-path/">https://leetcode.cn/problems/simplify-path/</a></p>
<p>思路其实不是很复杂，主要是通过栈。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">path</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> simplifyPath = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (path[path.length - <span class="number">1</span>] === <span class="string">&quot;/&quot;</span>) path = path.slice(<span class="number">0</span>, path.length - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (path[<span class="number">0</span>] !== <span class="string">&quot;/&quot;</span>) path = <span class="string">&quot;/&quot;</span> + path;</span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; path.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path[i] === <span class="string">&quot;/&quot;</span> &amp;&amp; path[i + <span class="number">1</span>] === <span class="string">&quot;/&quot;</span>) <span class="keyword">continue</span>;</span><br><span class="line">    tmp += path[i];</span><br><span class="line">  &#125;</span><br><span class="line">  path = tmp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> files = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">  files.shift();</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> file <span class="keyword">of</span> files) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file === <span class="string">&quot;.&quot;</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (file === <span class="string">&quot;..&quot;</span>) stack.pop();</span><br><span class="line">    <span class="keyword">else</span> stack.push(file);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;/&quot;</span> + stack.filter(<span class="function">(<span class="params">str</span>) =&gt;</span> str !== <span class="string">&quot;&quot;</span>).join(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">https://leetcode.cn/problems/merge-intervals/</a></p>
<blockquote>
<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回   一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间  。<br>示例 1：<br>输入：intervals = [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p>
</blockquote>
<p>双指针比较，然后原地替换并删除多于的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">intervals</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">intervals</span>) </span>&#123;</span><br><span class="line">  intervals.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (intervals[i + <span class="number">1</span>] &amp;&amp; intervals[i][<span class="number">1</span>] &gt;= intervals[i + <span class="number">1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">      intervals[i] = [</span><br><span class="line">        intervals[i][<span class="number">0</span>],</span><br><span class="line">        <span class="built_in">Math</span>.min(intervals[i + <span class="number">1</span>][<span class="number">1</span>], intervals[i][<span class="number">1</span>]),</span><br><span class="line">      ];</span><br><span class="line">      intervals.splice(i + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> intervals;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="简单计算器"><a href="#简单计算器" class="headerlink" title="简单计算器"></a>简单计算器</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/basic-calculator-ii/">https://leetcode.cn/problems/basic-calculator-ii/</a></p>
<blockquote>
<p>给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。<br>整数除法仅保留整数部分。<br>你可以假设给定的表达式总是有效的。所有中间结果将在  [-2^31, 2^31 - 1] 的范围内。<br>示例 1：<br>输入：s = “3+2*2”<br>输出：7</p>
</blockquote>
<p>这道题因为没有括号，因此不用考虑转为后缀表达式求值；<br>思路还是利用栈，每个数字前都有一个符号（第一个数字视为+）</p>
<ul>
<li>如果这个符号是+/-，就入栈数字</li>
<li>如果这个符号是乘或除，就把当前数字和栈顶数字取出来做相乘、相除，并把结果入栈</li>
<li>最后栈中剩下的数字全部相加即可。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> calculate = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s[<span class="number">0</span>] !== <span class="string">&quot;-&quot;</span>) s = <span class="string">&quot;+&quot;</span> + s;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; ) &#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[i++] === <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!<span class="built_in">isNaN</span>(s[i])) num += s[i++];</span><br><span class="line">      stack.push(+num);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i++] === <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!<span class="built_in">isNaN</span>(s[i])) num += s[i++];</span><br><span class="line">      stack.push(-<span class="built_in">Number</span>(num));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i++] === <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> top = stack.pop();</span><br><span class="line">      <span class="keyword">while</span> (!<span class="built_in">isNaN</span>(s[i])) num += s[i++];</span><br><span class="line">      stack.push(top * +num);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i++] === <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> top = stack.pop();</span><br><span class="line">      <span class="keyword">while</span> (!<span class="built_in">isNaN</span>(s[i])) num += s[i++];</span><br><span class="line">      stack.push(<span class="built_in">Math</span>.trunc(top / +num));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre + cur);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="对角线遍历矩阵"><a href="#对角线遍历矩阵" class="headerlink" title="对角线遍历矩阵"></a>对角线遍历矩阵</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diagonal-traverse/">https://leetcode.cn/problems/diagonal-traverse/</a></p>
<blockquote>
<p>给你一个大小为 m x n 的矩阵 mat ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。</p>
</blockquote>
<p>思路：首先确定遍历方式：始终从右上向左下遍历。因此以第一行为基准，每一行都从右上向左下遍历。<br>注意要确定遍历次数，遍历次数经过一点数学计算，应该是<code>长边+短边-1</code>，表示一共需要来回走多少次。最后把偶数位置上的数组翻转展平即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">mat</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findDiagonalOrder = <span class="function"><span class="keyword">function</span> (<span class="params">mat</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 右上角mat[i-1][j+1]</span></span><br><span class="line">  <span class="comment">// 左下角mat[i+1][i-1]</span></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> m = mat.length;</span><br><span class="line">  <span class="keyword">const</span> n = mat[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">const</span> mostTimes = <span class="built_in">Math</span>.max(m, n) + <span class="built_in">Math</span>.min(m, n) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; mostTimes; k++) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> j = k;</span><br><span class="line">    <span class="keyword">const</span> tmp = [];</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; i &lt; m) &#123;</span><br><span class="line">      mat[i][j] != <span class="literal">undefined</span> &amp;&amp; tmp.push(mat[i][j]);</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    res.push([...tmp]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      res[i] = res[i].reverse();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.flat(<span class="literal">Infinity</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-to-roman/">https://leetcode.cn/problems/integer-to-roman/</a></p>
<p>这道题有一个很重要的思路：数字的拆分。<br>因为罗马数字实际上只是表示不同，位数的顺序和阿拉伯数字并没有区别；因此可以将罗马数字对应的阿拉伯数字从高到低位依次从数字中减去，按照这个顺序就恰好是结果。<br>比如，1586 这个数字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1586 -- 1000 -- M</span><br><span class="line">586 -- 500 -- D</span><br><span class="line">86 -- 50 -- L</span><br><span class="line">36 -- 10 -- X</span><br><span class="line">26 -- 10 -- X</span><br><span class="line">16 -- 10 -- X</span><br><span class="line">6 -- 5 -- V</span><br><span class="line">1 -- 1 -- I</span><br></pre></td></tr></table></figure>

<p>可以看到，随着数字的减小，对应的罗马数字也是依次减小的；因此只需要<strong>从大到小遍历一次</strong>就可以。每次遍历执行这个步骤：</p>
<ol>
<li>找到第一个比当前数 num 小的数</li>
<li>num - 该数，然后把结果放入数组。注意这里应该是一个<strong>循环</strong>，如果减去之后大于这个数，那就继续减，对应的是叠加的情况。</li>
<li>当减到 num 比该数小的时候，继续向后遍历，直到再找到一个比 num 小的数，执行上面步骤。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">num</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> intToRoman = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="comment">// map还要包含4和9的情况</span></span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="number">1</span>, <span class="string">&quot;I&quot;</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="string">&quot;IV&quot;</span>],</span><br><span class="line">    [<span class="number">5</span>, <span class="string">&quot;V&quot;</span>],</span><br><span class="line">    [<span class="number">9</span>, <span class="string">&quot;IX&quot;</span>],</span><br><span class="line">    [<span class="number">10</span>, <span class="string">&quot;X&quot;</span>],</span><br><span class="line">    [<span class="number">40</span>, <span class="string">&quot;XL&quot;</span>],</span><br><span class="line">    [<span class="number">50</span>, <span class="string">&quot;L&quot;</span>],</span><br><span class="line">    [<span class="number">90</span>, <span class="string">&quot;XC&quot;</span>],</span><br><span class="line">    [<span class="number">100</span>, <span class="string">&quot;C&quot;</span>],</span><br><span class="line">    [<span class="number">400</span>, <span class="string">&quot;CD&quot;</span>],</span><br><span class="line">    [<span class="number">500</span>, <span class="string">&quot;D&quot;</span>],</span><br><span class="line">    [<span class="number">900</span>, <span class="string">&quot;CM&quot;</span>],</span><br><span class="line">    [<span class="number">1000</span>, <span class="string">&quot;M&quot;</span>],</span><br><span class="line">  ]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [key, val] <span class="keyword">of</span> [...map.entries()].reverse()) &#123;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; key) &#123;</span><br><span class="line">      <span class="comment">// 找到第一个比当前数num小的数</span></span><br><span class="line">      num -= key;</span><br><span class="line">      res.push(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num === <span class="number">0</span>) <span class="keyword">return</span> res.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="第-N-个数"><a href="#第-N-个数" class="headerlink" title="第 N 个数"></a>第 N 个数</h2><p>这道题是一个找规律的题目，主要是前期的规律分析，找出规律之后很简单</p>
<p>按照题意，可以得到下面这个表格：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>范围</th>
<th>位数</th>
<th>总位数大小</th>
<th>起始序号 n</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0-9</td>
<td>1</td>
<td><code>9*10^0 = 9</code></td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>10-99</td>
<td>2</td>
<td><code>9*10^1 = 180</code></td>
<td>0+9=9</td>
</tr>
<tr>
<td>3</td>
<td>100-999</td>
<td>3</td>
<td><code>9*10^2 = 2700</code></td>
<td>180+9=189</td>
</tr>
<tr>
<td>4</td>
<td>1000-9999</td>
<td>4</td>
<td><code>9*10^3 = 36000</code></td>
<td>189+2700=2889</td>
</tr>
</tbody></table>
<p>思路如下：</p>
<ol>
<li>首先计算 n 应该是上面哪个范围的，把 n 依次减去 $(9 \times 10^{n-1})\times n$ 得到 n 应该是哪个位数哪个范围的</li>
<li>计算 n 应该在这个范围的多少位，<code>n/位数</code>可以得到是这一组数中的第几个数字，余数则是找到该数字之后的位数。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findNthDigit = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">10</span>) <span class="keyword">return</span> n;</span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> num = n;</span><br><span class="line">  <span class="keyword">while</span> (num &gt; <span class="number">9</span> * <span class="number">10</span> ** cnt * (cnt + <span class="number">1</span>)) &#123;</span><br><span class="line">    num -= <span class="number">9</span> * <span class="number">10</span> ** cnt * (cnt + <span class="number">1</span>);</span><br><span class="line">    cnt++;</span><br><span class="line">  &#125;</span><br><span class="line">  cnt++;</span><br><span class="line">  <span class="keyword">let</span> rest = num - <span class="number">1</span>; <span class="comment">// 这里注意要-1，因为num是这一组数的第num个数，但是每组数都是从0开始的，-1才得到真正的数字值</span></span><br><span class="line">  <span class="keyword">let</span> idx = <span class="built_in">Math</span>.floor(rest / cnt); <span class="comment">// 这一组数中的第idx个数</span></span><br><span class="line">  <span class="keyword">let</span> extra = rest % cnt; <span class="comment">// 余数，相当于idx的第extra位数</span></span><br><span class="line">  <span class="keyword">return</span> (idx + <span class="number">10</span> ** (cnt - <span class="number">1</span>)).toString().charAt(extra);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="和为-k-的子数组"><a href="#和为-k-的子数组" class="headerlink" title="和为 k 的子数组"></a>和为 k 的子数组</h2><blockquote>
<p>给你一个整数数组 nums 和一个整数  k ，请你统计并返回 该数组中和为  k  的子数组的个数  。<br>示例 1：<br>输入：nums = [1,1,1], k = 2<br>输出：2</p>
</blockquote>
<p>这道题用暴力法很好解决，固定左边界，伸缩右边界计算和即可。</p>
<p>最开始想到了背包问题和回溯解法，但是这两个方法都有问题：</p>
<ul>
<li>01 背包要求 k&gt;=0，这里 k 可以是负数，肯定不行。并且 01 背包得到的一般都是子序列而不是子数组</li>
<li>回溯对于不重复的数组可以处理，考虑子数组的话，设置一个 path 每次存储上一个的序号，如果本次不是相邻就跳过。但是对于有重复数字的数组好像 8 太行，反正我是没整出来</li>
</ul>
<p>因此这道题标准解法是前缀和+map。其实看到子数组的和就应该考虑前缀和，并且前缀和应该也只能在子数组中用，子序列是不行的。</p>
<p>如果有一个子数组的和为 k，那么就必然会有<code>pre[j] - pre[i] === k</code>，也就是说它两边的两个前缀和的差恰好是 k。由此可以类似两数之和的思路：</p>
<ul>
<li>设定一个 map，每次遍历计算 pre 并存储 pre 为键，出现次数为值；如果 pre 存在，就给次数+1</li>
<li>每次遍历查找是否有 pre-k 存在，有就给总数 cnt 加上 pre-k 对应的值（次数）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> subarraySum = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  map.set(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    pre += num;</span><br><span class="line">    <span class="keyword">if</span> (map.has(pre - k)) &#123;</span><br><span class="line">      cnt += map.get(pre - k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (map.has(pre)) &#123;</span><br><span class="line">      map.set(pre, map.get(pre) + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      map.set(pre, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最大数"><a href="#最大数" class="headerlink" title="最大数"></a>最大数</h2><blockquote>
<p>给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。<br>注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。<br>示例 1：<br>输入：nums = [10,2]<br>输出：”210”</p>
</blockquote>
<p>这道题的思路其实是根据字典序排序数组。<br>因为字典序的排序规则是先比较最高位，相同再依次比较后面的位。正好符合题意，优先把最高位移到前面。<br>但是这仅限于位数相同的情况；当位数不同时，就会出现问题<br>比如<code>[3, 30]</code>，按照字典序是<code>[30,3]</code>，但是显然<code>303 &lt; 330</code>，所以需要对这种情况做出调整。<br>调整的方式就是比较这两种排列的大小，即比较`${b}${a}`和`${a}${b}`的大小。实际上这里还需要比较严密的数学证明，就不详述了。<br>最后还要考虑全 0 时的处理，直接返回 0 就可以。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> largestNumber = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (+nums.join(<span class="string">&quot;&quot;</span>) === <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> +<span class="string">`<span class="subst">$&#123;b&#125;</span><span class="subst">$&#123;a&#125;</span>`</span> - +<span class="string">`<span class="subst">$&#123;a&#125;</span><span class="subst">$&#123;b&#125;</span>`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> nums.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="优势洗牌"><a href="#优势洗牌" class="headerlink" title="优势洗牌"></a>优势洗牌</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/advantage-shuffle">https://leetcode.cn/problems/advantage-shuffle</a></p>
<blockquote>
<p>给定两个大小相等的数组  nums1  和  nums2，nums1  相对于 nums  的优势可以用满足  nums1[i] &gt; nums2[i]  的索引 i  的数目来描述。<br>返回 nums1  的任意排列，使其相对于 nums2  的优势最大化。<br>示例 1：<br>输入：nums1 = [2,7,11,15], nums2 = [1,10,4,11]<br>输出：[2,11,7,15]</p>
</blockquote>
<p>这道题其实就是田忌赛马的加强版，即调整 nums1 的顺序，使得比较的总次数中 nums1[i] &gt; nums2[i]  的次数占更多。</p>
<p>那么就可以按照田忌赛马的思路：</p>
<ol>
<li>首先将两个数组排序，然后依次比较。这里采用倒序排序，正序也可以。但是结果不能直接按照排序的结果来，因为本来 nums1 的顺序就应该是对应 nums2 的每个元素的，因此不能直接对 nums2 排序，具体操作下面解释</li>
<li>依次比较两个数组的对应值：</li>
</ol>
<ul>
<li>如果 nums1[i] &gt; nums2[i]，即比得过，那么就比，即 res[i] = nums1[i]</li>
<li>如果比不过，那么就选一个送人头的。为了使比不过选择最小的造成的损失最小，应该每次都选最小的那个数，即倒序，开始选</li>
</ul>
<p>有了思路，接下来就是很多细节问题。这道题真正的难点就是细节：</p>
<ol>
<li>上面说不能直接对 nums2 排序，因此可以不对 nums2 直接操作，而是取它的序号，然后将序号按照原数组从大到小排序。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">就是这个意思：</span><br><span class="line">比如说原数组  [20,32,8,12]</span><br><span class="line">排序之后  [32,20,12,8]</span><br><span class="line">把每个数在原数组中的序号提出来 [1,0,3,2]</span><br><span class="line">接下来就用这个数组去比。比如 nums2[tmp[1]] 就表示从大到小第二个数，和直接排序一个效果</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>依次比较应该采用双指针的形式，一边从左边取值，一边从右边取最小值，直到两个指针相遇为止。</li>
<li>结果数组不能直接 push！！这也是很重要的一点。因为结果数组的顺序应该对应于 nums2，因此应该是<code>res[nums2[i]] = nums1[i]</code>这样的形式，而不是直接通过 push、unshift 的形式放入值。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> advantageCount = <span class="function"><span class="keyword">function</span> (<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  nums1.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tmpNums2 = <span class="keyword">new</span> <span class="built_in">Array</span>(nums2.length).fill(<span class="number">0</span>).map(<span class="function">(<span class="params">num, index</span>) =&gt;</span> index);</span><br><span class="line">  tmpNums2.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> nums2[b] - nums2[a]); <span class="comment">// 给nums2的序号数组排序</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> right = nums1.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="comment">// 注意nums1的数组取数和nums2的应该是独立的，不管比不比的过，nums2应该始终向前走</span></span><br><span class="line">    <span class="comment">// 因此再设置一个j，j始终自增</span></span><br><span class="line">    <span class="comment">// left和right只在nums1中生效</span></span><br><span class="line">    <span class="keyword">const</span> index2 = tmpNums2[j++];</span><br><span class="line">    <span class="keyword">if</span> (nums1[left] &gt; nums2[index2]) &#123;</span><br><span class="line">      <span class="comment">// 比得过，就选这个数，放到结果数组对应nums2的位置上</span></span><br><span class="line">      res[index2] = nums1[left--];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 比不过，选最小的</span></span><br><span class="line">      res[index2] = nums1[right--];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="O-1-时间插入、删除和获取随机元素"><a href="#O-1-时间插入、删除和获取随机元素" class="headerlink" title="O(1) 时间插入、删除和获取随机元素"></a>O(1) 时间插入、删除和获取随机元素</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-delete-getrandom-o1/">https://leetcode.cn/problems/insert-delete-getrandom-o1/</a></p>
<blockquote>
<p>实现一个类，能在 O(1) 时间插入、删除和获取随机元素</p>
</blockquote>
<p>这道题的关键是在 O(1)时间同时完成插入删除和随机获取。<br>如果只是前两个，可以采取哈希表的形式，因为哈希表的查找、插入、删除、修改都是 o(1)的。但是问题在于哈希表不连续，并且可能会有哈希冲突带来的更复杂的数据结构，因此不能保证在获取随即元素时的真随机。因此仍然需要一个紧凑的数组，同时关键在于如何实现删除的 o(1)。思路是这样：</p>
<ul>
<li>如果我们想在 O(1) 的时间删除数组中的某一个元素 val，可以先把这个元素交换到数组的尾部，然后再 pop 掉。</li>
<li>设置一个哈希表 valToIndex 来记录每个元素值对应的索引。</li>
</ul>
<p>代码细节比较多，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.numsSet = [];</span><br><span class="line">    <span class="built_in">this</span>.valToIndex = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="built_in">this</span>.len = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">swap</span>(<span class="params">i, j</span>)</span> &#123;</span><br><span class="line">    [<span class="built_in">this</span>.numsSet[i], <span class="built_in">this</span>.numsSet[j]] = [<span class="built_in">this</span>.numsSet[j], <span class="built_in">this</span>.numsSet[i]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.valToIndex.has(val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>.numsSet.push(val);</span><br><span class="line">    <span class="built_in">this</span>.valToIndex.set(val, <span class="built_in">this</span>.len++);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.valToIndex.has(val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="built_in">this</span>.valToIndex.get(val); <span class="comment">// 找到对应的值的索引</span></span><br><span class="line">    <span class="keyword">if</span> (index !== <span class="built_in">this</span>.numsSet.length - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> lastVal = <span class="built_in">this</span>.numsSet[<span class="built_in">this</span>.numsSet.length - <span class="number">1</span>]; <span class="comment">// 最后一个值，用于找最后一个值对应的索引</span></span><br><span class="line">      <span class="built_in">this</span>.swap(index, <span class="built_in">this</span>.numsSet.length - <span class="number">1</span>); <span class="comment">// 交换最后一个和当前</span></span><br><span class="line">      <span class="built_in">this</span>.valToIndex.set(lastVal, index); <span class="comment">// 交换后，把原先最后一个值对应的索引改成该值的索引</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.valToIndex.delete(val); <span class="comment">// 删除该值</span></span><br><span class="line">    <span class="built_in">this</span>.numsSet.pop();</span><br><span class="line">    <span class="built_in">this</span>.len--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getRandom</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.numsSet[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="built_in">this</span>.len)];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>常用的位运算操作就是与<code>&amp;</code>、或<code>|</code>、异或<code>^</code>这三个。</p>
<ul>
<li>与：同为 1 结果为 1，其他都为 0。比如<code>110 &amp; 010 = 010</code></li>
<li>或：只要有一个 1 结果就为 1，只有同为 0 结果才为 0。<code>110 | 010 = 110</code></li>
<li>异或：相同为 1，不同为 0，即“负负得正，正正得正，正负得负，负正得负”。<code>110 | 010 = 011</code></li>
</ul>
<p>在 js 中，number 只能表示十进制数字，而字符串又不像 c 语言那样直接和 ASCII 码关联。因此很多在其它语言中能用到的、处理字符串的骚操作可能用不到。因此 js 的位运算操作通常针对的是十进制数字。</p>
<p>常见的位运算操作有：</p>
<ol>
<li>根据数字的二进制值判断性质。</li>
</ol>
<p>比如判断一个数是不是 2 的幂，一个数如果是 2 的指数，那么它的二进制表示一定只含有一个 1。因此把这个数转为 2 进制数 1 的个数即可。</p>
<ol start="2">
<li><code>n &amp; (n-1)</code>，这个操作是算法中常见的，作用是消除数字 n 的二进制表示中的最后一个 1</li>
</ol>
<p><img src="https://pic.imgdb.cn/item/62e78ce38c61dc3b8edfce13.jpg"></p>
<p>这个操作主要用于二进制“数 1”，即从后向前依次去掉最后一个 1（全部去掉这个数就成为 0 了），顺便数出来 1 的个数。当然直接数也是可以的，只是这种方法相较于字符串要快的多。<br>比如力扣第 136 题<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-1-bits/">位 1 的个数</a>，就可以逐个去掉最后一个 1，直到该数变成 0 为止。</p>
<ol start="3">
<li><code>a ^ a = 0</code>，即异或，一个数和它本身做异或运算结果为 0，即 <code>a ^ a = 0</code>；一个数和 0 做异或运算的结果为它本身，即 <code>a ^ 0 = a</code>。并且异或操作遵循结合律、交换律，可以无视顺序。</li>
</ol>
<p>这个操作常见于把一组数字异或起来，往往剩下的那个数字就是一个特殊值。比如下面的这道题就是。<br>还有一道下面的题的变种，即<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/missing-number/">丢失的数字</a>这道题，其实基本思路是一样的，只是这道题先把</p>
<h3 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/single-number/">https://leetcode.cn/problems/single-number/</a></p>
<blockquote>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
</blockquote>
<p>这道题的暴力解法很好想到，给数组排序，如果一个数既不和前面的相等又不和后面的相等，就说明是唯一的数字。</p>
<p>但是这道题有一个更 nb 的解法，就是利用异或。</p>
<p><strong>一个数和它本身做异或运算结果为 0，即 <code>a ^ a = 0</code>；一个数和 0 做异或运算的结果为它本身，即<code> a ^ 0 = a</code></strong></p>
<p>所以我们就可以把数组内的所有数都异或起来（初始值为 0），相同的数无论顺序，最后都会会互相异或成为 0；因此最后剩下的数，就是只出现一次的数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> singleNumber = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nums.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a ^ b, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="阶乘后的-0"><a href="#阶乘后的-0" class="headerlink" title="阶乘后的 0"></a>阶乘后的 0</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/factorial-trailing-zeroes/">https://leetcode.cn/problems/factorial-trailing-zeroes/</a></p>
<blockquote>
<p>给定一个整数 n ，返回 n! 结果中尾随零的数量。</p>
</blockquote>
<p>这道题肯定不能硬算，解法有且只有一个，只能记住：即，寻找小于等于 n 的 5 的因子数量。</p>
<blockquote>
<p>首先，两个数相乘结果末尾有 0，一定是因为两个数中有因子 2 和 5，因为 10 = 2 x 5。<br>也就是说，问题转化为：n! 最多可以分解出多少个因子 2 和 5？<br>比如说 n = 25，那么 25! 最多可以分解出几个 2 和 5 相乘？这个主要取决于能分解出几个因子 5，因为每个偶数都能分解出因子 2，因子 2 肯定比因子 5 多得多。<br>25! 中 5 可以提供一个，10 可以提供一个，15 可以提供一个，20 可以提供一个，25 可以提供两个，总共有 6 个因子 5，所以 25! 的结果末尾就有 6 个 0。<br>现在，问题转化为：n! 最多可以分解出多少个因子 5？<br>难点在于像 25，50，125 这样的数，可以提供不止一个因子 5，怎么才能不漏掉呢？<br>这样，我们假设 n = 125，来算一算 125! 的结果末尾有几个 0：<br>首先，125 / 5 = 25，这一步就是计算有多少个像 5，15，20，25 这些 5 的倍数，它们一定可以提供一个因子 5。<br>但是，这些足够吗？刚才说了，像 25，50，75 这些 25 的倍数，可以提供两个因子 5，那么我们再计算出 125! 中有 125 / 25 = 5 个 25 的倍数，它们每人可以额外再提供一个因子 5。<br>够了吗？我们发现 125 = 5 x 5 x 5，像 125，250 这些 125 的倍数，可以提供 3 个因子 5，那么我们还得再计算出 125! 中有 125 / 125 = 1 个 125 的倍数，它还可以额外再提供一个因子 5。<br>这下应该够了，125! 最多可以分解出 25 + 5 + 1 = 31 个因子 5，也就是说阶乘结果的末尾有 31 个 0。</p>
</blockquote>
<p>依照这个思路代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> trailingZeroes = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (n &gt;= <span class="number">5</span> ** i) &#123;</span><br><span class="line">    sum += <span class="built_in">Math</span>.floor(n / <span class="number">5</span> ** i);</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="计数质数"><a href="#计数质数" class="headerlink" title="计数质数"></a>计数质数</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-primes/">https://leetcode.cn/problems/count-primes/</a></p>
<blockquote>
<p>给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。</p>
</blockquote>
<p>首先先考虑怎么判断一个数 n 是不是质数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n % i === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即，从 2 开始到 n 的数，如果这之间有一个数能整除 n，那么 n 一定就不是质数。<br>但是这个明显有个问题，即因子会重复。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n    i  n%i</span><br><span class="line">12 = 2 * 6</span><br><span class="line">12 = 3 * 4</span><br><span class="line">...</span><br><span class="line">12 = 4 * 3</span><br><span class="line">12 = 6 * 2</span><br></pre></td></tr></table></figure>

<p>显然这里 i 重复了，当 i=2 时已经得到了另一个因子为 6 的结果，那么 i 就不应该再遍历到 6。这个的分界线就是根号下 n，即<code>i &lt; Math.sqrt(n)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i * i &lt; n; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n % i === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>接下来就是判断 n 以内的数是不是正数：方法是采取一个数学方法，即<code>素数筛选法</code>。每次从<code>[2,n)</code>中去掉每个数的倍数，剩下的数就一定是质数。<br>比如先去掉 2 的倍数，再去掉 3 的，然后是 5、7、11 等等</p>
<p><img src="https://labuladong.github.io/algo/images/prime/1.gif"></p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countPrimes = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span> || n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> primes = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 外层循环：遍历从2开始的每个数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i * i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// 这里和上面一样的逻辑，i只需要到根号n就够了</span></span><br><span class="line">    <span class="keyword">if</span> (primes[i]) &#123;</span><br><span class="line">      <span class="comment">// 内层循环：找到这个数i的所有倍数，变成非质数</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = i * i; j &lt; n; j += i) &#123;</span><br><span class="line">        <span class="comment">// 这里j是从i*i开始的，因为：</span></span><br><span class="line">        <span class="comment">// 比如 n = 25，i = 5 时算法会标记 5 × 2 = 10，5 × 3 = 15 等等数字，但是这两个数字已经被 i = 2 和 i = 3 的 2 × 5 和 3 × 5 标记了。</span></span><br><span class="line">        <span class="comment">// 因此原本是2*i，改进称i*i更好一些</span></span><br><span class="line">        primes[j] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prime <span class="keyword">of</span> primes) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prime) sum++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="水塘抽样算法"><a href="#水塘抽样算法" class="headerlink" title="水塘抽样算法"></a>水塘抽样算法</h2><p>这个算法的题目参考<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-random-node/%EF%BC%8C%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E3%80%82">https://leetcode.cn/problems/linked-list-random-node/，就是这个算法的实现。</a></p>
<p>概括一下其实就是解决这样一个问题：给你一个未知长度的链表，请你设计一个算法，只能遍历一次，随机地返回链表中的一个节点。</p>
<p><strong>结论是，当你遇到第 i 个元素时，应该有 1/i 的概率选择该元素，1 - 1/i 的概率保持原有的选择</strong>。这样就可以一边遍历，一边保持随机性了。<br>举个例子，比如遍历到第二个元素，那就是 1/2 的概率选该元素，1-1/2 概率保持选第一个元素。<br>这个结论的证明需要数学方法，参考<a target="_blank" rel="noopener" href="https://labuladong.github.io/algo/4/32/119/">https://labuladong.github.io/algo/4/32/119/</a></p>
<p>代码实现上，为了实现<code>1/i</code>的概率选择，其实可以通过<code>Math.random() * i === 0</code>的形式得到 1/i 的概率。<br>比如上面的例题，代码就是这个样子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">head</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.head = head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getRandom</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * i) === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 1/i的概率选择新遍历到的元素</span></span><br><span class="line">        res = p.val;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分割数组为连续子序列"><a href="#分割数组为连续子序列" class="headerlink" title="分割数组为连续子序列"></a>分割数组为连续子序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/split-array-into-consecutive-subsequences/">https://leetcode.cn/problems/split-array-into-consecutive-subsequences/</a></p>
<blockquote>
<p>给你一个按升序排序的整数数组 num（可能包含重复数字），请你将它们分割成一个或多个长度至少为 3 的子序列，其中每个子序列都由连续整数组成。<br>如果可以完成上述分割，则返回 true ；否则，返回 false 。<br>示例 1：<br>输入: [1,2,3,3,4,5]<br>输出: True<br>解释:<br>你可以分割出这样两个连续子序列 :<br>1, 2, 3<br>3, 4, 5</p>
</blockquote>
<p>这道题其实不是常规的分割数组的题目，因为预先并不知道能分成几组，也不能通过上面讲的“装桶”算法解决。</p>
<p>这道题的思路其实可以借鉴到其他子序列问题的，即，通过一个 map 统计序列中的数字数量，当需要一个数字时直接到 map 中查找，而不是遍历数组。<br>比如说现在有一个数字 3，希望构成一个序列[3,4,5]，那么就可以查找 map[3]、map[4]、map[5]是否都大于 0（即还有几个能用的数字），如果能用就取出来用，不行就考虑其他方法。</p>
<p>现在来说这道题的思路。对于每一个数字 num，有两种情况：</p>
<ol>
<li>当前元素 num 自成一派，「以自己开头」构成一个长度至少为 3 的序列。<br>比如输入 nums = [1,2,3,6,7,8]，遍历到元素 6 时，它只能自己开头形成一个符合条件的子序列 [6,7,8]。</li>
<li>当前元素 num 接到已经存在的子序列后面。<br>比如输入 nums = [1,2,3,4,5]，遍历到元素 4 时，它只能接到已经存在的子序列 [1,2,3] 后面。它没办法自成开头形成新的子序列，因为少了个 6。</li>
</ol>
<p>并且每个元素都应该优先判断自己是否能够接到其他序列后面。</p>
<p>我们可以设置两个 map，</p>
<ul>
<li>appear 用于记录当前序列中的剩余数字数量，即这个数字还有几个没有被合并到其他序列中去；</li>
<li>need 用于记录已经成型的子序列还需要哪个元素接到后面，比如现在已经有两个子序列 [1,2,3,4] 和 [2,3,4]，那么 need[5] 的值就应该是 2，说明对元素 5 的总需求为 2。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isPossible = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> appear = [];</span><br><span class="line">  <span class="keyword">const</span> need = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// appear初始就是每个数字出现次数</span></span><br><span class="line">  nums.forEach(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">    appear[num] = appear[num] ? appear[num] + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (appear[num] === <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (need[num] &gt; <span class="number">0</span> &amp;&amp; need.length) &#123;</span><br><span class="line">      <span class="comment">// 先判断能不能接在后面</span></span><br><span class="line">      <span class="comment">// 如果当前数字恰好被其他序列需要，就用上</span></span><br><span class="line">      appear[num]--;</span><br><span class="line">      need[num]--;</span><br><span class="line">      need[num + <span class="number">1</span>] = need[num + <span class="number">1</span>] ? need[num + <span class="number">1</span>] + <span class="number">1</span> : <span class="number">1</span>; <span class="comment">// 把当前序列的需要向后移动一个</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (appear[num] &gt; <span class="number">0</span> &amp;&amp; appear[num + <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; appear[num + <span class="number">2</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果要新形成一个序列，就把后面两个数都用上</span></span><br><span class="line">      appear[num]--;</span><br><span class="line">      appear[num + <span class="number">1</span>]--;</span><br><span class="line">      appear[num + <span class="number">2</span>]--;</span><br><span class="line">      need[num + <span class="number">3</span>] = need[num + <span class="number">3</span>] ? need[num + <span class="number">3</span>] + <span class="number">1</span> : <span class="number">1</span>; <span class="comment">// 需要num+2后面的数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="煎饼排序"><a href="#煎饼排序" class="headerlink" title="煎饼排序"></a>煎饼排序</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/pancake-sorting/">https://leetcode.cn/problems/pancake-sorting/</a></p>
<p>（题目太长了这里就不写了）<br>其实就是这样一件事，和汉诺塔很像：<br><img src="https://pic.imgdb.cn/item/62e8e62216f2c2beb1ee7c2d.jpg"></p>
<p>这个题的思路就是：<br>每次选择最大的一个元素，先把它翻到最上面，再翻到最下面去，也就是相当于把数组从大到小排序。<br>但是这个“最大的元素”并不能每次都是整个数组最大的，显然第一次放好最大元素之后，后面就应该选取第二大的，然后是第三大，以此类推。<br>这个思路其实可以用一个倒序的循环，这里用递归更清晰一些，其实就是在每次缩小排序的范围。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pancakeSort = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> findMax = <span class="function">(<span class="params">nums</span>) =&gt;</span> nums.indexOf(<span class="built_in">Math</span>.max(...nums));</span><br><span class="line">  <span class="keyword">const</span> reversePart = <span class="function">(<span class="params">nums, start, end</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 翻转函数</span></span><br><span class="line">    <span class="keyword">let</span> i = start;</span><br><span class="line">    <span class="keyword">let</span> j = end;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">      [nums[i], nums[j]] = [nums[j], nums[i]];</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> kVals = [];</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> maxIndex = findMax(arr.slice(<span class="number">0</span>, end + <span class="number">1</span>)); <span class="comment">// 先找到范围内最大元素的位置</span></span><br><span class="line">    <span class="keyword">if</span> (maxIndex !== end) &#123;</span><br><span class="line">      reversePart(arr, <span class="number">0</span>, maxIndex); <span class="comment">// 翻转到顶层</span></span><br><span class="line">      kVals.push(maxIndex + <span class="number">1</span>); <span class="comment">// 翻转一次，记录翻转的位置</span></span><br><span class="line">      reversePart(arr, <span class="number">0</span>, end); <span class="comment">// 反转到底层，即全部翻转一次</span></span><br><span class="line">      kVals.push(end + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(end - <span class="number">1</span>); <span class="comment">// 范围缩小一个，相当于最后一个已经排好了</span></span><br><span class="line">  &#125;</span><br><span class="line">  dfs(arr.length - <span class="number">1</span>); <span class="comment">// 从整个数组开始</span></span><br><span class="line">  <span class="keyword">return</span> kVals;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="括号问题"><a href="#括号问题" class="headerlink" title="括号问题"></a>括号问题</h2><p>括号问题的解决无非就是两种方式：栈和数量统计。</p>
<p>栈解决就是“左括号入栈，右括号出栈”的思路。这里说一个新的思路，就是数量统计。</p>
<p>比如这一类问题的最简单问题<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">有效的括号</a>，可以设置一个变量 need，用于表示需要的右括号数量；每遍历一个左括号，就 need++。如果最后 need 不为 0，就说明不能完全匹配。当然设置变量表示还未匹配的左括号数量也可以。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> left = <span class="number">0</span>; <span class="comment">// 未匹配的左括号数量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (s[i] == <span class="string">&quot;(&quot;</span>) &#123;</span><br><span class="line">    left++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 遇到右括号</span></span><br><span class="line">    left--;</span><br><span class="line">    <span class="comment">// 右括号太多</span></span><br><span class="line">    <span class="keyword">if</span> (left === -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 是否所有的左括号都被匹配了</span></span><br><span class="line"><span class="keyword">return</span> left === <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>这个方法就可以解决<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/">使括号有效的最少添加</a>。<br>这道题就是统计匹配完成后还剩几个，那么就可以直接套用上面的方法。<br>但是还有一点要注意的，就是右括号数量可能多于左括号，并且这题不是到这一步就结束的，需要遍历完所有括号，得出没匹配的还有几个。<br>因此需要两个变量，分别统计需要的左括号和右括号数量；如果需要的右括号小于 0 了，那就还需要一个左括号；最后的结果应该是两者之和</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minAddToMakeValid = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> needLeft = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> needRight = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> str <span class="keyword">of</span> s.split(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str === <span class="string">&quot;(&quot;</span>) &#123;</span><br><span class="line">      needLeft++;</span><br><span class="line">      <span class="comment">// 这里不需要needRight--，因为left是主动增加的，这一步不会出现-1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      needLeft--;</span><br><span class="line">      <span class="keyword">if</span> (needLeft === -<span class="number">1</span>) &#123;</span><br><span class="line">        needRight++;</span><br><span class="line">        needLeft = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> needLeft + needRight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再改进一下就可以解决另一道题<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/">平衡括号字符串的最少插入次数</a>。<br>这道题无非就是一个左括号对应两个 needLeft，<strong>并且右括号的数量（即 needLeft）应该是偶数</strong>，如果不是就需要再添加一个左括号（不能删除，因为题目要求是插入次数）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minInsertions = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> needLeft = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> needRight = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] === <span class="string">&quot;(&quot;</span>) &#123;</span><br><span class="line">      needLeft += <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (needLeft % <span class="number">2</span>) &#123;</span><br><span class="line">        needRight++;</span><br><span class="line">        needLeft--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      needLeft--;</span><br><span class="line">      <span class="keyword">if</span> (needLeft === -<span class="number">1</span>) &#123;</span><br><span class="line">        needRight++;</span><br><span class="line">        needLeft = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> needLeft + needRight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="会议室-II（扫描线）"><a href="#会议室-II（扫描线）" class="headerlink" title="会议室 II（扫描线）"></a>会议室 II（扫描线）</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/meeting-rooms-ii/">https://leetcode.cn/problems/meeting-rooms-ii/</a></p>
<blockquote>
<p>给你一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，返回 所需会议室的最小数量 。<br>示例 1：<br>输入：intervals = [[0,30],[5,10],[15,20]]<br>输出：2</p>
</blockquote>
<p>这道题看着和前面的区间类问题很像，但是这道题其实是求最大的重叠数量，也就是从开始到结束的最多重叠区间数量。<br>暴力法很容易想到，就是遍历每一个整数时间，检查这个时间经过了多少个区间（<code>i &gt;= start &amp;&amp; i &lt;= end</code>）。<br>还可以采用之前的区间问题的解决方法，即先按照 end 排序，每次更新 minEnd 时计算穿过的数量（即重叠了应该删除的数量），最后得到最大值即可。</p>
<p>但是这里有一个更好的方法，即扫描线，可以参考这张图：</p>
<p><img src="https://pic.imgdb.cn/item/62e8fd6016f2c2beb10ae149.jpg"></p>
<p>红色的点代表每个会议的开始时间点，绿色的点代表每个会议的结束时间点。</p>
<p>现在假想有一条带着计数器的线，在时间线上从左至右进行扫描，每遇到红色的点，计数器 count 加一，每遇到绿色的点，计数器 count 减一：<br><img src="https://pic.imgdb.cn/item/62e8fd6a16f2c2beb10aea83.jpg"></p>
<p>这样一来，每个时刻有多少个会议在同时进行，就是计数器 count 的值，count 的最大值，就是需要申请的会议室数量。</p>
<p>具体的代码实现，需要先对开始和结束的时间进行记录和排序，然后用双指针比较每一项，如果<code>begin&lt;end</code>，就给 count++，反之就 count–。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如数组[[0,30],[5,10],[15,20]]</span><br><span class="line">得到 begins = [0,5,15]</span><br><span class="line">     ends = [10,20,30]</span><br><span class="line"></span><br><span class="line">我们模拟一个从小到大走的扫描线，那肯定是先走两个数组中较小的，即按照0、5、10、15、20、30的顺序。</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minMeetingRooms = <span class="function"><span class="keyword">function</span> (<span class="params">intervals</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> begins = [];</span><br><span class="line">  <span class="keyword">const</span> ends = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [begin, end] <span class="keyword">of</span> intervals) &#123;</span><br><span class="line">    begins.push(begin);</span><br><span class="line">    ends.push(end);</span><br><span class="line">  &#125;</span><br><span class="line">  begins.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  ends.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; begins.length &amp;&amp; j &lt; ends.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (begins[i] &lt; ends[j]) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      count++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      count--;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">Math</span>.max(res, count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/">日常学习</a></div><div class="post_share"><div class="social-share" data-image="/img/codes1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/12/OS/"><img class="prev-cover" src="/img/codes1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">操作系统知识点总结</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/05/blog44-optimization/"><img class="next-cover" src="/img/codes1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">优化问题总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/11/06/blog11-myReact/" title="react知识点汇总和使用小总结(一)"><img class="cover" src="/img/react.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-06</div><div class="title">react知识点汇总和使用小总结(一)</div></div></a></div><div><a href="/2021/10/27/blog10-react-router/" title="react-router的使用"><img class="cover" src="/img/reactrouter.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-27</div><div class="title">react-router的使用</div></div></a></div><div><a href="/2021/11/20/blog14-react-ts-basic/" title="typescript+react基础部分"><img class="cover" src="/img/typescript.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-20</div><div class="title">typescript+react基础部分</div></div></a></div><div><a href="/2021/11/22/blog17-react-pubsub-issues/" title="react+typescript使用pubsub时的一点小问题"><img class="cover" src="/img/pubsub.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-22</div><div class="title">react+typescript使用pubsub时的一点小问题</div></div></a></div><div><a href="/2021/11/20/blog16-react-ts-hooks-redux/" title="typescript+react:自定义hooks代替redux"><img class="cover" src="/img/typescript.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-20</div><div class="title">typescript+react:自定义hooks代替redux</div></div></a></div><div><a href="/2021/11/25/blog18-vue3ts-basic/" title="vue3+ts配置及简单使用注意"><img class="cover" src="/img/vue3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-25</div><div class="title">vue3+ts配置及简单使用注意</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/pinkstar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xing Ye</div><div class="author-info__description">a singleThreaded boy's blog</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/penghei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/penghei" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:632885485@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">A SingleThreaded Boy...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.</span> <span class="toc-text">算法复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.1.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.</span> <span class="toc-text">迭代时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.3.</span> <span class="toc-text">递归的时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">2.1.</span> <span class="toc-text">两数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.</span> <span class="toc-text">合并有序数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%95%B0%E6%B1%82%E5%92%8C"><span class="toc-number">2.3.</span> <span class="toc-text">三数求和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="toc-number">2.4.</span> <span class="toc-text">有序数组的平方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">2.5.</span> <span class="toc-text">移除元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="toc-number">2.6.</span> <span class="toc-text">移动零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="toc-number">2.7.</span> <span class="toc-text">两个数组的交集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%EF%BC%88%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84%EF%BC%89"><span class="toc-number">2.8.</span> <span class="toc-text">旋转数组（轮转数组）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84"><span class="toc-number">2.9.</span> <span class="toc-text">差分数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E5%8A%A0%E6%B3%95"><span class="toc-number">2.9.1.</span> <span class="toc-text">区间加法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%BC%E8%BD%A6"><span class="toc-number">2.9.2.</span> <span class="toc-text">拼车</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.1.</span> <span class="toc-text">回文字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP-%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">KMP 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.3.</span> <span class="toc-text">重复子字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="toc-number">3.4.</span> <span class="toc-text">最长公共前缀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%BA%8F%E5%8F%B7"><span class="toc-number">3.5.</span> <span class="toc-text">列表序号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%90%8D%E7%A7%B0"><span class="toc-number">3.6.</span> <span class="toc-text">列表名称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81-IP-%E5%9C%B0%E5%9D%80"><span class="toc-number">3.7.</span> <span class="toc-text">验证 IP 地址</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">4.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">4.1.</span> <span class="toc-text">合并有序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%88dummy-%E8%8A%82%E7%82%B9%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">删除所有重复元素（dummy 节点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="toc-number">4.3.</span> <span class="toc-text">快慢指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">4.4.</span> <span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E5%8F%8D%E8%BD%AC%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8"><span class="toc-number">4.5.</span> <span class="toc-text">部分反转一个链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8"><span class="toc-number">4.6.</span> <span class="toc-text">递归反转一个链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E4%BA%A4%E5%8F%89"><span class="toc-number">4.7.</span> <span class="toc-text">链表交叉</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-number">4.8.</span> <span class="toc-text">判断回文链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%86%E5%88%86%E9%93%BE%E8%A1%A8"><span class="toc-number">4.9.</span> <span class="toc-text">拆分链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">5.</span> <span class="toc-text">栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.</span> <span class="toc-text">括号匹配问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C%E5%AF%B9%E5%AF%B9%E7%A2%B0%E2%80%9D%E6%B6%88%E9%99%A4"><span class="toc-number">5.2.</span> <span class="toc-text">“对对碰”消除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">5.3.</span> <span class="toc-text">后缀表达式求值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-number">5.4.</span> <span class="toc-text">单调栈和单调队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E9%AB%98%E6%B8%A9%E5%BA%A6%EF%BC%88%E5%8D%95%E8%B0%83%E6%A0%88%EF%BC%89"><span class="toc-number">5.4.1.</span> <span class="toc-text">更高温度（单调栈）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E6%8E%89-K-%E4%BD%8D%E6%95%B0%E5%AD%97%EF%BC%88%E5%8D%95%E8%B0%83%E6%A0%88%EF%BC%89"><span class="toc-number">5.4.2.</span> <span class="toc-text">移掉 K 位数字（单调栈）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D"><span class="toc-number">5.4.3.</span> <span class="toc-text">去除重复字母</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">5.5.</span> <span class="toc-text">滑动窗口最大值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81"><span class="toc-number">5.6.</span> <span class="toc-text">字符串解码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">5.7.</span> <span class="toc-text">栈实现队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">6.</span> <span class="toc-text">滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-number">6.1.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="toc-number">6.2.</span> <span class="toc-text">字符串的排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-number">6.3.</span> <span class="toc-text">无重复字符的最长子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-number">6.4.</span> <span class="toc-text">找到字符串中所有字母异位词</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">7.</span> <span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1"><span class="toc-number">7.1.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E8%BE%B9%E7%95%8C"><span class="toc-number">7.2.</span> <span class="toc-text">二分查找的边界</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC"><span class="toc-number">7.3.</span> <span class="toc-text">寻找峰值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">7.4.</span> <span class="toc-text">搜索旋转排序数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E6%9D%83%E9%87%8D%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9"><span class="toc-number">7.5.</span> <span class="toc-text">按权重随机选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8-D-%E5%A4%A9%E5%86%85%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B"><span class="toc-number">7.6.</span> <span class="toc-text">在 D 天内送达包裹的能力</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82"><span class="toc-number">7.7.</span> <span class="toc-text">爱吃香蕉的珂珂</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%80%92%E5%BD%92%E6%80%9D%E8%B7%AF"><span class="toc-number">8.1.</span> <span class="toc-text">二叉树问题的基本递归思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86"><span class="toc-number">8.2.</span> <span class="toc-text">二叉树的迭代遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">8.2.1.</span> <span class="toc-text">先序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">8.2.2.</span> <span class="toc-text">后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">8.2.3.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">8.2.4.</span> <span class="toc-text">层序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.3.</span> <span class="toc-text">翻转二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BST%EF%BC%88%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%89"><span class="toc-number">8.4.</span> <span class="toc-text">BST（二叉搜索树）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BST-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">8.4.1.</span> <span class="toc-text">BST 的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BST-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">8.4.2.</span> <span class="toc-text">BST 基本操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E6%98%AF%E5%90%A6%E6%98%AF%E6%9C%89%E6%95%88-BST"><span class="toc-number">8.5.</span> <span class="toc-text">验证是否是有效 BST</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC-BST"><span class="toc-number">8.6.</span> <span class="toc-text">有序数组转 BST</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.6.0.1.</span> <span class="toc-text">构造最大二叉树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.7.</span> <span class="toc-text">判断平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.8.</span> <span class="toc-text">平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.9.</span> <span class="toc-text">比较两棵二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%B4%E5%AF%B9%E7%A7%B0"><span class="toc-number">8.10.</span> <span class="toc-text">二叉树轴对称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-number">8.11.</span> <span class="toc-text">二叉树的深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-number">8.12.</span> <span class="toc-text">二叉树的路径问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98-1%EF%BC%88%E7%9B%AE%E6%A0%87%E5%92%8C%EF%BC%89"><span class="toc-number">8.12.1.</span> <span class="toc-text">路径问题 1（目标和）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98-2%EF%BC%88%E5%85%B7%E4%BD%93%E8%B7%AF%E5%BE%84%EF%BC%89"><span class="toc-number">8.12.2.</span> <span class="toc-text">路径问题 2（具体路径）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98-3%EF%BC%88%E4%BB%BB%E6%84%8F%E8%8A%82%E7%82%B9%E5%BC%80%E5%A7%8B%EF%BC%89"><span class="toc-number">8.12.3.</span> <span class="toc-text">路径问题 3（任意节点开始）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">8.12.4.</span> <span class="toc-text">最大路径和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="toc-number">8.13.</span> <span class="toc-text">二叉树左叶子之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%80%BC"><span class="toc-number">8.14.</span> <span class="toc-text">二叉树最值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">8.15.</span> <span class="toc-text">二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.16.</span> <span class="toc-text">从前序遍历和中序遍历构造二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.17.</span> <span class="toc-text">合并二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%88%E5%89%8D%E6%8C%87%E9%92%88%EF%BC%89"><span class="toc-number">8.18.</span> <span class="toc-text">二叉树的双指针（前指针）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A0%E6%A0%91%E7%9A%84%E4%BC%97%E6%95%B0"><span class="toc-number">8.18.1.</span> <span class="toc-text">二叉搜素树的众数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9B%9E%E6%BA%AF"><span class="toc-number">8.19.</span> <span class="toc-text">二叉树的回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">8.20.</span> <span class="toc-text">二叉树的序列化和反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-II"><span class="toc-number">8.21.</span> <span class="toc-text">不同的二叉搜索树 II</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-number">9.</span> <span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-number">9.1.</span> <span class="toc-text">回溯问题的基本思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">9.1.1.</span> <span class="toc-text">去重方法的选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%BB%E9%87%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">9.1.2.</span> <span class="toc-text">去重的几种方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98"><span class="toc-number">9.1.3.</span> <span class="toc-text">特殊回溯问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-number">9.2.</span> <span class="toc-text">全排列问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">9.2.1.</span> <span class="toc-text">基本全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97-2%EF%BC%88%E5%89%AA%E6%9E%9D%EF%BC%89"><span class="toc-number">9.2.2.</span> <span class="toc-text">全排列 2（剪枝）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98"><span class="toc-number">9.3.</span> <span class="toc-text">组合问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98"><span class="toc-number">9.3.1.</span> <span class="toc-text">基本组合问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-number">9.3.2.</span> <span class="toc-text">组合总和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-2"><span class="toc-number">9.3.3.</span> <span class="toc-text">组合总和 2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-number">9.3.4.</span> <span class="toc-text">电话号码的字母组合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98"><span class="toc-number">9.4.</span> <span class="toc-text">子集问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98"><span class="toc-number">9.4.1.</span> <span class="toc-text">基本子集问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">9.4.2.</span> <span class="toc-text">递增子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%92%E5%88%86-K-%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86"><span class="toc-number">9.4.3.</span> <span class="toc-text">划分 K 个相等的子集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E9%97%AE%E9%A2%98"><span class="toc-number">9.5.</span> <span class="toc-text">分割问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-number">9.5.1.</span> <span class="toc-text">分割回文串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%95%88-ip-%E5%9C%B0%E5%9D%80"><span class="toc-number">9.5.2.</span> <span class="toc-text">有效 ip 地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">9.5.3.</span> <span class="toc-text">把数字翻译成字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98"><span class="toc-number">9.6.</span> <span class="toc-text">岛屿问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-number">9.6.1.</span> <span class="toc-text">岛屿数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%B2%9B%E5%B1%BF%E9%9D%A2%E7%A7%AF"><span class="toc-number">9.6.2.</span> <span class="toc-text">最大岛屿面积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E9%97%AD%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-number">9.6.3.</span> <span class="toc-text">封闭岛屿数量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="toc-number">9.7.</span> <span class="toc-text">括号生成</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">10.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">10.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">10.2.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">10.3.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">10.4.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E6%8E%92"><span class="toc-number">10.5.</span> <span class="toc-text">快排</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TOP-K-%E9%97%AE%E9%A2%98"><span class="toc-number">10.6.</span> <span class="toc-text">TOP K 问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">11.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98"><span class="toc-number">11.1.</span> <span class="toc-text">爬楼梯问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%98"><span class="toc-number">11.2.</span> <span class="toc-text">跳跃问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-I"><span class="toc-number">11.2.1.</span> <span class="toc-text">跳跃游戏 I</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II"><span class="toc-number">11.2.2.</span> <span class="toc-text">跳跃游戏 II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%91%E7%A1%AC%E5%B8%81%E6%89%BE%E9%9B%B6"><span class="toc-number">11.3.</span> <span class="toc-text">最少硬币找零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="toc-number">11.4.</span> <span class="toc-text">整数拆分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">11.5.</span> <span class="toc-text">不同的二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-number">11.6.</span> <span class="toc-text">不同路径问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E6%9C%80%E5%B0%8F%E5%92%8C"><span class="toc-number">11.7.</span> <span class="toc-text">下降路径最小和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="toc-number">11.8.</span> <span class="toc-text">杨辉三角</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="toc-number">11.9.</span> <span class="toc-text">背包类问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-number">11.9.1.</span> <span class="toc-text">背包问题基本思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">11.9.2.</span> <span class="toc-text">0-1 背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84"><span class="toc-number">11.9.2.1.</span> <span class="toc-text">滚动数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-number">11.9.3.</span> <span class="toc-text">分割等和子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-II"><span class="toc-number">11.9.4.</span> <span class="toc-text">最后一块石头的重量 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-number">11.9.5.</span> <span class="toc-text">目标和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">11.9.6.</span> <span class="toc-text">完全背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-II"><span class="toc-number">11.9.7.</span> <span class="toc-text">零钱兑换 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98-IV"><span class="toc-number">11.9.8.</span> <span class="toc-text">组合问题 IV</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="toc-number">11.9.9.</span> <span class="toc-text">单词拆分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8-I"><span class="toc-number">11.10.</span> <span class="toc-text">买卖股票 I</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8-II"><span class="toc-number">11.11.</span> <span class="toc-text">买卖股票 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F"><span class="toc-number">11.12.</span> <span class="toc-text">买卖股票含冷冻期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-I"><span class="toc-number">11.13.</span> <span class="toc-text">打家劫舍 I</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-II"><span class="toc-number">11.14.</span> <span class="toc-text">打家劫舍 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">11.15.</span> <span class="toc-text">最大子数组和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">11.16.</span> <span class="toc-text">最长上升子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">11.17.</span> <span class="toc-text">最长连续递增子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">11.18.</span> <span class="toc-text">最长公共子数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">11.19.</span> <span class="toc-text">最长公共子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">11.20.</span> <span class="toc-text">判断子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">11.21.</span> <span class="toc-text">不同子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E6%95%B0%E9%87%8F"><span class="toc-number">11.22.</span> <span class="toc-text">回文子串数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">11.23.</span> <span class="toc-text">最长回文子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">11.24.</span> <span class="toc-text">最长回文子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="toc-number">11.25.</span> <span class="toc-text">最大正方形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">11.26.</span> <span class="toc-text">最长递增子序列的个数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">12.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AC%A2%E4%B9%90%E6%95%B0"><span class="toc-number">12.1.</span> <span class="toc-text">欢乐数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C-II"><span class="toc-number">12.2.</span> <span class="toc-text">四数之和 II</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-number">13.</span> <span class="toc-text">贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><span class="toc-number">13.1.</span> <span class="toc-text">最大子序和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#K-%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">13.2.</span> <span class="toc-text">K 次取反后最大化的数组和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="toc-number">13.3.</span> <span class="toc-text">无重叠区间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E6%B3%95"><span class="toc-number">14.</span> <span class="toc-text">分治法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">14.1.</span> <span class="toc-text">为运算表达式设计优先级</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BFS"><span class="toc-number">15.</span> <span class="toc-text">BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81"><span class="toc-number">15.1.</span> <span class="toc-text">打开转盘锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95"><span class="toc-number">16.</span> <span class="toc-text">图相关算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E8%A1%A8%E9%97%AE%E9%A2%98%EF%BC%88%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%88%90%E7%8E%AF%E5%88%A4%E6%96%AD%EF%BC%89"><span class="toc-number">16.1.</span> <span class="toc-text">课程表问题（有向图的成环判断）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-number">16.2.</span> <span class="toc-text">二分图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">17.</span> <span class="toc-text">特殊数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8-1"><span class="toc-number">17.1.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-number">17.1.1.</span> <span class="toc-text">哈希函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%EF%BC%88%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E%EF%BC%89"><span class="toc-number">17.1.2.</span> <span class="toc-text">哈希冲突（哈希碰撞）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js-%E5%AE%9E%E7%8E%B0%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">17.1.3.</span> <span class="toc-text">js 实现哈希表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">17.2.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">17.2.1.</span> <span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Top-K"><span class="toc-number">17.2.2.</span> <span class="toc-text">Top K</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">17.3.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">17.3.1.</span> <span class="toc-text">邻接表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">17.3.2.</span> <span class="toc-text">图的遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">17.4.</span> <span class="toc-text">并查集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE"><span class="toc-number">18.</span> <span class="toc-text">其他类型题目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">18.1.</span> <span class="toc-text">圆圈中最后剩下的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%98%E6%B3%95"><span class="toc-number">18.2.</span> <span class="toc-text">字符串乘法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E4%B8%80%E4%B8%AA%E7%9F%A9%E9%98%B5"><span class="toc-number">18.3.</span> <span class="toc-text">旋转一个矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84"><span class="toc-number">18.4.</span> <span class="toc-text">简化路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-number">18.5.</span> <span class="toc-text">合并区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="toc-number">18.6.</span> <span class="toc-text">简单计算器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86%E7%9F%A9%E9%98%B5"><span class="toc-number">18.7.</span> <span class="toc-text">对角线遍历矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97"><span class="toc-number">18.8.</span> <span class="toc-text">整数转罗马数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-N-%E4%B8%AA%E6%95%B0"><span class="toc-number">18.9.</span> <span class="toc-text">第 N 个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C%E4%B8%BA-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">18.10.</span> <span class="toc-text">和为 k 的子数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%95%B0"><span class="toc-number">18.11.</span> <span class="toc-text">最大数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C"><span class="toc-number">18.12.</span> <span class="toc-text">优势洗牌</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#O-1-%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0"><span class="toc-number">18.13.</span> <span class="toc-text">O(1) 时间插入、删除和获取随机元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">18.14.</span> <span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">18.14.1.</span> <span class="toc-text">只出现一次的数字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84-0"><span class="toc-number">18.15.</span> <span class="toc-text">阶乘后的 0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0"><span class="toc-number">18.16.</span> <span class="toc-text">计数质数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B7%E7%AE%97%E6%B3%95"><span class="toc-number">18.17.</span> <span class="toc-text">水塘抽样算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E4%B8%BA%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">18.18.</span> <span class="toc-text">分割数组为连续子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F"><span class="toc-number">18.19.</span> <span class="toc-text">煎饼排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98"><span class="toc-number">18.20.</span> <span class="toc-text">括号问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%9A%E8%AE%AE%E5%AE%A4-II%EF%BC%88%E6%89%AB%E6%8F%8F%E7%BA%BF%EF%BC%89"><span class="toc-number">18.21.</span> <span class="toc-text">会议室 II（扫描线）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/15/blog47-nextjs/" title="next.js 学习"><img src="/img/nextjs.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="next.js 学习"/></a><div class="content"><a class="title" href="/2022/09/15/blog47-nextjs/" title="next.js 学习">next.js 学习</a><time datetime="2022-09-15T07:37:22.000Z" title="发表于 2022-09-15 15:37:22">2022-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/24/blog46-fe-design-pattern/" title="设计模式学习总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式学习总结"/></a><div class="content"><a class="title" href="/2022/07/24/blog46-fe-design-pattern/" title="设计模式学习总结">设计模式学习总结</a><time datetime="2022-07-24T08:21:22.000Z" title="发表于 2022-07-24 16:21:22">2022-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/11/blog42-react-deeping/" title="react原理浅析学习"><img src="/img/react.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="react原理浅析学习"/></a><div class="content"><a class="title" href="/2022/07/11/blog42-react-deeping/" title="react原理浅析学习">react原理浅析学习</a><time datetime="2022-07-11T06:07:32.000Z" title="发表于 2022-07-11 14:07:32">2022-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/18/projects/" title="无题"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/05/18/projects/" title="无题">无题</a><time datetime="2022-05-18T02:57:57.356Z" title="发表于 2022-05-18 10:57:57">2022-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/13/handwriting/" title="js手写"><img src="/img/JS.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="js手写"/></a><div class="content"><a class="title" href="/2022/05/13/handwriting/" title="js手写">js手写</a><time datetime="2022-05-13T04:21:10.000Z" title="发表于 2022-05-13 12:21:10">2022-05-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Xing Ye</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hello stranger!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>