<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>算法学习总结 | XingYeBlog</title><meta name="keywords" content="日常学习"><meta name="author" content="Xing Ye,632885485@qq.com"><meta name="copyright" content="Xing Ye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数组两数之和 1  给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。   这道题是经典的解法简单、但是可以使用更好的方法优化的问题。最简单的方式是通过双重循环遍历： 1234567function findTarget(nums, target) &amp;#123;  for (let a &#x3D; 0; a &lt; nums.le">
<meta property="og:type" content="article">
<meta property="og:title" content="算法学习总结">
<meta property="og:url" content="http://example.com/2022/04/05/blog43-algorithms/index.html">
<meta property="og:site_name" content="XingYeBlog">
<meta property="og:description" content="数组两数之和 1  给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。   这道题是经典的解法简单、但是可以使用更好的方法优化的问题。最简单的方式是通过双重循环遍历： 1234567function findTarget(nums, target) &amp;#123;  for (let a &#x3D; 0; a &lt; nums.le">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/codes1.jpg">
<meta property="article:published_time" content="2022-04-05T08:01:22.000Z">
<meta property="article:modified_time" content="2022-05-17T14:10:47.196Z">
<meta property="article:author" content="Xing Ye">
<meta property="article:tag" content="日常学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/codes1.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2022/04/05/blog43-algorithms/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法学习总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-17 22:10:47'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/pinkstar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/codes1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XingYeBlog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法学习总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-05T08:01:22.000Z" title="发表于 2022-04-05 16:01:22">2022-04-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-17T14:10:47.196Z" title="更新于 2022-05-17 22:10:47">2022-05-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">24.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>95分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法学习总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="两数之和-1"><a href="#两数之和-1" class="headerlink" title="两数之和 1"></a>两数之和 1</h2><blockquote>
<ol>
<li>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</li>
</ol>
</blockquote>
<p>这道题是经典的解法简单、但是可以使用更好的方法优化的问题。<br>最简单的方式是通过双重循环遍历：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findTarget</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> a = <span class="number">0</span>; a &lt; nums.length; a++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> b = <span class="number">0</span>; b &lt; nums.length; b++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[a] + nums[b] === target) <span class="keyword">return</span> [a, b];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是可以通过“空间换时间，加法转减法”的方法优化这道题目。<br>思路是求和问题转化为求差问题, 每遍历到一个新数字的时候，都回到 <code>Map</code> 里去查询 <code>targetNum</code> 与该数的差值是否已经在前面的数字中出现过了。如果出现过显然就是结果；如果没有出现就记录当前数字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findTargetByMap</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  map.set(nums[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.has(target - nums[i])) &#123;</span><br><span class="line">      <span class="comment">// 如果目标数减去当前数在map中存在, 说明找到了</span></span><br><span class="line">      <span class="keyword">return</span> [i, map.get(target - nums[i])];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有找到, 则把该数放到map中</span></span><br><span class="line">      map.set(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><blockquote>
<ol start="2">
<li>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</li>
</ol>
</blockquote>
<p>思路是使用两个指针（i、j）分别指向两个数组中的数字，然后两边同时遍历，比较两个指针所指的数字的大小关系，把较小的一个放入新数组，依次类推；<br>最终有一个数组会剩下一部分，再把这一部分截下来补在最后即可</p>
<blockquote>
<p>注意：双指针法用在涉及求和、比大小类的数组题目里时，大前提往往是：该数组必须有序。否则双指针根本无法帮助我们缩小定位的范围，压根没有意义。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatArray</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newArr = [];</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) &#123;</span><br><span class="line">    newArr.push(arr1[i] &lt; arr2[j] ? arr1[i++] : arr2[j++]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [...newArr, ...(i === arr1.length ? arr2.slice(j) : arr1.slice(i))];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三数求和"><a href="#三数求和" class="headerlink" title="三数求和"></a>三数求和</h2><blockquote>
<ol start="3">
<li>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</li>
</ol>
</blockquote>
<p>思路：</p>
<ol>
<li>首先先对数组排序；</li>
<li>然后固定一个元素<code>k</code>,然后双指针分别指向其后后面元素的第一个<code>k+1</code>和最后一个<code>length - 1</code>,按照两元素和的方法移动指针<ul>
<li>若三个数相加之和大于 0，说明右侧的数偏大了，右指针左移</li>
<li>若三个数相加之和小于 0，说明左侧的数偏小了，左指针右移</li>
</ul>
</li>
</ol>
<p>因为要求找到不重复的三元组，因此遍历期间两个指针处如果有重复的数字应该跳过；并且固定的元素也应该跳过重复</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">triNumberSum</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  nums = nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> cache = []; <span class="comment">// 存储防止重复</span></span><br><span class="line">  <span class="keyword">const</span> newArr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; nums.length - <span class="number">2</span>; k++) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果当前正在遍历的数字重复了就直接跳过</span></span><br><span class="line">    <span class="keyword">if</span> (cache.includes(nums[k])) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">const</span> sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">      <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 等于0得到结果</span></span><br><span class="line">        newArr.push([nums[i], nums[j], nums[k]]);</span><br><span class="line">        cache.push(nums[k]);</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 大于0说明右边大了</span></span><br><span class="line">        j--;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; i &amp;&amp; nums[j] === nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="comment">// 如果前一个数和这个数一样就继续向前，即跳过重复的</span></span><br><span class="line">          j--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 小于0说明左边小了</span></span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] === nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">          i++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>左右指针一起从两边往中间位置相互迫近，这样的特殊双指针形态，被称为“对撞指针”。<br><strong>有序</strong>和<strong>数组</strong>这样的关键词出现，就要考虑使用对撞指针</p>
</blockquote>
<h2 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h2><blockquote>
<p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。<br>示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p>
</blockquote>
<p>这道题的解法不是先平方再排序，而是通过双指针的形式原地 O(1)实现。</p>
<p>思路是，新创建一个数组，然后新数组从后往前存值；接下来循环：<br>比较左指针和右指针的数的平方值大小；将较大的一个数放入新数组，然后较大数的那边指针移动。</p>
<p>之所以从后向前存值，是因为负数的平方有可能超过正数，如果从前向后没法确定最小值是哪个。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortedSquares = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="built_in">Array</span>(nums.length);</span><br><span class="line">  <span class="keyword">while</span> (k &lt; res.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] ** <span class="number">2</span> &lt; nums[j] ** <span class="number">2</span>) &#123;</span><br><span class="line">      res[k++] = nums[i] ** <span class="number">2</span>;</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res[k++] = nums[j] ** <span class="number">2</span>;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><blockquote>
<p>给你一个数组 nums  和一个值 val，你需要 原地 移除所有数值等于  val  的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<p>这道题的思路是利用快慢指针；当走到目标元素时，让快指针先走到第一个不是目标元素的位置，然后将快指针所指的值替换到慢指针的位置即可。注意要保存两个指针之间的位置差</p>
<p>还有一点，遍历至少要完成所有元素的一次遍历；所以可以<strong>让慢指针延迟，而不是让快指针先走</strong>的方式；当快指针走到头时，遍历就完成了，此时慢指针恰好就是最后一个。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">val</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElement = <span class="function"><span class="keyword">function</span> (<span class="params">nums, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] !== val) &#123;</span><br><span class="line">      nums[k] = nums[i];</span><br><span class="line">      k++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> k;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="回文字符串"><a href="#回文字符串" class="headerlink" title="回文字符串"></a>回文字符串</h2><blockquote>
<ol>
<li>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。<br>示例：<br>输入: “abca”<br>输出: True<br>解释: 你可以删除 c 字符。</li>
</ol>
</blockquote>
<p>思路：利用回文字符串的“对称性”，即字符串从两头分别遍历，每个字符都相等（直到两个遍历指针相碰）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> strArr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = strArr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strArr[i] === strArr[j]) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么放到这个题就是，现进行一次上面的操作，直到找到第一个不不相等的字符串为止；</p>
<p>然后“跳过”这个字符，分别让左指针跳过当前正在指的字符、右指针跳过当前正在指的字符，然后判断跳过之后左右指针中间的字符段是否回文。</p>
<p>原理其实是，由于判断出现不同时，不知道是左边还是右边的那个字符不对，因此就让左右分别跳过，测试跳过之后中间部分是不是还能正常回文。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">palindrome</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> strArr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = strArr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strArr[i] === strArr[j]) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        isPalindrome(str.slice(i + <span class="number">1</span>, j)) &amp;&amp; isPalindrome(str.slice(i, j - <span class="number">1</span>))</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> strArr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = strArr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strArr[i] === strArr[j]) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><p>KMP 算法的讲解可以参考 <a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a><br>详细代码参考 <a target="_blank" rel="noopener" href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s2</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">KMP</span>(<span class="params">s1, s2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取next数组，这里就是最大前缀数组</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getNext</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [<span class="number">0</span>]; <span class="comment">// 第一项一定是0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">1</span>; k &lt; str.length; k++) &#123;</span><br><span class="line">      <span class="comment">//从第二个字母开始遍历</span></span><br><span class="line">      <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> j = k;</span><br><span class="line">      <span class="keyword">let</span> start = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">let</span> end = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; str.length - <span class="number">1</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        start += str[i++];</span><br><span class="line">        end += str[j--]; <span class="comment">// 因为end是从后向前拼的，应该倒转一下</span></span><br><span class="line">        <span class="keyword">if</span> (start === end.split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">          max = <span class="built_in">Math</span>.max(max, start.length);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      res.push(max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> str = s1.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> search = s2.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> next = getNext(search);</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 这里用while而不是用if，因为如果出现不匹配，应当是按照前缀数组next一个一个</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str[i] !== search[j]) &#123;</span><br><span class="line">      <span class="comment">// 如果j=0，说明子串第一项就不匹配，直接继续（只i++）</span></span><br><span class="line">      j = next[j - <span class="number">1</span>]; <span class="comment">// 回退的实际上是前一项的最大前后缀</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前匹配，继续</span></span><br><span class="line">    <span class="keyword">if</span> (str[i] === search[j]) &#123;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 匹配完成</span></span><br><span class="line">    <span class="keyword">if</span> (j === search.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> i - search.length + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>next 的计算还有一种的写法，利用前缀和后缀的最后一个字母不同时，回退前一个 next 值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNext</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> next = [<span class="number">0</span>]; <span class="comment">// 第一项一定是0</span></span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] !== s[j]) &#123;</span><br><span class="line">      j = next[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s[i] === s[j]) &#123;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    next[i] = j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重复子字符串"><a href="#重复子字符串" class="headerlink" title="重复子字符串"></a>重复子字符串</h2><blockquote>
<p>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。<br>输入: s = “abcabcabcabc”<br>输出: true<br>解释: 可由子串 “abc” 重复四次构成。 (或子串 “abcabc” 重复两次构成。)</p>
</blockquote>
<p>思路是利用 KMP 算法中的 next 数组。因为 next 数组判断的是最长公共前缀，那么 next 数组的最后一项就应该是前面的最长重复子串的长度的整数倍数。<br>即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getNext(&quot;abcdabcdabcd&quot;)</span><br><span class="line">(12) [0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure>

<p>8 这个值是<code>abcdabcd</code>的长度，这个长度重复两次就刚好是这个字符串。<br>然后让<code>12 - 8 = 4</code>，即除去公共串后，剩下还有多长；剩下的 4 可以整除 12，说明存在长度为 4 的重复子字符串。<br>因此公式为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">next.length % (next.length - next[next.length - <span class="number">1</span>]) === <span class="number">0</span> &amp;&amp;</span><br><span class="line">  next[next.length - <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 能整除，并且最后一项不为0，说明为true</span></span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> repeatedSubstringPattern = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getNext</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> next = [<span class="number">0</span>]; <span class="comment">// 第一项一定是0</span></span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] !== s[j]) &#123;</span><br><span class="line">        j = next[j - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (s[i] === s[j]) &#123;</span><br><span class="line">        j++;</span><br><span class="line">      &#125;</span><br><span class="line">      next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> next = getNext(s);</span><br><span class="line">  <span class="keyword">if</span> (s.length % (s.length - next[next.length - <span class="number">1</span>]) || !next[next.length - <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="合并链表"><a href="#合并链表" class="headerlink" title="合并链表"></a>合并链表</h2><blockquote>
<ol>
<li>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有结点组成的。</li>
</ol>
</blockquote>
<p>有序链表的合成和有序数组的合并类似，都是用双指针依次遍历节点。</p>
<p>通过 LinkNode 新创建一个头节点，然后依次把两个链表中的节点比较、附加在这个新的头节点后面，形成的新链表就是有序链表。最后再把没连接上的多余部分加上去即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeTwoLists = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> head = <span class="keyword">new</span> LinkNode();</span><br><span class="line">  <span class="keyword">let</span> curr = head;</span><br><span class="line">  <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">      curr.next = l1;</span><br><span class="line">      l1 = l1.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      curr.next = l2;</span><br><span class="line">      l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  curr.next = l1 ? l1 : l2;</span><br><span class="line">  <span class="keyword">return</span> curr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="dummy-节点"><a href="#dummy-节点" class="headerlink" title="dummy 节点"></a>dummy 节点</h2><blockquote>
<ol start="2">
<li>给定一个排序链表，删除所有含有重复数字的结点，只保留原始链表中 没有重复出现的数字。</li>
</ol>
</blockquote>
<p>这道题乍看起来比较简单，可以用一个 set 存储前面遍历过的数字，如果在 set 中找到，就把这些删去。</p>
<p>问题在于，这里要求删去所有节点，那么重复的这一组节点中的头一个节点就无法删去，因为不能获取到它前面的节点，就不能删去它</p>
<p>为了解决这个问题，设置一个位于整个链表头部的 dummy 节点，从 dummy 开始遍历（假设当前指针是 curr）：如果<code>curr.next.val === curr.next.next.val</code>，就用循环依次遍历到不相等的节点，然后把<code>curr.next</code>指过去即可。</p>
<p>dummy 节点的出现在这里主要是为了解决第一个节点就是重复节点的问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deleteDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 设定 dummy 指针，作为头节点的前一个虚拟节点</span></span><br><span class="line">  <span class="keyword">let</span> dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">  dummy.next = head;</span><br><span class="line">  <span class="keyword">let</span> cur = dummy; <span class="comment">// 从dummy开始，这样就解决了第一个就重复的情况</span></span><br><span class="line">  <span class="keyword">while</span> (cur.next &amp;&amp; cur.next.next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur.next.val === cur.next.next.val) &#123;</span><br><span class="line">      <span class="comment">// 若值重复，则记下这个值</span></span><br><span class="line">      <span class="keyword">let</span> val = cur.next.val;</span><br><span class="line">      <span class="comment">// 反复地排查后面的元素是否存在多次重复该值的情况</span></span><br><span class="line">      <span class="keyword">while</span> (cur.next &amp;&amp; cur.next.val === val) &#123;</span><br><span class="line">        <span class="comment">// 若有，则删除</span></span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 若不重复，则正常遍历</span></span><br><span class="line">      cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注意是dummy.next</span></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><blockquote>
<ol start="3">
<li>给定一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</li>
</ol>
</blockquote>
<p>快慢指针即设定两个指针，快指针在慢指针前面或者快指针一次走的步数比慢指针多；当快指针到达某个位置时，慢指针往往就是对应的解。</p>
<p>比如倒数 n 个节点，可以让快指针先走 n 步，然后两者一起往前走；当快指针走到最后一个节点时，慢指针所指向的就是倒数第 n 个</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> removeNthFromEnd = <span class="function"><span class="keyword">function</span> (<span class="params">head, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">  dummy.next = head;</span><br><span class="line">  <span class="keyword">let</span> fast = dummy;</span><br><span class="line">  <span class="keyword">let</span> slow = dummy;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!fast.next) <span class="keyword">return</span>;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (fast.next) &#123;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">  &#125;</span><br><span class="line">  slow.next = slow.next.next;</span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><blockquote>
<ol start="4">
<li>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</li>
</ol>
</blockquote>
<p>记住方法：</p>
<ol>
<li>使用 prev/curr/next 三个指针分别指向前一个、当前和后一个节点；其中 curr 是第一个节点，prev 可以是 null 或者 dummy</li>
<li>从 curr 指向的第一个节点开始，让当前节点的 next 指向 pre；</li>
<li>然后令<code>curr = next，prev = curr，next = next.next</code>，即依次向后移动，直到最后一个节点被反转</li>
<li>cur 节点是真正反转的节点，因此要遍历到最后一个；当 cur 成为 null 时，pre 就是最后一个节点</li>
</ol>
<blockquote>
<p>实际上并不需要 next 指针，因为直接用<code>curr.next</code>就可以，每次遍历都先获取<code>curr.next</code>并缓存一下，然后继续即可</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseList = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="literal">null</span>; <span class="comment">// 前节点</span></span><br><span class="line">  <span class="keyword">let</span> cur = head; <span class="comment">// 当前节点，从头节点开始</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = cur.next; <span class="comment">// 先缓存next</span></span><br><span class="line">    cur.next = pre;</span><br><span class="line">    pre = cur;</span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<ol start="5">
<li>部分反转：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</li>
</ol>
</blockquote>
<p>核心方法和正常的反转链表一样，关键在于反转之后把反转的部分和其他的连起来。<br>其实就是先把反转部分的前节点和后节点存起来，反转完成后再连起来。</p>
<p><img src="https://pic.imgdb.cn/item/6266b3c3239250f7c528044f.jpg"></p>
<p>以这幅图为例，当 curr 指针遍历到 left 时，即开始遍历到区域时，就把节点 1 缓存下来（此时正好是 pre 指针指向的）；<br>随着遍历的进行，当结点 4 的指针反转后，此时 cur 指针就恰好指在结点 5 上，这时只需要把节点 2 指向 cur 即可。</p>
<p>另外，还需要记录反转区域内部的头尾节点（上面的 2、4 节点）；其中 4 节点恰好是遍历完的 pre，直接<code>leftHead.next = pre</code>即可；但是 2 节点需要提前缓存（下面代码中的 start），结束后让<code>start.next = cur</code>连接尾部。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseBetween = <span class="function"><span class="keyword">function</span> (<span class="params">head, m, n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义pre、cur，用leftHead来承接整个区间的前驱结点</span></span><br><span class="line">  <span class="keyword">let</span> pre, cur, leftHead;</span><br><span class="line">  <span class="keyword">const</span> dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">  <span class="comment">// dummy后继结点是头结点</span></span><br><span class="line">  dummy.next = head;</span><br><span class="line">  <span class="comment">// p是一个游标，用于遍历，最初指向 dummy</span></span><br><span class="line">  <span class="keyword">let</span> p = dummy;</span><br><span class="line">  <span class="comment">// p往前走 m-1 步，走到整个区间的前驱结点处</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    p = p.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 缓存这个前驱结点到 leftHead 里</span></span><br><span class="line">  leftHead = p;</span><br><span class="line">  <span class="comment">// start 是反转区间的第一个结点</span></span><br><span class="line">  <span class="keyword">let</span> start = leftHead.next;</span><br><span class="line">  <span class="comment">// pre 指向start</span></span><br><span class="line">  pre = start;</span><br><span class="line">  <span class="comment">// cur 指向 start 的下一个结点</span></span><br><span class="line">  cur = pre.next;</span><br><span class="line">  <span class="comment">// 开始重复反转动作</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = m; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = cur.next;</span><br><span class="line">    cur.next = pre;</span><br><span class="line">    pre = cur;</span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  leftHead 的后继结点此时为反转后的区间的第一个结点</span></span><br><span class="line">  leftHead.next = pre;</span><br><span class="line">  <span class="comment">// 将区间内反转后的最后一个结点 next 指向 cur</span></span><br><span class="line">  start.next = cur;</span><br><span class="line">  <span class="comment">// dummy.next 永远指向链表头结点</span></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="链表交叉"><a href="#链表交叉" class="headerlink" title="链表交叉"></a>链表交叉</h2><blockquote>
<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>
</blockquote>
<p>思路是这样：因为相交之前，两个链表长度不一样；所以可以先调整起始位置，让较长的链表向前移动几位，和较短的链表头节点并齐之后再开始遍历。<br>判断相交节点的方式是两个<strong>指针</strong>相同，注意不是值相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">headA</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">headB</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span> (<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getLen</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">      len++;</span><br><span class="line">      curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> lenA = getLen(headA);</span><br><span class="line">  <span class="keyword">const</span> lenB = getLen(headB);</span><br><span class="line">  <span class="keyword">let</span> startIndex = <span class="built_in">Math</span>.abs(lenA - lenB);</span><br><span class="line">  <span class="keyword">let</span> startA = headA;</span><br><span class="line">  <span class="keyword">let</span> startB = headB;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (lenA &gt; lenB) &#123;</span><br><span class="line">    startA = headA;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; startIndex; i++) &#123;</span><br><span class="line">      startA = startA.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lenA &lt; lenB) &#123;</span><br><span class="line">    startB = headB;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; startIndex; i++) &#123;</span><br><span class="line">      startB = startB.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (startA &amp;&amp; startB) &#123;</span><br><span class="line">    startA = startA.next;</span><br><span class="line">    startB = startB.next;</span><br><span class="line">    <span class="keyword">if</span> (startA === startB) flag = startA;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="判断回文链表"><a href="#判断回文链表" class="headerlink" title="判断回文链表"></a>判断回文链表</h2><blockquote>
<p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p>
</blockquote>
<p>这道题有几个思路：</p>
<ol>
<li>最朴实的方法，先快慢指针找到中间节点，然后从中间节点开始反转后面的链表，再双指针比较两个链表是否相等。</li>
<li>顺序输出转换成数组，然后判断数组是否回文。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> curr = head;</span><br><span class="line">  <span class="keyword">const</span> arr = [];</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    arr.push(curr.val);</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.join(<span class="string">&quot;&quot;</span>) === arr.reverse().join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h2><blockquote>
<ol>
<li>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</li>
</ol>
</blockquote>
<p>比较基础的栈问题，先把左括号入栈，然后当遇见右括号时，根据预设的匹配关系出栈左括号，如果不匹配就返回 false</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isValid = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">const</span> str = s.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;[&quot;</span>, <span class="string">&quot;]&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>],</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s === <span class="string">&quot;(&quot;</span> || s === <span class="string">&quot;[&quot;</span> || s === <span class="string">&quot;&#123;&quot;</span>) &#123;</span><br><span class="line">      stack.push(s);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s === <span class="string">&quot;)&quot;</span> || s === <span class="string">&quot;]&quot;</span> || s === <span class="string">&quot;&#125;&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> top = stack.pop();</span><br><span class="line">      <span class="keyword">if</span> (s !== map.get(top)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!stack.length) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="“对对碰”消除"><a href="#“对对碰”消除" class="headerlink" title="“对对碰”消除"></a>“对对碰”消除</h2><blockquote>
<p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。<br>在 S 上反复执行重复项删除操作，直到无法继续删除。<br>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p>示例：</p>
<p>输入：”abbaca”<br>输出：”ca”<br>解释：例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。</p>
</blockquote>
<p>利用栈，把每一项一次入栈，如果有和栈顶元素相同的就把栈顶元素出栈</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.gif"></p>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> top = stack[stack.length - <span class="number">1</span>] || <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[i] === top) stack.pop();</span><br><span class="line">    <span class="keyword">else</span> stack.push(s[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="后缀表达式求值"><a href="#后缀表达式求值" class="headerlink" title="后缀表达式求值"></a>后缀表达式求值</h2><blockquote>
<p>根据 逆波兰表示法，求表达式的值。<br>有效的运算符包括 + , - , * , / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br>说明：<br>整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
<p>示例 1：<br>输入: [“2”, “1”, “+”, “3”, “ * “]<br>输出: 9<br>解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9<br>示例 2：<br>输入: [“4”, “13”, “5”, “/“, “+”]<br>输出: 6<br>解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</p>
</blockquote>
<p>后缀表达式是计算机常用的计算表达式的方法。<br>后缀表达式可以看作是一棵后序遍历的树，每个运算符都是中间节点，以运算符为根节点的子树是一个表达式的值；<br>因此可以通过这个思路引入栈，执行这样的操作：</p>
<ol>
<li>如果是数字，入栈</li>
<li>如果是运算符，就把栈顶的两个元素出栈，并通过运算符计算，结果入栈</li>
</ol>
<p>代码如下：</p>
<blockquote>
<p>注意这里有个坑：除法应该使用<code>Math.trunc</code>去掉小数部分，模拟 java 等语言中的整形运算。不能是<code>Math.floor</code>，因为处理负数时会向下取整。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">tokens</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> evalRPN = <span class="function"><span class="keyword">function</span> (<span class="params">tokens</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">&quot;+&quot;</span>, <span class="function">(<span class="params">a, b</span>) =&gt;</span> a * <span class="number">1</span> + b * <span class="number">1</span>],</span><br><span class="line">    [<span class="string">&quot;-&quot;</span>, <span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a],</span><br><span class="line">    [<span class="string">&quot;*&quot;</span>, <span class="function">(<span class="params">a, b</span>) =&gt;</span> b * a],</span><br><span class="line">    [<span class="string">&quot;/&quot;</span>, <span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="built_in">Math</span>.trunc(b / a)],</span><br><span class="line">  ]);</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">of</span> tokens) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!s.has(i)) &#123;</span><br><span class="line">      stack.push(i);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(s.get(i)(stack.pop(), stack.pop()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack.pop();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="单调栈和单调队列"><a href="#单调栈和单调队列" class="headerlink" title="单调栈和单调队列"></a>单调栈和单调队列</h2><blockquote>
<p>给定一个整数数组  temperatures ，表示每天的温度，返回一个数组  answer ，其中<code>answer[i]</code>  是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用  0 来代替。<br>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
</blockquote>
<p>思路：创建一个索引栈，用于记录索引。这个栈同时还是一个最小栈，即保持栈顶的元素始终是最小的。</p>
<p>确定一个<strong>单调递减的趋势</strong>，一旦有数字打破了这个趋势，也就说一个数字比它前面入栈的数字大，那就把它前面比他小的数字都出栈，并且用它的索引减去这些数字的索引，减去的值恰好就是对应的 answer。</p>
<blockquote>
<p>演示视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12t4y1274o/">https://www.bilibili.com/video/BV12t4y1274o/</a></p>
</blockquote>
<p>至于为什么栈中不直接放入温度而是存索引，是因为要得出的结果 ans 是每个元素的索引相加减得出的，并且也恰好是按照索引顺序摆放的。<br>索引栈是一个很好用的思维方式，可以尝试多用用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dailyTemperatures = <span class="function"><span class="keyword">function</span> (<span class="params">temperatures</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  stack[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> ans = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (</span><br><span class="line">      stack.length &amp;&amp;</span><br><span class="line">      temperatures[i] &gt; temperatures[stack[stack.length - <span class="number">1</span>]]</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">const</span> index = stack.pop();</span><br><span class="line">      ans[index] = i - index;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h2><blockquote>
<ol start="3">
<li>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。<br>滑动窗口大概长这样：<br>1 [3 -1 -3] 5 3 6 7<br>1 3 [-1 -3 5] 3 6 7<br>1 3 -1 [-3 5 3] 6 7<br>1 3 -1 -3 [5 3 6] 7<br>1 3 -1 -3 5 [3 6 7]</li>
</ol>
</blockquote>
<p>基础思路是用一个双指针分别指向窗口的左和右，然后取得双指针之间的最大值放入结果.但是这个方法不好，因为实际上有很多已经判断过的数被重复比较</p>
<p>因此更好的思路是利用<strong>单调递减</strong>的<strong>双端队列</strong>，遍历把每个 nums 中的索引放入（还是索引，因为需要判断队列中的数字是否超出滑动窗口范围）</p>
<p>然后最重要的是和上面的最小栈类似，如果有比队尾数小的就放入；如果比队尾数大就依次出队，直到<code>队尾数&gt;=当前数</code>为止。因此队头的元素一定是本次遍历的最大值</p>
<p>遍历时从第一个开始，当遍历数到达 k 时，就相当于产生了第一个窗口，开始记录最大值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxSlidingWindow = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> deque = [];</span><br><span class="line">  <span class="keyword">const</span> answer = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果当前数比队尾数大，就依次出队</span></span><br><span class="line">    <span class="keyword">while</span> (deque.length &amp;&amp; nums[i] &gt; nums[deque[deque.length - <span class="number">1</span>]]) &#123;</span><br><span class="line">      deque.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    deque.push(i); <span class="comment">// 当前数的索引放入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队头元素的位置是否超过了滑动窗口的前沿（即 i + 1 - k）</span></span><br><span class="line">    <span class="keyword">if</span> (deque.length &amp;&amp; deque[<span class="number">0</span>] &lt; i + <span class="number">1</span> - k) &#123;</span><br><span class="line">      deque.shift();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当遍历数到达k时，开始记录最大值</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">      answer.push(nums[deque[<span class="number">0</span>]]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h2><blockquote>
<ol start="4">
<li>用栈实现队列，只能使用栈的 push 和 pop 方法。</li>
</ol>
</blockquote>
<p>思路是用两个栈存储，正常的入队就是 push 到 stack1；但是每次出队时，将 stack1 中的元素依次出栈再入栈到 stack2 中，这样栈底元素就被取出了；此后再次入队仍然是到 stack1 中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stack1 = [];</span><br><span class="line">    <span class="built_in">this</span>.stack2 = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">enqueue</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stack1.push(val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">dequeue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.stack2.length) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.stack1.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>.stack2.push(<span class="built_in">this</span>.stack1.pop());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack2.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">peek</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.stack2.length) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.stack1.length; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>.stack2.push(<span class="built_in">this</span>.stack1.pop());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack2[<span class="built_in">this</span>.stack2.length - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack1.length + <span class="built_in">this</span>.stack2.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树问题的基本递归思路"><a href="#二叉树问题的基本递归思路" class="headerlink" title="二叉树问题的基本递归思路"></a>二叉树问题的基本递归思路</h2><p>二叉树问题基本上都离不开递归和遍历；<br>而递归实际上有两种，一种是单纯只递归，比如基本的递归遍历方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  dfs(node.left);</span><br><span class="line">  dfs(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种递归只有在边界条件才会返回，因此一般常用于彻底的遍历，比如路径问题。<br>在思考方式上，这种递归可以看作是只有一个左右节点的树的遍历。常常把操作放置在两个递归的<code>dfs()</code>前面、中间或后面，对应不同的时刻：</p>
<ul>
<li>前面：该节点已经遍历到，但其子节点还没开始遍历，可以进行记录该节点值、判断临界条件等操作</li>
<li>中间：只遍历了左子树，一般很少放在这里，除非是为了中序遍历</li>
<li>后面：该节点和其子树都被完全遍历。站在最顶层调用栈的角度上，这时整棵树已经遍历完毕；可以在这里显式返回一个值，这个值将会是上面每个 dfs 都会返回的值；也可以执行一些<strong>回溯</strong>相关的操作，比如路径问题中在这里让当前节点出栈、回溯问题中在这里返回上一层等等</li>
</ul>
<hr>
<p>另一种递归是显式的返回值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = dfs(node.left);</span><br><span class="line">  <span class="keyword">let</span> right = dfs(node.right);</span><br><span class="line">  <span class="keyword">return</span> node.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时前面两个递归的 dfs 也会产生有效的返回值，并且返回的值就是最末端的返回值。</p>
<p>注意要以“递归的方式思考问题”，不要把上面两个 dfs 看成复杂的调用栈，而是只把他们当作左节点和右节点的调用结果即可。</p>
<blockquote>
<p>这种遍历方式能够生效的最重要一点是：<strong>左右递归调用结果</strong>（<strong>当前节点</strong>有时候也会）都会参与返回值的运算</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = dfs(node.left);</span><br><span class="line">  <span class="keyword">let</span> right = dfs(node.right);</span><br><span class="line">  <span class="keyword">return</span> node.val + <span class="built_in">Math</span>.max(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就会把当前节点的值和左右子节点中较大的值加起来。由于自底向上的每次返回都用到了 left 和 right，因此数值就是从下向上连续的，left 和 right 可以看作是左右子树的计算结果。</p>
<p>再比如，常见的方法之一是利用返回布尔值进行一些判断。比如基本的递归搜索一个值，找到了则返回 true</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和搜索相关的问题是少都要考虑这个写法，这是最基本的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">root, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> search(root.left, val) || search(root.right, val) || root.val === val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里返回值综合了两个遍历的结果和当前节点的值，只要有一个符合条件就返回 true，即找到一个就返回 true。</p>
<p>当函数参数不止有节点这一个参数时，当前节点值还可以放入参数中。比如<code>路径总和1</code>这个题，就是通过每次递减一个当前节点值来实现。</p>
<p>还可以有条件的返回不同的值；这种方法常见于偏运算，比如只计算左叶子和这种问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = dfs(node.left);</span><br><span class="line">  dfs(node.right);</span><br><span class="line">  sum += left;</span><br><span class="line">  <span class="keyword">if</span> (!node.left &amp;&amp; !node.right) <span class="keyword">return</span> node.val;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只有当节点为叶子节点时才会返回有效的值，相当于是在遍历之中设置了回溯条件。</p>
<h2 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h2><blockquote>
<ol>
<li>用迭代方法实现二叉树的遍历</li>
</ol>
</blockquote>
<h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><ol>
<li>将根节点入栈</li>
<li>出栈，输出该节点，然后将该节点的子节点入栈，先右后左；这样出栈的顺序就是先左后右，符合先序遍历的<code>左-&gt;右-&gt;中</code>顺序</li>
<li>后续依次类推</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> preorder = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  stack.push(root);</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = stack.pop();</span><br><span class="line">    res.push(node.val);</span><br><span class="line">    <span class="keyword">if</span> (node.right) stack.push(node.right);</span><br><span class="line">    <span class="keyword">if</span> (node.left) stack.push(node.left);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><ol>
<li>同样是先入栈根节点</li>
<li>出栈，将该节点的输出插入到结果队列的头部（unshift），这样结果数组相当于是反向；然后将子节点入栈，先左后右</li>
<li>以此类推</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> postorderIterate = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">  stack.push(root);</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = stack.pop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相当于把结果数组反向了</span></span><br><span class="line">    res.unshift(node.val);</span><br><span class="line">    <span class="comment">// 因为结果数组反向,这里也要变一下</span></span><br><span class="line">    <span class="keyword">if</span> (node.left) stack.push(node.left);</span><br><span class="line">    <span class="keyword">if</span> (node.right) stack.push(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>中序遍历根另外两者都不一样，因为先序和后序都是通过出栈一个元素作为根节点，然后把它的左右子元素入栈。但是中序遍历的顺序是<code>左-&gt;中-&gt;右</code>，也就说必须有从<code>左</code>回到其父元素<code>中</code>的过程。</p>
<ol>
<li>从根节点开始迭代取左子元素，每迭代一次就入栈一个元素，直到最左端位置</li>
<li>出栈一个元素，输出结果，然后取该节点的右节点再次迭代。因为这时的出栈元素如果有右节点，说明就是一个父元素，相当于<code>中</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inorderIterate = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">  stack.push(root);</span><br><span class="line">  <span class="keyword">let</span> curr = root;</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">      stack.push(curr);</span><br><span class="line">      curr = curr.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curr = stack.pop();</span><br><span class="line">    res.push(curr.val);</span><br><span class="line">    curr = curr.right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><ol>
<li>设置一个队列，将根元素入队</li>
<li>出队队头元素并输出，把这个元素的子元素全部入队。重复这个过程，直到把上一步的所有入队元素都出队并输出；这里需要先缓存上一步时队列的长度，然后遍历这个长度直到上一层的元素都依次执行该过程。</li>
<li>依次类推</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> levelOrder = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> queue = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  queue.push(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = queue.length;</span><br><span class="line">    <span class="comment">// 相当于每次执行到这里就是新的一层</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> node = queue.shift();</span><br><span class="line">      res.push(node.val);</span><br><span class="line">      <span class="keyword">if</span> (curr.left) queue.push(curr.left);</span><br><span class="line">      <span class="keyword">if</span> (curr.right) queue.push(curr.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><blockquote>
<p><img src="https://pic.imgdb.cn/item/62675aab239250f7c5499cac.jpg"></p>
</blockquote>
<p>思路：以递归的方式，遍历树中的每一个结点，并将每一个结点的左右孩子进行交换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> invertTree = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">let</span> left = invertTree(root.left);</span><br><span class="line">  <span class="keyword">let</span> right = invertTree(root.right);</span><br><span class="line">  root.left = right;</span><br><span class="line">  root.right = left;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>翻转二叉树是这种非尾递归思想的重要体现之一；通过递归先一直到边界（即叶子节点）为止，然后返回该节点给上一层的<code>left</code>；再同理把<code>right</code>交给上一层，在上一层中进行交换，就完成了自下而上的第一次交换，后续同理。</p>
<p>比如一个通常的遍历是这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  dfs(node.left);</span><br><span class="line">  dfs(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的遍历只会在遇到边界时返回。如果我们在最后显式返回某一个值（一般就是本次递归的参数传入的节点），每一个递归就相当于拿到了其上一层的返回值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> node;</span><br><span class="line">  <span class="keyword">let</span> left = dfs(node.left); <span class="comment">// left是当前node的左子树的根节点</span></span><br><span class="line">  <span class="keyword">let</span> right = dfs(node.right); <span class="comment">// 右子树</span></span><br><span class="line">  <span class="keyword">return</span> node; <span class="comment">// 返回本节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到了 left 和 right，从递归的思维来看，实际上就是拿到了任一个节点的左右子树（不用考虑反复递归的多层，只考虑一层即可）。所以我们可以进行一些操作，比如上面的交换节点。</p>
<p>如果最简单的二叉树（只有三个节点）可以执行，那么任何情况下的二叉树都可以执行。因此这类问题可以先从最简单的考虑。如果最简单的情况可以保证递归的完整，那么之后的逻辑就不用考虑递归的内部，而是只把递归当成一个“取值”的步骤，正常处理其他逻辑。</p>
<h2 id="BST（二叉搜索树）"><a href="#BST（二叉搜索树）" class="headerlink" title="BST（二叉搜索树）"></a>BST（二叉搜索树）</h2><h3 id="BST-基本操作"><a href="#BST-基本操作" class="headerlink" title="BST 基本操作"></a>BST 基本操作</h3><p>查找：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">root, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (root.val === n) <span class="keyword">return</span> root;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; n) search(root.left, n);</span><br><span class="line">  <span class="keyword">else</span> search(root.right, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">root, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; root.val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root.left) root.left = <span class="keyword">new</span> TreeNode(n);</span><br><span class="line">    <span class="keyword">else</span> insert(root.left, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root.right) root.right = <span class="keyword">new</span> TreeNode(n);</span><br><span class="line">    <span class="keyword">else</span> insert(root.right, n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除：</p>
<p>删除节点的函数要返回参数 root，因为执行函数的返回值实际上是“替换子树”的效果，也是上面说的非尾递归的形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeNode</span>(<span class="params">root, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">  <span class="keyword">if</span> (root.val === n) &#123;</span><br><span class="line">    <span class="comment">// 如果n和当前节点值相等，即找到了要删除的节点</span></span><br><span class="line">    <span class="keyword">if</span> (root.left &amp;&amp; !root.right) &#123;</span><br><span class="line">      <span class="comment">//如果只有左子树，就把左子树中最大的值替换过来，并把这个节点删掉</span></span><br><span class="line">      root.val = findMax(root.left);</span><br><span class="line">      root.left = removeNode(root.left, findMax(root.left));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!root.left &amp;&amp; !root.right) &#123;</span><br><span class="line">      <span class="comment">// 没有左右子树，直接删去</span></span><br><span class="line">      root = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//只有右子树或者左右子树都有的情况，找到右子树最小的值并替换删去</span></span><br><span class="line">      root.val = findMin(root.right);</span><br><span class="line">      root.right = removeNode(root.right, findMin(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; n) &#123;</span><br><span class="line">    <span class="comment">// 如果没找到且小于，找左子树</span></span><br><span class="line">    root.left = removeNode(root.left, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    root.right = removeNode(root.right, n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最后一定要返回经过修改后的root</span></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找最大最小实际上就是找最左最右的值</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">findMax</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root.right) root = root.right;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">findMin</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root.left) root = root.left;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证是否是有效-BST"><a href="#验证是否是有效-BST" class="headerlink" title="验证是否是有效 BST"></a>验证是否是有效 BST</h3><p>即验证树是否保证<code>左 &lt; 中 &lt; 右</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isValidBST = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left &amp;&amp; root.left.val &gt; root.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root.right &amp;&amp; root.right.val &lt; root.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> dfs(root.left) &amp;&amp; dfs(root.right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dfs(root);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="构造-BST"><a href="#构造-BST" class="headerlink" title="构造 BST"></a>构造 BST</h3><blockquote>
<p>把有序数组转为平衡二叉树</p>
</blockquote>
<p>思路类似二分查找,把中间的数作为根节点”提起来”,然后范围二分为<code>[low,mid)</code>和<code>(mid,high]</code>分别给左右子树</p>
<p><img src="https://pic.imgdb.cn/item/62677250239250f7c582b679.jpg"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortedArrayToBST = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> buildBST(<span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buildBST</span>(<span class="params">low, high</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(low + (high - low) / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//注意这个地方需要low+...,因为不一定是从0开始的,需要low+计算值才是真正的中间值</span></span><br><span class="line">    <span class="keyword">const</span> curr = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    curr.left = buildBST(low, mid - <span class="number">1</span>);</span><br><span class="line">    curr.right = buildBST(mid + <span class="number">1</span>, high);</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>buildBST</code>方法还可以接收一个分割好的数组:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildBST</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!arr.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 这里取arr.length / 2,这样偶数元素中间值就会划分到偏后一位,防止arr.slice(0, mid - 1)在有元素的时候仍截取到空数组</span></span><br><span class="line">  <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> TreeNode(arr[mid]);</span><br><span class="line">  node.left = buildBST(arr.slice(<span class="number">0</span>, mid));</span><br><span class="line">  node.right = buildBST(arr.slice(mid + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造最大二叉树"><a href="#构造最大二叉树" class="headerlink" title="构造最大二叉树"></a>构造最大二叉树</h4><blockquote>
<p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：<br>二叉树的根是数组中的最大元素。<br>左子树是通过数组中最大值左边部分构造出的最大二叉树。<br>右子树是通过数组中最大值右边部分构造出的最大二叉树。<br>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p>
</blockquote>
<p>构造最大二叉树的思路就是在构造二叉树时，把中间节点置为数组中的最大值即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> constructMaximumBinaryTree = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> buildBST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buildBST</span>(<span class="params">nums, low, high</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> maxVal = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> maxIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = low; i &lt;= high; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; maxVal) &#123;</span><br><span class="line">        maxVal = nums[i];</span><br><span class="line">        maxIndex = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> curr = <span class="keyword">new</span> TreeNode(maxVal);</span><br><span class="line">    <span class="built_in">console</span>.log(maxVal);</span><br><span class="line">    curr.left = buildBST(nums, low, maxIndex - <span class="number">1</span>);</span><br><span class="line">    curr.right = buildBST(nums, maxIndex + <span class="number">1</span>, high);</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="判断平衡二叉树"><a href="#判断平衡二叉树" class="headerlink" title="判断平衡二叉树"></a>判断平衡二叉树</h2><p>平衡二叉树，即一个节点的左右子树高度差不能大于 1。</p>
<p>思路就是递归遍历每一个节点，计算每隔节点的左右子树高度差，如果有一个节点高度差大于 1，整体就失去平衡。</p>
<p>第一种方法是计算和遍历分开，计算节点高度是单独的方法，而遍历采用先序遍历的方式。<br>获取节点高度的方式是分别递归左右子树，每返回一次高度都会+1，最终会以左右子树中较高的为结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isBalanced = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  dfs(root);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> left = getNodeHeight(root.left);</span><br><span class="line">    <span class="keyword">let</span> right = getNodeHeight(root.right);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(left - right) &gt; <span class="number">1</span>) flag = <span class="literal">false</span>;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getNodeHeight</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(getNodeHeight(node.left), getNodeHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更好的解决方法是遍历的同时就计算高度，在递归函数末尾返回上一步得到的左右高度中较大一个+1</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isBalanced2 = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  dfs(root);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> left = dfs(root.left);</span><br><span class="line">    <span class="keyword">const</span> right = dfs(root.right);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(left - right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(left, right) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="转化-BST"><a href="#转化-BST" class="headerlink" title="转化 BST"></a>转化 BST</h2><blockquote>
<p>构造平衡二叉树.给你一棵二叉搜索树，请你返回一棵平衡后的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。</p>
</blockquote>
<p>思路就是<strong>中序遍历</strong>获取数的数组形式,然后用上面的有序数组转为平衡二叉树方法即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> balanceBST = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> nums = [];</span><br><span class="line"></span><br><span class="line">  inorder(root);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inorder</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    inorder(node.left);</span><br><span class="line">    nums.push(node.val);</span><br><span class="line">    inorder(node.right);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tree = buildBST(nums);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buildBST</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> TreeNode(arr[mid]);</span><br><span class="line">    node.left = buildBST(arr.slice(<span class="number">0</span>, mid));</span><br><span class="line">    node.right = buildBST(arr.slice(mid + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tree;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="比较两棵二叉树"><a href="#比较两棵二叉树" class="headerlink" title="比较两棵二叉树"></a>比较两棵二叉树</h2><blockquote>
<p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
</blockquote>
<p>思路：递归比较两棵树的左、右子树即可。如果两棵树完全相等，则 p 和 q 应当是完全相同的，只要有一个对不上就是 false</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isSameTree = <span class="function"><span class="keyword">function</span> (<span class="params">p, q</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((q &amp;&amp; !p) || (p &amp;&amp; !q) || p.val !== q.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树轴对称"><a href="#二叉树轴对称" class="headerlink" title="二叉树轴对称"></a>二叉树轴对称</h2><blockquote>
<p>给你一个二叉树的根节点 root，检查它是否轴对称。</p>
</blockquote>
<p>这道题和翻转二叉树思路近似，从<code>root.left</code>和<code>root.right</code>分开，分别递归比较左子树的右节点和右子树的左节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">p, q</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> ((!p &amp;&amp; q) || (!q &amp;&amp; p) || p.val !== q.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><blockquote>
<p>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
</blockquote>
<p>这道题就是求节点高度，递归遍历每一个节点，每次遍历都给返回值+1，并选择左右子树中较大的一个。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = maxDepth(root.left);</span><br><span class="line">  <span class="keyword">let</span> right = maxDepth(root.right);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这道题还有一个变种，就是求一个节点的最小深度。注意最小深度仍然是到叶子节点的，不能在空节点就停下，因此需要判断左右子节点的高度，不为 0 才返回：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minDepth = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = minDepth(root.left);</span><br><span class="line">  <span class="keyword">let</span> right = minDepth(root.right);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (left === <span class="number">0</span> &amp;&amp; right &gt; <span class="number">0</span>) <span class="keyword">return</span> right + <span class="number">1</span>; <span class="comment">// 左节点为空</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; <span class="number">0</span> &amp;&amp; right === <span class="number">0</span>) <span class="keyword">return</span> left + <span class="number">1</span>; <span class="comment">// 右节点为空</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Math</span>.min(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的路径问题"><a href="#二叉树的路径问题" class="headerlink" title="二叉树的路径问题"></a>二叉树的路径问题</h2><p>这里可以参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-ii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-oo63/">https://leetcode-cn.com/problems/path-sum-ii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-oo63/</a></p>
<p>路径问题可以分为两大类</p>
<ul>
<li>自顶向下，从某一个节点(不一定是根节点)，从上向下寻找路径，到某一个节点(不一定是叶节点)结束。方法类似，在每次遍历中记录路径，当遍历到合适条件时输出结果，再在每次递归的最尾端执行复原操作（比如出栈、总和减去当前值等等）。</li>
</ul>
<blockquote>
<p>其实这是一种回溯，路径记录之后要返回上一层，因此就在函数的最尾端执行复原操作</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  path.push(node.val);</span><br><span class="line">  <span class="keyword">if</span> (临界条件) &#123;</span><br><span class="line">    res.push(path);</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(node.left);</span><br><span class="line">  dfs(node.right);</span><br><span class="line">  path.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>

<p>如果要求有路径和，一般是把目标值放在最顶端，然后自顶向下每次遍历都减去当前节点值，直到减为 0 或者其他临界条件为止。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node, sum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  path.push(node.val);</span><br><span class="line">  sum -= node.val;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">    res.push(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dfs(node.left, sum);</span><br><span class="line">  dfs(node.right, sum);</span><br><span class="line">  path.pop();</span><br><span class="line">&#125;</span><br><span class="line">dfs(root, targetNum);</span><br></pre></td></tr></table></figure>

<ul>
<li>非自顶向下：就是从任意节点到任意节点的路径，不需要自顶向下。<br>这种一般比较麻烦，除了从上到下的基本顺序，还有可能是横着的甚至倒着的路径。</li>
</ul>
<p>这类题目一般解题思路如下：<br>设计一个辅助函数 maxpath，调用自身求出以一个节点为根节点的左侧最长路径 left 和右侧最长路径 right，那么经过该节点的最长路径就是 <code>left+right</code><br>接着只需要从根节点开始 dfs,不断比较更新全局变量即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = -<span class="literal">Infinity</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxPath</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = maxPath(node.left);</span><br><span class="line">  <span class="keyword">let</span> right = maxPath(node.right);</span><br><span class="line">  res = <span class="built_in">Math</span>.max(res, node.val + left + right);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(left, right) + node.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>left,right 代表的含义要根据题目所求设置，比如最长路径、最大路径和等等</li>
<li>全局变量 res 的初值设置是 0 还是<code>-Infinity</code>要看题目节点是否存在负值，如果存在就用<code>-Infinity</code>，否则就是 0</li>
</ol>
<h3 id="路径问题-1（目标和）"><a href="#路径问题-1（目标和）" class="headerlink" title="路径问题 1（目标和）"></a>路径问题 1（目标和）</h3><blockquote>
<p>给你二叉树的根节点  root 和一个表示目标和的整数  targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和  targetSum 。如果存在，返回 true ；否则，返回 false</p>
</blockquote>
<p>路径问题最基本的一道题，好好背就完事了。<br>思路就是：把总和依次相减下来，每到一个节点就减去当前节点的值，直到叶子节点判断是否等于叶子节点的值，<br>如果等于说明一路上减去的值加起来正好就是 targetSum</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasPathSum = <span class="function"><span class="keyword">function</span> (<span class="params">root, targetSum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (!root.left &amp;&amp; !root.right) &#123;</span><br><span class="line">    <span class="keyword">return</span> targetSum === root.val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    hasPathSum(root.left, targetSum - root.val) ||</span><br><span class="line">    hasPathSum(root.right, targetSum - root.val)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="路径问题-2（具体路径）"><a href="#路径问题-2（具体路径）" class="headerlink" title="路径问题 2（具体路径）"></a>路径问题 2（具体路径）</h3><p>这道题是上一个的升级版，要求求出具体路径</p>
<p>思路在上面的解析中已经有过，就是记录路径，在递归结束时弹出当前节点，并在条件合适时记录路径。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pathSum = <span class="function"><span class="keyword">function</span> (<span class="params">root, targetSum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> path = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  dfs(root, targetSum);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node, sum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    path.push(node.val);</span><br><span class="line">    sum -= node.val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!node.left &amp;&amp; !node.right &amp;&amp; sum === <span class="number">0</span>) &#123;</span><br><span class="line">      res.push(path);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(node.left, sum);</span><br><span class="line">    dfs(node.right, sum);</span><br><span class="line">    <span class="comment">// 这个位置是当前节点的左右子树都遍历完了；</span></span><br><span class="line">    <span class="comment">// 如果是叶子节点，上面两个递归都会直接返回，然后pop出叶子节点</span></span><br><span class="line">    <span class="comment">// 如果不是叶子节点，相当于把左右子树记录完成了，这时应该返回上一层了，执行pop</span></span><br><span class="line">    <span class="comment">// 要在这里pop</span></span><br><span class="line">    path.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="路径问题-3（任意节点开始）"><a href="#路径问题-3（任意节点开始）" class="headerlink" title="路径问题 3（任意节点开始）"></a>路径问题 3（任意节点开始）</h3><blockquote>
<p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
</blockquote>
<p>这道题有两种解法，最好想的就是二重递归：</p>
<ul>
<li>第一重递归遍历所有节点</li>
<li>然后对于每个节点，执行路径问题 1 的算法</li>
</ul>
<p>方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pathSum = <span class="function"><span class="keyword">function</span> (<span class="params">root, sum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">0</span>, <span class="number">1</span>]]);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    prefix += node.val;</span><br><span class="line">    <span class="keyword">if</span> (map.has(prefix - sum)) &#123;</span><br><span class="line">      res += map.get(prefix - sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!map.has(prefix)) map.set(prefix, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> map.set(prefix, map.get(prefix) + <span class="number">1</span>);</span><br><span class="line">    dfs(node.left);</span><br><span class="line">    dfs(node.right);</span><br><span class="line">    prefix -= node.val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> prefix = <span class="number">0</span>;</span><br><span class="line">  dfs(root);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还有一种方法是使用<strong>前缀和</strong>，但是比较麻烦，没太看懂，参考<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-iii/solution/lu-jing-zong-he-iii-by-leetcode-solution-z9td/">https://leetcode-cn.com/problems/path-sum-iii/solution/lu-jing-zong-he-iii-by-leetcode-solution-z9td/</a></p>
<blockquote>
<p>前缀和还是先搞清一维数组的前缀和把</p>
</blockquote>
<h3 id="最大路径和"><a href="#最大路径和" class="headerlink" title="最大路径和"></a>最大路径和</h3><blockquote>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。<br>路径和 是路径中各节点值的总和。<br>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。<br>同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点</p>
</blockquote>
<p>这个是上面说的非自顶向下的典型例题，方法也是参考那个的，但是稍有改动：</p>
<ul>
<li>节点有负值，加上一个负值会对最大路径和起到反作用，因此如果左右路径和为负数就不选取（即取 0，和空节点的情况一样）</li>
<li><code>路径</code> 一定是先上升（ 0 ～ n 个）节点, 到达顶点, 后下降（ 0 ～ n 个）节点；因此表现出来就是<code>node.val + left + right</code></li>
</ul>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxPathSum = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = -<span class="literal">Infinity</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">maxPath</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="built_in">Math</span>.max(maxPath(node.left), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> right = <span class="built_in">Math</span>.max(maxPath(node.right), <span class="number">0</span>);</span><br><span class="line">    res = <span class="built_in">Math</span>.max(res, node.val + left + right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(left, right) + node.val;</span><br><span class="line">  &#125;</span><br><span class="line">  maxPath(root);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树左叶子之和"><a href="#二叉树左叶子之和" class="headerlink" title="二叉树左叶子之和"></a>二叉树左叶子之和</h2><blockquote>
<p>计算给定二叉树的所有左叶子之和。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sumOfLeftLeaves = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left) sum += root.left.val;</span><br><span class="line">    dfs(node.left);</span><br><span class="line">    dfs(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(root);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="回溯问题的基本思路"><a href="#回溯问题的基本思路" class="headerlink" title="回溯问题的基本思路"></a>回溯问题的基本思路</h2><p>参考<br><a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB%E5%A4%A7%E7%BA%B2%E5%A6%82%E4%B8%8B">https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB%E5%A4%A7%E7%BA%B2%E5%A6%82%E4%B8%8B</a></p>
<p>上面的回溯说到回溯问题的基本模板是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xxx</span>(<span class="params">入参</span>) </span>&#123;</span><br><span class="line">  前期的变量定义、缓存等准备工作</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义路径栈</span></span><br><span class="line">  <span class="keyword">const</span> path = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进入 dfs</span></span><br><span class="line">  dfs(起点)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义 dfs</span></span><br><span class="line">  <span class="function"><span class="title">dfs</span>(<span class="params">递归参数</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(到达了递归边界) &#123;</span><br><span class="line">      结合题意处理边界逻辑，往往和 path 内容有关</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里也可能不是 for，视题意决定</span></span><br><span class="line">    <span class="keyword">for</span>(遍历坑位的可选值) &#123;</span><br><span class="line">      path.push(当前选中值)</span><br><span class="line">      处理坑位本身的相关逻辑,一般就是递归</span><br><span class="line">      path.pop()<span class="comment">// 这里让已经选中的值退出，相当于树回退一层</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上这并不是一种生硬的模板，而是对应了回溯问题的基本形状：<strong>迭代表示同一层的横向展开，递归表示纵向的遍历</strong></p>
<p>根据前面 dfs 的经验，我们把递归只看成是一个简单的访问语句：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">dfs</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  递归边界</span><br><span class="line">  <span class="keyword">for</span>(i)&#123;</span><br><span class="line">    path.push(当前选中值)</span><br><span class="line">    访问第(i+<span class="number">1</span>)个</span><br><span class="line">    path.pop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，迭代的部分实际上就是将所有情况横向展开，也就是<strong>树的分叉</strong>；迭代几次也就对应根节点展开了几个枝；这也是通过限制迭代次数从而避免重复的原因。</p>
<blockquote>
<p><img src="https://pic.imgdb.cn/item/626a9a55239250f7c5e9286e.jpg"><br>迭代实际上就是这部分</p>
</blockquote>
<p>而递归则是<strong>纵向</strong>的延伸；和二叉树问题类似，递归的每一项可以看作是一个子节点的产生，而递归语句旁边的<code>path.push</code>和<code>path.pop</code>操作也正是对应了递归路径的记录和回溯。回溯的关键并不是循环，而是结尾的<code>pop()</code>，也就是状态的恢复；</p>
<p>理解了这两个地方，就可以理解各种其他问题中<strong>去重</strong>的方式和原因。</p>
<ol>
<li>所选序列是否重复按照出现次数区分，比如<code>[1,2,1]</code>和<code>[1,1,2]</code>没有区别；<br>这种通常限制迭代的<strong>起始位置</strong>。上面说到迭代就是树枝的展开，那如果让迭代每次从上一层位置的下一个元素展开，就可以避免重复一遍上一层的操作。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">val, begin</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//递归边界</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = begin; i &lt; xxx.length; i++) &#123;</span><br><span class="line">    path.push();</span><br><span class="line">    dfs(val, i); <span class="comment">// i作为下一个的begin</span></span><br><span class="line">    path.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>纵向不能重复；限制同一结果中元素出现个数，比如全排列问题，不允许出现<code>[1,1,2]</code>这样有重复数字的元素。<br>这种是限制每次迭代的元素；因为回溯问题的解通常就是若干个 dfs 的<strong>路径</strong>；通过记录某个元素被使用过，就可以避免反复迭代同一个元素：<br>每次迭代到一个元素时，如果该元素已经被记录访问过，就会跳到下一个元素。注意这种方法是去重<strong>垂直</strong>方向的，即 visited 数组横向独立、纵向统一</li>
</ol>
<blockquote>
<p>visited 通常存的是对应的索引，表示同一索引（位置）的元素不能被重复使用。如果想要同一个值的元素不能重复使用，就应该用方法 3</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//递归边界</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; xxx.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">      path.push();</span><br><span class="line">      visited[i] = <span class="literal">true</span>;</span><br><span class="line">      dfs(val); <span class="comment">// i作为下一个的begin</span></span><br><span class="line">      path.pop();</span><br><span class="line">      visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>横向不能重复，限制所有结果中相同值的重复，即不能有<code>[[1,2,2],[1,2,2]]</code>这样两个相同的元素，但是元素内部仍然可以重复。</li>
</ol>
<p>判断方法条件为：<code>nums[i] === nums[i - 1]</code>和<code>i &gt; 0</code>，以及<code>visited[nums[i - 1]] === false</code>，满足这三个条件时就应当跳过。</p>
<ul>
<li><code>nums[i] === nums[i - 1]</code>：当前值和前一个不能相同，即横向规定不能有重复值</li>
<li><code>visited[nums[i - 1]] === false</code>：这个很重要，是判断上一个条件是横向重复还是纵向重复；因为上一个条件既有可能是横向重复，也可以是纵向的重复；因此当这个条件为 true 时，即上一个值已经被访问过了，说明是纵向重复；反之则是横向重复。<strong>该条件===true 判断纵向重复，==false 判断横向重复</strong></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/626ab4ee239250f7c5375bd0.jpg"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">//！！！一定要先排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//递归边界</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; xxx.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!visited[nums[i - <span class="number">1</span>]] &amp;&amp; nums[i] === nums[i - <span class="number">1</span>] &amp;&amp; i &gt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (!visited) path.push();</span><br><span class="line">    visited[nums[i]] = <span class="literal">true</span>;</span><br><span class="line">    dfs(val); <span class="comment">// i作为下一个的begin</span></span><br><span class="line">    path.pop();</span><br><span class="line">    visited[nums[i]] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者综合第一种 begin 的方式；当<code>i &gt; begin</code>时，相当于当前遍历的位置是其他同层元素，和<code>visited[nums[i - 1]] === false</code>效果相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; begin &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>

<h3 id="具体题目"><a href="#具体题目" class="headerlink" title="具体题目"></a>具体题目</h3><p>具体题目参考<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problem-list/QS1BC1f6/%EF%BC%8C%E5%9F%BA%E6%9C%AC%E9%83%BD%E5%81%9A%E4%BA%86%EF%BC%8C%E5%B0%91%E6%95%B0%E6%B2%A1%E6%9C%89%E7%9A%84%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83">https://leetcode-cn.com/problem-list/QS1BC1f6/，基本都做了，少数没有的也可以参考</a><a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录</a></p>
<h2 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h2><h3 id="基本全排列"><a href="#基本全排列" class="headerlink" title="基本全排列"></a>基本全排列</h3><blockquote>
<p>给定一个没有重复数字的序列，返回其所有可能的全排列。<br>示例：<br>输入: [1,2,3]<br>输出: [<br>[1,2,3],<br>[1,3,2],<br>[2,1,3],<br>[2,3,1],<br>[3,1,2],<br>[3,2,1]<br>]</p>
</blockquote>
<p>像全排列这样的穷举，或者有一定限制的穷举，都可以用 DFS、递归回溯的思想。</p>
<p>这类问题的特点都是，穷举之中有不变化的部分；比如全排列问题不变的是三个数字的位置。三个位置可能是 1/2/3 任意一个数字，这样就可以构建出一个树：<br><img src="https://pic.imgdb.cn/item/6266c1cc239250f7c554635b.jpg"></p>
<p>然后按照树的先序遍历方式，就可以得到结果。当然并不需要构造一棵树。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> permute = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存数组的长度</span></span><br><span class="line">  <span class="keyword">const</span> len = nums.length;</span><br><span class="line">  <span class="comment">// curr 变量用来记录当前的排列内容</span></span><br><span class="line">  <span class="keyword">const</span> curr = [];</span><br><span class="line">  <span class="comment">// res 用来记录所有的排列顺序</span></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="comment">// visited 用来避免重复使用同一个数字</span></span><br><span class="line">  <span class="keyword">const</span> visited = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 定义 dfs 函数，入参是坑位的索引（从 0 计数）</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">nth</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 若遍历到了不存在的坑位（第 len+1 个），则触碰递归边界返回</span></span><br><span class="line">    <span class="keyword">if</span> (nth === len) &#123;</span><br><span class="line">      <span class="comment">// 此时前 len 个坑位已经填满，将对应的排列记录下来</span></span><br><span class="line">      res.push(curr.slice());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查手里剩下的数字有哪些</span></span><br><span class="line">    <span class="comment">// 循环套递归是常见的形式,循环的作用就是让DFS过程能&quot;返回&quot;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="comment">// 若 nums[i] 之前没被其它坑位用过，则可以理解为“这个数字剩下了”</span></span><br><span class="line">      <span class="keyword">if</span> (!visited[nums[i]]) &#123;</span><br><span class="line">        <span class="comment">// 给 nums[i] 打个“已用过”的标</span></span><br><span class="line">        visited[nums[i]] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 将nums[i]推入当前排列</span></span><br><span class="line">        curr.push(nums[i]);</span><br><span class="line">        <span class="comment">// 基于这个排列继续往下一个坑走去</span></span><br><span class="line">        dfs(nth + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// nums[i]让出当前坑位</span></span><br><span class="line">        curr.pop();</span><br><span class="line">        <span class="comment">// 下掉“已用过”标识</span></span><br><span class="line">        visited[nums[i]] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从索引为 0 的坑位（也就是第一个坑位）开始 dfs</span></span><br><span class="line">  dfs(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码很奇怪的地方是有一个“循环套递归”，并且递归的前后恰好是入栈、出栈结果的时候。</p>
<p>其实这正是这类题的“模板解法”。在递归产生的不同函数上下文中，每个的遍历次数不同。<br>以这道题为例，当 dfs 执行到第三个时，前两个的上下文的遍历次数分别是 1、2；这时当第三个返回时，上一个的循环还会执行一次，就相当于从树的底部“退回”了一个位置，并把 3 这个数字让了出来。</p>
<p>因此这类穷举相关的题目有一个通用模板，遇到这种问题可以先试着套一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xxx</span>(<span class="params">入参</span>) </span>&#123;</span><br><span class="line">  前期的变量定义、缓存等准备工作</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义路径栈</span></span><br><span class="line">  <span class="keyword">const</span> path = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进入 dfs</span></span><br><span class="line">  dfs(起点)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义 dfs</span></span><br><span class="line">  <span class="function"><span class="title">dfs</span>(<span class="params">递归参数</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(到达了递归边界) &#123;</span><br><span class="line">      结合题意处理边界逻辑，往往和 path 内容有关</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里也可能不是 for，视题意决定</span></span><br><span class="line">    <span class="keyword">for</span>(遍历坑位的可选值) &#123;</span><br><span class="line">      path.push(当前选中值)</span><br><span class="line">      处理坑位本身的相关逻辑,一般就是递归</span><br><span class="line">      path.pop()<span class="comment">// 这里让已经选中的值退出，相当于树回退一层</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全排列-2（剪枝）"><a href="#全排列-2（剪枝）" class="headerlink" title="全排列 2（剪枝）"></a>全排列 2（剪枝）</h3><blockquote>
<p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。<br>示例 1：<br>输入：nums = [1,1,2]<br>输出：<br>[[1,1,2],<br> [1,2,1],<br> [2,1,1]]</p>
</blockquote>
<p>这个题和全排列 1 的区别在于，每个结果允许数组内的数字重复，即给定的 nums 中有重复的数字。<br>因此这是一个横向剪枝的问题，即在保证一个数字不会纵向重复的情况下，进行横向剪枝去掉可能重复的组合。<br><img src="https://pic.imgdb.cn/item/628108d109475431293e2fd6.png"></p>
<p>利用上面说的去重的第三种方法即可。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permuteUnique = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> curr = []; <span class="comment">// 当前排列</span></span><br><span class="line">  <span class="keyword">const</span> res = []; <span class="comment">// 结果数组</span></span><br><span class="line">  <span class="keyword">const</span> visit = &#123;&#125;;</span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">  dfs(<span class="number">0</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index === nums.length) &#123;</span><br><span class="line">      res.push([...curr]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>] &amp;&amp; !visit[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (!visit[i]) &#123;</span><br><span class="line">        visit[i] = <span class="literal">true</span>;</span><br><span class="line">        curr.push(nums[i]);</span><br><span class="line">        dfs(index + <span class="number">1</span>);</span><br><span class="line">        curr.pop();</span><br><span class="line">        visit[i] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><h3 id="基本组合问题"><a href="#基本组合问题" class="headerlink" title="基本组合问题"></a>基本组合问题</h3><blockquote>
<p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。<br>示例:<br>输入: n = 4, k = 2<br>输出:<br>[<br>[2,4],<br>[3,4],<br>[2,3],<br>[1,2],<br>[1,3],<br>[1,4],<br>]</p>
</blockquote>
<p>最基本的组合问题，当递归次数等于 k 时记录即可。<br>因为同一个位置上的数字不能用多次，因此需要纵向剪枝；并且同样开头的数字也只能统计一次，所以需要起始序号剪枝。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combine = <span class="function"><span class="keyword">function</span> (<span class="params">n, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> curr = [];</span><br><span class="line">  <span class="keyword">const</span> nums = [];</span><br><span class="line">  <span class="keyword">const</span> visit = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// 创建数组</span></span><br><span class="line">    nums[i] = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> times = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">nth, begin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nth === k) &#123;</span><br><span class="line">      res.push([...curr]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = begin; i &lt; nums.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!visit[i]) &#123;</span><br><span class="line">        curr.push(nums[i]);</span><br><span class="line">        visit[i] = <span class="literal">true</span>;</span><br><span class="line">        times++;</span><br><span class="line">        dfs(times, i);</span><br><span class="line">        times--;</span><br><span class="line">        visit[i] = <span class="literal">false</span>;</span><br><span class="line">        curr.pop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="组合总合"><a href="#组合总合" class="headerlink" title="组合总合"></a>组合总合</h3><blockquote>
<p>给你一个 无重复元素 的整数数组  candidates 和一个目标整数  target ，找出 candidates  中可以使数字和为目标数  target 的 所有   不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。<br>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p>
</blockquote>
<p>基本组合问题，设定一个 sum 变量每次传入，每次加上当前值，当 sum 值等于 target 时记录。</p>
<p>因为同一个数可以选多次，因此纵向不需要剪枝，只需要起始序号剪枝即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">candidates</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combinationSum = <span class="function"><span class="keyword">function</span> (<span class="params">candidates, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> curr = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">sum, begin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">      res.push([...curr]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = begin; i &lt; candidates.length; i++) &#123;</span><br><span class="line">      curr.push(candidates[i]);</span><br><span class="line">      sum += candidates[i];</span><br><span class="line">      dfs(sum, i);</span><br><span class="line">      sum -= candidates[i];</span><br><span class="line">      curr.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="组合总和-2"><a href="#组合总和-2" class="headerlink" title="组合总和 2"></a>组合总和 2</h3><blockquote>
<p>给定一个候选人编号的集合  candidates  和一个目标数  target ，找出  candidates  中所有可以使数字和为  target  的组合。<br>candidates  中的每个数字在每个组合中只能使用   一次  。解集不能包含重复的组合。</p>
</blockquote>
<p>显然和上一个的区别在于每个数字在每个组合中只能使用一次，但是每个组合中允许重复数字，最终结果不允许有重复组合；</p>
<p>因此使用第三种剪枝就可以</p>
<p>这道题有一个特殊的解法，就是使用一个 prev 变量保存前一个的值；如果前一个值和当前<code>candidates[i]</code>相等，就直接跳过。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">candidates</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combinationSum2 = <span class="function"><span class="keyword">function</span> (<span class="params">candidates, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> curr = [];</span><br><span class="line">  <span class="keyword">const</span> visited = &#123;&#125;;</span><br><span class="line">  candidates.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">sum, begin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">      res.push([...curr]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> prev = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = begin; i &lt; candidates.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (candidates[i] === prev) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//这里使用第三种剪枝也可以</span></span><br><span class="line">      <span class="comment">// if (candidates[i] === candidates[i-1] &amp;&amp; i &gt; begin &amp;&amp; !visited[i - 1]) continue</span></span><br><span class="line">      <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">        visited[i] = <span class="literal">true</span>;</span><br><span class="line">        curr.push(candidates[i]);</span><br><span class="line">        sum += candidates[i];</span><br><span class="line">        prev = candidates[i];</span><br><span class="line">        dfs(sum, i);</span><br><span class="line">        sum -= candidates[i];</span><br><span class="line">        curr.pop();</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h2><blockquote>
<p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的不重复子集</p>
</blockquote>
<p>首先先按照树形思维构建；这道题中不变的部分是是否选中某个数字。</p>
<p>比如选中 1、不选 2、选中 3，那么结果就是[1,3]，依次类推就是所有选择。树的两个叶子分别代表选或不选该层对应的数字，每一层恰好就是这个数字。</p>
<p><img src="https://pic.imgdb.cn/item/6266c73d239250f7c5647e11.jpg"></p>
<p>按照上面的模板，可以尝试构建如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> subsets = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ans = [];</span><br><span class="line">  <span class="keyword">const</span> curr = [];</span><br><span class="line"></span><br><span class="line">  dfs(<span class="number">0</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 每次进入，都意味着组合内容更新了一次，故直接推入结果数组</span></span><br><span class="line">    ans.push(curr.slice());</span><br><span class="line">    <span class="comment">// 从当前数字的索引开始，遍历 nums</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 这是当前数字存在于组合中的情况</span></span><br><span class="line">      curr.push(nums[i]);</span><br><span class="line">      <span class="comment">// 基于当前数字存在于组合中的情况，进一步 dfs</span></span><br><span class="line">      dfs(i + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 这是当前数字不存在与组合中的情况</span></span><br><span class="line">      curr.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意这道题虽然有显式的递归边界（遍历三层），但是其实并不需要，因为循环直接从当前的 index（即树的层数）开始，跳过了前面的情况。</p>
<p>如果我们再给这个解法显式加上一个递归条件，比如规定<code>curr.length &lt; k</code>，这就是一种“回溯”，即到达某种情况后就提前返回，并不是每次都遍历完。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> combine = <span class="function"><span class="keyword">function</span> (<span class="params">n, k</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化结果数组</span></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="comment">// 初始化组合数组</span></span><br><span class="line">  <span class="keyword">const</span> subset = [];</span><br><span class="line">  <span class="comment">// 进入 dfs，起始数字是1</span></span><br><span class="line">  dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义 dfs 函数，入参是当前遍历到的数字</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (subset.length === k) &#123;</span><br><span class="line">      res.push(subset.slice());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从当前数字的值开始，遍历 index-n 之间的所有数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="comment">// 这是当前数字存在于组合中的情况</span></span><br><span class="line">      subset.push(i);</span><br><span class="line">      <span class="comment">// 基于当前数字存在于组合中的情况，进一步 dfs</span></span><br><span class="line">      dfs(i + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 这是当前数字不存在与组合中的情况</span></span><br><span class="line">      subset.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回结果数组</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="分割问题"><a href="#分割问题" class="headerlink" title="分割问题"></a>分割问题</h2><p>分割问题是变种的回溯问题；常见回溯问题一般是记录路径，累加求值；但是分割问题通常是把字符串分割递归下去。<br>具体来说，分割问题的通常思路如下：</p>
<ol>
<li>在迭代中，从某一项开始取前 i 个字符</li>
<li>判断该字符是否符合要求</li>
</ol>
<ul>
<li>不符合，继续迭代</li>
<li>符合，把分割后剩下的串传递下去。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">str, times</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (临界条件) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> part = str.slice(<span class="number">0</span>, i);</span><br><span class="line">    <span class="keyword">if</span> (isValid(part)) &#123;</span><br><span class="line">      curr.push(part);</span><br><span class="line">      dfs(str.slice(i + <span class="number">1</span>)); <span class="comment">// 把分割后剩下的继续递归分割</span></span><br><span class="line">      curr.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h3><blockquote>
<p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。<br>返回 s 所有可能的分割方案。<br>示例: 输入: “aab” 输出: [ [“aa”,”b”], [“a”,”a”,”b”] ]</p>
</blockquote>
<p>思路：先切割子串，对每个子串判断回文，如果回文就记录。</p>
<p>关键是切割字串的方法。切割子串思路和回溯记录路径类似：</p>
<ol>
<li>遍历每一项，把整个子串先从头到最后一个切割</li>
<li>如果子串是回文串，就记录，并且把<strong>切割之后剩下的部分</strong>递归下去。<br>思路可以参考这张图：<br><img src="https://pic.imgdb.cn/item/6281198609475431297e2c6e.jpg"></li>
</ol>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> partition = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> curr = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> visit = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str === <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">      res.push([...curr]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> part = str.slice(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (isPalindrome(part)) &#123;</span><br><span class="line">        curr.push(part);</span><br><span class="line">        dfs(str.slice(i + <span class="number">1</span>));</span><br><span class="line">        curr.pop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dfs(s);</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> strArr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> j = strArr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (strArr[i] === strArr[j]) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="有效-ip-地址"><a href="#有效-ip-地址" class="headerlink" title="有效 ip 地址"></a>有效 ip 地址</h3><blockquote>
<p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。<br>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。<br>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#49;&#57;&#50;&#46;&#x31;&#x36;&#x38;&#64;&#x31;&#46;&#x31;">&#49;&#57;&#50;&#46;&#x31;&#x36;&#x38;&#64;&#x31;&#46;&#x31;</a>“ 是 无效的 IP 地址。<br>示例 1：<br>输入：s = “25525511135”<br>输出：[“255.255.11.135”,”255.255.111.35”]</p>
</blockquote>
<p>思路和分割回文串类似，先从头开始分割，如果分割到符合单个 IP 的情况，就存下来并把后面的继续递归。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> restoreIpAddresses = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> curr = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">str, times</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str === <span class="string">&quot;&quot;</span> &amp;&amp; times === <span class="number">4</span>) &#123;</span><br><span class="line">      res.push(curr.join(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> part = str.slice(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (times &gt;= <span class="number">4</span>) part = str.slice(i + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (isValid(part)) &#123;</span><br><span class="line">        curr.push(part);</span><br><span class="line">        times++;</span><br><span class="line">        dfs(str.slice(i + <span class="number">1</span>), times);</span><br><span class="line">        times--;</span><br><span class="line">        curr.pop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(s, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isValid</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      str !== <span class="string">&quot;&quot;</span> &amp;&amp;</span><br><span class="line">      <span class="built_in">Number</span>(str) &lt;= <span class="number">255</span> &amp;&amp;</span><br><span class="line">      <span class="built_in">Number</span>(str).toString().length === str.length</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="岛屿问题"><a href="#岛屿问题" class="headerlink" title="岛屿问题"></a>岛屿问题</h2><h3 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h3><blockquote>
<p>给你一个由  ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;character[][]&#125;</span> <span class="variable">grid</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numIslands = <span class="function"><span class="keyword">function</span> (<span class="params">grid</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> islands = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> m = grid[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">const</span> n = grid.length;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= n || j &gt;= m) <span class="keyword">return</span>; <span class="comment">// 超出边界</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] === <span class="string">&quot;0&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 遍历到的是0就回溯</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这道题的关键就在这里,遍历之后直接就把这一个变为0</span></span><br><span class="line">    <span class="comment">// 这样既完成了去重,同时下面统计岛屿数量时,遍历过的一整块都会变成&#x27;0&#x27;</span></span><br><span class="line">    grid[i][j] = <span class="string">&quot;0&quot;</span>;</span><br><span class="line"></span><br><span class="line">    dfs(i + <span class="number">1</span>, j);</span><br><span class="line">    dfs(i, j + <span class="number">1</span>);</span><br><span class="line">    dfs(i - <span class="number">1</span>, j);</span><br><span class="line">    dfs(i, j - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">      <span class="comment">// 从每个点开始执行一次递归</span></span><br><span class="line">      <span class="comment">// 因为遍历过的地方会置0，因此实际上只会调用 岛屿数量 次dfs</span></span><br><span class="line">      <span class="keyword">if</span> (grid[i][j] === <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">        dfs(i, j);</span><br><span class="line">        islands++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> islands;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="最大岛屿面积"><a href="#最大岛屿面积" class="headerlink" title="最大岛屿面积"></a>最大岛屿面积</h3><p>和上一道题类似</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">grid</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxAreaOfIsland = <span class="function"><span class="keyword">function</span> (<span class="params">grid</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> m = grid[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">const</span> n = grid.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= n || j &gt;= m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    grid[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里+1的方法类似二叉树计算深度的方法；遍历该点四周，并加上当前点的面积（就是1）</span></span><br><span class="line">    <span class="keyword">return</span> dfs(i + <span class="number">1</span>, j) + dfs(i, j + <span class="number">1</span>) + dfs(i - <span class="number">1</span>, j) + dfs(i, j - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (grid[i][j] === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> area = dfs(i, j);</span><br><span class="line">        max = max &gt; area ? max : area;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>这些算法没什么好说的，记就完事了。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bubbleSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j + <span class="number">1</span>] &lt; nums[j]) swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>冒泡排序的最优解,即时间复杂度 O(n)；<br>对应完全有序的情况，这时只需要遍历一次</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> betterBubbleSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j + <span class="number">1</span>] &lt; nums[j]) swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 如果发生一次交换就破功了</span></span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果一次都没有交换,说明数组有序,直接返回,这时只遍历了一次</span></span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span> nums;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>冒泡排序的复杂度：</p>
<ul>
<li>最好时间复杂度：它对应的是数组本身有序这种情况。在这种情况下，我们只需要作比较（n-1 次），而不需要做交换。时间复杂度为 O(n)</li>
<li>最坏时间复杂度： 它对应的是数组完全逆序这种情况。在这种情况下，每一轮内层循环都要执行，重复的总次数是 n(n-1)/2 次，因此时间复杂度是 O(n^2)</li>
<li>平均时间复杂度： O(n^2)</li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>循环遍历数组，每次都找出当前范围内的最小值，把它放在当前范围的头部；然后缩小排序范围，继续重复以上操作，直至数组完全有序为止。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selectionSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; arr.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">        minIndex = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, minIndex, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>选择排序的复杂度都是 O(n^2)</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序所有的操作都基于一个这样的前提：当前元素前面的序列是有序的。基于这个前提，从后往前去寻找当前元素在前面那个序列里的正确位置；</p>
<p>即把当前选中的元素和前面的依次比较，如果小于前面的元素，就把前面的元素往后移一位，直到大于前面元素为止。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insertionSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = i;</span><br><span class="line">    tmp = nums[i];</span><br><span class="line">    <span class="keyword">while</span> (tmp &lt; nums[j - <span class="number">1</span>] &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>最好时间复杂度：它对应的数组本身就有序这种情况。此时内层循环只走一次，整体复杂度取决于外层循环，时间复杂度就是一层循环对应的 O(n)。</li>
<li>最坏时间复杂度：它对应的是数组完全逆序这种情况。此时内层循环每次都要移动有序序列里的所有元素，因此时间复杂度对应的就是两层循环的 O(n^2)</li>
<li>平均时间复杂度：O(n^2)</li>
</ul>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>将数组拆分成两个部分，然后分别单独排序，最后合并。因此拆分过程实际上是类似二叉树的递归遍历，递归边界是数组只有一个元素的时候，直接返回该元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并两个有序数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeArr</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> newArr = [];</span><br><span class="line">  <span class="keyword">while</span> (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) &#123;</span><br><span class="line">    arr1[i] &lt; arr2[j] ? newArr.push(arr1[i++]) : newArr.push(arr2[j++]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [...newArr, i === arr1.length - <span class="number">1</span> ? arr2.slice(j) : arr1.slice(i)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mergeSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">  <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(nums.length / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> left = mergeSort(nums.slice(<span class="number">0</span>, mid));</span><br><span class="line">  <span class="keyword">const</span> right = mergeSort(nums.slice(mid));</span><br><span class="line">  <span class="keyword">return</span> mergeArr(left, right);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>归并排序的时间复杂度是 <code>O(nlog(n))</code></p>
<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>快速排序会将原始的数组筛选成较小和较大的两个子数组，然后递归地排序两个子数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> quickSort = <span class="function">(<span class="params">nums, left = <span class="number">0</span>, right = nums.length - <span class="number">1</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">  <span class="keyword">let</span> divider = <span class="built_in">Math</span>.floor(left + (right - left) / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">let</span> i = left;</span><br><span class="line">  <span class="keyword">let</span> j = right;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (nums[i] &lt; nums[divider]) i++;</span><br><span class="line">    <span class="keyword">while</span> (nums[j] &gt; nums[divider]) j--;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">      swap(nums, i, j);</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (left &lt; i - <span class="number">1</span>) quickSort(nums, left, i - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (i &lt; right) quickSort(nums, i, right);</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote>
<p>动态规划（dynamic programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。<br>用动态规划解决问题时，要遵循三个重要步骤：</p>
<ol>
<li>定义子问题；</li>
<li>实现要反复执行来解决子问题的部分；</li>
<li>识别并求解出基线条件。</li>
</ol>
</blockquote>
<p>动态规划的题目有几个关键的特征：</p>
<ol>
<li>要求你给出达成某个目的的解法个数</li>
<li>不要求你给出每一种解法对应的具体路径</li>
<li>题目要求中有“最值”，即最优解；</li>
<li>一个解的得出依赖于前一个解，依次依赖迭代</li>
</ol>
<p>这样的问题，往往可以用动态规划进行求解</p>
<p>动态规划的题目可能很难理解，如果有实在理解不了的可以先记下来</p>
<h2 id="爬楼梯问题"><a href="#爬楼梯问题" class="headerlink" title="爬楼梯问题"></a>爬楼梯问题</h2><blockquote>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
</blockquote>
<p>倒着思考问题,如果要到达 n 阶的方法为<code>f(n)</code>种,从第 n 阶退一层的方法就是<code>f(n-1)</code>或<code>f(n-2)</code>种,即<code>f(n) = f(n-1) + f(n-2)</code> ,然后依次类推,直到<code>f(1)</code>和<code>f(2)</code>返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> climbStairs = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 树形思考问题,这里相当于两个子节点</span></span><br><span class="line">  <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面这个解法会有很多重复的,比如<code>f(n-2)</code>的下一层会包含<code>f(n-3)</code>,这个值可能被多次计算<br>可以考虑 Map 缓存计算过的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> climbStairsCached = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">return</span> climbStairs(n);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">climbStairs</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.has(n)) <span class="keyword">return</span> map.get(n);</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> res = climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">    map.set(n, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上这种在递归的过程中，不断保存已经计算出的结果，从而避免重复计算的手法，叫做记忆化搜索。</p>
<p>真正的动态规划，是一个自底向上的过程。它要求我们站在已知的角度，通过定位已知和未知之间的关系，一步一步向前推导，进而求解出未知的值。</p>
<p>由上面的关系，可以推出状态转移方程为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n-1) + f(n-2)</span><br><span class="line">且</span><br><span class="line">f(1) = 1</span><br><span class="line">f(2) = 2</span><br></pre></td></tr></table></figure>

<p>把这个方程放到循环中，就可以解出来了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> climbStairsDynamic = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> f = [];</span><br><span class="line">  f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  f[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt; n; i++) &#123;</span><br><span class="line">    f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此动态规划的关键就是推出状态转移方程，只要方程能得出，丢到迭代里边就可以计算了。</p>
<h2 id="最少硬币找零"><a href="#最少硬币找零" class="headerlink" title="最少硬币找零"></a>最少硬币找零</h2><blockquote>
<p>给定不同面额的硬币 coins 和一个总金额 amount。<br>编写一个函数来计算可以凑成总金额所需的 最少 的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
</blockquote>
<p>站在已经凑成的角度上思考问题，如果从已经凑成的结果中取走一个硬币，就会有以下的情况：<br><img src="https://pic.imgdb.cn/item/626789ea239250f7c5c0b9d6.jpg"></p>
<p>借此可以推出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n表示amount，f(n)表示凑成n金额所需的最少硬币数量</span><br><span class="line"></span><br><span class="line">f(n) = Math.min(f(n-c1)+1,f(n-c2)+1,f(n-c3)+1......f(n-cn)+1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>放入循环：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getCoinsDynamic = <span class="function">(<span class="params">coins, amount</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> f = [];</span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; amount; i++) &#123;</span><br><span class="line">    f[i] = <span class="literal">Infinity</span>;</span><br><span class="line">    <span class="comment">// 这个循环相当于是 f[n] = Math.min(f(n-coin1),f(n-coin2),...,f(n-coinn))</span></span><br><span class="line">    <span class="comment">// 由于coin数量不确定,因此两两比较每个f(n)和f(n-coin)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> coin <span class="keyword">of</span> coins) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= coin) f[i] = <span class="built_in">Math</span>.min(f[i], f[i - coin] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (f[amount] === <span class="literal">Infinity</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> f[amount];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最大子序列和"><a href="#最大子序列和" class="headerlink" title="最大子序列和"></a>最大子序列和</h2><blockquote>
<p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
</blockquote>
<p>用 <code>f(i)</code>代表以第 i 个数结尾的「连续子数组的最大和」,可得方程为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(i)=max&#123;f(i−1)+nums[i],nums[i]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也就是以第 i 个数结尾的最大和，有可能是加上第 i 个数的结果，也有可能是只有第 i 个数的结果。因为<code>f(i)</code>代表以第 i 个数结尾的,因此必须要包含当前数(即<code>nums[i]</code>)；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxChildArr = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> f = [];</span><br><span class="line">  f[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    f[i] = <span class="built_in">Math</span>.max(f[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(...f);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><blockquote>
<p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
</blockquote>
<p>假设最长序列长度为<code>f(i)</code>,这道题不适合倒推得出方程,而是通过正向思考<br>对于每一个数字,如果前面还有比它小的一个数字或一组数字,就可以组合成一个序列;<br>那么可以执行两次遍历,遍历每个数字,每次迭代都遍历<strong>这个数字前面的所有数字</strong>,如果有比它小的就加入序列长度，直到找到该项之前的、比该项小的数字个数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lengthOfLIS = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> f = [];</span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    f[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">        <span class="comment">//注意这里不是要f[i] 与 f[j] + 1进行比较，而是取f[j] + 1的最大值。</span></span><br><span class="line">        f[i] = <span class="built_in">Math</span>.max(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(...f);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>核心代码写成这样也可以：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">  f[i] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">      <span class="comment">// 取f[j] + 1的最大值。</span></span><br><span class="line">      tmp = tmp + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  f[i] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长连续递增子序列"><a href="#最长连续递增子序列" class="headerlink" title="最长连续递增子序列"></a>最长连续递增子序列</h2><blockquote>
<p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p>
</blockquote>
<p>这道题和上面的最大区别在于“连续”，即序列是连续的。<br>因此同样设<code>dp[i]</code>表示以 i 结尾的最长连续递增序列的长度，但是<code>dp[i]</code>此时只能由<code>dp[i - 1]</code>推出，即<code>dp[i] = dp[i - 1] + 1</code>。</p>
<p>遍历整个数组，如果当前数<code>nums[i]</code>比前面的数大，就更新<code>dp[i]</code>，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findLengthOfLCIS = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = [];</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">    dp[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    res = res &gt; dp[i] ? res : dp[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最长公共子数组"><a href="#最长公共子数组" class="headerlink" title="最长公共子数组"></a>最长公共子数组</h2><blockquote>
<p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。<br>示例：<br>输入： A: [1,2,3,2,1] B: [3,2,1,4,7] 输出：3 解释： 长度最长的公共子数组是 [3, 2, 1] 。</p>
</blockquote>
<p>类似这种的公共问题，一定是取二维数组<code>dp[i][j]</code>，并且两个维度分别对应一个数组。<br>这里<code>dp[i][j]</code>表示：以下标<code>i - 1</code>为结尾的 A，和以下标<code>j - 1</code>为结尾的 B，最长重复子数组长度为<code>dp[i][j]</code>。<br>当<code>A[i - 1] === B[j - 1]</code>相等的时候，<code>dp[i][j] = dp[i - 1][j - 1] + 1</code></p>
<blockquote>
<p>这里取<code>i-1</code>和<code>j-1</code>主要是为了方便计算，直接取 i、j 也可以，但是要提前初始化<code>dp[i][0]</code>和 dp<code>[0][j]</code></p>
</blockquote>
<p>dp 数组的结构如下，状态的更新是斜向的，即 dp[i][j]总是由左上方的 dp[i - 1][j - 1]更新而来</p>
<p><img src="https://img-blog.csdnimg.cn/2021011215282060.jpg"></p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> findLength = <span class="function">(<span class="params">A, B</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// A、B数组的长度</span></span><br><span class="line">  <span class="keyword">const</span> [m, n] = [A.length, B.length];</span><br><span class="line">  <span class="comment">// dp数组初始化，都初始化为0</span></span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m + <span class="number">1</span>).fill(<span class="number">0</span>).map(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>));</span><br><span class="line">  <span class="comment">// 初始化最大长度为0</span></span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="comment">// 遇到A[i - 1] === B[j - 1]，则更新dp数组</span></span><br><span class="line">      <span class="keyword">if</span> (A[i - <span class="number">1</span>] === B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新res</span></span><br><span class="line">      res = dp[i][j] &gt; res ? dp[i][j] : res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历完成，返回res</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="不同路径问题"><a href="#不同路径问题" class="headerlink" title="不同路径问题"></a>不同路径问题</h2><blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？<br><img src="https://img-blog.csdnimg.cn/20210110174033215.png"></p>
</blockquote>
<p>机器人移动经过的是二维数组，因此对于每一个节点来说，必然会有水平和竖直两种方向上的两组路径，即只需要记录左边和上边来的路径数（因为是从左向右遍历，因此不需要统计右和下）<br><img src="https://pic.imgdb.cn/item/6273a6e40947543129d857e0.jpg"></p>
<p>因此设<code>dp[i][j]</code>为经过点<code>(i,j)</code>的路径最大值，并且该值一定是由其水平和竖直推出的，即<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code></p>
<p><img src="https://img-blog.csdnimg.cn/20201209113631392.png"></p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePaths = <span class="function"><span class="keyword">function</span> (<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(n), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(m));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; m - <span class="number">1</span>; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h2><blockquote>
<p>有 n 件物品，物品体积用一个名为 w 的数组存起来，物品的价值用一个名为 value 的数组存起来；<br>每件物品的体积用 w[i] 来表示，每件物品的价值用 value[i] 来表示。现在有一个容量为 c 的背包<br>问你如何选取物品放入背包，才能使得背包内的物品总价值最大？</p>
</blockquote>
<p>设<code>dp[i][j]</code> 表示从下标为<code>[0-i]</code>的物品里任意取，放进容量为 j 的背包，价值总和最大是多少。(记住 i 和 j 的含义)</p>
<p>我们假设每个物品重量和价值关系如下:</p>
<table>
<thead>
<tr>
<th></th>
<th>weight</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>物品 0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>物品 1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>物品 2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody></table>
<p>那么得到的 dp 数组就是这样的：<br><img src="https://img-blog.csdnimg.cn/20210110103003361.png"></p>
<p>然后需要确定递推公式。我们可以这样理解，对于每一个即将要放入背包的物品 i ，可能有两种情况：</p>
<ol>
<li>当前背包容量不够（没有空余或者空余小于当前物品重量），放不下（背包不是一开始就是最大的，而是从 0 开始一个一个遍历上来的）</li>
<li>当前背包容量够，并且空余大于等于当前物品重量</li>
</ol>
<p>这两种情况恰恰是对应两个公式：</p>
<ol>
<li>不够放下该物品 i，所以直接无视掉，依旧取之前的值。这个“之前的值”，就是<strong>背包容量不变，并且不放物品 i</strong>的值，体现为<code>dp[i - 1][j]</code>。<code>dp[i-1]</code>表示的含义是，当前物品没有放入，那么就还是上一个或上面几个物品放入的情况。</li>
<li>能放下物品 i，这时候就选择放入物品 i，并且加上物品 i 的价值。但是注意这里并不是直接在<code>dp[i - 1][j]</code>的基础上加，而是取<code>dp[i - 1][j - weight[i]]</code>；原因是这样：</li>
</ol>
<p>比如计算<code>dp[1][3]</code>，如下图<br><img src="https://img-blog.csdnimg.cn/20210110103244701.png"></p>
<p>这时<code>dp[i - 1][j] = dp[0][3]</code>，即不放入物品 1，那么背包中仍旧只有一个物品 0，价值为 15<br>如果放入物品 1，我们就需要知道一个特殊的情况，即<strong>空余空间足够，但并未放入</strong>的情况。即<code>dp[i - 1][j - weight[i]] = dp[0][0]</code>：这时什么都没有放入，背包空余大小为 3，足够放入重量为 3 的物品 1。最后加上物品 1 的价值 20，得到最终值</p>
<p>如果不找到有足够空间的情况，那么本次的<code>j</code>之前可能会有其他情况，比如一个比物品 i 重量小的已经放入，但是没有填满，并且去掉这个小物品是可以放入该物品 i 的。应当避免的就是这种情况。</p>
<p>结合上面两种情况，其实就是在比较“选不选物品 i”；选和不选之间取出一个最大值，成为当前的结果。</p>
<p>状态转移方程为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure>

<p>核心遍历代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; weight.length; i++) &#123;</span><br><span class="line">  <span class="comment">// 遍历物品</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= size; j++) &#123;</span><br><span class="line">    <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">if</span> (j &lt; weight[i])</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j]; <span class="comment">// 如果当前容量都小于物品i的重量，那肯定不用放入</span></span><br><span class="line">    <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testweightbagproblem</span>(<span class="params">wight, value, size</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = wight.length;</span><br><span class="line">  <span class="keyword">const</span> dp = array.from(<span class="keyword">new</span> <span class="built_in">Array</span>(len + <span class="number">1</span>), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(size).fill(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= size; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j &lt; weight[i])</span><br><span class="line">        <span class="comment">// 如果当前容量都小于物品i的重量，那肯定不用放入</span></span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">      <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dp[len][size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h2><blockquote>
<p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。<br>示例 :<br>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。<br>说明: 你可以假设 n 不小于 2 且不大于 58</p>
</blockquote>
<p>思路：对于一个数 i，可能的拆分方式有两种：</p>
<ol>
<li>从 j 到 i 遍历，即<code>j * (i - j)</code></li>
<li>因为<code>i - j</code>可能也能拆分（比如 6 可以再拆成 3*3），因此可能是<code>i - j</code>拆分的<code>最大乘积 * j</code></li>
</ol>
<p>状态转移方程：<br>设<code>dp[i]</code>表示数字 i 拆分得到的最大乘积</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = Math.max(dp[i - j] * j, j * (i - j))</span><br></pre></td></tr></table></figure>

<p>实际实现应该取 j 从 1 到 i 遍历得到的<code>dp[i]</code>最大值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> integerBreak = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = [];</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// dp[i]有两种情况,一种是拆分成两个数的,最大值为max(...[j * (i - j)]),即从1到i遍历j,计算拆分成两个数的最大值</span></span><br><span class="line">  <span class="comment">// 另一种情况是可能拆成多个数,即j * dp[i - j],即拆分i-j.</span></span><br><span class="line">  <span class="comment">// 这里不能拆分j,即不能dp[j] * dp[i - j],因为这样最少都是四个数相乘</span></span><br><span class="line">  <span class="comment">// dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      dp[i] = <span class="built_in">Math</span>.max(dp[i], (i - j) * j, dp[i - j] * j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h2><blockquote>
<p>给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。<br>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
</blockquote>
<p><img src="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif"></p>
<p>这道题不是标准的动态规划题，但是可以用动态规划解。<br>思路是通过二维数组，设<code>dp[i][j]</code>为第 i 行、第 j 个数字的值，那么显然</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j] + dp[i - 1][j-1]</span><br></pre></td></tr></table></figure>

<p>然后每行计算的时候，都初始化行首和行尾的元素值为 1</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">numRows</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> generate = <span class="function"><span class="keyword">function</span> (<span class="params">numRows</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = [[<span class="number">1</span>]];</span><br><span class="line">  <span class="keyword">const</span> res = [...dp];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">    dp[i] = [];</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(dp[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票"><a href="#买卖股票" class="headerlink" title="买卖股票"></a>买卖股票</h2><blockquote>
<p>给定一个数组 prices ，它的第  i 个元素  prices[i] 表示一支给定股票第 i 天的价格。<br>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。<br>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。<br>示例 1：<br>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</p>
</blockquote>
<p>设 dp[i]表示第 i 天持有股票的现金。<br>为了区分在某一天购入和售出，设置两个状态表示在改天持有和不持有股票：</p>
<ul>
<li>dp[i][0]表示在第 i 天持有股票。<strong>持有</strong>股票表示两种可能：<ul>
<li>今天购买了股票，那么现在剩余的现金就是<code>-price[i]</code></li>
<li>今天没有购买，保持昨天的状态，即<code>dp[i-1][0]</code></li>
</ul>
</li>
<li>dp[i][1]表示在第 i 天不持有股票，同理：<ul>
<li>今天售出了股票，那么剩余现金就是 当天的股票价格 price[i]和前一天的持有金钱的差值；又因为 dp[i][0]一定是小于等于 0，因此实际上是<code>price[i] + dp[i-1][0]</code>。<br>并且，<code>dp[i-1][0]</code>本身是由前面推出来的，因此一定在这天之前是购买成本最小的情况。</li>
<li>今天没有售出，即保持<code>dp[i - 1][1]</code></li>
</ul>
</li>
</ul>
<p>因此实际上 dp 是两个动态规划的组合。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0] = Math.max(dp[i-1][0],-price[i])</span><br><span class="line"></span><br><span class="line">dp[i][1] = Math.max(dp[i-1][1],price[i] + dp[i-1][0])</span><br></pre></td></tr></table></figure>

<p>最终结果取<code>dp[price.length - 1][1]</code>就是最大值。</p>
<p><img src="https://pic.imgdb.cn/item/6281dbeb09475431290d7d2e.jpg"></p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">prices</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span> (<span class="params">prices</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = [[-prices[<span class="number">0</span>], <span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">    dp[i] = [];</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], prices[i] + dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h2><blockquote>
<p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。<br>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。<br>示例 1： 输入：s = “abc”, t = “ahbgdc” 输出：true</p>
</blockquote>
<p>这道题用双指针就能很快解决，但是用动态规划也可以，并且可以引出下一道题的类似思路。</p>
<p>用动态规划的话思路和<em>最长公共子数组</em>这道题类似，同样取二维数组 dp[i][j]，表示以下标<code>i - 1</code>结尾的字符串 s 和下标<code>j - 1</code>结尾的字符串 t 之间的子序列长度。</p>
<p>那么就会有两种情况：</p>
<ol>
<li>如果<code>s[i-1]===t[j-1]</code>，那么子序列长度加 1，即<code>dp[i][j] = dp[i - 1][j - 1] + 1</code>；（即下标 i-2 和 j-2 的串的子序列长度+1）</li>
<li>如果<code>s[i-1]!==t[j-1]</code>，那么子序列长度不变，即<code>dp[i][j] = dp[i][j - 1]</code>。注意这里相当于 s 串不变，但 t 串向前走了，应该删去当前元素，所以是下标 i-1 的串和下标 j-2 的串子序列长度。</li>
</ol>
<p>因此可以得到方程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[i-1]===t[j-1]</span></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s[i-1]!==t[j-1]</span></span><br><span class="line">dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>最终结果只需要返回最右下角的元素即可。</p>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isSubsequence = <span class="function">(<span class="params">s, t</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// s、t的长度</span></span><br><span class="line">  <span class="keyword">const</span> [m, n] = [s.length, t.length];</span><br><span class="line">  <span class="comment">// dp全初始化为0</span></span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m + <span class="number">1</span>).fill(<span class="number">0</span>).map(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="comment">// 更新dp[i][j]，两种情况</span></span><br><span class="line">      <span class="keyword">if</span> (s[i - <span class="number">1</span>] === t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历结束，判断dp右下角的数是否等于s的长度</span></span><br><span class="line">  <span class="keyword">return</span> dp[m][n] === m ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于这种两个序列判断公共的问题，通常的解法都是利用二维数组；<br>而递推关系一般是两种情况得出的，可以类比双指针解法</p>
</blockquote>
<h2 id="不同子序列"><a href="#不同子序列" class="headerlink" title="不同子序列"></a>不同子序列</h2><blockquote>
<p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p>
</blockquote>
<blockquote>
<p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
</blockquote>
<p>这个题和上面的题思路大致不变，因为都是在找公共子序列；<br>但是这个题是让你找到 s 有几种方法删除元素可以得到 t</p>
<p>同样设 dp[i][j]为 对于 i-1 结尾的 s 和 j-1 结尾的 t，t 在 s 中出现的个数。</p>
<p>那么会有同样的两种情况：</p>
<ol>
<li><p>如果<code>s[i-1]===t[j-1]</code>，此时<code>dp[i][j] = dp[i - 1][j - 1] + dp[i-1][j]</code>。这个的关键在于，后者表示 s 串中除去当前元素的判断结果，是因为对于如果已经匹配上的两个串，<strong>s 串向后走不管多少位都不会减少之前 t 串已经出现的次数</strong>。因此不应该是+1，而是加上之前匹配的次数。</p>
</li>
<li><p>如果<code>s[i-1]!==t[j-1]</code>，<code>dp[i][j] = dp[i-1][j]</code>，和上面原因一样，只有之前匹配的次数结果。</p>
</li>
</ol>
<p>得到方程为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line"></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br></pre></td></tr></table></figure>

<p>注意初始化：</p>
<ul>
<li>dp[i][0]表示从以 i 结尾的串 s 中找到空字串。那么选取方法就只有一种，即一个都不选，或者说是全部删除</li>
<li>dp[0][i]表示从空串中找到非空串，显然不可能，都为 0</li>
<li>dp[0][0]表示空串找空串，为 1</li>
</ul>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">t</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numDistinct = <span class="function"><span class="keyword">function</span> (<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="built_in">Array</span>.from(<span class="built_in">Array</span>(s.length + <span class="number">1</span>), <span class="function">() =&gt;</span> <span class="built_in">Array</span>(t.length + <span class="number">1</span>).fill(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= s.length; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= t.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i - <span class="number">1</span>] === t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dp[s.length][t.length];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h2><blockquote>
<p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。<br>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。<br>示例 1：<br>输入：”abc” 输出：3 解释：三个回文子串: “a”, “b”, “c”</p>
</blockquote>
<p>回文子串类型的动态规划数组 dp 一般都是这样设置的：<br>设 dp[i][j]表示字符串 i 和 j 之间的串<strong>是不是回文串</strong>，如果是就是 ture，不是就是 false。注意这里的值是布尔值，算是一个特例。（回文子串相关的都可以这么取）<br>因此主要判断两端的字符是不是相等，因此有几种情况：</p>
<ol>
<li>s[i] === s[j]，说明两端字符相等</li>
</ol>
<ul>
<li>i === j，即同一个字符，为 true</li>
<li>|i - j| === 1，说明是两个相邻的字符，为 true</li>
<li>其他情况，即 i 和 j 之间还包含其他字符串。因此需要判断两者之间的部分是不是，即判断<code>dp[i + 1][j - 1]</code>是否为 true</li>
</ul>
<ol start="2">
<li>s[i] !== s[j]，肯定是 false</li>
</ol>
<p>由此可以得到公式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] === s[j]) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i === j || <span class="built_in">Math</span>.abs(i - j) &lt;= <span class="number">1</span>) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> dp[i][j] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>这里注意因为 dp[i][j]是从 dp[i + 1][j - 1]推出来的，因此一定要从下向上、从左向右遍历。（即从 dp[s.length - 1][0]开始，i 递减）</p>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countSubstrings = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(s.length), <span class="function">() =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Array</span>(s.length).fill(<span class="literal">false</span>)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = s.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt;= s.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i] === s[j]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i === j || j - i &lt;= <span class="number">1</span>) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (dp[i][j]) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/">日常学习</a></div><div class="post_share"><div class="social-share" data-image="/img/codes1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/12/OS/"><img class="prev-cover" src="/img/codes1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">操作系统知识点总结</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/05/blog44-optimization/"><img class="next-cover" src="/img/codes1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">优化问题总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/11/06/blog11-myReact/" title="react知识点汇总和使用小总结(一)"><img class="cover" src="/img/react.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-06</div><div class="title">react知识点汇总和使用小总结(一)</div></div></a></div><div><a href="/2021/10/27/blog10-react-router/" title="react-router的使用"><img class="cover" src="/img/reactrouter.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-27</div><div class="title">react-router的使用</div></div></a></div><div><a href="/2021/11/20/blog14-react-ts-basic/" title="typescript+react基础部分"><img class="cover" src="/img/typescript.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-20</div><div class="title">typescript+react基础部分</div></div></a></div><div><a href="/2021/11/22/blog17-react-pubsub-issues/" title="react+typescript使用pubsub时的一点小问题"><img class="cover" src="/img/pubsub.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-22</div><div class="title">react+typescript使用pubsub时的一点小问题</div></div></a></div><div><a href="/2021/11/20/blog16-react-ts-hooks-redux/" title="typescript+react:自定义hooks代替redux"><img class="cover" src="/img/typescript.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-20</div><div class="title">typescript+react:自定义hooks代替redux</div></div></a></div><div><a href="/2021/11/25/blog18-vue3ts-basic/" title="vue3+ts配置及简单使用注意"><img class="cover" src="/img/vue3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-25</div><div class="title">vue3+ts配置及简单使用注意</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/pinkstar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xing Ye</div><div class="author-info__description">a singleThreaded boy's blog</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/penghei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/penghei" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:632885485@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">A SingleThreaded Boy...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-1"><span class="toc-number">1.1.</span> <span class="toc-text">两数之和 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">双指针法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%95%B0%E6%B1%82%E5%92%8C"><span class="toc-number">1.3.</span> <span class="toc-text">三数求和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="toc-number">1.4.</span> <span class="toc-text">有序数组的平方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.5.</span> <span class="toc-text">移除元素</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.1.</span> <span class="toc-text">回文字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP-%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">KMP 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.3.</span> <span class="toc-text">重复子字符串</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8"><span class="toc-number">3.1.</span> <span class="toc-text">合并链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dummy-%E8%8A%82%E7%82%B9"><span class="toc-number">3.2.</span> <span class="toc-text">dummy 节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="toc-number">3.3.</span> <span class="toc-text">快慢指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">3.4.</span> <span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E4%BA%A4%E5%8F%89"><span class="toc-number">3.5.</span> <span class="toc-text">链表交叉</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-number">3.6.</span> <span class="toc-text">判断回文链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">4.</span> <span class="toc-text">栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.</span> <span class="toc-text">括号匹配问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C%E5%AF%B9%E5%AF%B9%E7%A2%B0%E2%80%9D%E6%B6%88%E9%99%A4"><span class="toc-number">4.2.</span> <span class="toc-text">“对对碰”消除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">4.3.</span> <span class="toc-text">后缀表达式求值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-number">4.4.</span> <span class="toc-text">单调栈和单调队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">4.5.</span> <span class="toc-text">滑动窗口最大值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">4.6.</span> <span class="toc-text">栈实现队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%80%92%E5%BD%92%E6%80%9D%E8%B7%AF"><span class="toc-number">5.1.</span> <span class="toc-text">二叉树问题的基本递归思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.</span> <span class="toc-text">二叉树的迭代遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.1.</span> <span class="toc-text">先序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.2.</span> <span class="toc-text">后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.3.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.4.</span> <span class="toc-text">层序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.3.</span> <span class="toc-text">翻转二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BST%EF%BC%88%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">BST（二叉搜索树）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BST-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">5.4.1.</span> <span class="toc-text">BST 基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E6%98%AF%E5%90%A6%E6%98%AF%E6%9C%89%E6%95%88-BST"><span class="toc-number">5.4.2.</span> <span class="toc-text">验证是否是有效 BST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0-BST"><span class="toc-number">5.4.3.</span> <span class="toc-text">构造 BST</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.4.3.1.</span> <span class="toc-text">构造最大二叉树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.5.</span> <span class="toc-text">判断平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E5%8C%96-BST"><span class="toc-number">5.6.</span> <span class="toc-text">转化 BST</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.7.</span> <span class="toc-text">比较两棵二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%B4%E5%AF%B9%E7%A7%B0"><span class="toc-number">5.8.</span> <span class="toc-text">二叉树轴对称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-number">5.9.</span> <span class="toc-text">二叉树的深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.10.</span> <span class="toc-text">二叉树的路径问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98-1%EF%BC%88%E7%9B%AE%E6%A0%87%E5%92%8C%EF%BC%89"><span class="toc-number">5.10.1.</span> <span class="toc-text">路径问题 1（目标和）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98-2%EF%BC%88%E5%85%B7%E4%BD%93%E8%B7%AF%E5%BE%84%EF%BC%89"><span class="toc-number">5.10.2.</span> <span class="toc-text">路径问题 2（具体路径）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98-3%EF%BC%88%E4%BB%BB%E6%84%8F%E8%8A%82%E7%82%B9%E5%BC%80%E5%A7%8B%EF%BC%89"><span class="toc-number">5.10.3.</span> <span class="toc-text">路径问题 3（任意节点开始）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">5.10.4.</span> <span class="toc-text">最大路径和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="toc-number">5.11.</span> <span class="toc-text">二叉树左叶子之和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-number">6.</span> <span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-number">6.1.</span> <span class="toc-text">回溯问题的基本思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E9%A2%98%E7%9B%AE"><span class="toc-number">6.1.1.</span> <span class="toc-text">具体题目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-number">6.2.</span> <span class="toc-text">全排列问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">6.2.1.</span> <span class="toc-text">基本全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97-2%EF%BC%88%E5%89%AA%E6%9E%9D%EF%BC%89"><span class="toc-number">6.2.2.</span> <span class="toc-text">全排列 2（剪枝）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98"><span class="toc-number">6.3.</span> <span class="toc-text">组合问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98"><span class="toc-number">6.3.1.</span> <span class="toc-text">基本组合问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%90%88"><span class="toc-number">6.3.2.</span> <span class="toc-text">组合总合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-2"><span class="toc-number">6.3.3.</span> <span class="toc-text">组合总和 2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98"><span class="toc-number">6.4.</span> <span class="toc-text">子集问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E9%97%AE%E9%A2%98"><span class="toc-number">6.5.</span> <span class="toc-text">分割问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-number">6.5.1.</span> <span class="toc-text">分割回文串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%95%88-ip-%E5%9C%B0%E5%9D%80"><span class="toc-number">6.5.2.</span> <span class="toc-text">有效 ip 地址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98"><span class="toc-number">6.6.</span> <span class="toc-text">岛屿问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-number">6.6.1.</span> <span class="toc-text">岛屿数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%B2%9B%E5%B1%BF%E9%9D%A2%E7%A7%AF"><span class="toc-number">6.6.2.</span> <span class="toc-text">最大岛屿面积</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">7.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">7.2.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">7.3.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">7.4.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E6%8E%92"><span class="toc-number">7.5.</span> <span class="toc-text">快排</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">8.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98"><span class="toc-number">8.1.</span> <span class="toc-text">爬楼梯问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%91%E7%A1%AC%E5%B8%81%E6%89%BE%E9%9B%B6"><span class="toc-number">8.2.</span> <span class="toc-text">最少硬币找零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C"><span class="toc-number">8.3.</span> <span class="toc-text">最大子序列和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">8.4.</span> <span class="toc-text">最长上升子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">8.5.</span> <span class="toc-text">最长连续递增子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">8.6.</span> <span class="toc-text">最长公共子数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-number">8.7.</span> <span class="toc-text">不同路径问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-1-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">8.8.</span> <span class="toc-text">0-1 背包问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="toc-number">8.9.</span> <span class="toc-text">整数拆分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="toc-number">8.10.</span> <span class="toc-text">杨辉三角</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8"><span class="toc-number">8.11.</span> <span class="toc-text">买卖股票</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">8.12.</span> <span class="toc-text">判断子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">8.13.</span> <span class="toc-text">不同子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">8.14.</span> <span class="toc-text">回文子串</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/05/18/projects/" title="无题"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/05/18/projects/" title="无题">无题</a><time datetime="2022-05-18T02:57:57.356Z" title="发表于 2022-05-18 10:57:57">2022-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/13/handwriting/" title="js题目"><img src="/img/JS.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="js题目"/></a><div class="content"><a class="title" href="/2022/05/13/handwriting/" title="js题目">js题目</a><time datetime="2022-05-13T04:21:10.000Z" title="发表于 2022-05-13 12:21:10">2022-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/12/OS/" title="操作系统知识点总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统知识点总结"/></a><div class="content"><a class="title" href="/2022/05/12/OS/" title="操作系统知识点总结">操作系统知识点总结</a><time datetime="2022-05-12T07:58:22.000Z" title="发表于 2022-05-12 15:58:22">2022-05-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/05/blog43-algorithms/" title="算法学习总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法学习总结"/></a><div class="content"><a class="title" href="/2022/04/05/blog43-algorithms/" title="算法学习总结">算法学习总结</a><time datetime="2022-04-05T08:01:22.000Z" title="发表于 2022-04-05 16:01:22">2022-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/05/blog44-optimization/" title="优化问题总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="优化问题总结"/></a><div class="content"><a class="title" href="/2022/04/05/blog44-optimization/" title="优化问题总结">优化问题总结</a><time datetime="2022-04-05T08:01:22.000Z" title="发表于 2022-04-05 16:01:22">2022-04-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Xing Ye</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hello stranger!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>