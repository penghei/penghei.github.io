<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>算法学习总结 | XingYeBlog</title><meta name="keywords" content="日常学习"><meta name="author" content="Xing Ye,632885485@qq.com"><meta name="copyright" content="Xing Ye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数组加法转减法  给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。   这道题是经典的解法简单、但是可以使用更好的方法优化的问题。最简单的方式是通过双重循环遍历： 1234567function findTarget(nums, target) &amp;#123;  for (let a &#x3D; 0; a &lt; nums.len">
<meta property="og:type" content="article">
<meta property="og:title" content="算法学习总结">
<meta property="og:url" content="http://example.com/2022/04/05/blog43-algorithms/index.html">
<meta property="og:site_name" content="XingYeBlog">
<meta property="og:description" content="数组加法转减法  给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。   这道题是经典的解法简单、但是可以使用更好的方法优化的问题。最简单的方式是通过双重循环遍历： 1234567function findTarget(nums, target) &amp;#123;  for (let a &#x3D; 0; a &lt; nums.len">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/codes1.jpg">
<meta property="article:published_time" content="2022-04-05T08:01:22.000Z">
<meta property="article:modified_time" content="2022-05-06T16:52:37.452Z">
<meta property="article:author" content="Xing Ye">
<meta property="article:tag" content="日常学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/codes1.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2022/04/05/blog43-algorithms/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法学习总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-07 00:52:37'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/pinkstar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/codes1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XingYeBlog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法学习总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-05T08:01:22.000Z" title="发表于 2022-04-05 16:01:22">2022-04-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-06T16:52:37.452Z" title="更新于 2022-05-07 00:52:37">2022-05-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>63分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法学习总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="加法转减法"><a href="#加法转减法" class="headerlink" title="加法转减法"></a>加法转减法</h2><blockquote>
<ol>
<li>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</li>
</ol>
</blockquote>
<p>这道题是经典的解法简单、但是可以使用更好的方法优化的问题。<br>最简单的方式是通过双重循环遍历：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findTarget</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> a = <span class="number">0</span>; a &lt; nums.length; a++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> b = <span class="number">0</span>; b &lt; nums.length; b++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[a] + nums[b] === target) <span class="keyword">return</span> [a, b];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是可以通过“空间换时间，加法转减法”的方法优化这道题目。<br>思路是求和问题转化为求差问题, 每遍历到一个新数字的时候，都回到 <code>Map</code> 里去查询 <code>targetNum</code> 与该数的差值是否已经在前面的数字中出现过了。如果出现过显然就是结果；如果没有出现就记录当前数字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findTargetByMap</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  map.set(nums[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.has(target - nums[i])) &#123;</span><br><span class="line">      <span class="comment">// 如果目标数减去当前数在map中存在, 说明找到了</span></span><br><span class="line">      <span class="keyword">return</span> [i, map.get(target - nums[i])];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有找到, 则把该数放到map中</span></span><br><span class="line">      map.set(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><blockquote>
<ol start="2">
<li>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</li>
</ol>
</blockquote>
<p>思路是使用两个指针（i、j）分别指向两个数组中的数字，然后两边同时遍历，比较两个指针所指的数字的大小关系，把较小的一个放入新数组，依次类推；<br>最终有一个数组会剩下一部分，再把这一部分截下来补在最后即可</p>
<blockquote>
<p>注意：双指针法用在涉及求和、比大小类的数组题目里时，大前提往往是：该数组必须有序。否则双指针根本无法帮助我们缩小定位的范围，压根没有意义。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatArray</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newArr = [];</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) &#123;</span><br><span class="line">    newArr.push(arr1[i] &lt; arr2[j] ? arr1[i++] : arr2[j++]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [...newArr, ...(i === arr1.length ? arr2.slice(j) : arr1.slice(i))];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三数求和"><a href="#三数求和" class="headerlink" title="三数求和"></a>三数求和</h2><blockquote>
<ol start="3">
<li>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</li>
</ol>
</blockquote>
<p>思路：</p>
<ol>
<li>首先先对数组排序；</li>
<li>然后固定一个元素<code>k</code>,然后双指针分别指向其后后面元素的第一个<code>k+1</code>和最后一个<code>length - 1</code>,按照两元素和的方法移动指针<ul>
<li>若三个数相加之和大于 0，说明右侧的数偏大了，右指针左移</li>
<li>若三个数相加之和小于 0，说明左侧的数偏小了，左指针右移</li>
</ul>
</li>
</ol>
<p>因为要求找到不重复的三元组，因此遍历期间两个指针处如果有重复的数字应该跳过；并且固定的元素也应该跳过重复</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">triNumberSum</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  nums = nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> cache = []; <span class="comment">// 存储防止重复</span></span><br><span class="line">  <span class="keyword">const</span> newArr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; nums.length - <span class="number">2</span>; k++) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果当前正在遍历的数字重复了就直接跳过</span></span><br><span class="line">    <span class="keyword">if</span> (cache.includes(nums[k])) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">const</span> sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">      <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 等于0得到结果</span></span><br><span class="line">        newArr.push([nums[i], nums[j], nums[k]]);</span><br><span class="line">        cache.push(nums[k]);</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 大于0说明右边大了</span></span><br><span class="line">        j--;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; i &amp;&amp; nums[j] === nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="comment">// 如果前一个数和这个数一样就继续向前，即跳过重复的</span></span><br><span class="line">          j--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 小于0说明左边小了</span></span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] === nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">          i++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>左右指针一起从两边往中间位置相互迫近，这样的特殊双指针形态，被称为“对撞指针”。<br><strong>有序</strong>和<strong>数组</strong>这样的关键词出现，就要考虑使用对撞指针</p>
</blockquote>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="回文字符串"><a href="#回文字符串" class="headerlink" title="回文字符串"></a>回文字符串</h2><blockquote>
<ol>
<li>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。<br>示例：<br>输入: “abca”<br>输出: True<br>解释: 你可以删除 c 字符。</li>
</ol>
</blockquote>
<p>思路：利用回文字符串的“对称性”，即字符串从两头分别遍历，每个字符都相等（直到两个遍历指针相碰）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> strArr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = strArr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strArr[i] === strArr[j]) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么放到这个题就是，现进行一次上面的操作，直到找到第一个不不相等的字符串为止；</p>
<p>然后“跳过”这个字符，分别让左指针跳过当前正在指的字符、右指针跳过当前正在指的字符，然后判断跳过之后左右指针中间的字符段是否回文。</p>
<p>原理其实是，由于判断出现不同时，不知道是左边还是右边的那个字符不对，因此就让左右分别跳过，测试跳过之后中间部分是不是还能正常回文。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">palindrome</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> strArr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = strArr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strArr[i] === strArr[j]) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        isPalindrome(str.slice(i + <span class="number">1</span>, j)) &amp;&amp; isPalindrome(str.slice(i, j - <span class="number">1</span>))</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> strArr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = strArr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strArr[i] === strArr[j]) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="合并链表"><a href="#合并链表" class="headerlink" title="合并链表"></a>合并链表</h2><blockquote>
<ol>
<li>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有结点组成的。</li>
</ol>
</blockquote>
<p>有序链表的合成和有序数组的合并类似，都是用双指针依次遍历节点。</p>
<p>通过 LinkNode 新创建一个头节点，然后依次把两个链表中的节点比较、附加在这个新的头节点后面，形成的新链表就是有序链表。最后再把没连接上的多余部分加上去即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeTwoLists = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> head = <span class="keyword">new</span> LinkNode();</span><br><span class="line">  <span class="keyword">let</span> curr = head;</span><br><span class="line">  <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">      curr.next = l1;</span><br><span class="line">      l1 = l1.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      curr.next = l2;</span><br><span class="line">      l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  curr.next = l1 ? l1 : l2;</span><br><span class="line">  <span class="keyword">return</span> curr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="dummy-节点"><a href="#dummy-节点" class="headerlink" title="dummy 节点"></a>dummy 节点</h2><blockquote>
<ol start="2">
<li>给定一个排序链表，删除所有含有重复数字的结点，只保留原始链表中 没有重复出现的数字。</li>
</ol>
</blockquote>
<p>这道题乍看起来比较简单，可以用一个 set 存储前面遍历过的数字，如果在 set 中找到，就把这些删去。</p>
<p>问题在于，这里要求删去所有节点，那么重复的这一组节点中的头一个节点就无法删去，因为不能获取到它前面的节点，就不能删去它</p>
<p>为了解决这个问题，设置一个位于整个链表头部的 dummy 节点，从 dummy 开始遍历（假设当前指针是 curr）：如果<code>curr.next.val === curr.next.next.val</code>，就用循环依次遍历到不相等的节点，然后把<code>curr.next</code>指过去即可。</p>
<p>dummy 节点的出现在这里主要是为了解决第一个节点就是重复节点的问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deleteDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 设定 dummy 指针，作为头节点的前一个虚拟节点</span></span><br><span class="line">  <span class="keyword">let</span> dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">  dummy.next = head;</span><br><span class="line">  <span class="keyword">let</span> cur = dummy; <span class="comment">// 从dummy开始，这样就解决了第一个就重复的情况</span></span><br><span class="line">  <span class="keyword">while</span> (cur.next &amp;&amp; cur.next.next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur.next.val === cur.next.next.val) &#123;</span><br><span class="line">      <span class="comment">// 若值重复，则记下这个值</span></span><br><span class="line">      <span class="keyword">let</span> val = cur.next.val;</span><br><span class="line">      <span class="comment">// 反复地排查后面的元素是否存在多次重复该值的情况</span></span><br><span class="line">      <span class="keyword">while</span> (cur.next &amp;&amp; cur.next.val === val) &#123;</span><br><span class="line">        <span class="comment">// 若有，则删除</span></span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 若不重复，则正常遍历</span></span><br><span class="line">      cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注意是dummy.next</span></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><blockquote>
<ol start="3">
<li>给定一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</li>
</ol>
</blockquote>
<p>快慢指针即设定两个指针，快指针在慢指针前面或者快指针一次走的步数比慢指针多；当快指针到达某个位置时，慢指针往往就是对应的解。</p>
<p>比如倒数 n 个节点，可以让快指针先走 n 步，然后两者一起往前走；当快指针走到最后一个节点时，慢指针所指向的就是倒数第 n 个</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> removeNthFromEnd = <span class="function"><span class="keyword">function</span> (<span class="params">head, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">  dummy.next = head;</span><br><span class="line">  <span class="keyword">let</span> fast = dummy;</span><br><span class="line">  <span class="keyword">let</span> slow = dummy;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!fast.next) <span class="keyword">return</span>;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (fast.next) &#123;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">  &#125;</span><br><span class="line">  slow.next = slow.next.next;</span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="多指针"><a href="#多指针" class="headerlink" title="多指针"></a>多指针</h2><blockquote>
<ol start="4">
<li>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</li>
</ol>
</blockquote>
<p>记住方法：</p>
<ol>
<li>使用 prev/curr/next 三个指针分别指向前一个、当前和后一个节点；其中 curr 是第一个节点，prev 可以是 null 或者 dummy</li>
<li>从 curr 指向的第一个节点开始，让当前节点的 next 指向 pre；</li>
<li>然后令<code>curr = next，prev = curr，next = next.next</code>，即依次向后移动，直到最后一个节点被反转</li>
<li>cur 节点是真正反转的节点，因此要遍历到最后一个；当 cur 成为 null 时，pre 就是最后一个节点</li>
</ol>
<blockquote>
<p>实际上并不需要 next 指针，因为直接用<code>curr.next</code>就可以，每次遍历都先获取<code>curr.next</code>并缓存一下，然后继续即可</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseList = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="literal">null</span>; <span class="comment">// 前节点</span></span><br><span class="line">  <span class="keyword">let</span> cur = head; <span class="comment">// 当前节点，从头节点开始</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = cur.next; <span class="comment">// 先缓存next</span></span><br><span class="line">    cur.next = pre;</span><br><span class="line">    pre = cur;</span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<ol start="5">
<li>部分反转：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</li>
</ol>
</blockquote>
<p>核心方法和正常的反转链表一样，关键在于反转之后把反转的部分和其他的连起来。<br>其实就是先把反转部分的前节点和后节点存起来，反转完成后再连起来。</p>
<p><img src="https://pic.imgdb.cn/item/6266b3c3239250f7c528044f.jpg"></p>
<p>以这幅图为例，当 curr 指针遍历到 left 时，即开始遍历到区域时，就把节点 1 缓存下来（此时正好是 pre 指针指向的）；<br>随着遍历的进行，当结点 4 的指针反转后，此时 cur 指针就恰好指在结点 5 上，这时只需要把节点 2 指向 cur 即可。</p>
<p>另外，还需要记录反转区域内部的头尾节点（上面的 2、4 节点）；其中 4 节点恰好是遍历完的 pre，直接<code>leftHead.next = pre</code>即可；但是 2 节点需要提前缓存（下面代码中的 start），结束后让<code>start.next = cur</code>连接尾部。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseBetween = <span class="function"><span class="keyword">function</span> (<span class="params">head, m, n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义pre、cur，用leftHead来承接整个区间的前驱结点</span></span><br><span class="line">  <span class="keyword">let</span> pre, cur, leftHead;</span><br><span class="line">  <span class="keyword">const</span> dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">  <span class="comment">// dummy后继结点是头结点</span></span><br><span class="line">  dummy.next = head;</span><br><span class="line">  <span class="comment">// p是一个游标，用于遍历，最初指向 dummy</span></span><br><span class="line">  <span class="keyword">let</span> p = dummy;</span><br><span class="line">  <span class="comment">// p往前走 m-1 步，走到整个区间的前驱结点处</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    p = p.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 缓存这个前驱结点到 leftHead 里</span></span><br><span class="line">  leftHead = p;</span><br><span class="line">  <span class="comment">// start 是反转区间的第一个结点</span></span><br><span class="line">  <span class="keyword">let</span> start = leftHead.next;</span><br><span class="line">  <span class="comment">// pre 指向start</span></span><br><span class="line">  pre = start;</span><br><span class="line">  <span class="comment">// cur 指向 start 的下一个结点</span></span><br><span class="line">  cur = pre.next;</span><br><span class="line">  <span class="comment">// 开始重复反转动作</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = m; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = cur.next;</span><br><span class="line">    cur.next = pre;</span><br><span class="line">    pre = cur;</span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  leftHead 的后继结点此时为反转后的区间的第一个结点</span></span><br><span class="line">  leftHead.next = pre;</span><br><span class="line">  <span class="comment">// 将区间内反转后的最后一个结点 next 指向 cur</span></span><br><span class="line">  start.next = cur;</span><br><span class="line">  <span class="comment">// dummy.next 永远指向链表头结点</span></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h2><blockquote>
<ol>
<li>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</li>
</ol>
</blockquote>
<p>比较基础的栈问题，先把左括号入栈，然后当遇见右括号时，根据预设的匹配关系出栈左括号，如果不匹配就返回 false</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isValid = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">const</span> str = s.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;[&quot;</span>, <span class="string">&quot;]&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>],</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s === <span class="string">&quot;(&quot;</span> || s === <span class="string">&quot;[&quot;</span> || s === <span class="string">&quot;&#123;&quot;</span>) &#123;</span><br><span class="line">      stack.push(s);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s === <span class="string">&quot;)&quot;</span> || s === <span class="string">&quot;]&quot;</span> || s === <span class="string">&quot;&#125;&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> top = stack.pop();</span><br><span class="line">      <span class="keyword">if</span> (s !== map.get(top)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!stack.length) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最小-最大栈"><a href="#最小-最大栈" class="headerlink" title="最小/最大栈"></a>最小/最大栈</h2><blockquote>
<ol start="2">
<li>给定一个整数数组  temperatures ，表示每天的温度，返回一个数组  answer ，其中<code>answer[i]</code>  是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用  0 来代替。<br>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</li>
</ol>
</blockquote>
<p>思路：创建一个索引栈，用于记录索引。这个栈同时还是一个最小栈，即保持栈顶的元素始终是最小的。</p>
<p>确定一个<strong>单调递减的趋势</strong>，一旦有数字打破了这个趋势，也就说一个数字比它前面入栈的数字大，那就把它前面比他小的数字都出栈，并且用它的索引减去这些数字的索引，减去的值恰好就是对应的 answer。</p>
<blockquote>
<p>演示视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12t4y1274o/">https://www.bilibili.com/video/BV12t4y1274o/</a></p>
</blockquote>
<p>至于为什么栈中不直接放入温度而是存索引，是因为要得出的结果 ans 是每个元素的索引相加减得出的，并且也恰好是按照索引顺序摆放的。<br>索引栈是一个很好用的思维方式，可以尝试多用用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dailyTemperatures = <span class="function"><span class="keyword">function</span> (<span class="params">temperatures</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  stack[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> ans = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (</span><br><span class="line">      stack.length &amp;&amp;</span><br><span class="line">      temperatures[i] &gt; temperatures[stack[stack.length - <span class="number">1</span>]]</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">const</span> index = stack.pop();</span><br><span class="line">      ans[index] = i - index;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口和双端队列"><a href="#滑动窗口和双端队列" class="headerlink" title="滑动窗口和双端队列"></a>滑动窗口和双端队列</h2><blockquote>
<ol start="3">
<li>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。<br>滑动窗口大概长这样：<br>1 [3 -1 -3] 5 3 6 7<br>1 3 [-1 -3 5] 3 6 7<br>1 3 -1 [-3 5 3] 6 7<br>1 3 -1 -3 [5 3 6] 7<br>1 3 -1 -3 5 [3 6 7]</li>
</ol>
</blockquote>
<p>基础思路是用一个双指针分别指向窗口的左和右，然后取得双指针之间的最大值放入结果.但是这个方法不好，因为实际上有很多已经判断过的数被重复比较</p>
<p>因此更好的思路是利用<strong>单调递减</strong>的<strong>双端队列</strong>，遍历把每个 nums 中的索引放入（还是索引，因为需要判断队列中的数字是否超出滑动窗口范围）</p>
<p>然后最重要的是和上面的最小栈类似，如果有比队尾数小的就放入；如果比队尾数大就依次出队，直到<code>队尾数&gt;=当前数</code>为止。因此队头的元素一定是本次遍历的最大值</p>
<p>遍历时从第一个开始，当遍历数到达 k 时，就相当于产生了第一个窗口，开始记录最大值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxSlidingWindow = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> deque = [];</span><br><span class="line">  <span class="keyword">const</span> answer = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果当前数比队尾数大，就依次出队</span></span><br><span class="line">    <span class="keyword">while</span> (deque.length &amp;&amp; nums[i] &gt; nums[deque[deque.length - <span class="number">1</span>]]) &#123;</span><br><span class="line">      deque.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    deque.push(i); <span class="comment">// 当前数的索引放入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队头元素的位置是否超过了滑动窗口的前沿（即 i + 1 - k）</span></span><br><span class="line">    <span class="keyword">if</span> (deque.length &amp;&amp; deque[<span class="number">0</span>] &lt; i + <span class="number">1</span> - k) &#123;</span><br><span class="line">      deque.shift();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当遍历数到达k时，开始记录最大值</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">      answer.push(nums[deque[<span class="number">0</span>]]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h2><blockquote>
<ol start="4">
<li>用栈实现队列，只能使用栈的 push 和 pop 方法。</li>
</ol>
</blockquote>
<p>思路是用两个栈存储，正常的入队就是 push 到 stack1；但是每次出队时，将 stack1 中的元素依次出栈再入栈到 stack2 中，这样栈底元素就被取出了；此后再次入队仍然是到 stack1 中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stack1 = [];</span><br><span class="line">    <span class="built_in">this</span>.stack2 = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">enqueue</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stack1.push(val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">dequeue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.stack2.length) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.stack1.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>.stack2.push(<span class="built_in">this</span>.stack1.pop());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack2.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">peek</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.stack2.length) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.stack1.length; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>.stack2.push(<span class="built_in">this</span>.stack1.pop());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack2[<span class="built_in">this</span>.stack2.length - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack1.length + <span class="built_in">this</span>.stack2.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树问题的基本递归思路"><a href="#二叉树问题的基本递归思路" class="headerlink" title="二叉树问题的基本递归思路"></a>二叉树问题的基本递归思路</h2><p>二叉树问题基本上都离不开递归和遍历；<br>而递归实际上有两种，一种是单纯只递归，比如基本的递归遍历方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  dfs(node.left);</span><br><span class="line">  dfs(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种递归只有在边界条件才会返回，因此一般常用于彻底的遍历，比如路径问题。<br>在思考方式上，这种递归可以看作是只有一个左右节点的树的遍历。常常把操作放置在两个递归的<code>dfs()</code>前面、中间或后面，对应不同的时刻：</p>
<ul>
<li>前面：该节点已经遍历到，但其子节点还没开始遍历，可以进行记录该节点值、判断临界条件等操作</li>
<li>中间：只遍历了左子树，一般很少放在这里，除非是为了中序遍历</li>
<li>后面：该节点和其子树都被完全遍历。站在最顶层调用栈的角度上，这时整棵树已经遍历完毕；可以在这里显式返回一个值，这个值将会是上面每个 dfs 都会返回的值；也可以执行一些<strong>回溯</strong>相关的操作，比如路径问题中在这里让当前节点出栈、回溯问题中在这里返回上一层等等</li>
</ul>
<hr>
<p>另一种递归是显式的返回值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = dfs(node.left);</span><br><span class="line">  <span class="keyword">let</span> right = dfs(node.right);</span><br><span class="line">  <span class="keyword">return</span> node.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时前面两个递归的 dfs 也会产生有效的返回值，并且返回的值就是最末端的返回值。</p>
<p>注意要以“递归的方式思考问题”，不要把上面两个 dfs 看成复杂的调用栈，而是只把他们当作左节点和右节点的调用结果即可。</p>
<blockquote>
<p>这种遍历方式能够生效的最重要一点是：<strong>左右递归调用结果</strong>（<strong>当前节点</strong>有时候也会）都会参与返回值的运算</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = dfs(node.left);</span><br><span class="line">  <span class="keyword">let</span> right = dfs(node.right);</span><br><span class="line">  <span class="keyword">return</span> node.val + <span class="built_in">Math</span>.max(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就会把当前节点的值和左右子节点中较大的值加起来。由于自底向上的每次返回都用到了 left 和 right，因此数值就是从下向上连续的，left 和 right 可以看作是左右子树的计算结果。</p>
<p>再比如，常见的方法之一是利用返回布尔值进行一些判断。比如基本的递归搜索一个值，找到了则返回 true</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和搜索相关的问题是少都要考虑这个写法，这是最基本的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">root, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> search(root.left, val) || search(root.right, val) || root.val === val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里返回值综合了两个遍历的结果和当前节点的值，只要有一个符合条件就返回 true，即找到一个就返回 true。</p>
<p>当函数参数不止有节点这一个参数时，当前节点值还可以放入参数中。比如<code>路径总和1</code>这个题，就是通过每次递减一个当前节点值来实现。</p>
<p>还可以有条件的返回不同的值；这种方法常见于偏运算，比如只计算左叶子和这种问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = dfs(node.left);</span><br><span class="line">  dfs(node.right);</span><br><span class="line">  sum += left;</span><br><span class="line">  <span class="keyword">if</span> (!node.left &amp;&amp; !node.right) <span class="keyword">return</span> node.val;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只有当节点为叶子节点时才会返回有效的值，相当于是在遍历之中设置了回溯条件。</p>
<h2 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h2><blockquote>
<ol>
<li>用迭代方法实现二叉树的遍历</li>
</ol>
</blockquote>
<h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><ol>
<li>将根节点入栈</li>
<li>出栈，输出该节点，然后将该节点的子节点入栈，先右后左；这样出栈的顺序就是先左后右，符合先序遍历的<code>左-&gt;右-&gt;中</code>顺序</li>
<li>后续依次类推</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> preorder = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  stack.push(root);</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = stack.pop();</span><br><span class="line">    res.push(node.val);</span><br><span class="line">    <span class="keyword">if</span> (node.right) stack.push(node.right);</span><br><span class="line">    <span class="keyword">if</span> (node.left) stack.push(node.left);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><ol>
<li>同样是先入栈根节点</li>
<li>出栈，将该节点的输出插入到结果队列的头部（unshift），这样结果数组相当于是反向；然后将子节点入栈，先左后右</li>
<li>以此类推</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> postorderIterate = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">  stack.push(root);</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = stack.pop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相当于把结果数组反向了</span></span><br><span class="line">    res.unshift(node.val);</span><br><span class="line">    <span class="comment">// 因为结果数组反向,这里也要变一下</span></span><br><span class="line">    <span class="keyword">if</span> (node.left) stack.push(node.left);</span><br><span class="line">    <span class="keyword">if</span> (node.right) stack.push(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>中序遍历根另外两者都不一样，因为先序和后序都是通过出栈一个元素作为根节点，然后把它的左右子元素入栈。但是中序遍历的顺序是<code>左-&gt;中-&gt;右</code>，也就说必须有从<code>左</code>回到其父元素<code>中</code>的过程。</p>
<ol>
<li>从根节点开始迭代取左子元素，每迭代一次就入栈一个元素，直到最左端位置</li>
<li>出栈一个元素，输出结果，然后取该节点的右节点再次迭代。因为这时的出栈元素如果有右节点，说明就是一个父元素，相当于<code>中</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inorderIterate = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">  stack.push(root);</span><br><span class="line">  <span class="keyword">let</span> curr = root;</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">      stack.push(curr);</span><br><span class="line">      curr = curr.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curr = stack.pop();</span><br><span class="line">    res.push(curr.val);</span><br><span class="line">    curr = curr.right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><ol>
<li>设置一个队列，将根元素入队</li>
<li>出队队头元素并输出，把这个元素的子元素全部入队。重复这个过程，直到把上一步的所有入队元素都出队并输出；这里需要先缓存上一步时队列的长度，然后遍历这个长度直到上一层的元素都依次执行该过程。</li>
<li>依次类推</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> levelOrder = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> queue = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  queue.push(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = queue.length;</span><br><span class="line">    <span class="comment">// 相当于每次执行到这里就是新的一层</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> node = queue.shift();</span><br><span class="line">      res.push(node.val);</span><br><span class="line">      <span class="keyword">if</span> (curr.left) queue.push(curr.left);</span><br><span class="line">      <span class="keyword">if</span> (curr.right) queue.push(curr.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><blockquote>
<p><img src="https://pic.imgdb.cn/item/62675aab239250f7c5499cac.jpg"></p>
</blockquote>
<p>思路：以递归的方式，遍历树中的每一个结点，并将每一个结点的左右孩子进行交换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> invertTree = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">let</span> left = invertTree(root.left);</span><br><span class="line">  <span class="keyword">let</span> right = invertTree(root.right);</span><br><span class="line">  root.left = right;</span><br><span class="line">  root.right = left;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>翻转二叉树是这种非尾递归思想的重要体现之一；通过递归先一直到边界（即叶子节点）为止，然后返回该节点给上一层的<code>left</code>；再同理把<code>right</code>交给上一层，在上一层中进行交换，就完成了自下而上的第一次交换，后续同理。</p>
<p>比如一个通常的遍历是这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  dfs(node.left);</span><br><span class="line">  dfs(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的遍历只会在遇到边界时返回。如果我们在最后显式返回某一个值（一般就是本次递归的参数传入的节点），每一个递归就相当于拿到了其上一层的返回值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> node;</span><br><span class="line">  <span class="keyword">let</span> left = dfs(node.left); <span class="comment">// left是当前node的左子树的根节点</span></span><br><span class="line">  <span class="keyword">let</span> right = dfs(node.right); <span class="comment">// 右子树</span></span><br><span class="line">  <span class="keyword">return</span> node; <span class="comment">// 返回本节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到了 left 和 right，从递归的思维来看，实际上就是拿到了任一个节点的左右子树（不用考虑反复递归的多层，只考虑一层即可）。所以我们可以进行一些操作，比如上面的交换节点。</p>
<p>如果最简单的二叉树（只有三个节点）可以执行，那么任何情况下的二叉树都可以执行。因此这类问题可以先从最简单的考虑。如果最简单的情况可以保证递归的完整，那么之后的逻辑就不用考虑递归的内部，而是只把递归当成一个“取值”的步骤，正常处理其他逻辑。</p>
<h2 id="BST（二叉搜索树）"><a href="#BST（二叉搜索树）" class="headerlink" title="BST（二叉搜索树）"></a>BST（二叉搜索树）</h2><h3 id="BST-基本操作"><a href="#BST-基本操作" class="headerlink" title="BST 基本操作"></a>BST 基本操作</h3><p>查找：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">root, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (root.val === n) <span class="keyword">return</span> root;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; n) search(root.left, n);</span><br><span class="line">  <span class="keyword">else</span> search(root.right, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">root, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; root.val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root.left) root.left = <span class="keyword">new</span> TreeNode(n);</span><br><span class="line">    <span class="keyword">else</span> insert(root.left, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root.right) root.right = <span class="keyword">new</span> TreeNode(n);</span><br><span class="line">    <span class="keyword">else</span> insert(root.right, n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除：</p>
<p>删除节点的函数要返回参数 root，因为执行函数的返回值实际上是“替换子树”的效果，也是上面说的非尾递归的形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeNode</span>(<span class="params">root, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">  <span class="keyword">if</span> (root.val === n) &#123;</span><br><span class="line">    <span class="comment">// 如果n和当前节点值相等，即找到了要删除的节点</span></span><br><span class="line">    <span class="keyword">if</span> (root.left &amp;&amp; !root.right) &#123;</span><br><span class="line">      <span class="comment">//如果只有左子树，就把左子树中最大的值替换过来，并把这个节点删掉</span></span><br><span class="line">      root.val = findMax(root.left);</span><br><span class="line">      root.left = removeNode(root.left, findMax(root.left));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!root.left &amp;&amp; !root.right) &#123;</span><br><span class="line">      <span class="comment">// 没有左右子树，直接删去</span></span><br><span class="line">      root = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//只有右子树或者左右子树都有的情况，找到右子树最小的值并替换删去</span></span><br><span class="line">      root.val = findMin(root.right);</span><br><span class="line">      root.right = removeNode(root.right, findMin(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; n) &#123;</span><br><span class="line">    <span class="comment">// 如果没找到且小于，找左子树</span></span><br><span class="line">    root.left = removeNode(root.left, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    root.right = removeNode(root.right, n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最后一定要返回经过修改后的root</span></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找最大最小实际上就是找最左最右的值</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">findMax</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root.right) root = root.right;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">findMin</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root.left) root = root.left;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证是否是有效-BST"><a href="#验证是否是有效-BST" class="headerlink" title="验证是否是有效 BST"></a>验证是否是有效 BST</h3><p>即验证树是否保证<code>左 &lt; 中 &lt; 右</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isValidBST = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left &amp;&amp; root.left.val &gt; root.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root.right &amp;&amp; root.right.val &lt; root.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> dfs(root.left) &amp;&amp; dfs(root.right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dfs(root);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="建立-BST"><a href="#建立-BST" class="headerlink" title="建立 BST"></a>建立 BST</h3><blockquote>
<p>把有序数组转为平衡二叉树</p>
</blockquote>
<p>思路类似二分查找,把中间的数作为根节点”提起来”,然后范围二分为<code>[low,mid)</code>和<code>(mid,high]</code>分别给左右子树</p>
<p><img src="https://pic.imgdb.cn/item/62677250239250f7c582b679.jpg"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortedArrayToBST = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> buildBST(<span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buildBST</span>(<span class="params">low, high</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(low + (high - low) / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//注意这个地方需要low+...,因为不一定是从0开始的,需要low+计算值才是真正的中间值</span></span><br><span class="line">    <span class="keyword">const</span> curr = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    curr.left = buildBST(low, mid - <span class="number">1</span>);</span><br><span class="line">    curr.right = buildBST(mid + <span class="number">1</span>, high);</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>buildBST</code>方法还可以接收一个分割好的数组:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildBST</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!arr.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 这里取arr.length / 2,这样偶数元素中间值就会划分到偏后一位,防止arr.slice(0, mid - 1)在有元素的时候仍截取到空数组</span></span><br><span class="line">  <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> TreeNode(arr[mid]);</span><br><span class="line">  node.left = buildBST(arr.slice(<span class="number">0</span>, mid));</span><br><span class="line">  node.right = buildBST(arr.slice(mid + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断平衡二叉树"><a href="#判断平衡二叉树" class="headerlink" title="判断平衡二叉树"></a>判断平衡二叉树</h2><p>平衡二叉树，即一个节点的左右子树高度差不能大于 1。</p>
<p>思路就是递归遍历每一个节点，计算每隔节点的左右子树高度差，如果有一个节点高度差大于 1，整体就失去平衡。</p>
<p>第一种方法是计算和遍历分开，计算节点高度是单独的方法，而遍历采用先序遍历的方式。<br>获取节点高度的方式是分别递归左右子树，每返回一次高度都会+1，最终会以左右子树中较高的为结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isBalanced = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  dfs(root);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> left = getNodeHeight(root.left);</span><br><span class="line">    <span class="keyword">let</span> right = getNodeHeight(root.right);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(left - right) &gt; <span class="number">1</span>) flag = <span class="literal">false</span>;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getNodeHeight</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(getNodeHeight(node.left), getNodeHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更好的解决方法是遍历的同时就计算高度，在递归函数末尾返回上一步得到的左右高度中较大一个+1</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isBalanced2 = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  dfs(root);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> left = dfs(root.left);</span><br><span class="line">    <span class="keyword">const</span> right = dfs(root.right);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(left - right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(left, right) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="转化-BST"><a href="#转化-BST" class="headerlink" title="转化 BST"></a>转化 BST</h2><blockquote>
<ol start="8">
<li>构造平衡二叉树.给你一棵二叉搜索树，请你返回一棵平衡后的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。</li>
</ol>
</blockquote>
<p>思路就是<strong>中序遍历</strong>获取数的数组形式,然后用上面的有序数组转为平衡二叉树方法即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> balanceBST = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> nums = [];</span><br><span class="line"></span><br><span class="line">  inorder(root);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inorder</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    inorder(node.left);</span><br><span class="line">    nums.push(node.val);</span><br><span class="line">    inorder(node.right);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tree = buildBST(nums);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buildBST</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> TreeNode(arr[mid]);</span><br><span class="line">    node.left = buildBST(arr.slice(<span class="number">0</span>, mid));</span><br><span class="line">    node.right = buildBST(arr.slice(mid + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tree;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="比较两棵二叉树"><a href="#比较两棵二叉树" class="headerlink" title="比较两棵二叉树"></a>比较两棵二叉树</h2><blockquote>
<p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
</blockquote>
<p>思路：递归比较两棵树的左、右子树即可。如果两棵树完全相等，则 p 和 q 应当是完全相同的，只要有一个对不上就是 false</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isSameTree = <span class="function"><span class="keyword">function</span> (<span class="params">p, q</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((q &amp;&amp; !p) || (p &amp;&amp; !q) || p.val !== q.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树轴对称"><a href="#二叉树轴对称" class="headerlink" title="二叉树轴对称"></a>二叉树轴对称</h2><blockquote>
<p>给你一个二叉树的根节点 root，检查它是否轴对称。</p>
</blockquote>
<p>这道题和翻转二叉树思路近似，从<code>root.left</code>和<code>root.right</code>分开，分别递归比较左子树的右节点和右子树的左节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">p, q</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> ((!p &amp;&amp; q) || (!q &amp;&amp; p) || p.val !== q.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><blockquote>
<p>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
</blockquote>
<p>这道题就是求节点高度，递归遍历每一个节点，每次遍历都给返回值+1，并选择左右子树中较大的一个。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = maxDepth(root.left);</span><br><span class="line">  <span class="keyword">let</span> right = maxDepth(root.right);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这道题还有一个变种，就是求一个节点的最小深度。注意最小深度仍然是到叶子节点的，不能在空节点就停下，因此需要判断左右子节点的高度，不为 0 才返回：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minDepth = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = minDepth(root.left);</span><br><span class="line">  <span class="keyword">let</span> right = minDepth(root.right);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (left === <span class="number">0</span> &amp;&amp; right &gt; <span class="number">0</span>) <span class="keyword">return</span> right + <span class="number">1</span>; <span class="comment">// 左节点为空</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; <span class="number">0</span> &amp;&amp; right === <span class="number">0</span>) <span class="keyword">return</span> left + <span class="number">1</span>; <span class="comment">// 右节点为空</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Math</span>.min(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的路径问题"><a href="#二叉树的路径问题" class="headerlink" title="二叉树的路径问题"></a>二叉树的路径问题</h2><p>这里可以参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-ii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-oo63/">https://leetcode-cn.com/problems/path-sum-ii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-oo63/</a></p>
<p>路径问题可以分为两大类</p>
<ul>
<li>自顶向下，从某一个节点(不一定是根节点)，从上向下寻找路径，到某一个节点(不一定是叶节点)结束。方法类似，在每次遍历中记录路径，当遍历到合适条件时输出结果，再在每次递归的最尾端执行复原操作（比如出栈、总和减去当前值等等）。</li>
</ul>
<blockquote>
<p>其实这是一种回溯，路径记录之后要返回上一层，因此就在函数的最尾端执行复原操作</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  path.push(node.val);</span><br><span class="line">  <span class="keyword">if</span> (临界条件) &#123;</span><br><span class="line">    res.push(path);</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(node.left);</span><br><span class="line">  dfs(node.right);</span><br><span class="line">  path.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>

<p>如果要求有路径和，一般是把目标值放在最顶端，然后自顶向下每次遍历都减去当前节点值，直到减为 0 或者其他临界条件为止。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node, sum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  path.push(node.val);</span><br><span class="line">  sum -= node.val;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">    res.push(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dfs(node.left, sum);</span><br><span class="line">  dfs(node.right, sum);</span><br><span class="line">  path.pop();</span><br><span class="line">&#125;</span><br><span class="line">dfs(root, targetNum);</span><br></pre></td></tr></table></figure>

<ul>
<li>非自顶向下：就是从任意节点到任意节点的路径，不需要自顶向下。<br>这种一般比较麻烦，除了从上到下的基本顺序，还有可能是横着的甚至倒着的路径。</li>
</ul>
<p>这类题目一般解题思路如下：<br>设计一个辅助函数 maxpath，调用自身求出以一个节点为根节点的左侧最长路径 left 和右侧最长路径 right，那么经过该节点的最长路径就是 <code>left+right</code><br>接着只需要从根节点开始 dfs,不断比较更新全局变量即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = -<span class="literal">Infinity</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxPath</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = maxPath(node.left);</span><br><span class="line">  <span class="keyword">let</span> right = maxPath(node.right);</span><br><span class="line">  res = <span class="built_in">Math</span>.max(res, node.val + left + right);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(left, right) + node.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>left,right 代表的含义要根据题目所求设置，比如最长路径、最大路径和等等</li>
<li>全局变量 res 的初值设置是 0 还是<code>-Infinity</code>要看题目节点是否存在负值，如果存在就用<code>-Infinity</code>，否则就是 0</li>
</ol>
<h3 id="路径问题-1（目标和）"><a href="#路径问题-1（目标和）" class="headerlink" title="路径问题 1（目标和）"></a>路径问题 1（目标和）</h3><blockquote>
<p>给你二叉树的根节点  root 和一个表示目标和的整数  targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和  targetSum 。如果存在，返回 true ；否则，返回 false</p>
</blockquote>
<p>路径问题最基本的一道题，好好背就完事了。<br>思路就是：把总和依次相减下来，每到一个节点就减去当前节点的值，直到叶子节点判断是否等于叶子节点的值，<br>如果等于说明一路上减去的值加起来正好就是 targetSum</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasPathSum = <span class="function"><span class="keyword">function</span> (<span class="params">root, targetSum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (!root.left &amp;&amp; !root.right) &#123;</span><br><span class="line">    <span class="keyword">return</span> targetSum === root.val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    hasPathSum(root.left, targetSum - root.val) ||</span><br><span class="line">    hasPathSum(root.right, targetSum - root.val)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="路径问题-2（具体路径）"><a href="#路径问题-2（具体路径）" class="headerlink" title="路径问题 2（具体路径）"></a>路径问题 2（具体路径）</h3><p>这道题是上一个的升级版，要求求出具体路径</p>
<p>思路在上面的解析中已经有过，就是记录路径，在递归结束时弹出当前节点，并在条件合适时记录路径。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pathSum = <span class="function"><span class="keyword">function</span> (<span class="params">root, targetSum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> path = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  dfs(root, targetSum);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node, sum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    path.push(node.val);</span><br><span class="line">    sum -= node.val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!node.left &amp;&amp; !node.right &amp;&amp; sum === <span class="number">0</span>) &#123;</span><br><span class="line">      res.push(path);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(node.left, sum);</span><br><span class="line">    dfs(node.right, sum);</span><br><span class="line">    <span class="comment">// 这个位置是当前节点的左右子树都遍历完了；</span></span><br><span class="line">    <span class="comment">// 如果是叶子节点，上面两个递归都会直接返回，然后pop出叶子节点</span></span><br><span class="line">    <span class="comment">// 如果不是叶子节点，相当于把左右子树记录完成了，这时应该返回上一层了，执行pop</span></span><br><span class="line">    <span class="comment">// 要在这里pop</span></span><br><span class="line">    path.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="路径问题-3（任意节点开始）"><a href="#路径问题-3（任意节点开始）" class="headerlink" title="路径问题 3（任意节点开始）"></a>路径问题 3（任意节点开始）</h3><blockquote>
<p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
</blockquote>
<p>这道题有两种解法，最好想的就是二重递归：</p>
<ul>
<li>第一重递归遍历所有节点</li>
<li>然后对于每个节点，执行路径问题 1 的算法</li>
</ul>
<p>方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pathSum = <span class="function"><span class="keyword">function</span> (<span class="params">root, sum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">0</span>, <span class="number">1</span>]]);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    prefix += node.val;</span><br><span class="line">    <span class="keyword">if</span> (map.has(prefix - sum)) &#123;</span><br><span class="line">      res += map.get(prefix - sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!map.has(prefix)) map.set(prefix, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> map.set(prefix, map.get(prefix) + <span class="number">1</span>);</span><br><span class="line">    dfs(node.left);</span><br><span class="line">    dfs(node.right);</span><br><span class="line">    prefix -= node.val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> prefix = <span class="number">0</span>;</span><br><span class="line">  dfs(root);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还有一种方法是使用<strong>前缀和</strong>，但是比较麻烦，没太看懂，参考<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-iii/solution/lu-jing-zong-he-iii-by-leetcode-solution-z9td/">https://leetcode-cn.com/problems/path-sum-iii/solution/lu-jing-zong-he-iii-by-leetcode-solution-z9td/</a></p>
<blockquote>
<p>前缀和还是先搞清一维数组的前缀和把</p>
</blockquote>
<h3 id="最大路径和"><a href="#最大路径和" class="headerlink" title="最大路径和"></a>最大路径和</h3><blockquote>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。<br>路径和 是路径中各节点值的总和。<br>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。<br>同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点</p>
</blockquote>
<p>这个是上面说的非自顶向下的典型例题，方法也是参考那个的，但是稍有改动：</p>
<ul>
<li>节点有负值，加上一个负值会对最大路径和起到反作用，因此如果左右路径和为负数就不选取（即取 0，和空节点的情况一样）</li>
<li><code>路径</code> 一定是先上升（ 0 ～ n 个）节点, 到达顶点, 后下降（ 0 ～ n 个）节点；因此表现出来就是<code>node.val + left + right</code></li>
</ul>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxPathSum = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = -<span class="literal">Infinity</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">maxPath</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="built_in">Math</span>.max(maxPath(node.left), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> right = <span class="built_in">Math</span>.max(maxPath(node.right), <span class="number">0</span>);</span><br><span class="line">    res = <span class="built_in">Math</span>.max(res, node.val + left + right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(left, right) + node.val;</span><br><span class="line">  &#125;</span><br><span class="line">  maxPath(root);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>这些算法没什么好说的，记就完事了。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bubbleSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j + <span class="number">1</span>] &lt; nums[j]) swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>冒泡排序的最优解,即时间复杂度 O(n)；<br>对应完全有序的情况，这时只需要遍历一次</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> betterBubbleSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j + <span class="number">1</span>] &lt; nums[j]) swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 如果发生一次交换就破功了</span></span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果一次都没有交换,说明数组有序,直接返回,这时只遍历了一次</span></span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span> nums;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>冒泡排序的复杂度：</p>
<ul>
<li>最好时间复杂度：它对应的是数组本身有序这种情况。在这种情况下，我们只需要作比较（n-1 次），而不需要做交换。时间复杂度为 O(n)</li>
<li>最坏时间复杂度： 它对应的是数组完全逆序这种情况。在这种情况下，每一轮内层循环都要执行，重复的总次数是 n(n-1)/2 次，因此时间复杂度是 O(n^2)</li>
<li>平均时间复杂度： O(n^2)</li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>循环遍历数组，每次都找出当前范围内的最小值，把它放在当前范围的头部；然后缩小排序范围，继续重复以上操作，直至数组完全有序为止。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selectionSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; arr.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">        minIndex = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, minIndex, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>选择排序的复杂度都是 O(n^2)</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序所有的操作都基于一个这样的前提：当前元素前面的序列是有序的。基于这个前提，从后往前去寻找当前元素在前面那个序列里的正确位置；</p>
<p>即把当前选中的元素和前面的依次比较，如果小于前面的元素，就把前面的元素往后移一位，直到大于前面元素为止。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insertionSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = i;</span><br><span class="line">    tmp = nums[i];</span><br><span class="line">    <span class="keyword">while</span> (tmp &lt; nums[j - <span class="number">1</span>] &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>最好时间复杂度：它对应的数组本身就有序这种情况。此时内层循环只走一次，整体复杂度取决于外层循环，时间复杂度就是一层循环对应的 O(n)。</li>
<li>最坏时间复杂度：它对应的是数组完全逆序这种情况。此时内层循环每次都要移动有序序列里的所有元素，因此时间复杂度对应的就是两层循环的 O(n^2)</li>
<li>平均时间复杂度：O(n^2)</li>
</ul>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>将数组拆分成两个部分，然后分别单独排序，最后合并。因此拆分过程实际上是类似二叉树的递归遍历，递归边界是数组只有一个元素的时候，直接返回该元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并两个有序数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeArr</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> newArr = [];</span><br><span class="line">  <span class="keyword">while</span> (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) &#123;</span><br><span class="line">    arr1[i] &lt; arr2[j] ? newArr.push(arr1[i++]) : newArr.push(arr2[j++]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [...newArr, i === arr1.length - <span class="number">1</span> ? arr2.slice(j) : arr1.slice(i)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mergeSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">  <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(nums.length / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> left = mergeSort(nums.slice(<span class="number">0</span>, mid));</span><br><span class="line">  <span class="keyword">const</span> right = mergeSort(nums.slice(mid));</span><br><span class="line">  <span class="keyword">return</span> mergeArr(left, right);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>归并排序的时间复杂度是 <code>O(nlog(n))</code></p>
<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>快速排序会将原始的数组筛选成较小和较大的两个子数组，然后递归地排序两个子数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> quickSort = <span class="function">(<span class="params">nums, left = <span class="number">0</span>, right = nums.length - <span class="number">1</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">  <span class="keyword">let</span> divider = <span class="built_in">Math</span>.floor(left + (right - left) / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">let</span> i = left;</span><br><span class="line">  <span class="keyword">let</span> j = right;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (nums[i] &lt; nums[divider]) i++;</span><br><span class="line">    <span class="keyword">while</span> (nums[j] &gt; nums[divider]) j--;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">      swap(nums, i, j);</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (left &lt; i - <span class="number">1</span>) quickSort(nums, left, i - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (i &lt; right) quickSort(nums, i, right);</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote>
<p>动态规划（dynamic programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。<br>用动态规划解决问题时，要遵循三个重要步骤：</p>
<ol>
<li>定义子问题；</li>
<li>实现要反复执行来解决子问题的部分；</li>
<li>识别并求解出基线条件。</li>
</ol>
</blockquote>
<p>动态规划的题目有几个关键的特征：</p>
<ol>
<li>要求你给出达成某个目的的解法个数</li>
<li>不要求你给出每一种解法对应的具体路径</li>
<li>题目要求中有“最值”，即最优解；</li>
<li>一个解的得出依赖于前一个解，依次依赖迭代</li>
</ol>
<p>这样的问题，往往可以用动态规划进行求解</p>
<p>动态规划的题目可能很难理解，如果有实在理解不了的可以先记下来</p>
<h2 id="爬楼梯问题"><a href="#爬楼梯问题" class="headerlink" title="爬楼梯问题"></a>爬楼梯问题</h2><blockquote>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
</blockquote>
<p>倒着思考问题,如果要到达 n 阶的方法为<code>f(n)</code>种,从第 n 阶退一层的方法就是<code>f(n-1)</code>或<code>f(n-2)</code>种,即<code>f(n) = f(n-1) + f(n-2)</code> ,然后依次类推,直到<code>f(1)</code>和<code>f(2)</code>返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> climbStairs = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 树形思考问题,这里相当于两个子节点</span></span><br><span class="line">  <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面这个解法会有很多重复的,比如<code>f(n-2)</code>的下一层会包含<code>f(n-3)</code>,这个值可能被多次计算<br>可以考虑 Map 缓存计算过的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> climbStairsCached = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">return</span> climbStairs(n);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">climbStairs</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.has(n)) <span class="keyword">return</span> map.get(n);</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> res = climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">    map.set(n, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上这种在递归的过程中，不断保存已经计算出的结果，从而避免重复计算的手法，叫做记忆化搜索。</p>
<p>真正的动态规划，是一个自底向上的过程。它要求我们站在已知的角度，通过定位已知和未知之间的关系，一步一步向前推导，进而求解出未知的值。</p>
<p>由上面的关系，可以推出状态转移方程为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n-1) + f(n-2)</span><br><span class="line">且</span><br><span class="line">f(1) = 1</span><br><span class="line">f(2) = 2</span><br></pre></td></tr></table></figure>

<p>把这个方程放到循环中，就可以解出来了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> climbStairsDynamic = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> f = [];</span><br><span class="line">  f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  f[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt; n; i++) &#123;</span><br><span class="line">    f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此动态规划的关键就是推出状态转移方程，只要方程能得出，丢到迭代里边就可以计算了。</p>
<h2 id="最少硬币找零"><a href="#最少硬币找零" class="headerlink" title="最少硬币找零"></a>最少硬币找零</h2><blockquote>
<p>给定不同面额的硬币 coins 和一个总金额 amount。<br>编写一个函数来计算可以凑成总金额所需的 最少 的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
</blockquote>
<p>站在已经凑成的角度上思考问题，如果从已经凑成的结果中取走一个硬币，就会有以下的情况：<br><img src="https://pic.imgdb.cn/item/626789ea239250f7c5c0b9d6.jpg"></p>
<p>借此可以推出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n表示amount，f(n)表示凑成n金额所需的最少硬币数量</span><br><span class="line"></span><br><span class="line">f(n) = Math.min(f(n-c1)+1,f(n-c2)+1,f(n-c3)+1......f(n-cn)+1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>放入循环：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getCoinsDynamic = <span class="function">(<span class="params">coins, amount</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> f = [];</span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; amount; i++) &#123;</span><br><span class="line">    f[i] = <span class="literal">Infinity</span>;</span><br><span class="line">    <span class="comment">// 这个循环相当于是 f[n] = Math.min(f(n-coin1),f(n-coin2),...,f(n-coinn))</span></span><br><span class="line">    <span class="comment">// 由于coin数量不确定,因此两两比较每个f(n)和f(n-coin)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> coin <span class="keyword">of</span> coins) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= coin) f[i] = <span class="built_in">Math</span>.min(f[i], f[i - coin] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (f[amount] === <span class="literal">Infinity</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> f[amount];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最大子序列和"><a href="#最大子序列和" class="headerlink" title="最大子序列和"></a>最大子序列和</h2><blockquote>
<p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
</blockquote>
<p>用 <code>f(i)</code>代表以第 i 个数结尾的「连续子数组的最大和」,可得方程为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(i)=max&#123;f(i−1)+nums[i],nums[i]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也就是以第 i 个数结尾的最大和，有可能是加上第 i 个数的结果，也有可能是只有第 i 个数的结果。因为<code>f(i)</code>代表以第 i 个数结尾的,因此必须要包含当前数(即<code>nums[i]</code>)；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxChildArr = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> f = [];</span><br><span class="line">  f[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    f[i] = <span class="built_in">Math</span>.max(f[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(...f);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><blockquote>
<p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
</blockquote>
<p>假设最长序列长度为<code>f(i)</code>,这道题不适合倒推得出方程,而是通过正向思考<br>对于每一个数字,如果前面还有比它小的一个数字或一组数字,就可以组合成一个序列;<br>那么可以执行两次遍历,遍历每个数字,每次迭代都遍历<strong>这个数字前面的所有数字</strong>,如果有比它小的就加入序列长度，直到找到该项之前的、比该项小的数字个数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lengthOfLIS = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> f = [];</span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    f[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">        <span class="comment">//注意这里不是要f[i] 与 f[j] + 1进行比较，而是取f[j] + 1的最大值。</span></span><br><span class="line">        f[i] = <span class="built_in">Math</span>.max(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(...f);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>核心代码写成这样也可以：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">  f[i] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">      <span class="comment">// 取f[j] + 1的最大值。</span></span><br><span class="line">      tmp = tmp + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  f[i] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长连续递增子序列"><a href="#最长连续递增子序列" class="headerlink" title="最长连续递增子序列"></a>最长连续递增子序列</h2><blockquote>
<p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p>
</blockquote>
<p>这道题和上面的最大区别在于“连续”，即序列是连续的。<br>因此同样设<code>dp[i]</code>表示以 i 结尾的最长连续递增序列的长度，但是<code>dp[i]</code>此时只能由<code>dp[i - 1]</code>推出，即<code>dp[i] = dp[i - 1] + 1</code>。</p>
<p>遍历整个数组，如果当前数<code>nums[i]</code>比前面的数大，就更新<code>dp[i]</code>，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findLengthOfLCIS = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = [];</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">    dp[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    res = res &gt; dp[i] ? res : dp[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最长公共子数组"><a href="#最长公共子数组" class="headerlink" title="最长公共子数组"></a>最长公共子数组</h2><blockquote>
<p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。<br>示例：<br>输入： A: [1,2,3,2,1] B: [3,2,1,4,7] 输出：3 解释： 长度最长的公共子数组是 [3, 2, 1] 。</p>
</blockquote>
<p>类似这种的公共问题，一定是取二维数组<code>dp[i][j]</code>，并且两个维度分别对应一个数组。<br>这里<code>dp[i][j]</code>表示：以下标<code>i - 1</code>为结尾的 A，和以下标<code>j - 1</code>为结尾的 B，最长重复子数组长度为<code>dp[i][j]</code>。<br>当<code>A[i - 1] === B[j - 1]</code>相等的时候，<code>dp[i][j] = dp[i - 1][j - 1] + 1</code></p>
<blockquote>
<p>这里取<code>i-1</code>和<code>j-1</code>主要是为了方便计算，直接取 i、j 也可以，但是要提前初始化<code>dp[i][0]</code>和 dp<code>[0][j]</code></p>
</blockquote>
<p>dp 数组的结构如下，状态的更新是斜向的，即 dp[i][j]总是由左上方的 dp[i - 1][j - 1]更新而来</p>
<p><img src="https://img-blog.csdnimg.cn/2021011215282060.jpg"></p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> findLength = <span class="function">(<span class="params">A, B</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// A、B数组的长度</span></span><br><span class="line">  <span class="keyword">const</span> [m, n] = [A.length, B.length];</span><br><span class="line">  <span class="comment">// dp数组初始化，都初始化为0</span></span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m + <span class="number">1</span>).fill(<span class="number">0</span>).map(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>));</span><br><span class="line">  <span class="comment">// 初始化最大长度为0</span></span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="comment">// 遇到A[i - 1] === B[j - 1]，则更新dp数组</span></span><br><span class="line">      <span class="keyword">if</span> (A[i - <span class="number">1</span>] === B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新res</span></span><br><span class="line">      res = dp[i][j] &gt; res ? dp[i][j] : res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历完成，返回res</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="不同路径问题"><a href="#不同路径问题" class="headerlink" title="不同路径问题"></a>不同路径问题</h2><blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？<br><img src="https://img-blog.csdnimg.cn/20210110174033215.png"></p>
</blockquote>
<p>机器人移动经过的是二维数组，因此对于每一个节点来说，必然会有水平和竖直两种方向上的两组路径，即只需要记录左边和上边来的路径数（因为是从左向右遍历，因此不需要统计右和下）<br><img src="https://pic.imgdb.cn/item/6273a6e40947543129d857e0.jpg"></p>
<p>因此设<code>dp[i][j]</code>为经过点<code>(i,j)</code>的路径最大值，并且该值一定是由其水平和竖直推出的，即<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code></p>
<p><img src="https://img-blog.csdnimg.cn/20201209113631392.png"></p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePaths = <span class="function"><span class="keyword">function</span> (<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(n), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(m));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; m - <span class="number">1</span>; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h2><blockquote>
<p>有 n 件物品，物品体积用一个名为 w 的数组存起来，物品的价值用一个名为 value 的数组存起来；<br>每件物品的体积用 w[i] 来表示，每件物品的价值用 value[i] 来表示。现在有一个容量为 c 的背包<br>问你如何选取物品放入背包，才能使得背包内的物品总价值最大？</p>
</blockquote>
<p>设<code>dp[i][j]</code> 表示从下标为<code>[0-i]</code>的物品里任意取，放进容量为 j 的背包，价值总和最大是多少。(记住 i 和 j 的含义)</p>
<p>我们假设每个物品重量和价值关系如下:</p>
<table>
<thead>
<tr>
<th></th>
<th>weight</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>物品 0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>物品 1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>物品 2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody></table>
<p>那么得到的 dp 数组就是这样的：<br><img src="https://img-blog.csdnimg.cn/20210110103003361.png"></p>
<p>然后需要确定递推公式。我们可以这样理解，对于每一个即将要放入背包的物品 i ，可能有两种情况：</p>
<ol>
<li>当前背包容量不够（没有空余或者空余小于当前物品重量），放不下（背包不是一开始就是最大的，而是从 0 开始一个一个遍历上来的）</li>
<li>当前背包容量够，并且空余大于等于当前物品重量</li>
</ol>
<p>这两种情况恰恰是对应两个公式：</p>
<ol>
<li>不够放下该物品 i，所以直接无视掉，依旧取之前的值。这个“之前的值”，就是<strong>背包容量不变，并且不放物品 i</strong>的值，体现为<code>dp[i - 1][j]</code>。<code>dp[i-1]</code>表示的含义是，当前物品没有放入，那么就还是上一个或上面几个物品放入的情况。</li>
<li>能放下物品 i，这时候就选择放入物品 i，并且加上物品 i 的价值。但是注意这里并不是直接在<code>dp[i - 1][j]</code>的基础上加，而是取<code>dp[i - 1][j - weight[i]]</code>；原因是这样：</li>
</ol>
<p>比如计算<code>dp[1][3]</code>，如下图<br><img src="https://img-blog.csdnimg.cn/20210110103244701.png"></p>
<p>这时<code>dp[i - 1][j] = dp[0][3]</code>，即不放入物品 1，那么背包中仍旧只有一个物品 0，价值为 15<br>如果放入物品 1，我们就需要知道一个特殊的情况，即<strong>空余空间足够，但并未放入</strong>的情况。即<code>dp[i - 1][j - weight[i]] = dp[0][0]</code>：这时什么都没有放入，背包空余大小为 3，足够放入重量为 3 的物品 1。最后加上物品 1 的价值 20，得到最终值</p>
<p>如果不找到有足够空间的情况，那么本次的<code>j</code>之前可能会有其他情况，比如一个比物品 i 重量小的已经放入，但是没有填满，并且去掉这个小物品是可以放入该物品 i 的。应当避免的就是这种情况。</p>
<p>结合上面两种情况，其实就是在比较“选不选物品 i”；选和不选之间取出一个最大值，成为当前的结果。</p>
<p>状态转移方程为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure>

<p>核心遍历代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; weight.length; i++) &#123;</span><br><span class="line">  <span class="comment">// 遍历物品</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= size; j++) &#123;</span><br><span class="line">    <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">if</span> (j &lt; weight[i])</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j]; <span class="comment">// 如果当前容量都小于物品i的重量，那肯定不用放入</span></span><br><span class="line">    <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testweightbagproblem</span>(<span class="params">wight, value, size</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = wight.length;</span><br><span class="line">  <span class="keyword">const</span> dp = array.from(<span class="keyword">new</span> <span class="built_in">Array</span>(len + <span class="number">1</span>), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(size).fill(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= size; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j &lt; weight[i])</span><br><span class="line">        <span class="comment">// 如果当前容量都小于物品i的重量，那肯定不用放入</span></span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">      <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dp[len][size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="回溯问题的基本思路"><a href="#回溯问题的基本思路" class="headerlink" title="回溯问题的基本思路"></a>回溯问题的基本思路</h2><p>参考<br><a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB%E5%A4%A7%E7%BA%B2%E5%A6%82%E4%B8%8B">https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB%E5%A4%A7%E7%BA%B2%E5%A6%82%E4%B8%8B</a></p>
<p>上面的回溯说到回溯问题的基本模板是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xxx</span>(<span class="params">入参</span>) </span>&#123;</span><br><span class="line">  前期的变量定义、缓存等准备工作</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义路径栈</span></span><br><span class="line">  <span class="keyword">const</span> path = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进入 dfs</span></span><br><span class="line">  dfs(起点)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义 dfs</span></span><br><span class="line">  <span class="function"><span class="title">dfs</span>(<span class="params">递归参数</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(到达了递归边界) &#123;</span><br><span class="line">      结合题意处理边界逻辑，往往和 path 内容有关</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里也可能不是 for，视题意决定</span></span><br><span class="line">    <span class="keyword">for</span>(遍历坑位的可选值) &#123;</span><br><span class="line">      path.push(当前选中值)</span><br><span class="line">      处理坑位本身的相关逻辑,一般就是递归</span><br><span class="line">      path.pop()<span class="comment">// 这里让已经选中的值退出，相当于树回退一层</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上这并不是一种生硬的模板，而是对应了回溯问题的基本形状：<strong>迭代表示同一层的横向展开，递归表示纵向的遍历</strong></p>
<p>根据前面 dfs 的经验，我们把递归只看成是一个简单的访问语句：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">dfs</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  递归边界</span><br><span class="line">  <span class="keyword">for</span>(i)&#123;</span><br><span class="line">    path.push(当前选中值)</span><br><span class="line">    访问第(i+<span class="number">1</span>)个</span><br><span class="line">    path.pop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，迭代的部分实际上就是将所有情况横向展开，也就是<strong>树的分叉</strong>；迭代几次也就对应根节点展开了几个枝；这也是通过限制迭代次数从而避免重复的原因。</p>
<blockquote>
<p><img src="https://pic.imgdb.cn/item/626a9a55239250f7c5e9286e.jpg"><br>迭代实际上就是这部分</p>
</blockquote>
<p>而递归则是<strong>纵向</strong>的延伸；和二叉树问题类似，递归的每一项可以看作是一个子节点的产生，而递归语句旁边的<code>path.push</code>和<code>path.pop</code>操作也正是对应了递归路径的记录和回溯。回溯的关键并不是循环，而是结尾的<code>pop()</code>，也就是状态的恢复；</p>
<p>理解了这两个地方，就可以理解各种其他问题中<strong>去重</strong>的方式和原因。</p>
<ol>
<li>所选序列是否重复按照出现次数区分，比如<code>[1,2,1]</code>和<code>[1,1,2]</code>没有区别；<br>这种通常限制迭代的<strong>起始位置</strong>。上面说到迭代就是树枝的展开，那如果让迭代每次从上一层位置的下一个元素展开，就可以避免重复一遍上一层的操作。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">val, begin</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//递归边界</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = begin; i &lt; xxx.length; i++) &#123;</span><br><span class="line">    path.push();</span><br><span class="line">    dfs(val, i); <span class="comment">// i作为下一个的begin</span></span><br><span class="line">    path.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>纵向不能重复；限制同一结果中元素出现个数，比如全排列问题，不允许出现<code>[1,1,2]</code>这样有重复数字的元素。<br>这种是限制每次迭代的元素；因为回溯问题的解通常就是若干个 dfs 的<strong>路径</strong>；通过记录某个元素被使用过，就可以避免反复迭代同一个元素：<br>每次迭代到一个元素时，如果该元素已经被记录访问过，就会跳到下一个元素。注意这种方法是去重<strong>垂直</strong>方向的，即 visited 数组横向独立、纵向统一</li>
</ol>
<blockquote>
<p>visited 通常存的是对应的索引，表示同一索引（位置）的元素不能被重复使用。如果想要同一个值的元素不能重复使用，就应该用方法 3</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//递归边界</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; xxx.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">      path.push();</span><br><span class="line">      visited[i] = <span class="literal">true</span>;</span><br><span class="line">      dfs(val); <span class="comment">// i作为下一个的begin</span></span><br><span class="line">      path.pop();</span><br><span class="line">      visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>横向不能重复，限制所有结果中相同值的重复，即不能有<code>[[1,2,2],[1,2,2]]</code>这样两个相同的元素，但是元素内部仍然可以重复。</li>
</ol>
<p>判断方法条件为：<code>nums[i] === nums[i - 1]</code>和<code>i &gt; 0</code>，以及<code>visited[nums[i - 1]] === false</code>，满足这三个条件时就应当跳过。</p>
<ul>
<li><code>nums[i] === nums[i - 1]</code>：当前值和前一个不能相同，即横向规定不能有重复值</li>
<li><code>visited[nums[i - 1]] === false</code>：这个很重要，是判断上一个条件是横向重复还是纵向重复；因为上一个条件既有可能是横向重复，也可以是纵向的重复；因此当这个条件为 true 时，即上一个值已经被访问过了，说明是纵向重复；反之则是横向重复。<strong>该条件===true 判断纵向重复，==false 判断横向重复</strong></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/626ab4ee239250f7c5375bd0.jpg"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">//！！！一定要先排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//递归边界</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; xxx.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!visited[nums[i - <span class="number">1</span>]] &amp;&amp; nums[i] === nums[i - <span class="number">1</span>] &amp;&amp; i &gt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (!visited) path.push();</span><br><span class="line">    visited[nums[i]] = <span class="literal">true</span>;</span><br><span class="line">    dfs(val); <span class="comment">// i作为下一个的begin</span></span><br><span class="line">    path.pop();</span><br><span class="line">    visited[nums[i]] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者综合第一种 begin 的方式；当<code>i &gt; begin</code>时，相当于当前遍历的位置是其他同层元素，和<code>visited[nums[i - 1]] === false</code>效果相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; begin &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>

<h2 id="具体题目"><a href="#具体题目" class="headerlink" title="具体题目"></a>具体题目</h2><p>具体题目参考<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problem-list/QS1BC1f6/%EF%BC%8C%E5%9F%BA%E6%9C%AC%E9%83%BD%E5%81%9A%E4%BA%86%EF%BC%8C%E5%B0%91%E6%95%B0%E6%B2%A1%E6%9C%89%E7%9A%84%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83">https://leetcode-cn.com/problem-list/QS1BC1f6/，基本都做了，少数没有的也可以参考</a><a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录</a></p>
<h3 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h3><blockquote>
<ol>
<li>给定一个没有重复数字的序列，返回其所有可能的全排列。<br>示例：<br>输入: [1,2,3]<br>输出: [<br>[1,2,3],<br>[1,3,2],<br>[2,1,3],<br>[2,3,1],<br>[3,1,2],<br>[3,2,1]<br>]</li>
</ol>
</blockquote>
<p>像全排列这样的穷举，或者有一定限制的穷举，都可以用 DFS、递归回溯的思想。</p>
<p>这类问题的特点都是，穷举之中有不变化的部分；比如全排列问题不变的是三个数字的位置。三个位置可能是 1/2/3 任意一个数字，这样就可以构建出一个树：<br><img src="https://pic.imgdb.cn/item/6266c1cc239250f7c554635b.jpg"></p>
<p>然后按照树的先序遍历方式，就可以得到结果。当然并不需要构造一棵树。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> permute = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存数组的长度</span></span><br><span class="line">  <span class="keyword">const</span> len = nums.length;</span><br><span class="line">  <span class="comment">// curr 变量用来记录当前的排列内容</span></span><br><span class="line">  <span class="keyword">const</span> curr = [];</span><br><span class="line">  <span class="comment">// res 用来记录所有的排列顺序</span></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="comment">// visited 用来避免重复使用同一个数字</span></span><br><span class="line">  <span class="keyword">const</span> visited = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 定义 dfs 函数，入参是坑位的索引（从 0 计数）</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">nth</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 若遍历到了不存在的坑位（第 len+1 个），则触碰递归边界返回</span></span><br><span class="line">    <span class="keyword">if</span> (nth === len) &#123;</span><br><span class="line">      <span class="comment">// 此时前 len 个坑位已经填满，将对应的排列记录下来</span></span><br><span class="line">      res.push(curr.slice());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查手里剩下的数字有哪些</span></span><br><span class="line">    <span class="comment">// 循环套递归是常见的形式,循环的作用就是让DFS过程能&quot;返回&quot;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="comment">// 若 nums[i] 之前没被其它坑位用过，则可以理解为“这个数字剩下了”</span></span><br><span class="line">      <span class="keyword">if</span> (!visited[nums[i]]) &#123;</span><br><span class="line">        <span class="comment">// 给 nums[i] 打个“已用过”的标</span></span><br><span class="line">        visited[nums[i]] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 将nums[i]推入当前排列</span></span><br><span class="line">        curr.push(nums[i]);</span><br><span class="line">        <span class="comment">// 基于这个排列继续往下一个坑走去</span></span><br><span class="line">        dfs(nth + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// nums[i]让出当前坑位</span></span><br><span class="line">        curr.pop();</span><br><span class="line">        <span class="comment">// 下掉“已用过”标识</span></span><br><span class="line">        visited[nums[i]] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从索引为 0 的坑位（也就是第一个坑位）开始 dfs</span></span><br><span class="line">  dfs(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码很奇怪的地方是有一个“循环套递归”，并且递归的前后恰好是入栈、出栈结果的时候。</p>
<p>其实这正是这类题的“模板解法”。在递归产生的不同函数上下文中，每个的遍历次数不同。<br>以这道题为例，当 dfs 执行到第三个时，前两个的上下文的遍历次数分别是 1、2；这时当第三个返回时，上一个的循环还会执行一次，就相当于从树的底部“退回”了一个位置，并把 3 这个数字让了出来。</p>
<p>因此这类穷举相关的题目有一个通用模板，遇到这种问题可以先试着套一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xxx</span>(<span class="params">入参</span>) </span>&#123;</span><br><span class="line">  前期的变量定义、缓存等准备工作</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义路径栈</span></span><br><span class="line">  <span class="keyword">const</span> path = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进入 dfs</span></span><br><span class="line">  dfs(起点)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义 dfs</span></span><br><span class="line">  <span class="function"><span class="title">dfs</span>(<span class="params">递归参数</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(到达了递归边界) &#123;</span><br><span class="line">      结合题意处理边界逻辑，往往和 path 内容有关</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里也可能不是 for，视题意决定</span></span><br><span class="line">    <span class="keyword">for</span>(遍历坑位的可选值) &#123;</span><br><span class="line">      path.push(当前选中值)</span><br><span class="line">      处理坑位本身的相关逻辑,一般就是递归</span><br><span class="line">      path.pop()<span class="comment">// 这里让已经选中的值退出，相当于树回退一层</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h3><blockquote>
<ol start="2">
<li>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的不重复子集</li>
</ol>
</blockquote>
<p>首先先按照树形思维构建；这道题中不变的部分是是否选中某个数字。</p>
<p>比如选中 1、不选 2、选中 3，那么结果就是[1,3]，依次类推就是所有选择。树的两个叶子分别代表选或不选该层对应的数字，每一层恰好就是这个数字。</p>
<p><img src="https://pic.imgdb.cn/item/6266c73d239250f7c5647e11.jpg"></p>
<p>按照上面的模板，可以尝试构建如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> subsets = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ans = [];</span><br><span class="line">  <span class="keyword">const</span> curr = [];</span><br><span class="line"></span><br><span class="line">  dfs(<span class="number">0</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 每次进入，都意味着组合内容更新了一次，故直接推入结果数组</span></span><br><span class="line">    ans.push(curr.slice());</span><br><span class="line">    <span class="comment">// 从当前数字的索引开始，遍历 nums</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 这是当前数字存在于组合中的情况</span></span><br><span class="line">      curr.push(nums[i]);</span><br><span class="line">      <span class="comment">// 基于当前数字存在于组合中的情况，进一步 dfs</span></span><br><span class="line">      dfs(i + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 这是当前数字不存在与组合中的情况</span></span><br><span class="line">      curr.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意这道题虽然有显式的递归边界（遍历三层），但是其实并不需要，因为循环直接从当前的 index（即树的层数）开始，跳过了前面的情况。</p>
<p>如果我们再给这个解法显式加上一个递归条件，比如规定<code>curr.length &lt; k</code>，这就是一种“回溯”，即到达某种情况后就提前返回，并不是每次都遍历完。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> combine = <span class="function"><span class="keyword">function</span> (<span class="params">n, k</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化结果数组</span></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="comment">// 初始化组合数组</span></span><br><span class="line">  <span class="keyword">const</span> subset = [];</span><br><span class="line">  <span class="comment">// 进入 dfs，起始数字是1</span></span><br><span class="line">  dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义 dfs 函数，入参是当前遍历到的数字</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (subset.length === k) &#123;</span><br><span class="line">      res.push(subset.slice());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从当前数字的值开始，遍历 index-n 之间的所有数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="comment">// 这是当前数字存在于组合中的情况</span></span><br><span class="line">      subset.push(i);</span><br><span class="line">      <span class="comment">// 基于当前数字存在于组合中的情况，进一步 dfs</span></span><br><span class="line">      dfs(i + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 这是当前数字不存在与组合中的情况</span></span><br><span class="line">      subset.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回结果数组</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/">日常学习</a></div><div class="post_share"><div class="social-share" data-image="/img/codes1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/04/05/do-exercise-3/"><img class="next-cover" src="/img/codes1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">js编程题总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/11/06/blog11-myReact/" title="react知识点汇总和使用小总结(一)"><img class="cover" src="/img/react.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-06</div><div class="title">react知识点汇总和使用小总结(一)</div></div></a></div><div><a href="/2021/10/27/blog10-react-router/" title="react-router的使用"><img class="cover" src="/img/reactrouter.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-27</div><div class="title">react-router的使用</div></div></a></div><div><a href="/2021/11/20/blog14-react-ts-basic/" title="typescript+react基础部分"><img class="cover" src="/img/typescript.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-20</div><div class="title">typescript+react基础部分</div></div></a></div><div><a href="/2021/11/22/blog17-react-pubsub-issues/" title="react+typescript使用pubsub时的一点小问题"><img class="cover" src="/img/pubsub.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-22</div><div class="title">react+typescript使用pubsub时的一点小问题</div></div></a></div><div><a href="/2021/11/20/blog16-react-ts-hooks-redux/" title="typescript+react:自定义hooks代替redux"><img class="cover" src="/img/typescript.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-20</div><div class="title">typescript+react:自定义hooks代替redux</div></div></a></div><div><a href="/2021/11/25/blog18-vue3ts-basic/" title="vue3+ts配置及简单使用注意"><img class="cover" src="/img/vue3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-25</div><div class="title">vue3+ts配置及简单使用注意</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/pinkstar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xing Ye</div><div class="author-info__description">a singleThreaded boy's blog</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/penghei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/penghei" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:632885485@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">A SingleThreaded Boy...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E6%B3%95%E8%BD%AC%E5%87%8F%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">加法转减法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">双指针法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%95%B0%E6%B1%82%E5%92%8C"><span class="toc-number">1.3.</span> <span class="toc-text">三数求和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.1.</span> <span class="toc-text">回文字符串</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8"><span class="toc-number">3.1.</span> <span class="toc-text">合并链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dummy-%E8%8A%82%E7%82%B9"><span class="toc-number">3.2.</span> <span class="toc-text">dummy 节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="toc-number">3.3.</span> <span class="toc-text">快慢指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%8C%87%E9%92%88"><span class="toc-number">3.4.</span> <span class="toc-text">多指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">4.</span> <span class="toc-text">栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.</span> <span class="toc-text">括号匹配问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F-%E6%9C%80%E5%A4%A7%E6%A0%88"><span class="toc-number">4.2.</span> <span class="toc-text">最小&#x2F;最大栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%92%8C%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">4.3.</span> <span class="toc-text">滑动窗口和双端队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">4.4.</span> <span class="toc-text">栈实现队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%80%92%E5%BD%92%E6%80%9D%E8%B7%AF"><span class="toc-number">5.1.</span> <span class="toc-text">二叉树问题的基本递归思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.</span> <span class="toc-text">二叉树的迭代遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.1.</span> <span class="toc-text">先序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.2.</span> <span class="toc-text">后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.3.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.4.</span> <span class="toc-text">层序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.3.</span> <span class="toc-text">翻转二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BST%EF%BC%88%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">BST（二叉搜索树）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BST-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">5.4.1.</span> <span class="toc-text">BST 基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E6%98%AF%E5%90%A6%E6%98%AF%E6%9C%89%E6%95%88-BST"><span class="toc-number">5.4.2.</span> <span class="toc-text">验证是否是有效 BST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B-BST"><span class="toc-number">5.4.3.</span> <span class="toc-text">建立 BST</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.5.</span> <span class="toc-text">判断平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E5%8C%96-BST"><span class="toc-number">5.6.</span> <span class="toc-text">转化 BST</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.7.</span> <span class="toc-text">比较两棵二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%B4%E5%AF%B9%E7%A7%B0"><span class="toc-number">5.8.</span> <span class="toc-text">二叉树轴对称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-number">5.9.</span> <span class="toc-text">二叉树的深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.10.</span> <span class="toc-text">二叉树的路径问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98-1%EF%BC%88%E7%9B%AE%E6%A0%87%E5%92%8C%EF%BC%89"><span class="toc-number">5.10.1.</span> <span class="toc-text">路径问题 1（目标和）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98-2%EF%BC%88%E5%85%B7%E4%BD%93%E8%B7%AF%E5%BE%84%EF%BC%89"><span class="toc-number">5.10.2.</span> <span class="toc-text">路径问题 2（具体路径）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98-3%EF%BC%88%E4%BB%BB%E6%84%8F%E8%8A%82%E7%82%B9%E5%BC%80%E5%A7%8B%EF%BC%89"><span class="toc-number">5.10.3.</span> <span class="toc-text">路径问题 3（任意节点开始）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">5.10.4.</span> <span class="toc-text">最大路径和</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">6.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">6.2.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">6.3.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">6.4.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E6%8E%92"><span class="toc-number">6.5.</span> <span class="toc-text">快排</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">7.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98"><span class="toc-number">7.1.</span> <span class="toc-text">爬楼梯问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%91%E7%A1%AC%E5%B8%81%E6%89%BE%E9%9B%B6"><span class="toc-number">7.2.</span> <span class="toc-text">最少硬币找零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C"><span class="toc-number">7.3.</span> <span class="toc-text">最大子序列和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">7.4.</span> <span class="toc-text">最长上升子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">7.5.</span> <span class="toc-text">最长连续递增子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">7.6.</span> <span class="toc-text">最长公共子数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-number">7.7.</span> <span class="toc-text">不同路径问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-1-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">7.8.</span> <span class="toc-text">0-1 背包问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-number">8.</span> <span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-number">8.1.</span> <span class="toc-text">回溯问题的基本思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E9%A2%98%E7%9B%AE"><span class="toc-number">8.2.</span> <span class="toc-text">具体题目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-number">8.2.1.</span> <span class="toc-text">全排列问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98"><span class="toc-number">8.2.2.</span> <span class="toc-text">子集问题</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/05/blog43-algorithms/" title="算法学习总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法学习总结"/></a><div class="content"><a class="title" href="/2022/04/05/blog43-algorithms/" title="算法学习总结">算法学习总结</a><time datetime="2022-04-05T08:01:22.000Z" title="发表于 2022-04-05 16:01:22">2022-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/05/do-exercise-3/" title="js编程题总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="js编程题总结"/></a><div class="content"><a class="title" href="/2022/04/05/do-exercise-3/" title="js编程题总结">js编程题总结</a><time datetime="2022-04-05T03:08:25.000Z" title="发表于 2022-04-05 11:08:25">2022-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/29/blog42-react-review/" title="react复习"><img src="/img/react.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="react复习"/></a><div class="content"><a class="title" href="/2022/03/29/blog42-react-review/" title="react复习">react复习</a><time datetime="2022-03-29T11:20:32.000Z" title="发表于 2022-03-29 19:20:32">2022-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/06/blog41-tsdeeping/" title="typescript深入学习"><img src="/img/typescript.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="typescript深入学习"/></a><div class="content"><a class="title" href="/2022/02/06/blog41-tsdeeping/" title="typescript深入学习">typescript深入学习</a><time datetime="2022-02-06T05:44:25.000Z" title="发表于 2022-02-06 13:44:25">2022-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/06/do-exercise-1/" title="HTML+CSS+JS+原理性知识刷题总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTML+CSS+JS+原理性知识刷题总结"/></a><div class="content"><a class="title" href="/2022/02/06/do-exercise-1/" title="HTML+CSS+JS+原理性知识刷题总结">HTML+CSS+JS+原理性知识刷题总结</a><time datetime="2022-02-06T05:44:25.000Z" title="发表于 2022-02-06 13:44:25">2022-02-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Xing Ye</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hello stranger!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>