<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>算法学习总结 | XingYeBlog</title><meta name="keywords" content="日常学习"><meta name="author" content="Xing Ye,632885485@qq.com"><meta name="copyright" content="Xing Ye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="算法复杂度时间复杂度时间复杂度是一个函数，它定性描述该算法的运行时间。 我们在软件开发中，时间复杂度就是用来方便开发者估算出程序运行的答题时间。 那么该如何估计程序运行时间呢，通常会估算算法的操作单元数量来代表程序消耗的时间，这里默认 CPU 的每个单元运行消耗的时间都是相同的。 假设算法的问题规模为 n，那么操作单元数量便用函数 f(n)来表示，随着数据规模 n 的增大，算法执行时间的增长率和">
<meta property="og:type" content="article">
<meta property="og:title" content="算法学习总结">
<meta property="og:url" content="http://example.com/2022/04/05/blog43-algorithms/index.html">
<meta property="og:site_name" content="XingYeBlog">
<meta property="og:description" content="算法复杂度时间复杂度时间复杂度是一个函数，它定性描述该算法的运行时间。 我们在软件开发中，时间复杂度就是用来方便开发者估算出程序运行的答题时间。 那么该如何估计程序运行时间呢，通常会估算算法的操作单元数量来代表程序消耗的时间，这里默认 CPU 的每个单元运行消耗的时间都是相同的。 假设算法的问题规模为 n，那么操作单元数量便用函数 f(n)来表示，随着数据规模 n 的增大，算法执行时间的增长率和">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/codes1.jpg">
<meta property="article:published_time" content="2022-04-05T08:01:22.000Z">
<meta property="article:modified_time" content="2022-06-06T05:41:44.593Z">
<meta property="article:author" content="Xing Ye">
<meta property="article:tag" content="日常学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/codes1.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2022/04/05/blog43-algorithms/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法学习总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-06 13:41:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/pinkstar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/codes1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XingYeBlog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法学习总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-05T08:01:22.000Z" title="发表于 2022-04-05 16:01:22">2022-04-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-06T05:41:44.593Z" title="更新于 2022-06-06 13:41:44">2022-06-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">36k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>144分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法学习总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><strong>时间复杂度是一个函数，它定性描述该算法的运行时间</strong>。</p>
<p>我们在软件开发中，时间复杂度就是用来方便开发者估算出程序运行的答题时间。</p>
<p>那么该如何估计程序运行时间呢，通常会估算算法的操作单元数量来代表程序消耗的时间，这里默认 CPU 的每个单元运行消耗的时间都是相同的。</p>
<p>假设算法的问题规模为 n，那么操作单元数量便用函数 f(n)来表示，随着数据规模 n 的增大，算法执行时间的增长率和 f(n)的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 O(f(n))。大 O 就是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度，这个数据量也就是常数项系数已经不起决定性作用的数据量。所以我们说的时间复杂度都是省略常数项系数的，是因为一般情况下都是默认数据规模足够的大，基于这样的事实，给出的算法时间复杂的的一个排行如下所示：</p>
<blockquote>
<p>O(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O(n^2)平方阶 &lt; O(n^3)立方阶 &lt; O(2^n)指数阶</p>
</blockquote>
<p>通常来说，O(n)表示的都是算法的最大复杂度；但是对于一些更常见的情况，往往表示的是最一般的情况。比如快排的复杂度最大是 $O(n^2)$ ，但我们通常都说是 $O(nlogn)$，因为后者是更普遍的情况。</p>
<h2 id="迭代时间复杂度"><a href="#迭代时间复杂度" class="headerlink" title="迭代时间复杂度"></a>迭代时间复杂度</h2><p>时间复杂度最基本的形式就是迭代形式的。<br>比如一个最简单的迭代：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这个迭代一定会执行 n 次，所以时间复杂度就是 O(n)</p>
<p>如果 i 每次不是加 1 这样的线性增长，而是其他变化，时间复杂度就会有所不同：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i *= <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个迭代实际上执行了<code>n/2</code>次，但是算法复杂度忽略参数，我们还是看作 O(n)<br>第二个迭代很明显每次执行都会 i*2，这时就是一个对数复杂度，即 $O(log_{2}n)$ （通常忽略底数）</p>
<h2 id="递归的时间复杂度"><a href="#递归的时间复杂度" class="headerlink" title="递归的时间复杂度"></a>递归的时间复杂度</h2><p>递归算法的时间复杂度本质上是要看: <strong>递归的次数 * 每次递归中的操作次数</strong>。<br>递归其实是另一种迭代，因此很多算法的递归形式其实和迭代形式的复杂度差不多。<br>比如计算 x 的 n 次方，用递归形式描述为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> x * fn1(x, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个递归一共执行了 n 次（到 0 停止），每一次都是一个乘法操作（O(1)），因此总体时间复杂度就是 O(n)</p>
<p>再比如，递归形式的二分查找：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.length &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(nums.length / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (target === nums[mid]) flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">    binarySearch(nums.slice(mid + <span class="number">1</span>), target);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    binarySearch(nums.slice(<span class="number">0</span>, mid - <span class="number">1</span>), target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为每次实际上只会进入两个递归中的一个，并且 mid 一直在取数组长度 n 的一半，所以时间复杂度也是 O(logn)</p>
<hr>
<p>但是不一定所有每次减半的递归复杂度都是 O(logn)；如果一个递归是几个 O(logn)一起出现，那就有可能回到 O(n)</p>
<p>比如还是上面的乘方题，如果写成这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (x % <span class="number">2</span> === <span class="number">1</span>) <span class="keyword">return</span> fn2(x, n / <span class="number">2</span>) * fn2(x, n / <span class="number">2</span>) * x;</span><br><span class="line">  <span class="keyword">return</span> fn2(x, n / <span class="number">2</span>) * fn2(x, n / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个写法实际上就是把 2 的整数倍次方的情况单独列出来了；看起来好像是每次都只取 n/2，但是实际上每次递归都会执行两次同时的递归，所以时间复杂度还是 O(n)<br><img src="https://pic.imgdb.cn/item/6291a6c309475431292a43c7.jpg"></p>
<p>如果提前把这个结果缓存，让递归只执行一次，那么就会是 O(logn)了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> val = fn2(x, n / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (x % <span class="number">2</span> === <span class="number">1</span>) <span class="keyword">return</span> val * val * x;</span><br><span class="line">  <span class="keyword">return</span> val * val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>有些递归会展开成二叉树或多叉树的形式，比如回溯相关的题目，以及部分用递归来解的动态规划。<br>一棵深度（按根节点深度为 1）为 k 的二叉树最多可以有 $2^k - 1$ 个节点</p>
<p>以斐波那契数列为例，最基本的不做任何优化的算法复杂度为 $O(2^n)$ ，就是最大的指数时间复杂度<br><img src="https://pic.imgdb.cn/item/6291bdb90947543129471d30.jpg"><br>产生这么大复杂度的主要原因是同时进行了两次递归，并且每个递归的次数其实并没有多少减少（还是 n 次）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> fibonacci(i - <span class="number">1</span>) + fibonacci(i - <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="两数之和-1"><a href="#两数之和-1" class="headerlink" title="两数之和 1"></a>两数之和 1</h2><blockquote>
<ol>
<li>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</li>
</ol>
</blockquote>
<p>这道题是经典的解法简单、但是可以使用更好的方法优化的问题。<br>最简单的方式是通过双重循环遍历：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findTarget</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> a = <span class="number">0</span>; a &lt; nums.length; a++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> b = <span class="number">0</span>; b &lt; nums.length; b++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[a] + nums[b] === target) <span class="keyword">return</span> [a, b];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是可以通过“空间换时间，加法转减法”的方法优化这道题目。<br>思路是求和问题转化为求差问题, 每遍历到一个新数字的时候，都回到 <code>Map</code> 里去查询 <code>targetNum</code> 与该数的差值是否已经在前面的数字中出现过了。如果出现过显然就是结果；如果没有出现就记录当前数字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findTargetByMap</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  map.set(nums[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.has(target - nums[i])) &#123;</span><br><span class="line">      <span class="comment">// 如果目标数减去当前数在map中存在, 说明找到了</span></span><br><span class="line">      <span class="keyword">return</span> [i, map.get(target - nums[i])];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有找到, 则把该数放到map中</span></span><br><span class="line">      map.set(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合并有序数组"><a href="#合并有序数组" class="headerlink" title="合并有序数组"></a>合并有序数组</h2><blockquote>
<ol start="2">
<li>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</li>
</ol>
</blockquote>
<p>思路是使用两个指针（i、j）分别指向两个数组中的数字，然后两边同时遍历，比较两个指针所指的数字的大小关系，把较小的一个放入新数组，依次类推；<br>最终有一个数组会剩下一部分，再把这一部分截下来补在最后即可</p>
<blockquote>
<p>注意：双指针法用在涉及求和、比大小类的数组题目里时，大前提往往是：该数组必须有序。否则双指针根本无法帮助我们缩小定位的范围，压根没有意义。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatArray</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newArr = [];</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) &#123;</span><br><span class="line">    newArr.push(arr1[i] &lt; arr2[j] ? arr1[i++] : arr2[j++]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [...newArr, ...(i === arr1.length ? arr2.slice(j) : arr1.slice(i))];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三数求和"><a href="#三数求和" class="headerlink" title="三数求和"></a>三数求和</h2><blockquote>
<ol start="3">
<li>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</li>
</ol>
</blockquote>
<p>思路：</p>
<ol>
<li>首先先对数组排序；</li>
<li>然后固定一个元素<code>k</code>,然后双指针分别指向其后后面元素的第一个<code>k+1</code>和最后一个<code>length - 1</code>,按照两元素和的方法移动指针<ul>
<li>若三个数相加之和大于 0，说明右侧的数偏大了，右指针左移</li>
<li>若三个数相加之和小于 0，说明左侧的数偏小了，左指针右移</li>
</ul>
</li>
</ol>
<p>因为要求找到不重复的三元组，因此遍历期间两个指针处如果有重复的数字应该跳过；并且固定的元素也应该跳过重复</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">triNumberSum</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  nums = nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> cache = []; <span class="comment">// 存储防止重复</span></span><br><span class="line">  <span class="keyword">const</span> newArr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; nums.length - <span class="number">2</span>; k++) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果当前正在遍历的数字重复了就直接跳过</span></span><br><span class="line">    <span class="keyword">if</span> (cache.includes(nums[k])) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">const</span> sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">      <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 等于0得到结果</span></span><br><span class="line">        newArr.push([nums[i], nums[j], nums[k]]);</span><br><span class="line">        cache.push(nums[k]);</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 大于0说明右边大了</span></span><br><span class="line">        j--;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; i &amp;&amp; nums[j] === nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="comment">// 如果前一个数和这个数一样就继续向前，即跳过重复的</span></span><br><span class="line">          j--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 小于0说明左边小了</span></span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] === nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">          i++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>左右指针一起从两边往中间位置相互迫近，这样的特殊双指针形态，被称为“对撞指针”。<br><strong>有序</strong>和<strong>数组</strong>这样的关键词出现，就要考虑使用对撞指针</p>
</blockquote>
<h2 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h2><blockquote>
<p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。<br>示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p>
</blockquote>
<p>这道题的解法不是先平方再排序，而是通过双指针的形式原地 O(1)实现。</p>
<p>思路是，新创建一个数组，然后新数组从后往前存值；接下来循环：<br>比较左指针和右指针的数的平方值大小；将较大的一个数放入新数组，然后较大数的那边指针移动。</p>
<p>之所以从后向前存值，是因为负数的平方有可能超过正数，如果从前向后没法确定最小值是哪个。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortedSquares = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="built_in">Array</span>(nums.length);</span><br><span class="line">  <span class="keyword">while</span> (k &lt; res.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] ** <span class="number">2</span> &lt; nums[j] ** <span class="number">2</span>) &#123;</span><br><span class="line">      res[k++] = nums[i] ** <span class="number">2</span>;</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res[k++] = nums[j] ** <span class="number">2</span>;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><blockquote>
<p>给你一个数组 nums  和一个值 val，你需要<strong>原地</strong>移除<strong>所有</strong>数值等于  val  的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<p>这道题的思路是利用快慢指针；当走到目标元素时，让快指针先走到第一个不是目标元素的位置，然后将快指针所指的值替换到慢指针的位置即可。注意要保存两个指针之间的位置差</p>
<p>还有一点，遍历至少要完成所有元素的一次遍历；所以可以<strong>让慢指针延迟，而不是让快指针先走</strong>的方式；当快指针走到头时，遍历就完成了，此时慢指针恰好就是最后一个。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">val</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElement = <span class="function"><span class="keyword">function</span> (<span class="params">nums, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] !== val) &#123;</span><br><span class="line">      nums[k] = nums[i];</span><br><span class="line">      k++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> k;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/">https://leetcode.cn/problems/move-zeroes/</a></p>
<blockquote>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。<br>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p>
</blockquote>
<p>主要是学习一下移动数组的方式，这里直接写代码了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">arr, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt; arr.length; i++) &#123;</span><br><span class="line">      arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (nums[i] === <span class="number">0</span>) &#123;</span><br><span class="line">      move(nums, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] == <span class="literal">undefined</span>) nums[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/">https://leetcode.cn/problems/intersection-of-two-arrays/</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> intersection = <span class="function"><span class="keyword">function</span> (<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums1) &#123;</span><br><span class="line">    set.add(num);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (set.has(num)) res.add(num);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [res.values()];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="回文字符串"><a href="#回文字符串" class="headerlink" title="回文字符串"></a>回文字符串</h2><blockquote>
<ol>
<li>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。<br>示例：<br>输入: “abaca”<br>输出: True<br>解释: 你可以删除 c 字符。</li>
</ol>
</blockquote>
<p>思路：利用回文字符串的“对称性”，即字符串从两头分别遍历，每个字符都相等（直到两个遍历指针相碰）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> strArr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = strArr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strArr[i] === strArr[j]) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么放到这个题就是，现进行一次上面的操作，直到找到第一个不相等的字符串为止；</p>
<p>然后“跳过”这个字符，分别让左指针跳过当前正在指的字符、右指针跳过当前正在指的字符，然后判断跳过之后左右指针中间的字符段是否回文。</p>
<p>原理其实是，由于判断出现不同时，不知道是左边还是右边的那个字符不对，因此就让左右分别跳过，测试跳过之后中间部分是不是还能正常回文。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">palindrome</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> strArr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = strArr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strArr[i] === strArr[j]) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> isPalindrome(str.splice(i, <span class="number">1</span>)) &amp;&amp; isPalindrome(str.splice(j, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> strArr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = strArr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strArr[i] === strArr[j]) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><p>KMP 算法的讲解可以参考 <a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a><br>详细代码参考 <a target="_blank" rel="noopener" href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s2</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">KMP</span>(<span class="params">s1, s2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取next数组，这里就是最大前缀数组</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getNext</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [<span class="number">0</span>]; <span class="comment">// 第一项一定是0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">1</span>; k &lt; str.length; k++) &#123;</span><br><span class="line">      <span class="comment">//从第二个字母开始遍历</span></span><br><span class="line">      <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> j = k;</span><br><span class="line">      <span class="keyword">let</span> start = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">let</span> end = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; str.length - <span class="number">1</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        start += str[i++];</span><br><span class="line">        end += str[j--]; <span class="comment">// 因为end是从后向前拼的，应该倒转一下</span></span><br><span class="line">        <span class="keyword">if</span> (start === end.split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">          max = <span class="built_in">Math</span>.max(max, start.length);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      res.push(max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> str = s1.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> search = s2.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> next = getNext(search);</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 这里用while而不是用if，因为如果出现不匹配，应当是按照前缀数组next一个一个</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str[i] !== search[j]) &#123;</span><br><span class="line">      <span class="comment">// 如果j=0，说明子串第一项就不匹配，直接继续（只i++）</span></span><br><span class="line">      j = next[j - <span class="number">1</span>]; <span class="comment">// 回退的实际上是前一项的最大前后缀</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前匹配，继续</span></span><br><span class="line">    <span class="keyword">if</span> (str[i] === search[j]) &#123;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 匹配完成</span></span><br><span class="line">    <span class="keyword">if</span> (j === search.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> i - search.length + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>next 的计算还有一种的写法，利用前缀和后缀的最后一个字母不同时，回退前一个 next 值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNext</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> next = [<span class="number">0</span>]; <span class="comment">// 第一项一定是0</span></span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] !== s[j]) &#123;</span><br><span class="line">      j = next[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s[i] === s[j]) &#123;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    next[i] = j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重复子字符串"><a href="#重复子字符串" class="headerlink" title="重复子字符串"></a>重复子字符串</h2><blockquote>
<p>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。<br>输入: s = “abcabcabcabc”<br>输出: true<br>解释: 可由子串 “abc” 重复四次构成。 (或子串 “abcabc” 重复两次构成。)</p>
</blockquote>
<p>思路是利用 KMP 算法中的 next 数组。因为 next 数组判断的是最长公共前缀，那么 next 数组的最后一项就应该是前面的最长重复子串的长度的整数倍数。<br>即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getNext(&quot;abcdabcdabcd&quot;)</span><br><span class="line">(12) [0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure>

<p>8 这个值是<code>abcdabcd</code>的长度，这个长度重复两次就刚好是这个字符串。<br>然后让<code>12 - 8 = 4</code>，即除去公共串后，剩下还有多长；剩下的 4 可以整除 12，说明存在长度为 4 的重复子字符串。<br>因此公式为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">next.length % (next.length - next[next.length - <span class="number">1</span>]) === <span class="number">0</span> &amp;&amp;</span><br><span class="line">  next[next.length - <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 能整除，并且最后一项不为0，说明为true</span></span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> repeatedSubstringPattern = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getNext</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> next = [<span class="number">0</span>]; <span class="comment">// 第一项一定是0</span></span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] !== s[j]) &#123;</span><br><span class="line">        j = next[j - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (s[i] === s[j]) &#123;</span><br><span class="line">        j++;</span><br><span class="line">      &#125;</span><br><span class="line">      next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> next = getNext(s);</span><br><span class="line">  <span class="keyword">if</span> (s.length % (s.length - next[next.length - <span class="number">1</span>]) || !next[next.length - <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-prefix/">https://leetcode.cn/problems/longest-common-prefix/</a></p>
<p>思路就是纵向比较同一个位置上的字符，如果出现不一样的就立刻返回结果，否则持续向结果数组中放入当前字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">strs</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestCommonPrefix = <span class="function"><span class="keyword">function</span> (<span class="params">strs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> lengths = strs.map(<span class="function">(<span class="params">str</span>) =&gt;</span> str.length);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.min(...lengths); i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> str <span class="keyword">of</span> strs) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!tmp || tmp === str[i]) tmp = str[i];</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> res.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(tmp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="列表序号"><a href="#列表序号" class="headerlink" title="列表序号"></a>列表序号</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/excel-sheet-column-number/submissions/">https://leetcode.cn/problems/excel-sheet-column-number/submissions/</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">columnTitle</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> titleToNumber = <span class="function"><span class="keyword">function</span> (<span class="params">columnTitle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> letters = columnTitle.split(<span class="string">&quot;&quot;</span>).reverse();</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> getNum = <span class="function">(<span class="params">letters</span>) =&gt;</span> letters.charCodeAt() - <span class="string">&quot;A&quot;</span>.charCodeAt();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; letters.length; i++) &#123;</span><br><span class="line">    sum += getNum(letters[i]) * <span class="number">26</span> ** i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="验证-IP-地址"><a href="#验证-IP-地址" class="headerlink" title="验证 IP 地址"></a>验证 IP 地址</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-ip-address/">https://leetcode.cn/problems/validate-ip-address/</a></p>
<p>这道题本身比较简单，但是要学习一个方法：<br>怎么检验一个字符是合法字符？（数字、字母等）<br>最简单粗暴的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> all = <span class="string">&quot;0123456789abcdef&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!all.includes(s)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">queryIP</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> validIPAddress = <span class="function"><span class="keyword">function</span> (<span class="params">queryIP</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> queryIP.includes(<span class="string">&quot;.&quot;</span>) ? IPv4(queryIP) : IPv6(queryIP);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IPv4</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = str.split(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  arr.forEach(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isNaN</span>(num)) flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Number</span>(num).toString().length !== num.length) flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (+num &gt; <span class="number">255</span>) flag = <span class="literal">false</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> flag ? <span class="string">&quot;IPv4&quot;</span> : <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IPv6</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = str.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> isLetter = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    str = str.toLowerCase();</span><br><span class="line">    <span class="keyword">const</span> all = <span class="string">&quot;0123456789abcdef&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!all.includes(s)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  arr.forEach(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num.length &gt; <span class="number">4</span> || num.length &lt; <span class="number">1</span>) flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!isLetter(num)) flag = <span class="literal">false</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> flag ? <span class="string">&quot;IPv6&quot;</span> : <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="合并链表"><a href="#合并链表" class="headerlink" title="合并链表"></a>合并链表</h2><blockquote>
<ol>
<li>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有结点组成的。</li>
</ol>
</blockquote>
<p>有序链表的合成和有序数组的合并类似，都是用双指针依次遍历节点。</p>
<p>通过 LinkNode 新创建一个头节点，然后依次把两个链表中的节点比较、附加在这个新的头节点后面，形成的新链表就是有序链表。最后再把没连接上的多余部分加上去即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeTwoLists = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> head = <span class="keyword">new</span> LinkNode();</span><br><span class="line">  <span class="keyword">let</span> curr = head;</span><br><span class="line">  <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">      curr.next = l1;</span><br><span class="line">      l1 = l1.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      curr.next = l2;</span><br><span class="line">      l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  curr.next = l1 ? l1 : l2;</span><br><span class="line">  <span class="keyword">return</span> curr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="dummy-节点"><a href="#dummy-节点" class="headerlink" title="dummy 节点"></a>dummy 节点</h2><blockquote>
<ol start="2">
<li>给定一个排序链表，删除所有含有重复数字的结点，只保留原始链表中 没有重复出现的数字。</li>
</ol>
</blockquote>
<p>这道题乍看起来比较简单，可以用一个 set 存储前面遍历过的数字，如果在 set 中找到，就把这些删去。</p>
<p>问题在于，这里要求删去所有节点，那么重复的这一组节点中的头一个节点就无法删去，因为不能获取到它前面的节点，就不能删去它</p>
<p>为了解决这个问题，设置一个位于整个链表头部的 dummy 节点，从 dummy 开始遍历（假设当前指针是 curr）：如果<code>curr.next.val === curr.next.next.val</code>，就用循环依次遍历到不相等的节点，然后把<code>curr.next</code>指过去即可。</p>
<p>dummy 节点的出现在这里主要是为了解决第一个节点就是重复节点的问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deleteDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 设定 dummy 指针，作为头节点的前一个虚拟节点</span></span><br><span class="line">  <span class="keyword">let</span> dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">  dummy.next = head;</span><br><span class="line">  <span class="keyword">let</span> cur = dummy; <span class="comment">// 从dummy开始，这样就解决了第一个就重复的情况</span></span><br><span class="line">  <span class="keyword">while</span> (cur.next &amp;&amp; cur.next.next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur.next.val === cur.next.next.val) &#123;</span><br><span class="line">      <span class="comment">// 若值重复，则记下这个值</span></span><br><span class="line">      <span class="keyword">let</span> val = cur.next.val;</span><br><span class="line">      <span class="comment">// 反复地排查后面的元素是否存在多次重复该值的情况</span></span><br><span class="line">      <span class="keyword">while</span> (cur.next &amp;&amp; cur.next.val === val) &#123;</span><br><span class="line">        <span class="comment">// 若有，则删除</span></span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 若不重复，则正常遍历</span></span><br><span class="line">      cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注意是dummy.next</span></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><blockquote>
<ol start="3">
<li>给定一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</li>
</ol>
</blockquote>
<p>快慢指针即设定两个指针，快指针在慢指针前面或者快指针一次走的步数比慢指针多；当快指针到达某个位置时，慢指针往往就是对应的解。</p>
<p>比如倒数 n 个节点，可以让快指针先走 n 步，然后两者一起往前走；当快指针走到最后一个节点时，慢指针所指向的就是倒数第 n 个</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> removeNthFromEnd = <span class="function"><span class="keyword">function</span> (<span class="params">head, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">  dummy.next = head;</span><br><span class="line">  <span class="keyword">let</span> fast = dummy;</span><br><span class="line">  <span class="keyword">let</span> slow = dummy;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!fast.next) <span class="keyword">return</span>;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (fast.next) &#123;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">  &#125;</span><br><span class="line">  slow.next = slow.next.next;</span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><blockquote>
<ol start="4">
<li>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</li>
</ol>
</blockquote>
<p>记住方法：</p>
<ol>
<li>使用 prev/curr/next 三个指针分别指向前一个、当前和后一个节点；其中 curr 是第一个节点，prev 可以是 null 或者 dummy</li>
<li>从 curr 指向的第一个节点开始，让当前节点的 next 指向 pre；</li>
<li>然后令<code>curr = next，prev = curr，next = next.next</code>，即依次向后移动，直到最后一个节点被反转</li>
<li>cur 节点是真正反转的节点，因此要遍历到最后一个；当 cur 成为 null 时，pre 就是最后一个节点</li>
</ol>
<blockquote>
<p>实际上并不需要 next 指针，因为直接用<code>curr.next</code>就可以，每次遍历都先获取<code>curr.next</code>并缓存一下，然后继续即可</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseList = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="literal">null</span>; <span class="comment">// 前节点</span></span><br><span class="line">  <span class="keyword">let</span> cur = head; <span class="comment">// 当前节点，从头节点开始</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = cur.next; <span class="comment">// 先缓存next</span></span><br><span class="line">    cur.next = pre;</span><br><span class="line">    pre = cur;</span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="部分反转一个链表"><a href="#部分反转一个链表" class="headerlink" title="部分反转一个链表"></a>部分反转一个链表</h2><blockquote>
<ol start="5">
<li>部分反转：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</li>
</ol>
</blockquote>
<p>核心方法和正常的反转链表一样，关键在于反转之后把反转的部分和其他的连起来。<br>其实就是先把反转部分的前节点和后节点存起来，反转完成后再连起来。</p>
<p><img src="https://pic.imgdb.cn/item/6266b3c3239250f7c528044f.jpg"></p>
<p>以这幅图为例，当 curr 指针遍历到 left 时，即开始遍历到区域时，就把节点 1 缓存下来（此时正好是 pre 指针指向的）；<br>随着遍历的进行，当结点 4 的指针反转后，此时 cur 指针就恰好指在结点 5 上，这时只需要把节点 2 指向 cur 即可。</p>
<p>另外，还需要记录反转区域内部的头尾节点（上面的 2、4 节点）；其中 4 节点恰好是遍历完的 pre，直接<code>leftHead.next = pre</code>即可；但是 2 节点需要提前缓存（下面代码中的 start），结束后让<code>start.next = cur</code>连接尾部。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseBetween = <span class="function"><span class="keyword">function</span> (<span class="params">head, m, n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义pre、cur，用leftHead来承接整个区间的前驱结点</span></span><br><span class="line">  <span class="keyword">let</span> pre, cur, leftHead;</span><br><span class="line">  <span class="keyword">const</span> dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">  <span class="comment">// dummy后继结点是头结点</span></span><br><span class="line">  dummy.next = head;</span><br><span class="line">  <span class="comment">// p是一个游标，用于遍历，最初指向 dummy</span></span><br><span class="line">  <span class="keyword">let</span> p = dummy;</span><br><span class="line">  <span class="comment">// p往前走 m-1 步，走到整个区间的前驱结点处</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    p = p.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 缓存这个前驱结点到 leftHead 里</span></span><br><span class="line">  leftHead = p;</span><br><span class="line">  <span class="comment">// start 是反转区间的第一个结点</span></span><br><span class="line">  <span class="keyword">let</span> start = leftHead.next;</span><br><span class="line">  <span class="comment">// pre 指向start</span></span><br><span class="line">  pre = start;</span><br><span class="line">  <span class="comment">// cur 指向 start 的下一个结点</span></span><br><span class="line">  cur = pre.next;</span><br><span class="line">  <span class="comment">// 开始重复反转动作</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = m; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = cur.next;</span><br><span class="line">    cur.next = pre;</span><br><span class="line">    pre = cur;</span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  leftHead 的后继结点此时为反转后的区间的第一个结点</span></span><br><span class="line">  leftHead.next = pre;</span><br><span class="line">  <span class="comment">// 将区间内反转后的最后一个结点 next 指向 cur</span></span><br><span class="line">  start.next = cur;</span><br><span class="line">  <span class="comment">// dummy.next 永远指向链表头结点</span></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="递归反转一个链表"><a href="#递归反转一个链表" class="headerlink" title="递归反转一个链表"></a>递归反转一个链表</h2><p>链表的递归实际上和树的递归很像。链表同样有自己的前序和后序遍历：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travarse</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">  <span class="comment">// 前序（正向遍历）</span></span><br><span class="line">  travarse(head.next);</span><br><span class="line">  <span class="comment">// 后序（反向遍历）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后序遍历实际上就是在倒着走一遍链表。如果能在反向遍历的过程中改变指针，就表现为反转链表了。</p>
<p>先上写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseList = <span class="function">(<span class="params">head</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!head || !head.next) <span class="keyword">return</span> head; <span class="comment">// 递归边界返回当前节点</span></span><br><span class="line">  <span class="keyword">const</span> last = reverseList(head.next); <span class="comment">// last相当于一直递归找到了最尾端的节点</span></span><br><span class="line">  head.next.next = head; <span class="comment">// 让当前节点的后一个节点指向自己（反转紧邻的后面节点的方向）</span></span><br><span class="line">  head.next = <span class="literal">null</span>; <span class="comment">//本节点向后的指针删去</span></span><br><span class="line">  <span class="keyword">return</span> last; <span class="comment">// 理论上递归过程中不需要这个last，但是最后需要这个作为反转之后的头节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到这种写法有几个关键点：</p>
<ol>
<li>last 节点，虽然并没参与递归，但是需要最后作为头节点；</li>
<li>固定的两步</li>
</ol>
<ul>
<li><code>head.next.next = head;</code>：表示把后一个节点指向前一个（当前的）</li>
<li><code>head.next = null</code>：表示当前节点的后指针置空，因为链表已经反转了，原先的头节点变成了尾，因此就必须要置空。但是如果是部分反转，那么就不能设为空，因为还要和其他部分连起来。</li>
</ul>
<p>递归反转链表常见于部分反转，部分反转实际上就是更改递归边界即可。<br>比如反转前 k 个节点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseN = <span class="function">(<span class="params">head, k</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> after = <span class="literal">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k === <span class="number">1</span>) &#123;</span><br><span class="line">      after = head.next; <span class="comment">// 递归到位，然后将后驱节点存下来</span></span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> last = reverse(head.next, k - <span class="number">1</span>);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = after;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后，反转任意一个部分的链表，其实就是先递归到起始节点位置，然后以起始节点为第一个节点，执行上面的反转前 k 个节点，最后把返回值和前面的连起来就行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseMN = <span class="function">(<span class="params">head, m, n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (m === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> reverseN(head, n);</span><br><span class="line">  &#125;</span><br><span class="line">  head.next = reverseMN(head.next, m - <span class="number">1</span>, n - <span class="number">1</span>); <span class="comment">// 相当于往后走到了起始节点，然后m和n都对应-1（比如从2/4变为1/3这样）</span></span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="链表交叉"><a href="#链表交叉" class="headerlink" title="链表交叉"></a>链表交叉</h2><blockquote>
<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>
</blockquote>
<p>思路是这样：因为相交之前，两个链表长度不一样；所以可以先调整起始位置，让较长的链表向前移动几位，和较短的链表头节点并齐之后再开始遍历。<br>判断相交节点的方式是两个<strong>指针</strong>相同，注意不是值相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">headA</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">headB</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span> (<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getLen</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">      len++;</span><br><span class="line">      curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> lenA = getLen(headA);</span><br><span class="line">  <span class="keyword">const</span> lenB = getLen(headB);</span><br><span class="line">  <span class="keyword">let</span> startIndex = <span class="built_in">Math</span>.abs(lenA - lenB);</span><br><span class="line">  <span class="keyword">let</span> startA = headA;</span><br><span class="line">  <span class="keyword">let</span> startB = headB;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (lenA &gt; lenB) &#123;</span><br><span class="line">    startA = headA;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; startIndex; i++) &#123;</span><br><span class="line">      startA = startA.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lenA &lt; lenB) &#123;</span><br><span class="line">    startB = headB;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; startIndex; i++) &#123;</span><br><span class="line">      startB = startB.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (startA &amp;&amp; startB) &#123;</span><br><span class="line">    startA = startA.next;</span><br><span class="line">    startB = startB.next;</span><br><span class="line">    <span class="keyword">if</span> (startA === startB) flag = startA;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="判断回文链表"><a href="#判断回文链表" class="headerlink" title="判断回文链表"></a>判断回文链表</h2><blockquote>
<p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p>
</blockquote>
<p>这道题有几个思路：</p>
<ol>
<li>最朴实的方法，先快慢指针找到中间节点，然后从中间节点开始反转后面的链表，再双指针比较两个链表是否相等。</li>
<li>顺序输出转换成数组，然后判断数组是否回文。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> curr = head;</span><br><span class="line">  <span class="keyword">const</span> arr = [];</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    arr.push(curr.val);</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.join(<span class="string">&quot;&quot;</span>) === arr.reverse().join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还有一种方法是上面的递归方法。先通过递归走到最后一个节点，在返回的途中和正向遍历一一比较。</p>
<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h2><blockquote>
<ol>
<li>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</li>
</ol>
</blockquote>
<p>比较基础的栈问题，先把左括号入栈，然后当遇见右括号时，根据预设的匹配关系出栈左括号，如果不匹配就返回 false</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isValid = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">const</span> str = s.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;[&quot;</span>, <span class="string">&quot;]&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>],</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s === <span class="string">&quot;(&quot;</span> || s === <span class="string">&quot;[&quot;</span> || s === <span class="string">&quot;&#123;&quot;</span>) &#123;</span><br><span class="line">      stack.push(s);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s === <span class="string">&quot;)&quot;</span> || s === <span class="string">&quot;]&quot;</span> || s === <span class="string">&quot;&#125;&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> top = stack.pop();</span><br><span class="line">      <span class="keyword">if</span> (s !== map.get(top)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!stack.length) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="“对对碰”消除"><a href="#“对对碰”消除" class="headerlink" title="“对对碰”消除"></a>“对对碰”消除</h2><blockquote>
<p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。<br>在 S 上反复执行重复项删除操作，直到无法继续删除。<br>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p>示例：</p>
<p>输入：”abbaca”<br>输出：”ca”<br>解释：例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。</p>
</blockquote>
<p>利用栈，把每一项一次入栈，如果有和栈顶元素相同的就把栈顶元素出栈</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.gif"></p>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> top = stack[stack.length - <span class="number">1</span>] || <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[i] === top) stack.pop();</span><br><span class="line">    <span class="keyword">else</span> stack.push(s[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="后缀表达式求值"><a href="#后缀表达式求值" class="headerlink" title="后缀表达式求值"></a>后缀表达式求值</h2><blockquote>
<p>根据 逆波兰表示法，求表达式的值。<br>有效的运算符包括 + , - , * , / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br>说明：<br>整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
<p>示例 1：<br>输入: [“2”, “1”, “+”, “3”, “ * “]<br>输出: 9<br>解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9<br>示例 2：<br>输入: [“4”, “13”, “5”, “/“, “+”]<br>输出: 6<br>解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</p>
</blockquote>
<p>后缀表达式是计算机常用的计算表达式的方法。<br>后缀表达式可以看作是一棵后序遍历的树，每个运算符都是中间节点，以运算符为根节点的子树是一个表达式的值；<br>因此可以通过这个思路引入栈，执行这样的操作：</p>
<ol>
<li>如果是数字，入栈</li>
<li>如果是运算符，就把栈顶的两个元素出栈，并通过运算符计算，结果入栈</li>
</ol>
<p>代码如下：</p>
<blockquote>
<p>注意这里有个坑：除法应该使用<code>Math.trunc</code>去掉小数部分，模拟 java 等语言中的整形运算。不能是<code>Math.floor</code>，因为处理负数时会向下取整。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">tokens</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> evalRPN = <span class="function"><span class="keyword">function</span> (<span class="params">tokens</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">&quot;+&quot;</span>, <span class="function">(<span class="params">a, b</span>) =&gt;</span> a * <span class="number">1</span> + b * <span class="number">1</span>],</span><br><span class="line">    [<span class="string">&quot;-&quot;</span>, <span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a],</span><br><span class="line">    [<span class="string">&quot;*&quot;</span>, <span class="function">(<span class="params">a, b</span>) =&gt;</span> b * a],</span><br><span class="line">    [<span class="string">&quot;/&quot;</span>, <span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="built_in">Math</span>.trunc(b / a)],</span><br><span class="line">  ]);</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">of</span> tokens) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!s.has(i)) &#123;</span><br><span class="line">      stack.push(i);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(s.get(i)(stack.pop(), stack.pop()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack.pop();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="单调栈和单调队列（更高温度）"><a href="#单调栈和单调队列（更高温度）" class="headerlink" title="单调栈和单调队列（更高温度）"></a>单调栈和单调队列（更高温度）</h2><blockquote>
<p>给定一个整数数组  temperatures ，表示每天的温度，返回一个数组  answer ，其中<code>answer[i]</code>  是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用  0 来代替。<br>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
</blockquote>
<p>思路：创建一个索引栈，用于记录索引。这个栈同时还是一个最小栈，即保持栈顶的元素始终是最小的。</p>
<p>确定一个<strong>单调递减的趋势</strong>，一旦有数字打破了这个趋势，也就说一个数字比它前面入栈的数字大，那就把它前面比他小的数字都出栈，并且用它的索引减去这些数字的索引，减去的值恰好就是对应的 answer。</p>
<blockquote>
<p>演示视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12t4y1274o/">https://www.bilibili.com/video/BV12t4y1274o/</a></p>
</blockquote>
<p>至于为什么栈中不直接放入温度而是存索引，是因为要得出的结果 ans 是每个元素的索引相加减得出的，并且也恰好是按照索引顺序摆放的。<br>索引栈是一个很好用的思维方式，可以尝试多用用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dailyTemperatures = <span class="function"><span class="keyword">function</span> (<span class="params">temperatures</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  stack[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> ans = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (</span><br><span class="line">      stack.length &amp;&amp;</span><br><span class="line">      temperatures[i] &gt; temperatures[stack[stack.length - <span class="number">1</span>]]</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">const</span> index = stack.pop();</span><br><span class="line">      ans[index] = i - index;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h2><blockquote>
<ol start="3">
<li>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。<br>滑动窗口大概长这样：<br>1 [3 -1 -3] 5 3 6 7<br>1 3 [-1 -3 5] 3 6 7<br>1 3 -1 [-3 5 3] 6 7<br>1 3 -1 -3 [5 3 6] 7<br>1 3 -1 -3 5 [3 6 7]</li>
</ol>
</blockquote>
<p>基础思路是用一个双指针分别指向窗口的左和右，然后取得双指针之间的最大值放入结果.但是这个方法不好，因为实际上有很多已经判断过的数被重复比较</p>
<p>因此更好的思路是利用<strong>单调递减</strong>的<strong>双端队列</strong>，遍历把每个 nums 中的索引放入（还是索引，因为需要判断队列中的数字是否超出滑动窗口范围）</p>
<p>然后最重要的是和上面的最小栈类似，如果有比队尾数小的就放入；如果比队尾数大就依次出队，直到<code>队尾数&gt;=当前数</code>为止。因此队头的元素一定是本次遍历的最大值</p>
<p>遍历时从第一个开始，当遍历数到达 k 时，就相当于产生了第一个窗口，开始记录最大值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxSlidingWindow = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> deque = [];</span><br><span class="line">  <span class="keyword">const</span> answer = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果当前数比队尾数大，就依次出队</span></span><br><span class="line">    <span class="keyword">while</span> (deque.length &amp;&amp; nums[i] &gt; nums[deque[deque.length - <span class="number">1</span>]]) &#123;</span><br><span class="line">      deque.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    deque.push(i); <span class="comment">// 当前数的索引放入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队头元素的位置是否超过了滑动窗口的前沿（即 i + 1 - k）</span></span><br><span class="line">    <span class="keyword">if</span> (deque.length &amp;&amp; deque[<span class="number">0</span>] &lt; i + <span class="number">1</span> - k) &#123;</span><br><span class="line">      deque.shift();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当遍历数到达k时，开始记录最大值</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">      answer.push(nums[deque[<span class="number">0</span>]]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-string/">https://leetcode.cn/problems/decode-string/</a></p>
<blockquote>
<p>给定一个经过编码的字符串，返回它解码后的字符串。<br>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。<br>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。<br>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像  3a  或  2[4]  的输入。<br>示例 1：<br>输入：s = “3[a]2[bc]”<br>输出：”aaabcbc”</p>
</blockquote>
<p>思路：利用栈，逐个遍历字符串的每一项：</p>
<ul>
<li>如果是数字、左括号或者字母，入栈</li>
<li>如果是右括号，就出栈直到左括号为止，然后把之间的字母按照左括号前的数字作为倍数放入结果。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> decodeString = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isLetter = <span class="function">(<span class="params">s</span>) =&gt;</span></span><br><span class="line">    s.charCodeAt() &gt;= <span class="string">&quot;a&quot;</span>.charCodeAt() &amp;&amp; s.charCodeAt() &lt;= <span class="string">&quot;z&quot;</span>.charCodeAt();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; ) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = []; <span class="comment">// 每次执行res都应该清零，防止影响上一次的结果</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(s[i])) &#123;</span><br><span class="line">      <span class="comment">// 如果是数字，处理不止一位数的情况</span></span><br><span class="line">      <span class="keyword">let</span> num = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">while</span> (!<span class="built_in">isNaN</span>(s[i])) num += s[i++];</span><br><span class="line">      stack.push(+num);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">&quot;[&quot;</span> || isLetter(s[i])) &#123;</span><br><span class="line">      <span class="comment">// 左括号和字母入栈</span></span><br><span class="line">      stack.push(s[i]);</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">&quot;]&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 出栈到右括号</span></span><br><span class="line">        <span class="keyword">const</span> top = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (top === <span class="string">&quot;[&quot;</span>) <span class="keyword">break</span>;</span><br><span class="line">        str = top + str;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> times = stack.pop();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; times; j++) &#123;</span><br><span class="line">        <span class="comment">// 把中间的字符按照倍数放入</span></span><br><span class="line">        res.push(str);</span><br><span class="line">      &#125;</span><br><span class="line">      stack.push(res.join(<span class="string">&quot;&quot;</span>)); <span class="comment">// 注意，前面拼接好的还应该放回栈中，主要为了处理嵌套括号的情况。</span></span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (stack.length) &#123;</span><br><span class="line">    <span class="comment">// 剩余字母</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; stack.length; i++) res.push(stack[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>基本思路是这样的：</p>
<ol>
<li>循环，然后逐个将字符放入窗口中</li>
<li><strong>根据窗口本身的状态</strong>，判断是否需要弹出窗口（缩小左边），然后循环弹出直到窗口本身满足状态</li>
<li>结束循环的条件通常是一个指针走到了其中一个序列的末尾。</li>
</ol>
<p>通常的格式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">slidingWindow</span>(<span class="params">s,t</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> queue = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; s.length;i++)&#123;</span><br><span class="line">    queue.push(s[i])<span class="comment">// 增大窗口通常是在循环中直接插入的，不需要单独一个循环</span></span><br><span class="line">    <span class="comment">// 一些更新</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="comment">/*弹出的条件，通常是窗口内部的状态*/</span>)&#123;</span><br><span class="line">      <span class="keyword">const</span> out = queue.shift()</span><br><span class="line">      <span class="comment">// 一些更新</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其实问题的关键就是判断窗口里边部分的状态是否满足结束条件或者弹出条件。<br>以字符串为例，常用的判断方式有：</p>
<ol>
<li>用两个对象分别统计当前窗口中的字符数量 window 和目标的字符数量 need，如果匹配就记录，其他时候弹出直到不匹配为止；</li>
<li>直接判断窗口内和目标是否相等（字符串或数组）</li>
<li>记录一个 a-z 26 个字符的出现次数的数组，<strong>如果两个字符串之间除了顺序之外完全相同，那么这两个数组也一定是完全相同的</strong>，用于判断顺序不一致时的子序列。</li>
</ol>
<h3 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutation-in-string/">https://leetcode.cn/problems/permutation-in-string/</a></p>
<p>这道题的思路是这样：首先确定一个滑动窗口，然后逐个将字符放入窗口中，（当滑动窗口大小够的时候）比较窗口的字符是否满足条件（即判断窗口内的字符串和目标字符串 s1 是否相等）。如果相等就直接返回 true，不相等就把窗口中的第一个字符弹出（保证窗口大小始终和 s1 大小相等），然后继续添加下一个并判断。</p>
<p>但是这个问题在于判断字符相等，因为求得是字符串的<strong>排列</strong>而非子序列，因此它是连续但并不按顺序的，所以不能直接比较判断字符串相等（太耗时）。<br>这里提供了一个思路是记录 a-z 的 26 个字符的出现次数的数组，<strong>如果两个字符串之间除了顺序之外完全相同，那么这两个数组也一定是完全相同的</strong>。因此就可以在每次遍历中当前字符++，并把超出窗口大小的字符–即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> checkInclusion = <span class="function"><span class="keyword">function</span> (<span class="params">s1, s2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">26</span>).fill(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">26</span>).fill(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> s1) &#123;</span><br><span class="line">    target[s.charCodeAt() - <span class="string">&quot;a&quot;</span>.charCodeAt()]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> isEqual = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i] !== b[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; s2.length) &#123;</span><br><span class="line">    now[s2[i].charCodeAt() - <span class="string">&quot;a&quot;</span>.charCodeAt()]++;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= s1.length - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isEqual(now, target)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        now[s2[i - s1.length + <span class="number">1</span>].charCodeAt() - <span class="string">&quot;a&quot;</span>.charCodeAt()]--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这道题还有可能的几个变种：</p>
<ol>
<li>s1 就是 s2 的子串，不会变顺序：在判断阶段直接比较窗口的字符串和目标串即可，比较简单</li>
<li>s1 是 s2 的子序列，即不一定连续：用一个 now 对象（表示当前字符数量，按照<code>&#123;A:1,B:2,C:0&#125;</code>这种形式）表示当前记录次数，用同样的 target 对象表示目标，窗口每次增大都判断是否满足条件，满足就为 true；</li>
<li>判断 s1 在 s2 中出现的最短序列（<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/%EF%BC%89%EF%BC%9A%E6%9C%80%E9%9A%BE%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E8%A6%81%E8%AE%A1%E7%AE%97%E6%9C%80%E7%9F%AD%E6%83%85%E5%86%B5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E7%9C%8B%E8%A7%A3%E6%9E%90%E3%80%82">https://leetcode.cn/problems/minimum-window-substring/）：最难的情况，要计算最短情况，建议直接看解析。</a></li>
</ol>
<h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h3><blockquote>
<p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
</blockquote>
<p>同样的滑动窗口题，弹出条件是窗口有重复字符，把窗口左边的循环弹出直到不重复为止。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> queue = [];</span><br><span class="line">  <span class="keyword">const</span> isRepeat = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [...new <span class="built_in">Set</span>([...arr]).values()].length !== arr.length;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    queue.push(s[i]);</span><br><span class="line">    <span class="keyword">while</span> (isRepeat(queue)) &#123;</span><br><span class="line">      queue.shift();</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">Math</span>.max(res, queue.length);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">https://leetcode.cn/problems/find-all-anagrams-in-a-string/</a><br><img src="https://pic.imgdb.cn/item/628bc6f00947543129baa39b.jpg"></p>
<p>这个题的思路和前面的差不多：滑动窗口大小固定，然后每次增加一个并弹出一个，判断内部的字符是否满足</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">p</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findAnagrams = <span class="function"><span class="keyword">function</span> (<span class="params">s, p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> index = [];</span><br><span class="line">  <span class="keyword">const</span> len = p.length;</span><br><span class="line">  <span class="keyword">const</span> A = <span class="string">&quot;a&quot;</span>.charCodeAt();</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">window</span> = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">26</span>).fill(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> need = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">26</span>).fill(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> p) &#123;</span><br><span class="line">    need[s.charCodeAt() - A]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> isEqual = <span class="function">(<span class="params">arr1, arr2</span>) =&gt;</span> arr1.join(<span class="string">&quot;&quot;</span>) === arr2.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="built_in">window</span>[s[i].charCodeAt() - A]++;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= len - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isEqual(<span class="built_in">window</span>, need)) index.push(i - len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">window</span>[s[i - len + <span class="number">1</span>].charCodeAt() - A]--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h2><blockquote>
<ol start="4">
<li>用栈实现队列，只能使用栈的 push 和 pop 方法。</li>
</ol>
</blockquote>
<p>思路是用两个栈存储，正常的入队就是 push 到 stack1；但是每次出队时，将 stack1 中的元素依次出栈再入栈到 stack2 中，这样栈底元素就被取出了；此后再次入队仍然是到 stack1 中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stack1 = [];</span><br><span class="line">    <span class="built_in">this</span>.stack2 = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">enqueue</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stack1.push(val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">dequeue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.stack2.length) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.stack1.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>.stack2.push(<span class="built_in">this</span>.stack1.pop());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack2.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">peek</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.stack2.length) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.stack1.length; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>.stack2.push(<span class="built_in">this</span>.stack1.pop());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack2[<span class="built_in">this</span>.stack2.length - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack1.length + <span class="built_in">this</span>.stack2.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>二分查找问题的基本框架：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">nums,target</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> right = nums.length - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(...<span class="comment">/*通常是left &lt;= right*/</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> mid = left + <span class="built_in">Math</span>.floor((right - left) / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums[mid] ===  target)&#123;</span><br><span class="line">      <span class="keyword">return</span> ...</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">      right = ... <span class="comment">// 这里通常是mid - 1，相当于把右边界变为中值的左边一个数</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">      left = ... <span class="comment">// 通常是mid + 1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分查找也可以写成递归形式，但是一般不需要<br>二分查找的关键就是几个细节：</p>
<ol>
<li>while 循环的边界。因为这个边界表示的是没有查找到之后的退出条件，因此要保证<code>right - left</code>区域内的空间为 0，即当 left&gt;=right 时退出。</li>
<li>mid+1 和 mid-1，这两个情况都是因为 mid 已经排除了，因此自然不需要 mid 这一项。除非有一个特殊情况，就是需要左右边界的数，可以继续取 mid 表示边界位置。</li>
</ol>
<h2 id="二分查找的边界"><a href="#二分查找的边界" class="headerlink" title="二分查找的边界"></a>二分查找的边界</h2><p>对于有重复数字的二分查找，需要找到其最左边或者最右边的值；</p>
<blockquote>
<p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。<br>如果数组中不存在目标值 target，返回  [-1, -1]。</p>
</blockquote>
<p>一个方法是，先找到目标数，然后循环找到其左右边界并返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> searchRange = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> res = [-<span class="number">1</span>, -<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">const</span> mid = left + <span class="built_in">Math</span>.floor((right - left) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] === target) &#123;</span><br><span class="line">      <span class="keyword">let</span> index = mid;</span><br><span class="line">      <span class="keyword">while</span> (nums[index] === target) &#123;</span><br><span class="line">        res[<span class="number">0</span>] = index--;</span><br><span class="line">      &#125;</span><br><span class="line">      index = mid;</span><br><span class="line">      <span class="keyword">while</span> (nums[index] === target) &#123;</span><br><span class="line">        res[<span class="number">1</span>] = index++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="寻找峰值"><a href="#寻找峰值" class="headerlink" title="寻找峰值"></a>寻找峰值</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-peak-element/">https://leetcode.cn/problems/find-peak-element/</a></p>
<blockquote>
<p>峰值元素是指其值严格大于左右相邻值的元素。<br>给你一个整数数组  nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。<br>你可以假设  nums[-1] = nums[n] = -∞ 。<br>你必须实现时间复杂度为 O(log n) 的算法来解决此问题。<br>示例 1：<br>输入：nums = [1,2,3,1]<br>输出：2<br>解释：3 是峰值元素，你的函数应该返回其索引 2。</p>
</blockquote>
<p>思路：基本解法很简单，但是这道题其实可以用二分查找优化。<br>因为只需要找出一个峰值就可以，所以可以只找一边。首先先计算一个中间值 mid</p>
<ul>
<li>如果 右边 &gt; 中间值 &gt; 左边 ，那就向右走，即相当于取右边的值为新的 left</li>
<li>如果 左边 &lt; 中间值 &lt; 右边，向左走</li>
<li>如果 左 &lt; 中间 &gt; 右，说明找到了。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findPeakElement = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.length === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> len = nums.length;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">const</span> mid = left + <span class="built_in">Math</span>.floor((right - left) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (mid === <span class="number">0</span>) nums[mid - <span class="number">1</span>] = -<span class="literal">Infinity</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid === len - <span class="number">1</span>) nums[len] = -<span class="literal">Infinity</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &gt; nums[mid - <span class="number">1</span>] &amp;&amp; nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[mid - <span class="number">1</span>] &amp;&amp; nums[mid] &lt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[mid - <span class="number">1</span>] &amp;&amp; nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt;= nums[mid - <span class="number">1</span>] &amp;&amp; nums[mid] &lt;= nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树问题的基本递归思路"><a href="#二叉树问题的基本递归思路" class="headerlink" title="二叉树问题的基本递归思路"></a>二叉树问题的基本递归思路</h2><p>二叉树问题基本上都离不开递归和遍历；<br>而递归实际上有两种，一种是单纯只递归，比如基本的递归遍历方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  dfs(node.left);</span><br><span class="line">  dfs(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种递归只有在边界条件才会返回，因此一般常用于彻底的遍历，比如路径问题。<br>在思考方式上，这种递归可以看作是只有一个左右节点的树的遍历。常常把操作放置在两个递归的<code>dfs()</code>前面、中间或后面，对应不同的时刻：</p>
<ul>
<li>前面：该节点已经遍历到，但其子节点还没开始遍历，可以进行记录该节点值、判断临界条件等操作</li>
<li>中间：只遍历了左子树，一般很少放在这里，除非是为了中序遍历</li>
<li>后面：该节点和其子树都被完全遍历。站在最顶层调用栈的角度上，这时整棵树已经遍历完毕；可以在这里显式返回一个值，这个值将会是上面每个 dfs 都会返回的值；也可以执行一些<strong>回溯</strong>相关的操作，比如路径问题中在这里让当前节点出栈、回溯问题中在这里返回上一层等等</li>
</ul>
<hr>
<p>另一种递归是显式的返回值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = dfs(node.left);</span><br><span class="line">  <span class="keyword">let</span> right = dfs(node.right);</span><br><span class="line">  <span class="keyword">return</span> node.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时前面两个递归的 dfs 也会产生有效的返回值，并且返回的值就是最末端的返回值。</p>
<p>注意要以“递归的方式思考问题”，不要把上面两个 dfs 看成复杂的调用栈，而是只把他们当作左节点和右节点的调用结果即可。</p>
<blockquote>
<p>这种遍历方式能够生效的最重要一点是：<strong>左右递归调用结果</strong>（<strong>当前节点</strong>有时候也会）都会参与返回值的运算</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = dfs(node.left);</span><br><span class="line">  <span class="keyword">let</span> right = dfs(node.right);</span><br><span class="line">  <span class="keyword">return</span> node.val + <span class="built_in">Math</span>.max(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就会把当前节点的值和左右子节点中较大的值加起来。由于自底向上的每次返回都用到了 left 和 right，因此数值就是从下向上连续的，left 和 right 可以看作是左右子树的计算结果。</p>
<p>再比如，常见的方法之一是利用返回布尔值进行一些判断。比如基本的递归搜索一个值，找到了则返回 true</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和搜索相关的问题是少都要考虑这个写法，这是最基本的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">root, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> search(root.left, val) || search(root.right, val) || root.val === val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里返回值综合了两个遍历的结果和当前节点的值，只要有一个符合条件就返回 true，即找到一个就返回 true。</p>
<p>当函数参数不止有节点这一个参数时，当前节点值还可以放入参数中。比如<code>路径总和1</code>这个题，就是通过每次递减一个当前节点值来实现。</p>
<p>还可以有条件的返回不同的值；这种方法常见于偏运算，比如只计算左叶子和这种问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = dfs(node.left);</span><br><span class="line">  dfs(node.right);</span><br><span class="line">  sum += left;</span><br><span class="line">  <span class="keyword">if</span> (!node.left &amp;&amp; !node.right) <span class="keyword">return</span> node.val;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只有当节点为叶子节点时才会返回有效的值，相当于是在遍历之中设置了回溯条件。</p>
<h2 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h2><blockquote>
<ol>
<li>用迭代方法实现二叉树的遍历</li>
</ol>
</blockquote>
<h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><ol>
<li>将根节点入栈</li>
<li>出栈，输出该节点，然后将该节点的子节点入栈，先右后左；这样出栈的顺序就是先左后右，符合先序遍历的<code>左-&gt;右-&gt;中</code>顺序</li>
<li>后续依次类推</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> preorder = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  stack.push(root);</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = stack.pop();</span><br><span class="line">    res.push(node.val);</span><br><span class="line">    <span class="keyword">if</span> (node.right) stack.push(node.right);</span><br><span class="line">    <span class="keyword">if</span> (node.left) stack.push(node.left);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><ol>
<li>同样是先入栈根节点</li>
<li>出栈，将该节点的输出插入到结果队列的头部（unshift），这样结果数组相当于是反向；然后将子节点入栈，先左后右</li>
<li>以此类推</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> postorderIterate = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">  stack.push(root);</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = stack.pop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相当于把结果数组反向了</span></span><br><span class="line">    res.unshift(node.val);</span><br><span class="line">    <span class="comment">// 因为结果数组反向,这里也要变一下</span></span><br><span class="line">    <span class="keyword">if</span> (node.left) stack.push(node.left);</span><br><span class="line">    <span class="keyword">if</span> (node.right) stack.push(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>中序遍历根另外两者都不一样，因为先序和后序都是通过出栈一个元素作为根节点，然后把它的左右子元素入栈。但是中序遍历的顺序是<code>左-&gt;中-&gt;右</code>，也就说必须有从<code>左</code>回到其父元素<code>中</code>的过程。</p>
<ol>
<li>从根节点开始迭代取左子元素，每迭代一次就入栈一个元素，直到最左端位置</li>
<li>出栈一个元素，输出结果，然后取该节点的右节点再次迭代。因为这时的出栈元素如果有右节点，说明就是一个父元素，相当于<code>中</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inorderIterate = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">  stack.push(root);</span><br><span class="line">  <span class="keyword">let</span> curr = root;</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">      stack.push(curr);</span><br><span class="line">      curr = curr.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curr = stack.pop();</span><br><span class="line">    res.push(curr.val);</span><br><span class="line">    curr = curr.right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><ol>
<li>设置一个队列，将根元素入队</li>
<li>出队队头元素并输出，把这个元素的子元素全部入队。重复这个过程，直到把上一步的所有入队元素都出队并输出；这里需要先缓存上一步时队列的长度，然后遍历这个长度直到上一层的元素都依次执行该过程。</li>
<li>依次类推</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> levelOrder = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> queue = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  queue.push(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = queue.length;</span><br><span class="line">    <span class="comment">// 相当于每次执行到这里就是新的一层</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> node = queue.shift();</span><br><span class="line">      res.push(node.val);</span><br><span class="line">      <span class="keyword">if</span> (curr.left) queue.push(curr.left);</span><br><span class="line">      <span class="keyword">if</span> (curr.right) queue.push(curr.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><blockquote>
<p><img src="https://pic.imgdb.cn/item/62675aab239250f7c5499cac.jpg"></p>
</blockquote>
<p>思路：以递归的方式，遍历树中的每一个结点，并将每一个结点的左右孩子进行交换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> invertTree = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">let</span> left = invertTree(root.left);</span><br><span class="line">  <span class="keyword">let</span> right = invertTree(root.right);</span><br><span class="line">  root.left = right;</span><br><span class="line">  root.right = left;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>翻转二叉树是这种非尾递归思想的重要体现之一；通过递归先一直到边界（即叶子节点）为止，然后返回该节点给上一层的<code>left</code>；再同理把<code>right</code>交给上一层，在上一层中进行交换，就完成了自下而上的第一次交换，后续同理。</p>
<p>比如一个通常的遍历是这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  dfs(node.left);</span><br><span class="line">  dfs(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的遍历只会在遇到边界时返回。如果我们在最后显式返回某一个值（一般就是本次递归的参数传入的节点），每一个递归就相当于拿到了其上一层的返回值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> node;</span><br><span class="line">  <span class="keyword">let</span> left = dfs(node.left); <span class="comment">// left是当前node的左子树的根节点</span></span><br><span class="line">  <span class="keyword">let</span> right = dfs(node.right); <span class="comment">// 右子树</span></span><br><span class="line">  <span class="keyword">return</span> node; <span class="comment">// 返回本节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到了 left 和 right，从递归的思维来看，实际上就是拿到了任一个节点的左右子树（不用考虑反复递归的多层，只考虑一层即可）。所以我们可以进行一些操作，比如上面的交换节点。</p>
<p>如果最简单的二叉树（只有三个节点）可以执行，那么任何情况下的二叉树都可以执行。因此这类问题可以先从最简单的考虑。如果最简单的情况可以保证递归的完整，那么之后的逻辑就不用考虑递归的内部，而是只把递归当成一个“取值”的步骤，正常处理其他逻辑。</p>
<h2 id="BST（二叉搜索树）"><a href="#BST（二叉搜索树）" class="headerlink" title="BST（二叉搜索树）"></a>BST（二叉搜索树）</h2><h3 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h3><ul>
<li>BST 的基本特点是一个根节点的左叶子一定比该节点小，右叶子一定比该节点大</li>
<li>BST 的中序遍历会返回一个从小到大的顺序排列，可以利用这一点做很多事，比如求最值等等。</li>
</ul>
<h3 id="BST-基本操作"><a href="#BST-基本操作" class="headerlink" title="BST 基本操作"></a>BST 基本操作</h3><p>查找：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">root, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (root.val === n) <span class="keyword">return</span> root;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; n) search(root.left, n);</span><br><span class="line">  <span class="keyword">else</span> search(root.right, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">root, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; root.val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root.left) root.left = <span class="keyword">new</span> TreeNode(n);</span><br><span class="line">    <span class="keyword">else</span> insert(root.left, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root.right) root.right = <span class="keyword">new</span> TreeNode(n);</span><br><span class="line">    <span class="keyword">else</span> insert(root.right, n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除：</p>
<p>删除节点的函数要返回参数 root，因为执行函数的返回值实际上是“替换子树”的效果，也是上面说的非尾递归的形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeNode</span>(<span class="params">root, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">  <span class="keyword">if</span> (root.val === n) &#123;</span><br><span class="line">    <span class="comment">// 如果n和当前节点值相等，即找到了要删除的节点</span></span><br><span class="line">    <span class="keyword">if</span> (root.left &amp;&amp; !root.right) &#123;</span><br><span class="line">      <span class="comment">//如果只有左子树，就把左子树中最大的值替换过来，并把这个节点删掉</span></span><br><span class="line">      root.val = findMax(root.left);</span><br><span class="line">      root.left = removeNode(root.left, findMax(root.left));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!root.left &amp;&amp; !root.right) &#123;</span><br><span class="line">      <span class="comment">// 没有左右子树，直接删去</span></span><br><span class="line">      root = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//只有右子树或者左右子树都有的情况，找到右子树最小的值并替换删去</span></span><br><span class="line">      root.val = findMin(root.right);</span><br><span class="line">      root.right = removeNode(root.right, findMin(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; n) &#123;</span><br><span class="line">    <span class="comment">// 如果没找到且小于，找左子树</span></span><br><span class="line">    root.left = removeNode(root.left, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    root.right = removeNode(root.right, n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最后一定要返回经过修改后的root</span></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找最大最小实际上就是找最左最右的值</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">findMax</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root.right) root = root.right;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">findMin</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root.left) root = root.left;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="验证是否是有效-BST"><a href="#验证是否是有效-BST" class="headerlink" title="验证是否是有效 BST"></a>验证是否是有效 BST</h2><p>即验证树是否保证<code>左 &lt; 中 &lt; 右</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isValidBST = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left &amp;&amp; root.left.val &gt; root.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root.right &amp;&amp; root.right.val &lt; root.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> dfs(root.left) &amp;&amp; dfs(root.right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dfs(root);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="有序数组转-BST"><a href="#有序数组转-BST" class="headerlink" title="有序数组转 BST"></a>有序数组转 BST</h2><blockquote>
<p>把有序数组转为平衡二叉树</p>
</blockquote>
<p>思路类似二分查找,把中间的数作为根节点”提起来”,然后范围二分为<code>[low,mid)</code>和<code>(mid,high]</code>分别给左右子树</p>
<p><img src="https://pic.imgdb.cn/item/62677250239250f7c582b679.jpg"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortedArrayToBST = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> buildBST(<span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buildBST</span>(<span class="params">low, high</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(low + (high - low) / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//注意这个地方需要low+...,因为不一定是从0开始的,需要low+计算值才是真正的中间值</span></span><br><span class="line">    <span class="keyword">const</span> curr = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    curr.left = buildBST(low, mid - <span class="number">1</span>);</span><br><span class="line">    curr.right = buildBST(mid + <span class="number">1</span>, high);</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>buildBST</code>方法还可以接收一个分割好的数组:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildBST</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!arr.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 这里取arr.length / 2,这样偶数元素中间值就会划分到偏后一位,防止arr.slice(0, mid - 1)在有元素的时候仍截取到空数组</span></span><br><span class="line">  <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> TreeNode(arr[mid]);</span><br><span class="line">  node.left = buildBST(arr.slice(<span class="number">0</span>, mid));</span><br><span class="line">  node.right = buildBST(arr.slice(mid + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造最大二叉树"><a href="#构造最大二叉树" class="headerlink" title="构造最大二叉树"></a>构造最大二叉树</h4><blockquote>
<p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：<br>二叉树的根是数组中的最大元素。<br>左子树是通过数组中最大值左边部分构造出的最大二叉树。<br>右子树是通过数组中最大值右边部分构造出的最大二叉树。<br>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p>
</blockquote>
<p>构造最大二叉树的思路就是在构造二叉树时，把中间节点置为数组中的最大值即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> constructMaximumBinaryTree = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> buildBST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buildBST</span>(<span class="params">nums, low, high</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> maxVal = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> maxIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = low; i &lt;= high; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; maxVal) &#123;</span><br><span class="line">        maxVal = nums[i];</span><br><span class="line">        maxIndex = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> curr = <span class="keyword">new</span> TreeNode(maxVal);</span><br><span class="line">    <span class="built_in">console</span>.log(maxVal);</span><br><span class="line">    curr.left = buildBST(nums, low, maxIndex - <span class="number">1</span>);</span><br><span class="line">    curr.right = buildBST(nums, maxIndex + <span class="number">1</span>, high);</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="判断平衡二叉树"><a href="#判断平衡二叉树" class="headerlink" title="判断平衡二叉树"></a>判断平衡二叉树</h2><p>平衡二叉树，即一个节点的左右子树高度差不能大于 1。</p>
<p>思路就是递归遍历每一个节点，计算每隔节点的左右子树高度差，如果有一个节点高度差大于 1，整体就失去平衡。</p>
<p>第一种方法是计算和遍历分开，计算节点高度是单独的方法，而遍历采用先序遍历的方式。<br>获取节点高度的方式是分别递归左右子树，每返回一次高度都会+1，最终会以左右子树中较高的为结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isBalanced = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  dfs(root);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> left = getNodeHeight(root.left);</span><br><span class="line">    <span class="keyword">let</span> right = getNodeHeight(root.right);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(left - right) &gt; <span class="number">1</span>) flag = <span class="literal">false</span>;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getNodeHeight</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(getNodeHeight(node.left), getNodeHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更好的解决方法是遍历的同时就计算高度，在递归函数末尾返回上一步得到的左右高度中较大一个+1</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isBalanced2 = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  dfs(root);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> left = dfs(root.left);</span><br><span class="line">    <span class="keyword">const</span> right = dfs(root.right);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(left - right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(left, right) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><blockquote>
<p>构造平衡二叉树.给你一棵二叉搜索树，请你返回一棵平衡后的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。</p>
</blockquote>
<p>思路就是<strong>中序遍历</strong>获取数的数组形式,然后用上面的有序数组转为平衡二叉树方法即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> balanceBST = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> nums = [];</span><br><span class="line"></span><br><span class="line">  inorder(root);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inorder</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    inorder(node.left);</span><br><span class="line">    nums.push(node.val);</span><br><span class="line">    inorder(node.right);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tree = buildBST(nums);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buildBST</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> TreeNode(arr[mid]);</span><br><span class="line">    node.left = buildBST(arr.slice(<span class="number">0</span>, mid));</span><br><span class="line">    node.right = buildBST(arr.slice(mid + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tree;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="比较两棵二叉树"><a href="#比较两棵二叉树" class="headerlink" title="比较两棵二叉树"></a>比较两棵二叉树</h2><blockquote>
<p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
</blockquote>
<p>思路：递归比较两棵树的左、右子树即可。如果两棵树完全相等，则 p 和 q 应当是完全相同的，只要有一个对不上就是 false</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isSameTree = <span class="function"><span class="keyword">function</span> (<span class="params">p, q</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((q &amp;&amp; !p) || (p &amp;&amp; !q) || p.val !== q.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树轴对称"><a href="#二叉树轴对称" class="headerlink" title="二叉树轴对称"></a>二叉树轴对称</h2><blockquote>
<p>给你一个二叉树的根节点 root，检查它是否轴对称。</p>
</blockquote>
<p>这道题和翻转二叉树思路近似，从<code>root.left</code>和<code>root.right</code>分开，分别递归比较左子树的右节点和右子树的左节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">p, q</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> ((!p &amp;&amp; q) || (!q &amp;&amp; p) || p.val !== q.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><blockquote>
<p>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
</blockquote>
<p>这道题就是求节点高度，递归遍历每一个节点，每次遍历都给返回值+1，并选择左右子树中较大的一个。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = maxDepth(root.left);</span><br><span class="line">  <span class="keyword">let</span> right = maxDepth(root.right);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这道题还有一个变种，就是求一个节点的最小深度。注意最小深度仍然是到叶子节点的，不能在空节点就停下，因此需要判断左右子节点的高度，不为 0 才返回：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minDepth = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = minDepth(root.left);</span><br><span class="line">  <span class="keyword">let</span> right = minDepth(root.right);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (left === <span class="number">0</span> &amp;&amp; right &gt; <span class="number">0</span>) <span class="keyword">return</span> right + <span class="number">1</span>; <span class="comment">// 左节点为空</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; <span class="number">0</span> &amp;&amp; right === <span class="number">0</span>) <span class="keyword">return</span> left + <span class="number">1</span>; <span class="comment">// 右节点为空</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Math</span>.min(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的路径问题"><a href="#二叉树的路径问题" class="headerlink" title="二叉树的路径问题"></a>二叉树的路径问题</h2><p>这里可以参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-ii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-oo63/">https://leetcode-cn.com/problems/path-sum-ii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-oo63/</a></p>
<p>路径问题可以分为两大类</p>
<ul>
<li>自顶向下，从某一个节点(不一定是根节点)，从上向下寻找路径，到某一个节点(不一定是叶节点)结束。方法类似，在每次遍历中记录路径，当遍历到合适条件时输出结果，再在每次递归的最尾端执行复原操作（比如出栈、总和减去当前值等等）。</li>
</ul>
<blockquote>
<p>其实这是一种回溯，路径记录之后要返回上一层，因此就在函数的最尾端执行复原操作</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  path.push(node.val);</span><br><span class="line">  <span class="keyword">if</span> (临界条件) &#123;</span><br><span class="line">    res.push(path);</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(node.left);</span><br><span class="line">  dfs(node.right);</span><br><span class="line">  path.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>

<p>如果要求有路径和，一般是把目标值放在最顶端，然后自顶向下每次遍历都减去当前节点值，直到减为 0 或者其他临界条件为止。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node, sum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  path.push(node.val);</span><br><span class="line">  sum -= node.val;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">    res.push(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dfs(node.left, sum);</span><br><span class="line">  dfs(node.right, sum);</span><br><span class="line">  path.pop();</span><br><span class="line">&#125;</span><br><span class="line">dfs(root, targetNum);</span><br></pre></td></tr></table></figure>

<ul>
<li>非自顶向下：就是从任意节点到任意节点的路径，不需要自顶向下。<br>这种一般比较麻烦，除了从上到下的基本顺序，还有可能是横着的甚至倒着的路径。</li>
</ul>
<p>这类题目一般解题思路如下：<br>设计一个辅助函数 maxpath，调用自身求出以一个节点为根节点的左侧最长路径 left 和右侧最长路径 right，那么经过该节点的最长路径就是 <code>left+right</code><br>接着只需要从根节点开始 dfs,不断比较更新全局变量即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = -<span class="literal">Infinity</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxPath</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = maxPath(node.left);</span><br><span class="line">  <span class="keyword">let</span> right = maxPath(node.right);</span><br><span class="line">  res = <span class="built_in">Math</span>.max(res, node.val + left + right);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(left, right) + node.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>left,right 代表的含义要根据题目所求设置，比如最长路径、最大路径和等等</li>
<li>全局变量 res 的初值设置是 0 还是<code>-Infinity</code>要看题目节点是否存在负值，如果存在就用<code>-Infinity</code>，否则就是 0</li>
</ol>
<h3 id="路径问题-1（目标和）"><a href="#路径问题-1（目标和）" class="headerlink" title="路径问题 1（目标和）"></a>路径问题 1（目标和）</h3><blockquote>
<p>给你二叉树的根节点  root 和一个表示目标和的整数  targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和  targetSum 。如果存在，返回 true ；否则，返回 false</p>
</blockquote>
<p>路径问题最基本的一道题，好好背就完事了。<br>思路就是：把总和依次相减下来，每到一个节点就减去当前节点的值，直到叶子节点判断是否等于叶子节点的值，<br>如果等于说明一路上减去的值加起来正好就是 targetSum</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasPathSum = <span class="function"><span class="keyword">function</span> (<span class="params">root, targetSum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (!root.left &amp;&amp; !root.right) &#123;</span><br><span class="line">    <span class="keyword">return</span> targetSum === root.val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    hasPathSum(root.left, targetSum - root.val) ||</span><br><span class="line">    hasPathSum(root.right, targetSum - root.val)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另外一个方法是先序遍历时判断，思路差不多：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasPathSum = <span class="function"><span class="keyword">function</span> (<span class="params">root, targetSum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node, num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!node.left &amp;&amp; !node.right &amp;&amp; num === node.val) flag = <span class="literal">true</span>;</span><br><span class="line">    dfs(node.left, num - node.val);</span><br><span class="line">    dfs(node.right, num - node.val);</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(root, targetSum);</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="路径问题-2（具体路径）"><a href="#路径问题-2（具体路径）" class="headerlink" title="路径问题 2（具体路径）"></a>路径问题 2（具体路径）</h3><p>这道题是上一个的升级版，要求求出具体路径</p>
<p>思路在上面的解析中已经有过，就是记录路径，在递归结束时弹出当前节点，并在条件合适时记录路径。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pathSum = <span class="function"><span class="keyword">function</span> (<span class="params">root, targetSum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> path = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  dfs(root, targetSum);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node, sum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    path.push(node.val);</span><br><span class="line">    sum -= node.val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!node.left &amp;&amp; !node.right &amp;&amp; sum === <span class="number">0</span>) &#123;</span><br><span class="line">      res.push(path);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(node.left, sum);</span><br><span class="line">    dfs(node.right, sum);</span><br><span class="line">    <span class="comment">// 这个位置是当前节点的左右子树都遍历完了；</span></span><br><span class="line">    <span class="comment">// 如果是叶子节点，上面两个递归都会直接返回，然后pop出叶子节点</span></span><br><span class="line">    <span class="comment">// 如果不是叶子节点，相当于把左右子树记录完成了，这时应该返回上一层了，执行pop</span></span><br><span class="line">    <span class="comment">// 要在这里pop</span></span><br><span class="line">    path.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="路径问题-3（任意节点开始）"><a href="#路径问题-3（任意节点开始）" class="headerlink" title="路径问题 3（任意节点开始）"></a>路径问题 3（任意节点开始）</h3><blockquote>
<p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
</blockquote>
<p>这道题有两种解法，最好想的就是二重递归：</p>
<ul>
<li>第一重递归遍历所有节点</li>
<li>然后对于每个节点，执行路径问题 1 的算法</li>
</ul>
<p>方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pathSum = <span class="function"><span class="keyword">function</span> (<span class="params">root, sum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">0</span>, <span class="number">1</span>]]);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    prefix += node.val;</span><br><span class="line">    <span class="keyword">if</span> (map.has(prefix - sum)) &#123;</span><br><span class="line">      res += map.get(prefix - sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!map.has(prefix)) map.set(prefix, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> map.set(prefix, map.get(prefix) + <span class="number">1</span>);</span><br><span class="line">    dfs(node.left);</span><br><span class="line">    dfs(node.right);</span><br><span class="line">    prefix -= node.val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> prefix = <span class="number">0</span>;</span><br><span class="line">  dfs(root);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还有一种方法是使用<strong>前缀和</strong>，但是比较麻烦，没太看懂，参考<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-iii/solution/lu-jing-zong-he-iii-by-leetcode-solution-z9td/">https://leetcode-cn.com/problems/path-sum-iii/solution/lu-jing-zong-he-iii-by-leetcode-solution-z9td/</a></p>
<blockquote>
<p>前缀和还是先搞清一维数组的前缀和把</p>
</blockquote>
<h3 id="最大路径和"><a href="#最大路径和" class="headerlink" title="最大路径和"></a>最大路径和</h3><blockquote>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。<br>路径和 是路径中各节点值的总和。<br>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。<br>同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点</p>
</blockquote>
<p>这个是上面说的非自顶向下的典型例题，方法也是参考那个的，但是稍有改动：</p>
<ul>
<li>节点有负值，加上一个负值会对最大路径和起到反作用，因此如果左右路径和为负数就不选取（即取 0，和空节点的情况一样）</li>
<li><code>路径</code> 一定是先上升（ 0 ～ n 个）节点, 到达顶点, 后下降（ 0 ～ n 个）节点；因此表现出来就是<code>node.val + left + right</code></li>
</ul>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxPathSum = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = -<span class="literal">Infinity</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">maxPath</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="built_in">Math</span>.max(maxPath(node.left), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> right = <span class="built_in">Math</span>.max(maxPath(node.right), <span class="number">0</span>);</span><br><span class="line">    res = <span class="built_in">Math</span>.max(res, node.val + left + right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(left, right) + node.val;</span><br><span class="line">  &#125;</span><br><span class="line">  maxPath(root);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树左叶子之和"><a href="#二叉树左叶子之和" class="headerlink" title="二叉树左叶子之和"></a>二叉树左叶子之和</h2><blockquote>
<p>计算给定二叉树的所有左叶子之和。</p>
</blockquote>
<p>注意是左叶子，因此不能包括树枝节点；所以可以利用遍历找到包含左叶子的节点，加上这个节点即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sumOfLeftLeaves = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left) sum += root.left.val;</span><br><span class="line">    dfs(node.left);</span><br><span class="line">    dfs(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(root);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树最值"><a href="#二叉树最值" class="headerlink" title="二叉树最值"></a>二叉树最值</h2><p>怎么求一个二叉树的最值？</p>
<p>对于一个普通的二叉树，求最大值的方法就是简单的递归：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(dfs(node.left), dfs(node.right), node.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是 BST，BST 的一个特点的<strong>中序排列的输出结果是一个递增序列</strong>。即第 n 次到输出位置时，恰好是第 n 个最小的数字。<br>如果希望是一个倒序的输出，调换两个递归的位置即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  dfs(node.left);</span><br><span class="line">  res.push(node.val);</span><br><span class="line">  dfs(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><blockquote>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>
<p>思路：记住满足条件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lson = dfs(root.left, p, q);</span><br><span class="line"><span class="keyword">const</span> rson = dfs(root.right, p, q);</span><br><span class="line">(lson &amp;&amp; rson) ||</span><br><span class="line">  ((root.val === p.val || root.val === q.val) &amp;&amp; (lson || rson));</span><br></pre></td></tr></table></figure>

<p>解释： 0. 首先明确递归的返回值：指<strong>在该树中是否存在 p 或者 q 的一个或多个</strong></p>
<ol>
<li>如果 p 和 q 分别位于左子树和右子树中，那么<code>lson &amp;&amp; rson</code>一定为 true，说明两边至少包含 p 和 q 的一个；</li>
<li>如果 p 或 q 的一个是当前节点本身，那么值肯定相等，并且自己的左子树和右子树至少要有一个包含另一个节点。</li>
</ol>
<p>判断之后，最后返回的值应该是：</p>
<ol>
<li>判断自己和这个 p 和 q 之一是否相等，因为如果有一个相等就必然为 true（一定包含 q 或 p）</li>
<li>判断自己的子树情况，即<code>lson || rson</code>，因为递归条件是只要有一个包含就行，因此两个有一个为 true 就行</li>
</ol>
<p>最终代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="function"><span class="keyword">function</span> (<span class="params">root, p, q</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ans;</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">root, p, q</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> lson = dfs(root.left, p, q);</span><br><span class="line">    <span class="keyword">const</span> rson = dfs(root.right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      (lson &amp;&amp; rson) ||</span><br><span class="line">      ((root.val === p.val || root.val === q.val) &amp;&amp; (lson || rson))</span><br><span class="line">    ) &#123;</span><br><span class="line">      ans = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lson || rson || root.val === p.val || root.val === q.val;</span><br><span class="line">  &#125;;</span><br><span class="line">  dfs(root, p, q);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="从前序遍历和中序遍历构造二叉树"><a href="#从前序遍历和中序遍历构造二叉树" class="headerlink" title="从前序遍历和中序遍历构造二叉树"></a>从前序遍历和中序遍历构造二叉树</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>
<p>思路：</p>
<ul>
<li>前序遍历的第一个节点是整个二叉树的根元素</li>
<li>中序遍历从根元素划分，左右两半数组恰好是左右子树的中序遍历</li>
</ul>
<p>因此通过前序遍历划分左右子树的前序、先序遍历，再依次递归即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">preorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">inorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span> (<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!inorder.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">const</span> tmp = preorder[<span class="number">0</span>]; <span class="comment">// 前序的第一项，即根元素</span></span><br><span class="line">  <span class="keyword">const</span> mid = inorder.indexOf(tmp); <span class="comment">// 获取根元素所在的位置</span></span><br><span class="line">  <span class="comment">// 因为前序和中序的左右子树长度一定一样，所以preorder也可以用mid+1划分</span></span><br><span class="line">  root.left = buildTree(preorder.slice(<span class="number">1</span>, mid + <span class="number">1</span>), inorder.slice(<span class="number">0</span>, mid));</span><br><span class="line">  root.right = buildTree(preorder.slice(mid + <span class="number">1</span>), inorder.slice(mid + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="回溯问题的基本思路"><a href="#回溯问题的基本思路" class="headerlink" title="回溯问题的基本思路"></a>回溯问题的基本思路</h2><blockquote>
<p>回溯问题常见于题目中这样要求：找出所有情况、找出所有排列组合、遍历所有情况、走过所有格子等等。</p>
</blockquote>
<p>参考<br><a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB%E5%A4%A7%E7%BA%B2%E5%A6%82%E4%B8%8B">https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB%E5%A4%A7%E7%BA%B2%E5%A6%82%E4%B8%8B</a></p>
<p>上面的回溯说到回溯问题的基本模板是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xxx</span>(<span class="params">入参</span>) </span>&#123;</span><br><span class="line">  前期的变量定义、缓存等准备工作</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义路径栈</span></span><br><span class="line">  <span class="keyword">const</span> path = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进入 dfs</span></span><br><span class="line">  dfs(起点)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义 dfs</span></span><br><span class="line">  <span class="function"><span class="title">dfs</span>(<span class="params">递归参数</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(到达了递归边界) &#123;</span><br><span class="line">      结合题意处理边界逻辑，往往和 path 内容有关</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里也可能不是 for，视题意决定</span></span><br><span class="line">    <span class="keyword">for</span>(遍历坑位的可选值) &#123;</span><br><span class="line">      path.push(当前选中值)</span><br><span class="line">      处理坑位本身的相关逻辑,一般就是递归</span><br><span class="line">      path.pop()<span class="comment">// 这里让已经选中的值退出，相当于树回退一层</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上这并不是一种生硬的模板，而是对应了回溯问题的基本形状：<strong>迭代表示同一层的横向展开，递归表示纵向的遍历</strong></p>
<p>根据前面 dfs 的经验，我们把递归只看成是一个简单的访问语句：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">dfs</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  递归边界</span><br><span class="line">  <span class="keyword">for</span>(i)&#123;</span><br><span class="line">    path.push(当前选中值)</span><br><span class="line">    访问第(i+<span class="number">1</span>)个</span><br><span class="line">    path.pop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，迭代的部分实际上就是将所有情况横向展开，也就是<strong>树的分叉</strong>；迭代几次也就对应根节点展开了几个枝；这也是通过限制迭代次数从而避免重复的原因。</p>
<blockquote>
<p><img src="https://pic.imgdb.cn/item/626a9a55239250f7c5e9286e.jpg"><br>迭代实际上就是这部分</p>
</blockquote>
<p>而递归则是<strong>纵向</strong>的延伸；和二叉树问题类似，递归的每一项可以看作是一个子节点的产生，而递归语句旁边的<code>path.push</code>和<code>path.pop</code>操作也正是对应了递归路径的记录和回溯。回溯的关键并不是循环，而是结尾的<code>pop()</code>，也就是状态的恢复；</p>
<p>理解了这两个地方，就可以理解各种其他问题中<strong>去重</strong>的方式和原因。</p>
<ol>
<li>所选序列是否重复按照出现次数区分，比如<code>[1,2,1]</code>和<code>[1,1,2]</code>没有区别；<br>这种通常限制迭代的<strong>起始位置</strong>。上面说到迭代就是树枝的展开，那如果让迭代每次从上一层位置的下一个元素展开，就可以避免重复一遍上一层的操作。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">val, begin</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//递归边界</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = begin; i &lt; xxx.length; i++) &#123;</span><br><span class="line">    path.push();</span><br><span class="line">    dfs(val, i); <span class="comment">// i作为下一个的begin</span></span><br><span class="line">    path.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>纵向不能重复；限制同一结果中元素出现个数，比如全排列问题，不允许出现<code>[1,1,2]</code>这样有重复数字的元素。<br>这种是限制每次迭代的元素；因为回溯问题的解通常就是若干个 dfs 的<strong>路径</strong>；通过记录某个元素被使用过，就可以避免反复迭代同一个元素：<br>每次迭代到一个元素时，如果该元素已经被记录访问过，就会跳到下一个元素。注意这种方法是去重<strong>垂直</strong>方向的，即 visited 数组横向独立、纵向统一</li>
</ol>
<blockquote>
<p>visited 通常存的是对应的索引，表示同一索引（位置）的元素不能被重复使用。如果想要同一个值的元素不能重复使用，就应该用方法 3</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//递归边界</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; xxx.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">      path.push();</span><br><span class="line">      visited[i] = <span class="literal">true</span>;</span><br><span class="line">      dfs(val); <span class="comment">// i作为下一个的begin</span></span><br><span class="line">      path.pop();</span><br><span class="line">      visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>横向不能重复，限制所有结果中相同值的重复，即不能有<code>[[1,2,2],[1,2,2]]</code>这样两个相同的元素，但是元素内部仍然可以重复。</li>
</ol>
<p>判断方法条件为：<code>nums[i] === nums[i - 1]</code>和<code>i &gt; 0</code>，以及<code>visited[nums[i - 1]] === false</code>，满足这三个条件时就应当跳过。</p>
<ul>
<li><code>nums[i] === nums[i - 1]</code>：当前值和前一个不能相同，即横向规定不能有重复值</li>
<li><code>visited[nums[i - 1]] === false</code>：这个很重要，是判断上一个条件是横向重复还是纵向重复；因为上一个条件既有可能是横向重复，也可以是纵向的重复；因此当这个条件为 true 时，即上一个值已经被访问过了，说明是纵向重复；反之则是横向重复。<strong>该条件===true 判断纵向重复，==false 判断横向重复</strong></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/626ab4ee239250f7c5375bd0.jpg"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">//！！！一定要先排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//递归边界</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; xxx.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!visited[nums[i - <span class="number">1</span>]] &amp;&amp; nums[i] === nums[i - <span class="number">1</span>] &amp;&amp; i &gt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (!visited) path.push();</span><br><span class="line">    visited[nums[i]] = <span class="literal">true</span>;</span><br><span class="line">    dfs(val); <span class="comment">// i作为下一个的begin</span></span><br><span class="line">    path.pop();</span><br><span class="line">    visited[nums[i]] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者综合第一种 begin 的方式；当<code>i &gt; begin</code>时，相当于当前遍历的位置是其他同层元素，和<code>visited[nums[i - 1]] === false</code>效果相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; begin &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>

<h3 id="特殊回溯问题"><a href="#特殊回溯问题" class="headerlink" title="特殊回溯问题"></a>特殊回溯问题</h3><p>回溯问题的模板不一定都是递归+迭代这种类型的。有些情况下并不需要迭代。<br>迭代的核心目标是把所有情况都放入递归中执行一次，以达到遍历所有情况的目的；当一个回溯问题只有少数几种（通常是两种）情况时，就不需要迭代来遍历了。同样，如果递归的情况不能通过迭代线性展开（比如岛屿问题），也不需要。<br>总之回溯问题的核心部分其实还是<strong>递归</strong>和<strong>状态恢复</strong>，其他的地方都是在为这两个核心提供帮助。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">...</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(...) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 状态改变</span></span><br><span class="line">  <span class="keyword">if</span>(...) dfs(...)</span><br><span class="line">  <span class="keyword">else</span> dfs(...)</span><br><span class="line">  <span class="comment">// 状态恢复</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体题目"><a href="#具体题目" class="headerlink" title="具体题目"></a>具体题目</h3><p>具体题目参考<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problem-list/QS1BC1f6/%EF%BC%8C%E5%9F%BA%E6%9C%AC%E9%83%BD%E5%81%9A%E4%BA%86%EF%BC%8C%E5%B0%91%E6%95%B0%E6%B2%A1%E6%9C%89%E7%9A%84%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83">https://leetcode-cn.com/problem-list/QS1BC1f6/，基本都做了，少数没有的也可以参考</a><a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">代码随想录</a></p>
<h2 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h2><h3 id="基本全排列"><a href="#基本全排列" class="headerlink" title="基本全排列"></a>基本全排列</h3><blockquote>
<p>给定一个没有重复数字的序列，返回其所有可能的全排列。<br>示例：<br>输入: [1,2,3]<br>输出: [<br>[1,2,3],<br>[1,3,2],<br>[2,1,3],<br>[2,3,1],<br>[3,1,2],<br>[3,2,1]<br>]</p>
</blockquote>
<p>像全排列这样的穷举，或者有一定限制的穷举，都可以用 DFS、递归回溯的思想。</p>
<p>这类问题的特点都是，穷举之中有不变化的部分；比如全排列问题不变的是三个数字的位置。三个位置可能是 1/2/3 任意一个数字，这样就可以构建出一个树：<br><img src="https://pic.imgdb.cn/item/6266c1cc239250f7c554635b.jpg"></p>
<p>然后按照树的先序遍历方式，就可以得到结果。当然并不需要构造一棵树。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> permute = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存数组的长度</span></span><br><span class="line">  <span class="keyword">const</span> len = nums.length;</span><br><span class="line">  <span class="comment">// curr 变量用来记录当前的排列内容</span></span><br><span class="line">  <span class="keyword">const</span> curr = [];</span><br><span class="line">  <span class="comment">// res 用来记录所有的排列顺序</span></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="comment">// visited 用来避免重复使用同一个数字</span></span><br><span class="line">  <span class="keyword">const</span> visited = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 定义 dfs 函数，入参是坑位的索引（从 0 计数）</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">nth</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 若遍历到了不存在的坑位（第 len+1 个），则触碰递归边界返回</span></span><br><span class="line">    <span class="keyword">if</span> (nth === len) &#123;</span><br><span class="line">      <span class="comment">// 此时前 len 个坑位已经填满，将对应的排列记录下来</span></span><br><span class="line">      res.push(curr.slice());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查手里剩下的数字有哪些</span></span><br><span class="line">    <span class="comment">// 循环套递归是常见的形式,循环的作用就是让DFS过程能&quot;返回&quot;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="comment">// 若 nums[i] 之前没被其它坑位用过，则可以理解为“这个数字剩下了”</span></span><br><span class="line">      <span class="keyword">if</span> (!visited[nums[i]]) &#123;</span><br><span class="line">        <span class="comment">// 给 nums[i] 打个“已用过”的标</span></span><br><span class="line">        visited[nums[i]] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 将nums[i]推入当前排列</span></span><br><span class="line">        curr.push(nums[i]);</span><br><span class="line">        <span class="comment">// 基于这个排列继续往下一个坑走去</span></span><br><span class="line">        dfs(nth + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// nums[i]让出当前坑位</span></span><br><span class="line">        curr.pop();</span><br><span class="line">        <span class="comment">// 下掉“已用过”标识</span></span><br><span class="line">        visited[nums[i]] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从索引为 0 的坑位（也就是第一个坑位）开始 dfs</span></span><br><span class="line">  dfs(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码很奇怪的地方是有一个“循环套递归”，并且递归的前后恰好是入栈、出栈结果的时候。</p>
<p>其实这正是这类题的“模板解法”。在递归产生的不同函数上下文中，每个的遍历次数不同。<br>以这道题为例，当 dfs 执行到第三个时，前两个的上下文的遍历次数分别是 1、2；这时当第三个返回时，上一个的循环还会执行一次，就相当于从树的底部“退回”了一个位置，并把 3 这个数字让了出来。</p>
<p>因此这类穷举相关的题目有一个通用模板，遇到这种问题可以先试着套一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xxx</span>(<span class="params">入参</span>) </span>&#123;</span><br><span class="line">  前期的变量定义、缓存等准备工作</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义路径栈</span></span><br><span class="line">  <span class="keyword">const</span> path = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进入 dfs</span></span><br><span class="line">  dfs(起点)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义 dfs</span></span><br><span class="line">  <span class="function"><span class="title">dfs</span>(<span class="params">递归参数</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(到达了递归边界) &#123;</span><br><span class="line">      结合题意处理边界逻辑，往往和 path 内容有关</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里也可能不是 for，视题意决定</span></span><br><span class="line">    <span class="keyword">for</span>(遍历坑位的可选值) &#123;</span><br><span class="line">      path.push(当前选中值)</span><br><span class="line">      处理坑位本身的相关逻辑,一般就是递归</span><br><span class="line">      path.pop()<span class="comment">// 这里让已经选中的值退出，相当于树回退一层</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全排列-2（剪枝）"><a href="#全排列-2（剪枝）" class="headerlink" title="全排列 2（剪枝）"></a>全排列 2（剪枝）</h3><blockquote>
<p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。<br>示例 1：<br>输入：nums = [1,1,2]<br>输出：<br>[[1,1,2],<br> [1,2,1],<br> [2,1,1]]</p>
</blockquote>
<p>这个题和全排列 1 的区别在于，每个结果允许数组内的数字重复，即给定的 nums 中有重复的数字。<br>因此这是一个横向剪枝的问题，即在保证一个数字不会纵向重复的情况下，进行横向剪枝去掉可能重复的组合。<br><img src="https://pic.imgdb.cn/item/628108d109475431293e2fd6.png"></p>
<p>利用上面说的去重的第三种方法即可。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permuteUnique = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> curr = []; <span class="comment">// 当前排列</span></span><br><span class="line">  <span class="keyword">const</span> res = []; <span class="comment">// 结果数组</span></span><br><span class="line">  <span class="keyword">const</span> visit = &#123;&#125;;</span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">  dfs(<span class="number">0</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index === nums.length) &#123;</span><br><span class="line">      res.push([...curr]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>] &amp;&amp; !visit[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (!visit[i]) &#123;</span><br><span class="line">        visit[i] = <span class="literal">true</span>;</span><br><span class="line">        curr.push(nums[i]);</span><br><span class="line">        dfs(index + <span class="number">1</span>);</span><br><span class="line">        curr.pop();</span><br><span class="line">        visit[i] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><h3 id="基本组合问题"><a href="#基本组合问题" class="headerlink" title="基本组合问题"></a>基本组合问题</h3><blockquote>
<p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。<br>示例:<br>输入: n = 4, k = 2<br>输出:<br>[<br>[2,4],<br>[3,4],<br>[2,3],<br>[1,2],<br>[1,3],<br>[1,4],<br>]</p>
</blockquote>
<p>最基本的组合问题，当递归次数等于 k 时记录即可。<br>因为同一个位置上的数字不能用多次，因此需要纵向剪枝；并且同样开头的数字也只能统计一次，所以需要起始序号剪枝。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combine = <span class="function"><span class="keyword">function</span> (<span class="params">n, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> curr = [];</span><br><span class="line">  <span class="keyword">const</span> nums = [];</span><br><span class="line">  <span class="keyword">const</span> visit = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// 创建数组</span></span><br><span class="line">    nums[i] = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> times = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">nth, begin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nth === k) &#123;</span><br><span class="line">      res.push([...curr]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = begin; i &lt; nums.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!visit[i]) &#123;</span><br><span class="line">        curr.push(nums[i]);</span><br><span class="line">        visit[i] = <span class="literal">true</span>;</span><br><span class="line">        times++;</span><br><span class="line">        dfs(times, i);</span><br><span class="line">        times--;</span><br><span class="line">        visit[i] = <span class="literal">false</span>;</span><br><span class="line">        curr.pop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="组合总合"><a href="#组合总合" class="headerlink" title="组合总合"></a>组合总合</h3><blockquote>
<p>给你一个 无重复元素 的整数数组  candidates 和一个目标整数  target ，找出 candidates  中可以使数字和为目标数  target 的 所有   不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。<br>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p>
</blockquote>
<p>基本组合问题，设定一个 sum 变量每次传入，每次加上当前值，当 sum 值等于 target 时记录。</p>
<p>因为同一个数可以选多次，因此纵向不需要剪枝，只需要起始序号剪枝即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">candidates</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combinationSum = <span class="function"><span class="keyword">function</span> (<span class="params">candidates, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> curr = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">sum, begin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">      res.push([...curr]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = begin; i &lt; candidates.length; i++) &#123;</span><br><span class="line">      curr.push(candidates[i]);</span><br><span class="line">      sum += candidates[i];</span><br><span class="line">      dfs(sum, i);</span><br><span class="line">      sum -= candidates[i];</span><br><span class="line">      curr.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="组合总和-2"><a href="#组合总和-2" class="headerlink" title="组合总和 2"></a>组合总和 2</h3><blockquote>
<p>给定一个候选人编号的集合  candidates  和一个目标数  target ，找出  candidates  中所有可以使数字和为  target  的组合。<br>candidates  中的每个数字在每个组合中只能使用   一次  。解集不能包含重复的组合。</p>
</blockquote>
<p>显然和上一个的区别在于每个数字在每个组合中只能使用一次，但是每个组合中允许重复数字，最终结果不允许有重复组合；</p>
<p>因此使用第三种剪枝就可以</p>
<p>这道题有一个特殊的解法，就是使用一个 prev 变量保存前一个的值；如果前一个值和当前<code>candidates[i]</code>相等，就直接跳过。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">candidates</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combinationSum2 = <span class="function"><span class="keyword">function</span> (<span class="params">candidates, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> curr = [];</span><br><span class="line">  <span class="keyword">const</span> visited = &#123;&#125;;</span><br><span class="line">  candidates.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">sum, begin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">      res.push([...curr]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> prev = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = begin; i &lt; candidates.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (candidates[i] === prev) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//这里使用第三种剪枝也可以</span></span><br><span class="line">      <span class="comment">// if (candidates[i] === candidates[i-1] &amp;&amp; i &gt; begin &amp;&amp; !visited[i - 1]) continue</span></span><br><span class="line">      <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">        visited[i] = <span class="literal">true</span>;</span><br><span class="line">        curr.push(candidates[i]);</span><br><span class="line">        sum += candidates[i];</span><br><span class="line">        prev = candidates[i];</span><br><span class="line">        dfs(sum, i);</span><br><span class="line">        sum -= candidates[i];</span><br><span class="line">        curr.pop();</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h2><blockquote>
<p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的不重复子集</p>
</blockquote>
<p>首先先按照树形思维构建；这道题中不变的部分是是否选中某个数字。</p>
<p>比如选中 1、不选 2、选中 3，那么结果就是[1,3]，依次类推就是所有选择。树的两个叶子分别代表选或不选该层对应的数字，每一层恰好就是这个数字。</p>
<p><img src="https://pic.imgdb.cn/item/6266c73d239250f7c5647e11.jpg"></p>
<p>按照上面的模板，可以尝试构建如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> subsets = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ans = [];</span><br><span class="line">  <span class="keyword">const</span> curr = [];</span><br><span class="line"></span><br><span class="line">  dfs(<span class="number">0</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 每次进入，都意味着组合内容更新了一次，故直接推入结果数组</span></span><br><span class="line">    ans.push(curr.slice());</span><br><span class="line">    <span class="comment">// 从当前数字的索引开始，遍历 nums</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 这是当前数字存在于组合中的情况</span></span><br><span class="line">      curr.push(nums[i]);</span><br><span class="line">      <span class="comment">// 基于当前数字存在于组合中的情况，进一步 dfs</span></span><br><span class="line">      dfs(i + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 这是当前数字不存在与组合中的情况</span></span><br><span class="line">      curr.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意这道题虽然有显式的递归边界（遍历三层），但是其实并不需要，因为循环直接从当前的 index（即树的层数）开始，跳过了前面的情况。</p>
<p>如果我们再给这个解法显式加上一个递归条件，比如规定<code>curr.length &lt; k</code>，这就是一种“回溯”，即到达某种情况后就提前返回，并不是每次都遍历完。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> combine = <span class="function"><span class="keyword">function</span> (<span class="params">n, k</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化结果数组</span></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="comment">// 初始化组合数组</span></span><br><span class="line">  <span class="keyword">const</span> subset = [];</span><br><span class="line">  <span class="comment">// 进入 dfs，起始数字是1</span></span><br><span class="line">  dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义 dfs 函数，入参是当前遍历到的数字</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (subset.length === k) &#123;</span><br><span class="line">      res.push(subset.slice());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从当前数字的值开始，遍历 index-n 之间的所有数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="comment">// 这是当前数字存在于组合中的情况</span></span><br><span class="line">      subset.push(i);</span><br><span class="line">      <span class="comment">// 基于当前数字存在于组合中的情况，进一步 dfs</span></span><br><span class="line">      dfs(i + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 这是当前数字不存在与组合中的情况</span></span><br><span class="line">      subset.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回结果数组</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="分割问题"><a href="#分割问题" class="headerlink" title="分割问题"></a>分割问题</h2><p>分割问题是变种的回溯问题；常见回溯问题一般是记录路径，累加求值；但是分割问题通常是把字符串分割递归下去。<br>具体来说，分割问题的通常思路如下：</p>
<ol>
<li>在迭代中，从某一项开始取前 i 个字符</li>
<li>判断该字符是否符合要求</li>
</ol>
<ul>
<li>不符合，继续迭代</li>
<li>符合，把分割后剩下的串传递下去。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">str, times</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (临界条件) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> part = str.slice(<span class="number">0</span>, i);</span><br><span class="line">    <span class="keyword">if</span> (isValid(part)) &#123;</span><br><span class="line">      curr.push(part);</span><br><span class="line">      dfs(str.slice(i + <span class="number">1</span>)); <span class="comment">// 把分割后剩下的继续递归分割</span></span><br><span class="line">      curr.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h3><blockquote>
<p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。<br>返回 s 所有可能的分割方案。<br>示例: 输入: “aab” 输出: [ [“aa”,”b”], [“a”,”a”,”b”] ]</p>
</blockquote>
<p>思路：先切割子串，对每个子串判断回文，如果回文就记录。</p>
<p>关键是切割字串的方法。切割子串思路和回溯记录路径类似：</p>
<ol>
<li>遍历每一项，把整个子串先从头到最后一个切割</li>
<li>如果子串是回文串，就记录，并且把<strong>切割之后剩下的部分</strong>递归下去。<br>思路可以参考这张图：<br><img src="https://pic.imgdb.cn/item/6281198609475431297e2c6e.jpg"></li>
</ol>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> partition = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> curr = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> visit = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str === <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">      res.push([...curr]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> part = str.slice(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (isPalindrome(part)) &#123;</span><br><span class="line">        curr.push(part);</span><br><span class="line">        dfs(str.slice(i + <span class="number">1</span>));</span><br><span class="line">        curr.pop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dfs(s);</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> strArr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> j = strArr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (strArr[i] === strArr[j]) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="有效-ip-地址"><a href="#有效-ip-地址" class="headerlink" title="有效 ip 地址"></a>有效 ip 地址</h3><blockquote>
<p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。<br>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。<br>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#x31;&#x39;&#x32;&#46;&#x31;&#x36;&#56;&#x40;&#49;&#x2e;&#x31;">&#x31;&#x39;&#x32;&#46;&#x31;&#x36;&#56;&#x40;&#49;&#x2e;&#x31;</a>“ 是 无效的 IP 地址。<br>示例 1：<br>输入：s = “25525511135”<br>输出：[“255.255.11.135”,”255.255.111.35”]</p>
</blockquote>
<p>思路和分割回文串类似，先从头开始分割，如果分割到符合单个 IP 的情况，就存下来并把后面的继续递归。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> restoreIpAddresses = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> curr = [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">str, times</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str === <span class="string">&quot;&quot;</span> &amp;&amp; times === <span class="number">4</span>) &#123;</span><br><span class="line">      res.push(curr.join(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> part = str.slice(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (times &gt;= <span class="number">4</span>) part = str.slice(i + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (isValid(part)) &#123;</span><br><span class="line">        curr.push(part);</span><br><span class="line">        times++;</span><br><span class="line">        dfs(str.slice(i + <span class="number">1</span>), times);</span><br><span class="line">        times--;</span><br><span class="line">        curr.pop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(s, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isValid</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      str !== <span class="string">&quot;&quot;</span> &amp;&amp;</span><br><span class="line">      <span class="built_in">Number</span>(str) &lt;= <span class="number">255</span> &amp;&amp;</span><br><span class="line">      <span class="built_in">Number</span>(str).toString().length === str.length</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="岛屿问题"><a href="#岛屿问题" class="headerlink" title="岛屿问题"></a>岛屿问题</h2><h3 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h3><blockquote>
<p>给你一个由  ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;character[][]&#125;</span> <span class="variable">grid</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numIslands = <span class="function"><span class="keyword">function</span> (<span class="params">grid</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> islands = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> m = grid[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">const</span> n = grid.length;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= n || j &gt;= m) <span class="keyword">return</span>; <span class="comment">// 超出边界</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] === <span class="string">&quot;0&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 遍历到的是0就回溯</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这道题的关键就在这里,遍历之后直接就把这一个变为0</span></span><br><span class="line">    <span class="comment">// 这样既完成了去重,同时下面统计岛屿数量时,遍历过的一整块都会变成&#x27;0&#x27;</span></span><br><span class="line">    grid[i][j] = <span class="string">&quot;0&quot;</span>;</span><br><span class="line"></span><br><span class="line">    dfs(i + <span class="number">1</span>, j);</span><br><span class="line">    dfs(i, j + <span class="number">1</span>);</span><br><span class="line">    dfs(i - <span class="number">1</span>, j);</span><br><span class="line">    dfs(i, j - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">      <span class="comment">// 从每个点开始执行一次递归</span></span><br><span class="line">      <span class="comment">// 因为遍历过的地方会置0，因此实际上只会调用 岛屿数量 次dfs</span></span><br><span class="line">      <span class="keyword">if</span> (grid[i][j] === <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">        dfs(i, j);</span><br><span class="line">        islands++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> islands;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="最大岛屿面积"><a href="#最大岛屿面积" class="headerlink" title="最大岛屿面积"></a>最大岛屿面积</h3><p>和上一道题类似</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">grid</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxAreaOfIsland = <span class="function"><span class="keyword">function</span> (<span class="params">grid</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> m = grid[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">const</span> n = grid.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= n || j &gt;= m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    grid[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里+1的方法类似二叉树计算深度的方法；遍历该点四周，并加上当前点的面积（就是1）</span></span><br><span class="line">    <span class="keyword">return</span> dfs(i + <span class="number">1</span>, j) + dfs(i, j + <span class="number">1</span>) + dfs(i - <span class="number">1</span>, j) + dfs(i, j - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (grid[i][j] === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> area = dfs(i, j);</span><br><span class="line">        max = max &gt; area ? max : area;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/">https://leetcode.cn/problems/generate-parentheses/</a></p>
<blockquote>
<p>数字 n  代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。<br>示例 1：<br>输入：n = 3<br>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]</p>
</blockquote>
<blockquote>
<p>这道题第一眼看上去没想到用回溯，而是想到判断括号有效用到的栈。但是这种需要找到<strong>所有组合</strong>的题目，一般都是回溯。</p>
</blockquote>
<p>思路和上面的回溯有点不一样，递归的时候需要判断当前放入括号是否合理。关键就在于，怎么判断当前应该放入哪个括号。</p>
<ul>
<li>首先左括号和右括号各自的数量都不能大于 n</li>
<li>其次，为了右括号能和左括号匹配，右括号的数量不能大于左括号</li>
</ul>
<p>所以在回溯过程中，要记录左右括号的数量，满足上面的条件再加入。</p>
<blockquote>
<p>注意这个回溯不需要“弹出”，即因为传递的加和过后的字符串是在参数阶段才改变的，函数返回之后自然也就没有了</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> generateParenthesis = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">str, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length === <span class="number">2</span> * n) &#123;</span><br><span class="line">      res.push(str);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; n) dfs(str + <span class="string">&quot;(&quot;</span>, left + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">if</span> (right &lt; left) dfs(str + <span class="string">&quot;)&quot;</span>, left, right + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>这些算法没什么好说的，记就完事了。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bubbleSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j + <span class="number">1</span>] &lt; nums[j]) swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>冒泡排序的最优解,即时间复杂度 O(n)；<br>对应完全有序的情况，这时只需要遍历一次</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> betterBubbleSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j + <span class="number">1</span>] &lt; nums[j]) swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 如果发生一次交换就破功了</span></span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果一次都没有交换,说明数组有序,直接返回,这时只遍历了一次</span></span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span> nums;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>冒泡排序的复杂度：</p>
<ul>
<li>最好时间复杂度：它对应的是数组本身有序这种情况。在这种情况下，我们只需要作比较（n-1 次），而不需要做交换。时间复杂度为 O(n)</li>
<li>最坏时间复杂度： 它对应的是数组完全逆序这种情况。在这种情况下，每一轮内层循环都要执行，重复的总次数是 n(n-1)/2 次，因此时间复杂度是 O(n^2)</li>
<li>平均时间复杂度： O(n^2)</li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>循环遍历数组，每次都找出当前范围内的最小值，把它放在当前范围的头部；然后缩小排序范围，继续重复以上操作，直至数组完全有序为止。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selectionSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; arr.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">        minIndex = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, minIndex, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>选择排序的复杂度都是 O(n^2)</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序所有的操作都基于一个这样的前提：当前元素前面的序列是有序的。基于这个前提，从后往前去寻找当前元素在前面那个序列里的正确位置；</p>
<p>即把当前选中的元素和前面的依次比较，如果小于前面的元素，就把前面的元素往后移一位，直到大于前面元素为止。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insertionSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = i;</span><br><span class="line">    tmp = nums[i];</span><br><span class="line">    <span class="keyword">while</span> (tmp &lt; nums[j - <span class="number">1</span>] &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[j] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>最好时间复杂度：它对应的数组本身就有序这种情况。此时内层循环只走一次，整体复杂度取决于外层循环，时间复杂度就是一层循环对应的 O(n)。</li>
<li>最坏时间复杂度：它对应的是数组完全逆序这种情况。此时内层循环每次都要移动有序序列里的所有元素，因此时间复杂度对应的就是两层循环的 O(n^2)</li>
<li>平均时间复杂度：O(n^2)</li>
</ul>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>将数组拆分成两个部分，然后分别单独排序，最后合并。因此拆分过程实际上是类似二叉树的递归遍历，递归边界是数组只有一个元素的时候，直接返回该元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并两个有序数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeArr</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> newArr = [];</span><br><span class="line">  <span class="keyword">while</span> (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) &#123;</span><br><span class="line">    arr1[i] &lt; arr2[j] ? newArr.push(arr1[i++]) : newArr.push(arr2[j++]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [...newArr, i === arr1.length - <span class="number">1</span> ? arr2.slice(j) : arr1.slice(i)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mergeSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">  <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(nums.length / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> left = mergeSort(nums.slice(<span class="number">0</span>, mid));</span><br><span class="line">  <span class="keyword">const</span> right = mergeSort(nums.slice(mid));</span><br><span class="line">  <span class="keyword">return</span> mergeArr(left, right);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>归并排序的时间复杂度是 <code>O(nlog(n))</code></p>
<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>快速排序会将原始的数组筛选成较小和较大的两个子数组，然后递归地排序两个子数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> quickSort = <span class="function">(<span class="params">nums, left = <span class="number">0</span>, right = nums.length - <span class="number">1</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">  <span class="comment">// ！！！！！！！！！！！！！！</span></span><br><span class="line">  <span class="comment">// 注意这里不能只求一个序号！！！！！！！！！</span></span><br><span class="line">  <span class="comment">// 必须是得到具体的中间值，因为后面数组会变化，中间值如果是个序号会变，排序会出错！！！！！</span></span><br><span class="line">  <span class="comment">// 即必须是nums[Math.floor(left + (right - left) / 2)]</span></span><br><span class="line">  <span class="comment">// 不能只是Math.floor(left + (right - left) / 2)</span></span><br><span class="line">  <span class="keyword">let</span> divider = nums[<span class="built_in">Math</span>.floor(left + (right - left) / <span class="number">2</span>)];</span><br><span class="line">  <span class="keyword">let</span> i = left;</span><br><span class="line">  <span class="keyword">let</span> j = right;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (nums[i] &lt; divider) i++;</span><br><span class="line">    <span class="keyword">while</span> (nums[j] &gt; divider) j--;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">      swap(nums, i, j);</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (left &lt; i - <span class="number">1</span>) quickSort(nums, left, i - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (i &lt; right) quickSort(nums, i, right);</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>拆分一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left = <span class="number">0</span>, right = arr.length - <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> lineIndex = partition(arr, left, right);</span><br><span class="line">    <span class="keyword">if</span> (left &lt; lineIndex - <span class="number">1</span>) quickSort(arr, left, lineIndex - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (lineIndex &lt; right) quickSort(arr, lineIndex, right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> pivotValue = arr[<span class="built_in">Math</span>.floor(left + (right - left) / <span class="number">2</span>)];</span><br><span class="line">  <span class="keyword">let</span> i = left;</span><br><span class="line">  <span class="keyword">let</span> j = right;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[i] &lt; pivotValue) i++;</span><br><span class="line">    <span class="keyword">while</span> (arr[j] &gt; pivotValue) j--;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">      swap(arr, i, j);</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">  [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TOP-K-问题"><a href="#TOP-K-问题" class="headerlink" title="TOP K 问题"></a>TOP K 问题</h2><blockquote>
<p>给你一个数组，求这个数组中的第 K 个最大元素。<br>需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
</blockquote>
<p>这道题的思路有好几种：</p>
<ol>
<li>利用大根堆，只要把堆的数据结构建立好，依次取 K 次就可以。但是问题在于 js 很难用大根堆<br>实际上就是一个数组，详细解释可以参考 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/xie-gei-qian-duan-tong-xue-de-ti-jie-yi-kt5p2/">https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/xie-gei-qian-duan-tong-xue-de-ti-jie-yi-kt5p2/</a></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">arr, i, j</span>) =&gt;</span> ([arr[i], arr[j]] = [arr[j], arr[i]]);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findKthLargest = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> size = nums.length;</span><br><span class="line">  buildMaxHeap(nums, size);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = nums.length - <span class="number">1</span>; i &gt;= nums.length - k + <span class="number">1</span>; i--) &#123;</span><br><span class="line">    swap(nums, <span class="number">0</span>, i);</span><br><span class="line">    size--;</span><br><span class="line">    heapify(nums, <span class="number">0</span>, size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buildMaxHeap</span>(<span class="params">nums, size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(size / <span class="number">2</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      heapify(nums, i, size);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">heapify</span>(<span class="params">nums, i, size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> mid = i;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; size &amp;&amp; nums[left] &gt; nums[mid]) &#123;</span><br><span class="line">      mid = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; size &amp;&amp; nums[right] &gt; nums[mid]) &#123;</span><br><span class="line">      mid = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mid !== i) &#123;</span><br><span class="line">      swap(nums, mid, i);</span><br><span class="line">      heapify(nums, mid, size);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote>
<p>动态规划（dynamic programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。<br>用动态规划解决问题时，要遵循三个重要步骤：</p>
<ol>
<li>定义子问题；</li>
<li>实现要反复执行来解决子问题的部分；</li>
<li>识别并求解出基线条件。</li>
</ol>
</blockquote>
<p>动态规划的题目有几个关键的特征：</p>
<ol>
<li>要求你给出达成某个目的的解法个数</li>
<li>不要求你给出每一种解法对应的具体路径</li>
<li>题目要求中有“最值”，即最优解；</li>
<li>一个解的得出依赖于前一个解，依次依赖迭代</li>
</ol>
<p>这样的问题，往往可以用动态规划进行求解</p>
<p>动态规划的题目可能很难理解，如果有实在理解不了的可以先记下来</p>
<h2 id="爬楼梯问题"><a href="#爬楼梯问题" class="headerlink" title="爬楼梯问题"></a>爬楼梯问题</h2><blockquote>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
</blockquote>
<p>倒着思考问题,如果要到达 n 阶的方法为<code>f(n)</code>种,从第 n 阶退一层的方法就是<code>f(n-1)</code>或<code>f(n-2)</code>种,即<code>f(n) = f(n-1) + f(n-2)</code> ,然后依次类推,直到<code>f(1)</code>和<code>f(2)</code>返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> climbStairs = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 树形思考问题,这里相当于两个子节点</span></span><br><span class="line">  <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面这个解法会有很多重复的,比如<code>f(n-2)</code>的下一层会包含<code>f(n-3)</code>,这个值可能被多次计算<br>可以考虑 Map 缓存计算过的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> climbStairsCached = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">return</span> climbStairs(n);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">climbStairs</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.has(n)) <span class="keyword">return</span> map.get(n);</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> res = climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">    map.set(n, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上这种在递归的过程中，不断保存已经计算出的结果，从而避免重复计算的手法，叫做记忆化搜索。</p>
<p>真正的动态规划，是一个自底向上的过程。它要求我们站在已知的角度，通过定位已知和未知之间的关系，一步一步向前推导，进而求解出未知的值。</p>
<p>由上面的关系，可以推出状态转移方程为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n-1) + f(n-2)</span><br><span class="line">且</span><br><span class="line">f(1) = 1</span><br><span class="line">f(2) = 2</span><br></pre></td></tr></table></figure>

<p>把这个方程放到循环中，就可以解出来了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> climbStairsDynamic = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> f = [];</span><br><span class="line">  f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  f[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt; n; i++) &#123;</span><br><span class="line">    f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此动态规划的关键就是推出状态转移方程，只要方程能得出，丢到迭代里边就可以计算了。</p>
<h2 id="最少硬币找零"><a href="#最少硬币找零" class="headerlink" title="最少硬币找零"></a>最少硬币找零</h2><blockquote>
<p>给定不同面额的硬币 coins 和一个总金额 amount。<br>编写一个函数来计算可以凑成总金额所需的 最少 的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
</blockquote>
<p>站在已经凑成的角度上思考问题，如果从已经凑成的结果中取走一个硬币，就会有以下的情况：<br><img src="https://pic.imgdb.cn/item/626789ea239250f7c5c0b9d6.jpg"></p>
<p>借此可以推出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n表示amount，f(n)表示凑成n金额所需的最少硬币数量</span><br><span class="line"></span><br><span class="line">f(n) = Math.min(f(n-c1)+1,f(n-c2)+1,f(n-c3)+1......f(n-cn)+1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>放入循环：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getCoinsDynamic = <span class="function">(<span class="params">coins, amount</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> f = [];</span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; amount; i++) &#123;</span><br><span class="line">    f[i] = <span class="literal">Infinity</span>;</span><br><span class="line">    <span class="comment">// 这个循环相当于是 f[n] = Math.min(f(n-coin1),f(n-coin2),...,f(n-coinn))</span></span><br><span class="line">    <span class="comment">// 由于coin数量不确定,因此两两比较每个f(n)和f(n-coin)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> coin <span class="keyword">of</span> coins) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= coin) f[i] = <span class="built_in">Math</span>.min(f[i], f[i - coin] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (f[amount] === <span class="literal">Infinity</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> f[amount];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><blockquote>
<p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
</blockquote>
<p>用 <code>f(i)</code>代表以第 i 个数结尾的「连续子数组的最大和」,可得方程为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(i)=max&#123;f(i−1)+nums[i],nums[i]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也就是以第 i 个数结尾的最大和，有可能是加上第 i 个数的结果，也有可能是只有第 i 个数的结果。因为<code>f(i)</code>代表以第 i 个数结尾的,因此必须要包含当前数(即<code>nums[i]</code>)；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxChildArr = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> f = [];</span><br><span class="line">  f[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    f[i] = <span class="built_in">Math</span>.max(f[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(...f);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>如果要求是一个最大子序列呢？即不要求连续数组</p>
<p>其实就是改一下方程为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">1</span>] + nums[i]);</span><br></pre></td></tr></table></figure>

<p>因为这样每一项都可以选择其前面的某一项和，当自己为正时就加上自己即可。<br>而如果要求必须是子数组，那么一旦不合适就应该抛弃前面的子数组，重新以自己为起点创建数组。</p>
<h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><blockquote>
<p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
</blockquote>
<p>假设最长序列长度为<code>f(i)</code>,这道题不适合倒推得出方程,而是通过正向思考<br>对于每一个数字,如果前面还有比它小的一个数字或一组数字,就可以组合成一个序列;<br>那么可以执行两次遍历,遍历每个数字,每次迭代都遍历<strong>这个数字前面的所有数字</strong>,如果有比它小的就加入序列长度，直到找到该项之前的、比该项小的数字个数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lengthOfLIS = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> f = [];</span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    f[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">        <span class="comment">//注意这里不是要f[i] 与 f[j] + 1进行比较，而是取f[j] + 1的最大值。</span></span><br><span class="line">        f[i] = <span class="built_in">Math</span>.max(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(...f);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>核心代码写成这样也可以：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">  f[i] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">      <span class="comment">// 取f[j] + 1的最大值。</span></span><br><span class="line">      tmp = tmp + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  f[i] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长连续递增子序列"><a href="#最长连续递增子序列" class="headerlink" title="最长连续递增子序列"></a>最长连续递增子序列</h2><blockquote>
<p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p>
</blockquote>
<p>这道题和上面的最大区别在于“连续”，即序列是连续的。<br>因此同样设<code>dp[i]</code>表示以 i 结尾的最长连续递增序列的长度，但是<code>dp[i]</code>此时只能由<code>dp[i - 1]</code>推出，即<code>dp[i] = dp[i - 1] + 1</code>。</p>
<p>遍历整个数组，如果当前数<code>nums[i]</code>比前面的数大，就更新<code>dp[i]</code>，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findLengthOfLCIS = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = [];</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">    dp[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    res = res &gt; dp[i] ? res : dp[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最长公共子数组"><a href="#最长公共子数组" class="headerlink" title="最长公共子数组"></a>最长公共子数组</h2><blockquote>
<p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。<br>示例：<br>输入： A: [1,2,3,2,1] B: [3,2,1,4,7] 输出：3 解释： 长度最长的公共子数组是 [3, 2, 1] 。</p>
</blockquote>
<p>类似这种的公共问题，一定是取二维数组<code>dp[i][j]</code>，并且两个维度分别对应一个数组。<br>这里<code>dp[i][j]</code>表示：以下标<code>i - 1</code>为结尾的 A，和以下标<code>j - 1</code>为结尾的 B，最长重复子数组长度为<code>dp[i][j]</code>。<br>当<code>A[i - 1] === B[j - 1]</code>相等的时候，<code>dp[i][j] = dp[i - 1][j - 1] + 1</code></p>
<blockquote>
<p>这里取<code>i-1</code>和<code>j-1</code>主要是为了方便计算，直接取 i、j 也可以，但是要提前初始化<code>dp[i][0]</code>和 dp<code>[0][j]</code></p>
</blockquote>
<p>dp 数组的结构如下，状态的更新是斜向的，即 dp[i][j]总是由左上方的 dp[i - 1][j - 1]更新而来</p>
<p><img src="https://img-blog.csdnimg.cn/2021011215282060.jpg"></p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> findLength = <span class="function">(<span class="params">A, B</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// A、B数组的长度</span></span><br><span class="line">  <span class="keyword">const</span> [m, n] = [A.length, B.length];</span><br><span class="line">  <span class="comment">// dp数组初始化，都初始化为0</span></span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m + <span class="number">1</span>).fill(<span class="number">0</span>).map(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>));</span><br><span class="line">  <span class="comment">// 初始化最大长度为0</span></span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="comment">// 遇到A[i - 1] === B[j - 1]，则更新dp数组</span></span><br><span class="line">      <span class="keyword">if</span> (A[i - <span class="number">1</span>] === B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新res</span></span><br><span class="line">      res = dp[i][j] &gt; res ? dp[i][j] : res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历完成，返回res</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="不同路径问题"><a href="#不同路径问题" class="headerlink" title="不同路径问题"></a>不同路径问题</h2><blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？<br><img src="https://img-blog.csdnimg.cn/20210110174033215.png"></p>
</blockquote>
<p>机器人移动经过的是二维数组，因此对于每一个节点来说，必然会有水平和竖直两种方向上的两组路径，即只需要记录左边和上边来的路径数（因为是从左向右遍历，因此不需要统计右和下）<br><img src="https://pic.imgdb.cn/item/6273a6e40947543129d857e0.jpg"></p>
<p>因此设<code>dp[i][j]</code>为经过点<code>(i,j)</code>的路径最大值，并且该值一定是由其水平和竖直推出的，即<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code></p>
<p><img src="https://img-blog.csdnimg.cn/20201209113631392.png"></p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePaths = <span class="function"><span class="keyword">function</span> (<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(n), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(m));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; m - <span class="number">1</span>; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="下降路径最小和"><a href="#下降路径最小和" class="headerlink" title="下降路径最小和"></a>下降路径最小和</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-falling-path-sum/submissions/">https://leetcode.cn/problems/minimum-falling-path-sum/submissions/</a></p>
<p>设 dp[i][j]表示位于[i][j]的元素最小下降路径和，显然等于上面一层相邻的三个元素之间的最小值的递推。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">matrix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minFallingPathSum = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="built_in">Array</span>.from(</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Array</span>(matrix.length),</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(matrix[<span class="number">0</span>].length)</span><br><span class="line">  );</span><br><span class="line">  dp[<span class="number">0</span>] = [...matrix[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">      dp[i][j] =</span><br><span class="line">        matrix[i][j] +</span><br><span class="line">        <span class="built_in">Math</span>.min(</span><br><span class="line">          dp[i - <span class="number">1</span>][j - <span class="number">1</span>] || <span class="literal">Infinity</span>,</span><br><span class="line">          dp[i - <span class="number">1</span>][j] || <span class="literal">Infinity</span>,</span><br><span class="line">          dp[i - <span class="number">1</span>][j + <span class="number">1</span>] || <span class="literal">Infinity</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.min(...dp[dp.length - <span class="number">1</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h2><blockquote>
<p>有 n 件物品，物品体积用一个名为 w 的数组存起来，物品的价值用一个名为 value 的数组存起来；<br>每件物品的体积用 w[i] 来表示，每件物品的价值用 value[i] 来表示。现在有一个容量为 c 的背包<br>问你如何选取物品放入背包，才能使得背包内的物品总价值最大？</p>
</blockquote>
<p>设<code>dp[i][j]</code> 表示从下标为<code>[0-i]</code>的物品里任意取，放进容量为 j 的背包，价值总和最大是多少。(记住 i 和 j 的含义)</p>
<p>我们假设每个物品重量和价值关系如下:</p>
<table>
<thead>
<tr>
<th></th>
<th>weight</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>物品 0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>物品 1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>物品 2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody></table>
<p>那么得到的 dp 数组就是这样的：<br><img src="https://img-blog.csdnimg.cn/20210110103003361.png"></p>
<p>然后需要确定递推公式。我们可以这样理解，对于每一个即将要放入背包的物品 i ，可能有两种情况：</p>
<ol>
<li>当前背包容量不够（没有空余或者空余小于当前物品重量），放不下（背包不是一开始就是最大的，而是从 0 开始一个一个遍历上来的）</li>
<li>当前背包容量够，并且空余大于等于当前物品重量</li>
</ol>
<p>这两种情况恰恰是对应两个公式：</p>
<ol>
<li>不够放下该物品 i，所以直接无视掉，依旧取之前的值。这个“之前的值”，就是<strong>背包容量不变，并且不放物品 i</strong>的值，体现为<code>dp[i - 1][j]</code>。<code>dp[i-1]</code>表示的含义是，当前物品没有放入，那么就还是上一个或上面几个物品放入的情况。</li>
<li>能放下物品 i，这时候就选择放入物品 i，并且加上物品 i 的价值。但是注意这里并不是直接在<code>dp[i - 1][j]</code>的基础上加，而是取<code>dp[i - 1][j - weight[i]]</code>；原因是这样：</li>
</ol>
<p>比如计算<code>dp[1][3]</code>，如下图<br><img src="https://img-blog.csdnimg.cn/20210110103244701.png"></p>
<p>这时<code>dp[i - 1][j] = dp[0][3]</code>，即不放入物品 1，那么背包中仍旧只有一个物品 0，价值为 15<br>如果放入物品 1，我们就需要知道一个特殊的情况，即<strong>空余空间足够，但并未放入</strong>的情况。即<code>dp[i - 1][j - weight[i]] = dp[0][0]</code>：这时什么都没有放入，背包空余大小为 3，足够放入重量为 3 的物品 1。最后加上物品 1 的价值 20，得到最终值</p>
<p>如果不找到有足够空间的情况，那么本次的<code>j</code>之前可能会有其他情况，比如一个比物品 i 重量小的已经放入，但是没有填满，并且去掉这个小物品是可以放入该物品 i 的。应当避免的就是这种情况。</p>
<p>结合上面两种情况，其实就是在比较“选不选物品 i”；选和不选之间取出一个最大值，成为当前的结果。</p>
<p>状态转移方程为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure>

<p>核心遍历代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; weight.length; i++) &#123;</span><br><span class="line">  <span class="comment">// 遍历物品</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= size; j++) &#123;</span><br><span class="line">    <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">if</span> (j &lt; weight[i])</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j]; <span class="comment">// 如果当前容量都小于物品i的重量，那肯定不用放入</span></span><br><span class="line">    <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testweightbagproblem</span>(<span class="params">wight, value, size</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = wight.length;</span><br><span class="line">  <span class="keyword">const</span> dp = array.from(<span class="keyword">new</span> <span class="built_in">Array</span>(len + <span class="number">1</span>), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(size).fill(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= size; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j &lt; weight[i])</span><br><span class="line">        <span class="comment">// 如果当前容量都小于物品i的重量，那肯定不用放入</span></span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">      <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dp[len][size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h2><blockquote>
<p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。<br>示例 :<br>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。<br>说明: 你可以假设 n 不小于 2 且不大于 58</p>
</blockquote>
<p>思路：对于一个数 i，可能的拆分方式有两种：</p>
<ol>
<li>从 j 到 i 遍历，即<code>j * (i - j)</code></li>
<li>因为<code>i - j</code>可能也能拆分（比如 6 可以再拆成 3*3），因此可能是<code>i - j</code>拆分的<code>最大乘积 * j</code></li>
</ol>
<p>状态转移方程：<br>设<code>dp[i]</code>表示数字 i 拆分得到的最大乘积</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = Math.max(dp[i - j] * j, j * (i - j))</span><br></pre></td></tr></table></figure>

<p>实际实现应该取 j 从 1 到 i 遍历得到的<code>dp[i]</code>最大值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> integerBreak = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = [];</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// dp[i]有两种情况,一种是拆分成两个数的,最大值为max(...[j * (i - j)]),即从1到i遍历j,计算拆分成两个数的最大值</span></span><br><span class="line">  <span class="comment">// 另一种情况是可能拆成多个数,即j * dp[i - j],即拆分i-j.</span></span><br><span class="line">  <span class="comment">// 这里不能拆分j,即不能dp[j] * dp[i - j],因为这样最少都是四个数相乘</span></span><br><span class="line">  <span class="comment">// dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      dp[i] = <span class="built_in">Math</span>.max(dp[i], (i - j) * j, dp[i - j] * j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h2><blockquote>
<p>给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。<br>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
</blockquote>
<p><img src="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif"></p>
<p>这道题不是标准的动态规划题，但是可以用动态规划解。<br>思路是通过二维数组，设<code>dp[i][j]</code>为第 i 行、第 j 个数字的值，那么显然</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j] + dp[i - 1][j-1]</span><br></pre></td></tr></table></figure>

<p>然后每行计算的时候，都初始化行首和行尾的元素值为 1</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">numRows</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> generate = <span class="function"><span class="keyword">function</span> (<span class="params">numRows</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = [[<span class="number">1</span>]];</span><br><span class="line">  <span class="keyword">const</span> res = [...dp];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">    dp[i] = [];</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(dp[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票-I"><a href="#买卖股票-I" class="headerlink" title="买卖股票 I"></a>买卖股票 I</h2><blockquote>
<p>给定一个数组 prices ，它的第  i 个元素  prices[i] 表示一支给定股票第 i 天的价格。<br>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。<br>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。<br>示例 1：<br>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</p>
</blockquote>
<p>设 dp[i]表示第 i 天持有股票的现金。<br>为了区分在某一天购入和售出，设置两个状态表示在改天持有和不持有股票：</p>
<ul>
<li>dp[i][0]表示在第 i 天持有股票。<strong>持有</strong>股票表示两种可能：<ul>
<li>今天购买了股票，那么现在剩余的现金就是<code>-price[i]</code></li>
<li>今天没有购买，保持昨天的状态，即<code>dp[i-1][0]</code></li>
</ul>
</li>
<li>dp[i][1]表示在第 i 天不持有股票，同理：<ul>
<li>今天售出了股票，那么剩余现金就是 当天的股票价格 price[i]和前一天的持有金钱的差值；又因为 dp[i][0]一定是小于等于 0，因此实际上是<code>price[i] + dp[i-1][0]</code>。<br>并且，<code>dp[i-1][0]</code>本身是由前面推出来的，因此一定在这天之前是购买成本最小的情况。</li>
<li>今天没有售出，即保持<code>dp[i - 1][1]</code></li>
</ul>
</li>
</ul>
<p>因此实际上 dp 是两个动态规划的组合。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0] = Math.max(dp[i-1][0],-price[i])</span><br><span class="line"></span><br><span class="line">dp[i][1] = Math.max(dp[i-1][1],price[i] + dp[i-1][0])</span><br></pre></td></tr></table></figure>

<p>最终结果取<code>dp[price.length - 1][1]</code>就是最大值。</p>
<p><img src="https://pic.imgdb.cn/item/6281dbeb09475431290d7d2e.jpg"></p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">prices</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span> (<span class="params">prices</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = [[-prices[<span class="number">0</span>], <span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">    dp[i] = [];</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], prices[i] + dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票-II"><a href="#买卖股票-II" class="headerlink" title="买卖股票 II"></a>买卖股票 II</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/</a></p>
<p>这道题和上一道题的唯一区别在于：dp[i][0]的推导有一点点不一样。<br>因为上一道题购买的时候一定是不持有现金的，因此必然是<code>-prices[i]</code>；但是本题购买的时候可能是已经持有现金了，所以就需要把值变为<code>dp[i][1] - prices[i]</code>。<br>即</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i][<span class="number">1</span>] - prices[i]);</span><br><span class="line"></span><br><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], price[i] + dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>带入代码得：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">prices</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span> (<span class="params">prices</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = [[-prices[<span class="number">0</span>], <span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">    dp[i] = [];</span><br><span class="line">    dp[i][<span class="number">1</span>] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], prices[i] + dp[i - <span class="number">1</span>][<span class="number">0</span>]); <span class="comment">// 注意顺序稍微改了一下</span></span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i][<span class="number">1</span>] - prices[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h2><blockquote>
<p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。<br>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。<br>示例 1： 输入：s = “abc”, t = “ahbgdc” 输出：true</p>
</blockquote>
<p>这道题用双指针就能很快解决，但是用动态规划也可以，并且可以引出下一道题的类似思路。</p>
<p>用动态规划的话思路和<em>最长公共子数组</em>这道题类似，同样取二维数组 dp[i][j]，表示以下标<code>i - 1</code>结尾的字符串 s 和下标<code>j - 1</code>结尾的字符串 t 之间的子序列长度。</p>
<p>那么就会有两种情况：</p>
<ol>
<li>如果<code>s[i-1]===t[j-1]</code>，那么子序列长度加 1，即<code>dp[i][j] = dp[i - 1][j - 1] + 1</code>；（即下标 i-2 和 j-2 的串的子序列长度+1）</li>
<li>如果<code>s[i-1]!==t[j-1]</code>，那么子序列长度不变，即<code>dp[i][j] = dp[i][j - 1]</code>。注意这里相当于 s 串不变，但 t 串向前走了，应该删去当前元素，所以是下标 i-1 的串和下标 j-2 的串子序列长度。</li>
</ol>
<p>因此可以得到方程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[i-1]===t[j-1]</span></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s[i-1]!==t[j-1]</span></span><br><span class="line">dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>最终结果只需要返回最右下角的元素即可。</p>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isSubsequence = <span class="function">(<span class="params">s, t</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// s、t的长度</span></span><br><span class="line">  <span class="keyword">const</span> [m, n] = [s.length, t.length];</span><br><span class="line">  <span class="comment">// dp全初始化为0</span></span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m + <span class="number">1</span>).fill(<span class="number">0</span>).map(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="comment">// 更新dp[i][j]，两种情况</span></span><br><span class="line">      <span class="keyword">if</span> (s[i - <span class="number">1</span>] === t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历结束，判断dp右下角的数是否等于s的长度</span></span><br><span class="line">  <span class="keyword">return</span> dp[m][n] === m ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于这种两个序列判断公共的问题，通常的解法都是利用二维数组；<br>而递推关系一般是两种情况得出的，可以类比双指针解法</p>
</blockquote>
<h2 id="不同子序列"><a href="#不同子序列" class="headerlink" title="不同子序列"></a>不同子序列</h2><blockquote>
<p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p>
</blockquote>
<blockquote>
<p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
</blockquote>
<p>这个题和上面的题思路大致不变，因为都是在找公共子序列；<br>但是这个题是让你找到 s 有几种方法删除元素可以得到 t</p>
<p>同样设 dp[i][j]为 对于 i-1 结尾的 s 和 j-1 结尾的 t，t 在 s 中出现的个数。</p>
<p>那么会有同样的两种情况：</p>
<ol>
<li><p>如果<code>s[i-1]===t[j-1]</code>，此时<code>dp[i][j] = dp[i - 1][j - 1] + dp[i-1][j]</code>。这个的关键在于，后者表示 s 串中除去当前元素的判断结果，是因为对于如果已经匹配上的两个串，<strong>s 串向后走不管多少位都不会减少之前 t 串已经出现的次数</strong>。因此不应该是+1，而是加上之前匹配的次数。</p>
</li>
<li><p>如果<code>s[i-1]!==t[j-1]</code>，<code>dp[i][j] = dp[i-1][j]</code>，和上面原因一样，只有之前匹配的次数结果。</p>
</li>
</ol>
<p>得到方程为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line"></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br></pre></td></tr></table></figure>

<p>注意初始化：</p>
<ul>
<li>dp[i][0]表示从以 i 结尾的串 s 中找到空字串。那么选取方法就只有一种，即一个都不选，或者说是全部删除</li>
<li>dp[0][i]表示从空串中找到非空串，显然不可能，都为 0</li>
<li>dp[0][0]表示空串找空串，为 1</li>
</ul>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">t</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numDistinct = <span class="function"><span class="keyword">function</span> (<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="built_in">Array</span>.from(<span class="built_in">Array</span>(s.length + <span class="number">1</span>), <span class="function">() =&gt;</span> <span class="built_in">Array</span>(t.length + <span class="number">1</span>).fill(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= s.length; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= t.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i - <span class="number">1</span>] === t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dp[s.length][t.length];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="回文子串数量"><a href="#回文子串数量" class="headerlink" title="回文子串数量"></a>回文子串数量</h2><blockquote>
<p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。<br>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。<br>示例 1：<br>输入：”abc” 输出：3 解释：三个回文子串: “a”, “b”, “c”</p>
</blockquote>
<p>回文子串类型的动态规划数组 dp 一般都是这样设置的：<br>设 dp[i][j]表示字符串 i 和 j 之间的串<strong>是不是回文串</strong>，如果是就是 ture，不是就是 false。注意这里的值是布尔值，算是一个特例。（回文子串相关的都可以这么取）<br>因此主要判断两端的字符是不是相等，因此有几种情况：</p>
<ol>
<li>s[i] === s[j]，说明两端字符相等</li>
</ol>
<ul>
<li><code>i === j</code>，即同一个字符，为 true</li>
<li><code>|i - j| === 1</code>，说明是两个相邻的字符，为 true</li>
<li>其他情况，即 i 和 j 之间还包含其他字符串。因此需要判断两者之间的部分是不是，即判断<code>dp[i + 1][j - 1]</code>是否为 true</li>
</ul>
<ol start="2">
<li>s[i] !== s[j]，肯定是 false</li>
</ol>
<p>由此可以得到公式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] === s[j]) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i === j || <span class="built_in">Math</span>.abs(i - j) &lt;= <span class="number">1</span>) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> dp[i][j] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>这里注意因为 dp[i][j]是从 dp[i + 1][j - 1]推出来的，因此一定要从下向上、从左向右遍历。（即从 dp[s.length - 1][0]开始，i 递减）</p>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countSubstrings = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(s.length), <span class="function">() =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Array</span>(s.length).fill(<span class="literal">false</span>)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = s.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt;= s.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i] === s[j]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i === j || j - i &lt;= <span class="number">1</span>) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (dp[i][j]) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-subsequence/">https://leetcode.cn/problems/longest-palindromic-subsequence/</a></p>
<blockquote>
<p>给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。<br>示例 1: 输入: “bbbab” 输出: 4 一个可能的最长回文子序列为 “bbbb”。<br>示例 2: 输入:”cbbd” 输出: 2 一个可能的最长回文子序列为 “bb”。</p>
</blockquote>
<p>思路和上面的回文子串差不多，分开判断<code>s[i] === s[j]</code>;</p>
<ul>
<li>如果相等，<code>dp[i][j] = dp[i + 1][j - 1] + 2;</code>，这里可以不考虑 i、j 重合的情况</li>
<li>如果不相等，不能直接缩小范围，要测试一下只加上左边和只加上右边能不能构成回文；</li>
</ul>
<p>注意这里和上一道题不一样，因为上一道题只用考虑中间的是不是回文串，是就记录，不是就不记录，如果单独考虑反而会重复。</p>
<blockquote>
<p>比如字符串”bbbab”，当 i 指向第一个 b，j 指向 a 时，两者不相等，如果缩小右边的一个位置就有”bbb”；但是其实本来 j 就会走过这一串，这样统计反而重复了</p>
</blockquote>
<p>而这里需要的是前一个的最长回文子序列长度，除了复用两边都减去的情况，还必须要考虑两边各减一个的情况</p>
<blockquote>
<p>比如字符串”bbbab”，当 i 指向第一个 b，j 指向 a 时，两者不相等，同理缩小左右分别得到”bbb”和”bba”，因为是统计长度，因此不存在重复的可能，dp[i][j]一定取得是范围内设法得到的的最大值。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestPalindromeSubseq = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(s.length), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(s.length).fill(<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = s.length; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; s.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i] === s[j]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i === j) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(i - j) &lt;= <span class="number">1</span>) dp[i][j] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[i][j] = <span class="built_in">Math</span>.max(dp[i][j - <span class="number">1</span>], dp[i + <span class="number">1</span>][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(dp);</span><br><span class="line">  <span class="keyword">return</span> dp[<span class="number">0</span>][dp[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><blockquote>
<p>给你一个字符串 s，找到 s 中最长的回文子串。</p>
</blockquote>
<p>这道题的思路其实和找到回文子串数量的方式差不多，先判断是否存在回文子串，再在每一次遍历时更新最长字串即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = [];</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> max = -<span class="literal">Infinity</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = s.length; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    dp[i] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; s.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i] === s[j]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i === j || <span class="built_in">Math</span>.abs(i - j) === <span class="number">1</span>) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; max) &#123;</span><br><span class="line">        max = j - i + <span class="number">1</span>;</span><br><span class="line">        res = s.slice(i, j + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最大正方形"><a href="#最大正方形" class="headerlink" title="最大正方形"></a>最大正方形</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximal-square/">https://leetcode.cn/problems/maximal-square/</a></p>
<p>思路：设 dp[i][j]表示以(i,j)为右下角的正方形大小。那么显然 dp[i][j]可以从其左、上、斜上三个方向推出来。</p>
<ul>
<li>首先三个位置必须都是 1，否则当前 dp[i][j]最多只能是 1</li>
<li>满足上一条之后，dp[i][j]应该是三个中 <code>(根号下最小值+1)^2</code>。比如三个值分别是 4、9、16，那么最多只能和 4 所在的那个位置凑成一个 3*3 的正方形。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;character[][]&#125;</span> <span class="variable">matrix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maximalSquare = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [m, n] = [matrix.length, matrix[<span class="number">0</span>].length];</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(m), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      dp[<span class="number">0</span>][j] = +matrix[<span class="number">0</span>][j];</span><br><span class="line">      dp[i][<span class="number">0</span>] = +matrix[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (matrix[i] &amp;&amp; matrix[i][j] !== <span class="string">&quot;0&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &amp;&amp; dp[i][j - <span class="number">1</span>] &amp;&amp; dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">          dp[i][j] =</span><br><span class="line">            (<span class="built_in">Math</span>.sqrt(</span><br><span class="line">              <span class="built_in">Math</span>.min(+dp[i - <span class="number">1</span>][j], +dp[i][j - <span class="number">1</span>], +dp[i - <span class="number">1</span>][j - <span class="number">1</span>])</span><br><span class="line">            ) +</span><br><span class="line">              <span class="number">1</span>) **</span><br><span class="line">            <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> dp[i][j] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      max = <span class="built_in">Math</span>.max(max, dp[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最长递增子序列的个数"><a href="#最长递增子序列的个数" class="headerlink" title="最长递增子序列的个数"></a>最长递增子序列的个数</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence/">https://leetcode.cn/problems/number-of-longest-increasing-subsequence/</a><br>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<br>这道题很重要，是双数组动态规划的重要例题！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</p>
<blockquote>
<p>给定一个未排序的整数数组  nums ，  返回最长递增子序列的个数  。<br>注意   这个数列必须是 严格 递增的。<br>示例 1:<br>输入: [1,3,5,4,7]<br>输出: 2<br>解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。</p>
</blockquote>
<p>思路：用两个数组 dp 和 cnt 分别记录最长递增子序列的长度和数量。</p>
<ul>
<li>dp 比较好算，dp[i]就是从 0 到 i 的最大值+1</li>
<li>cnt 的变化依赖 dp；由于 cnt 表示的是第 i 个位置上的最长递增子序列数量，那么 cnt 就会有两种情况：<ul>
<li>当当前 dp 被更新，即此时 0 到 i 中有一个位置的长度比当前 dp 大，说明最长递增子序列的长度增加了；如果只是增加长度，那么数量不会发生改变，即 cnt[i] = cnt[j]。</li>
<li>当 dp 不变（dp[i] = dp[j] + 1），即找到了两个相同长度的递增子序列，那么此时就应该把这个位置上的 cnt[j]和当前的 cnt[i]加起来。</li>
</ul>
</li>
<li>最后，找到 dp 中最大的值，然后在 dp 中遍历出现最大值的位置，对应到 cnt 的出现次数，就是这个最大序列值的出现次数，全部加起来即可。</li>
</ul>
<p>这里的关键就是这个 cnt 数组的动态规划计算，什么时候 cnt 应该变化<br>以上面的[1,3,5,4,7]为例：</p>
<ol>
<li>当 i = 4，j = 2，j 走到 5 这个位置上，dp[i]被更新为 4</li>
<li>当 j = 3，也就是走到 4 这个位置上时，这时发现之前计算的最长子序列长度又出现了一次（4），说明 5 和 4 都可以和 7 构成最长序列。那么显然就应该加上这个位置的 cnt。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findNumberOfLIS = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="built_in">Array</span>(len).fill(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> count = <span class="built_in">Array</span>(len).fill(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[j] + <span class="number">1</span> &gt; dp[i]) &#123;</span><br><span class="line">          dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">          count[i] = count[j];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[j] + <span class="number">1</span> === dp[i]) &#123;</span><br><span class="line">          count[i] += count[j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...dp);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[i] === max) &#123;</span><br><span class="line">      <span class="comment">// 在 dp 中遍历出现最大值的位置</span></span><br><span class="line">      res += count[i]; <span class="comment">// 对应到 cnt 的出现次数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="其他类型题目"><a href="#其他类型题目" class="headerlink" title="其他类型题目"></a>其他类型题目</h1><h2 id="圆圈中最后剩下的数字"><a href="#圆圈中最后剩下的数字" class="headerlink" title="圆圈中最后剩下的数字"></a>圆圈中最后剩下的数字</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</a></p>
<p>这道题的最佳解法是数学解法，但是用循环链表暴力计算也可以得出，只是会超时。<br>这里先放上会超时的代码，如果不考虑超时的话这个写法是没问题的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListNode</span>(<span class="params">val, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.val = val || <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">this</span>.next = next || <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> createLinkList = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">let</span> p = head;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> listNode = <span class="keyword">new</span> ListNode(i);</span><br><span class="line">    p.next = listNode;</span><br><span class="line">    p = p.next;</span><br><span class="line">  &#125;</span><br><span class="line">  p.next = head;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">last</span>: p, head &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">m</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lastRemaining = <span class="function"><span class="keyword">function</span> (<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; head, last &#125; = createLinkList(n);</span><br><span class="line">  <span class="keyword">let</span> p = head;</span><br><span class="line">  <span class="keyword">let</span> prev = last;</span><br><span class="line">  <span class="keyword">let</span> cnt = n;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; (m &gt; cnt ? m % cnt : m); i++) &#123;</span><br><span class="line">      prev = p;</span><br><span class="line">      p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    prev.next = prev.next.next;</span><br><span class="line">    p = prev.next;</span><br><span class="line">    cnt--;</span><br><span class="line">    <span class="keyword">if</span> (p === prev) <span class="keyword">return</span> p.val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="字符串乘法"><a href="#字符串乘法" class="headerlink" title="字符串乘法"></a>字符串乘法</h2><blockquote>
<p>给定两个以字符串形式表示的非负整数  num1  和  num2，返回  num1  和  num2  的乘积，它们的乘积也表示为字符串形式。<br>注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p>
</blockquote>
<p>这个题不是很难，但是很麻烦。思路就是把成绩拆成先个位数相乘，然后末尾加上若干个 0（表示十位数百位数这样），最后再加起来</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (num1 == <span class="number">0</span> || num2 == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> addZero = <span class="function">(<span class="params">str, amount, dire = <span class="string">&quot;back&quot;</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> arr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; amount; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dire === <span class="string">&quot;back&quot;</span>) arr.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> arr.unshift(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mult1 = <span class="function">(<span class="params">str, num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> acc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = str.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">let</span> val = <span class="built_in">Math</span>.floor((acc + str[i] * num) % <span class="number">10</span>);</span><br><span class="line">    acc = <span class="built_in">Math</span>.floor((acc + str[i] * num) / <span class="number">10</span>);</span><br><span class="line">    res.unshift(val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (acc !== <span class="number">0</span>) res.unshift(acc);</span><br><span class="line">  <span class="keyword">return</span> res.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">str1, str2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [len1, len2] = [str1.length, str2.length];</span><br><span class="line">  <span class="keyword">const</span> len = <span class="built_in">Math</span>.max(len1, len2);</span><br><span class="line">  <span class="keyword">if</span> (len1 &gt; len2) &#123;</span><br><span class="line">    str2 = addZero(str2, len1 - len2, <span class="string">&quot;front&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len1 &lt; len2) &#123;</span><br><span class="line">    str1 = addZero(str1, len2 - len1, <span class="string">&quot;front&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> acc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">let</span> val = <span class="built_in">Math</span>.floor(</span><br><span class="line">      (acc + <span class="built_in">Number</span>(str1[i] || <span class="number">0</span>) + <span class="built_in">Number</span>(str2[i] || <span class="number">0</span>)) % <span class="number">10</span></span><br><span class="line">    );</span><br><span class="line">    acc = <span class="built_in">Math</span>.floor((acc + <span class="built_in">Number</span>(str1[i] || <span class="number">0</span>) + <span class="built_in">Number</span>(str2[i] || <span class="number">0</span>)) / <span class="number">10</span>);</span><br><span class="line">    res.unshift(val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (acc !== <span class="number">0</span>) res.unshift(acc);</span><br><span class="line">  <span class="keyword">return</span> res.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum = <span class="string">&quot;0&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> longerNum = num1.length &gt; num2.length ? num1 : num2;</span><br><span class="line"><span class="keyword">const</span> shoterNum = num1.length &lt;= num2.length ? num1 : num2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = shoterNum.length - <span class="number">1</span>, i = <span class="number">0</span>; j &gt;= <span class="number">0</span>; j--, i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = mult1(longerNum, shoterNum[j]);</span><br><span class="line">  res = addZero(res, i);</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  sum = add(sum, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br></pre></td></tr></table></figure>

<h2 id="旋转一个矩阵"><a href="#旋转一个矩阵" class="headerlink" title="旋转一个矩阵"></a>旋转一个矩阵</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-image/">https://leetcode.cn/problems/rotate-image/</a></p>
<blockquote>
<p>给定一个 n × n 的二维矩阵  matrix 表示一个图像。请你将图像顺时针旋转 90 度。<br>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
</blockquote>
<p>这个题其实关键在于思路，思路有了代码很好写。<br>思路就是：一个矩阵顺时针旋转 90°，就相当于先按照从左上到右下的对角线两两交换值，然后再两两交换对应的列即可（比如第一列和第四列，第二列和第三列这样）。<br>如果是逆时针，就把对角线变成右上到左下即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">matrix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> m = matrix.length;</span><br><span class="line">  <span class="keyword">const</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="comment">// 注意这里j从i开始，否则就会又转回去了</span></span><br><span class="line">      [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n / <span class="number">2</span>; j++) &#123;</span><br><span class="line">      [matrix[i][j], matrix[i][n - j - <span class="number">1</span>]] = [</span><br><span class="line">        matrix[i][n - j - <span class="number">1</span>],</span><br><span class="line">        matrix[i][j],</span><br><span class="line">      ];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="简化路径"><a href="#简化路径" class="headerlink" title="简化路径"></a>简化路径</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/simplify-path/">https://leetcode.cn/problems/simplify-path/</a></p>
<p>思路其实不是很复杂，主要是通过栈。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">path</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> simplifyPath = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (path[path.length - <span class="number">1</span>] === <span class="string">&quot;/&quot;</span>) path = path.slice(<span class="number">0</span>, path.length - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (path[<span class="number">0</span>] !== <span class="string">&quot;/&quot;</span>) path = <span class="string">&quot;/&quot;</span> + path;</span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; path.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path[i] === <span class="string">&quot;/&quot;</span> &amp;&amp; path[i + <span class="number">1</span>] === <span class="string">&quot;/&quot;</span>) <span class="keyword">continue</span>;</span><br><span class="line">    tmp += path[i];</span><br><span class="line">  &#125;</span><br><span class="line">  path = tmp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> files = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">  files.shift();</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> file <span class="keyword">of</span> files) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file === <span class="string">&quot;.&quot;</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (file === <span class="string">&quot;..&quot;</span>) stack.pop();</span><br><span class="line">    <span class="keyword">else</span> stack.push(file);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;/&quot;</span> + stack.filter(<span class="function">(<span class="params">str</span>) =&gt;</span> str !== <span class="string">&quot;&quot;</span>).join(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">https://leetcode.cn/problems/merge-intervals/</a></p>
<blockquote>
<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回   一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间  。<br>示例 1：<br>输入：intervals = [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p>
</blockquote>
<p>双指针比较，然后原地替换并删除多于的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">intervals</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">intervals</span>) </span>&#123;</span><br><span class="line">  intervals.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (intervals[i + <span class="number">1</span>] &amp;&amp; intervals[i][<span class="number">1</span>] &gt;= intervals[i + <span class="number">1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">      intervals[i] = [</span><br><span class="line">        intervals[i][<span class="number">0</span>],</span><br><span class="line">        <span class="built_in">Math</span>.min(intervals[i + <span class="number">1</span>][<span class="number">1</span>], intervals[i][<span class="number">1</span>]),</span><br><span class="line">      ];</span><br><span class="line">      intervals.splice(i + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> intervals;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="简单计算器"><a href="#简单计算器" class="headerlink" title="简单计算器"></a>简单计算器</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/basic-calculator-ii/">https://leetcode.cn/problems/basic-calculator-ii/</a></p>
<blockquote>
<p>给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。<br>整数除法仅保留整数部分。<br>你可以假设给定的表达式总是有效的。所有中间结果将在  [-231, 231 - 1] 的范围内。<br>示例 1：<br>输入：s = “3+2*2”<br>输出：7</p>
</blockquote>
<p>这道题因为没有括号，因此不用考虑转为后缀表达式求值；<br>思路还是利用栈，每个数字前都有一个符号（第一个数字视为+）</p>
<ul>
<li>如果这个符号是+/-，就入栈数字</li>
<li>如果这个符号是乘或除，就把当前数字和栈顶数字取出来做相乘、相除，并把结果入栈</li>
<li>最后栈中剩下的数字全部相加即可。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> calculate = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s[<span class="number">0</span>] !== <span class="string">&quot;-&quot;</span>) s = <span class="string">&quot;+&quot;</span> + s;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; ) &#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[i++] === <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!<span class="built_in">isNaN</span>(s[i])) num += s[i++];</span><br><span class="line">      stack.push(+num);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i++] === <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!<span class="built_in">isNaN</span>(s[i])) num += s[i++];</span><br><span class="line">      stack.push(-<span class="built_in">Number</span>(num));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i++] === <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> top = stack.pop();</span><br><span class="line">      <span class="keyword">while</span> (!<span class="built_in">isNaN</span>(s[i])) num += s[i++];</span><br><span class="line">      stack.push(top * +num);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i++] === <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> top = stack.pop();</span><br><span class="line">      <span class="keyword">while</span> (!<span class="built_in">isNaN</span>(s[i])) num += s[i++];</span><br><span class="line">      stack.push(<span class="built_in">Math</span>.trunc(top / +num));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre + cur);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="对角线遍历矩阵"><a href="#对角线遍历矩阵" class="headerlink" title="对角线遍历矩阵"></a>对角线遍历矩阵</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diagonal-traverse/">https://leetcode.cn/problems/diagonal-traverse/</a></p>
<blockquote>
<p>给你一个大小为 m x n 的矩阵 mat ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。</p>
</blockquote>
<p>思路：首先确定遍历方式：始终从右上向左下遍历。因此以第一行为基准，每一行都从右上向左下遍历。<br>注意要确定遍历次数，遍历次数经过一点数学计算，应该是<code>长边+短边-1</code>，表示一共需要来回走多少次。最后把偶数位置上的数组翻转展平即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">mat</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findDiagonalOrder = <span class="function"><span class="keyword">function</span> (<span class="params">mat</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 右上角mat[i-1][j+1]</span></span><br><span class="line">  <span class="comment">// 左下角mat[i+1][i-1]</span></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> m = mat.length;</span><br><span class="line">  <span class="keyword">const</span> n = mat[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">const</span> mostTimes = <span class="built_in">Math</span>.max(m, n) + <span class="built_in">Math</span>.min(m, n) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; mostTimes; k++) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> j = k;</span><br><span class="line">    <span class="keyword">const</span> tmp = [];</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; i &lt; m) &#123;</span><br><span class="line">      mat[i][j] != <span class="literal">undefined</span> &amp;&amp; tmp.push(mat[i][j]);</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    res.push([...tmp]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      res[i] = res[i].reverse();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.flat(<span class="literal">Infinity</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-to-roman/">https://leetcode.cn/problems/integer-to-roman/</a></p>
<p>这道题有一个很重要的思路：数字的拆分。<br>因为罗马数字实际上只是表示不同，位数的顺序和阿拉伯数字并没有区别；因此可以将罗马数字对应的阿拉伯数字从高到低位依次从数字中减去，按照这个顺序就恰好是结果。<br>比如，1586 这个数字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1586 -- 1000 -- M</span><br><span class="line">586 -- 500 -- D</span><br><span class="line">86 -- 50 -- L</span><br><span class="line">36 -- 10 -- X</span><br><span class="line">26 -- 10 -- X</span><br><span class="line">16 -- 10 -- X</span><br><span class="line">6 -- 5 -- V</span><br><span class="line">1 -- 1 -- I</span><br></pre></td></tr></table></figure>

<p>可以看到，随着数字的减小，对应的罗马数字也是依次减小的；因此只需要<strong>从大到小遍历一次</strong>就可以。每次遍历执行这个步骤：</p>
<ol>
<li>找到第一个比当前数 num 小的数</li>
<li>num - 该数，然后把结果放入数组。注意这里应该是一个<strong>循环</strong>，如果减去之后大于这个数，那就继续减，对应的是叠加的情况。</li>
<li>当减到 num 比该数小的时候，继续向后遍历，直到再找到一个比 num 小的数，执行上面步骤。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">num</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> intToRoman = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="comment">// map还要包含4和9的情况</span></span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="number">1</span>, <span class="string">&quot;I&quot;</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="string">&quot;IV&quot;</span>],</span><br><span class="line">    [<span class="number">5</span>, <span class="string">&quot;V&quot;</span>],</span><br><span class="line">    [<span class="number">9</span>, <span class="string">&quot;IX&quot;</span>],</span><br><span class="line">    [<span class="number">10</span>, <span class="string">&quot;X&quot;</span>],</span><br><span class="line">    [<span class="number">40</span>, <span class="string">&quot;XL&quot;</span>],</span><br><span class="line">    [<span class="number">50</span>, <span class="string">&quot;L&quot;</span>],</span><br><span class="line">    [<span class="number">90</span>, <span class="string">&quot;XC&quot;</span>],</span><br><span class="line">    [<span class="number">100</span>, <span class="string">&quot;C&quot;</span>],</span><br><span class="line">    [<span class="number">400</span>, <span class="string">&quot;CD&quot;</span>],</span><br><span class="line">    [<span class="number">500</span>, <span class="string">&quot;D&quot;</span>],</span><br><span class="line">    [<span class="number">900</span>, <span class="string">&quot;CM&quot;</span>],</span><br><span class="line">    [<span class="number">1000</span>, <span class="string">&quot;M&quot;</span>],</span><br><span class="line">  ]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [key, val] <span class="keyword">of</span> [...map.entries()].reverse()) &#123;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; key) &#123;</span><br><span class="line">      <span class="comment">// 找到第一个比当前数num小的数</span></span><br><span class="line">      num -= key;</span><br><span class="line">      res.push(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num === <span class="number">0</span>) <span class="keyword">return</span> res.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/">日常学习</a></div><div class="post_share"><div class="social-share" data-image="/img/codes1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/12/OS/"><img class="prev-cover" src="/img/codes1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">操作系统知识点总结</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/05/blog44-optimization/"><img class="next-cover" src="/img/codes1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">优化问题总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/11/06/blog11-myReact/" title="react知识点汇总和使用小总结(一)"><img class="cover" src="/img/react.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-06</div><div class="title">react知识点汇总和使用小总结(一)</div></div></a></div><div><a href="/2021/10/27/blog10-react-router/" title="react-router的使用"><img class="cover" src="/img/reactrouter.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-27</div><div class="title">react-router的使用</div></div></a></div><div><a href="/2021/11/20/blog14-react-ts-basic/" title="typescript+react基础部分"><img class="cover" src="/img/typescript.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-20</div><div class="title">typescript+react基础部分</div></div></a></div><div><a href="/2021/11/22/blog17-react-pubsub-issues/" title="react+typescript使用pubsub时的一点小问题"><img class="cover" src="/img/pubsub.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-22</div><div class="title">react+typescript使用pubsub时的一点小问题</div></div></a></div><div><a href="/2021/11/20/blog16-react-ts-hooks-redux/" title="typescript+react:自定义hooks代替redux"><img class="cover" src="/img/typescript.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-20</div><div class="title">typescript+react:自定义hooks代替redux</div></div></a></div><div><a href="/2021/11/25/blog18-vue3ts-basic/" title="vue3+ts配置及简单使用注意"><img class="cover" src="/img/vue3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-25</div><div class="title">vue3+ts配置及简单使用注意</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/pinkstar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xing Ye</div><div class="author-info__description">a singleThreaded boy's blog</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/penghei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/penghei" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:632885485@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">A SingleThreaded Boy...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.</span> <span class="toc-text">算法复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.1.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.</span> <span class="toc-text">迭代时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.3.</span> <span class="toc-text">递归的时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-1"><span class="toc-number">2.1.</span> <span class="toc-text">两数之和 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.</span> <span class="toc-text">合并有序数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%95%B0%E6%B1%82%E5%92%8C"><span class="toc-number">2.3.</span> <span class="toc-text">三数求和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="toc-number">2.4.</span> <span class="toc-text">有序数组的平方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">2.5.</span> <span class="toc-text">移除元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="toc-number">2.6.</span> <span class="toc-text">移动零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="toc-number">2.7.</span> <span class="toc-text">两个数组的交集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.1.</span> <span class="toc-text">回文字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP-%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">KMP 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.3.</span> <span class="toc-text">重复子字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="toc-number">3.4.</span> <span class="toc-text">最长公共前缀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%BA%8F%E5%8F%B7"><span class="toc-number">3.5.</span> <span class="toc-text">列表序号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81-IP-%E5%9C%B0%E5%9D%80"><span class="toc-number">3.6.</span> <span class="toc-text">验证 IP 地址</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">4.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8"><span class="toc-number">4.1.</span> <span class="toc-text">合并链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dummy-%E8%8A%82%E7%82%B9"><span class="toc-number">4.2.</span> <span class="toc-text">dummy 节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="toc-number">4.3.</span> <span class="toc-text">快慢指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">4.4.</span> <span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E5%8F%8D%E8%BD%AC%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8"><span class="toc-number">4.5.</span> <span class="toc-text">部分反转一个链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8"><span class="toc-number">4.6.</span> <span class="toc-text">递归反转一个链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E4%BA%A4%E5%8F%89"><span class="toc-number">4.7.</span> <span class="toc-text">链表交叉</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-number">4.8.</span> <span class="toc-text">判断回文链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">5.</span> <span class="toc-text">栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.</span> <span class="toc-text">括号匹配问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C%E5%AF%B9%E5%AF%B9%E7%A2%B0%E2%80%9D%E6%B6%88%E9%99%A4"><span class="toc-number">5.2.</span> <span class="toc-text">“对对碰”消除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">5.3.</span> <span class="toc-text">后缀表达式求值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%88%E6%9B%B4%E9%AB%98%E6%B8%A9%E5%BA%A6%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">单调栈和单调队列（更高温度）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">5.5.</span> <span class="toc-text">滑动窗口最大值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81"><span class="toc-number">5.6.</span> <span class="toc-text">字符串解码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">6.</span> <span class="toc-text">滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-number">6.1.</span> <span class="toc-text">基本思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="toc-number">6.1.1.</span> <span class="toc-text">字符串的排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-number">6.1.2.</span> <span class="toc-text">无重复字符的最长子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-number">6.1.3.</span> <span class="toc-text">找到字符串中所有字母异位词</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">6.2.</span> <span class="toc-text">栈实现队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">7.</span> <span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E8%BE%B9%E7%95%8C"><span class="toc-number">7.1.</span> <span class="toc-text">二分查找的边界</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC"><span class="toc-number">7.2.</span> <span class="toc-text">寻找峰值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%80%92%E5%BD%92%E6%80%9D%E8%B7%AF"><span class="toc-number">8.1.</span> <span class="toc-text">二叉树问题的基本递归思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86"><span class="toc-number">8.2.</span> <span class="toc-text">二叉树的迭代遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">8.2.1.</span> <span class="toc-text">先序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">8.2.2.</span> <span class="toc-text">后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">8.2.3.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">8.2.4.</span> <span class="toc-text">层序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.3.</span> <span class="toc-text">翻转二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BST%EF%BC%88%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%89"><span class="toc-number">8.4.</span> <span class="toc-text">BST（二叉搜索树）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">8.4.1.</span> <span class="toc-text">二叉树的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BST-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">8.4.2.</span> <span class="toc-text">BST 基本操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E6%98%AF%E5%90%A6%E6%98%AF%E6%9C%89%E6%95%88-BST"><span class="toc-number">8.5.</span> <span class="toc-text">验证是否是有效 BST</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC-BST"><span class="toc-number">8.6.</span> <span class="toc-text">有序数组转 BST</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.6.0.1.</span> <span class="toc-text">构造最大二叉树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.7.</span> <span class="toc-text">判断平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.8.</span> <span class="toc-text">平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.9.</span> <span class="toc-text">比较两棵二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%B4%E5%AF%B9%E7%A7%B0"><span class="toc-number">8.10.</span> <span class="toc-text">二叉树轴对称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-number">8.11.</span> <span class="toc-text">二叉树的深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-number">8.12.</span> <span class="toc-text">二叉树的路径问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98-1%EF%BC%88%E7%9B%AE%E6%A0%87%E5%92%8C%EF%BC%89"><span class="toc-number">8.12.1.</span> <span class="toc-text">路径问题 1（目标和）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98-2%EF%BC%88%E5%85%B7%E4%BD%93%E8%B7%AF%E5%BE%84%EF%BC%89"><span class="toc-number">8.12.2.</span> <span class="toc-text">路径问题 2（具体路径）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98-3%EF%BC%88%E4%BB%BB%E6%84%8F%E8%8A%82%E7%82%B9%E5%BC%80%E5%A7%8B%EF%BC%89"><span class="toc-number">8.12.3.</span> <span class="toc-text">路径问题 3（任意节点开始）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">8.12.4.</span> <span class="toc-text">最大路径和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="toc-number">8.13.</span> <span class="toc-text">二叉树左叶子之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%80%BC"><span class="toc-number">8.14.</span> <span class="toc-text">二叉树最值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">8.15.</span> <span class="toc-text">二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.16.</span> <span class="toc-text">从前序遍历和中序遍历构造二叉树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-number">9.</span> <span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-number">9.1.</span> <span class="toc-text">回溯问题的基本思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98"><span class="toc-number">9.1.1.</span> <span class="toc-text">特殊回溯问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E9%A2%98%E7%9B%AE"><span class="toc-number">9.1.2.</span> <span class="toc-text">具体题目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-number">9.2.</span> <span class="toc-text">全排列问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">9.2.1.</span> <span class="toc-text">基本全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97-2%EF%BC%88%E5%89%AA%E6%9E%9D%EF%BC%89"><span class="toc-number">9.2.2.</span> <span class="toc-text">全排列 2（剪枝）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98"><span class="toc-number">9.3.</span> <span class="toc-text">组合问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98"><span class="toc-number">9.3.1.</span> <span class="toc-text">基本组合问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%90%88"><span class="toc-number">9.3.2.</span> <span class="toc-text">组合总合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-2"><span class="toc-number">9.3.3.</span> <span class="toc-text">组合总和 2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98"><span class="toc-number">9.4.</span> <span class="toc-text">子集问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E9%97%AE%E9%A2%98"><span class="toc-number">9.5.</span> <span class="toc-text">分割问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-number">9.5.1.</span> <span class="toc-text">分割回文串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%95%88-ip-%E5%9C%B0%E5%9D%80"><span class="toc-number">9.5.2.</span> <span class="toc-text">有效 ip 地址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98"><span class="toc-number">9.6.</span> <span class="toc-text">岛屿问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-number">9.6.1.</span> <span class="toc-text">岛屿数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%B2%9B%E5%B1%BF%E9%9D%A2%E7%A7%AF"><span class="toc-number">9.6.2.</span> <span class="toc-text">最大岛屿面积</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="toc-number">9.7.</span> <span class="toc-text">括号生成</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">10.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">10.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">10.2.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">10.3.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">10.4.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E6%8E%92"><span class="toc-number">10.5.</span> <span class="toc-text">快排</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TOP-K-%E9%97%AE%E9%A2%98"><span class="toc-number">10.6.</span> <span class="toc-text">TOP K 问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">11.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98"><span class="toc-number">11.1.</span> <span class="toc-text">爬楼梯问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%91%E7%A1%AC%E5%B8%81%E6%89%BE%E9%9B%B6"><span class="toc-number">11.2.</span> <span class="toc-text">最少硬币找零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">11.3.</span> <span class="toc-text">最大子数组和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">11.4.</span> <span class="toc-text">最长上升子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">11.5.</span> <span class="toc-text">最长连续递增子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">11.6.</span> <span class="toc-text">最长公共子数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-number">11.7.</span> <span class="toc-text">不同路径问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E6%9C%80%E5%B0%8F%E5%92%8C"><span class="toc-number">11.8.</span> <span class="toc-text">下降路径最小和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-1-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">11.9.</span> <span class="toc-text">0-1 背包问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="toc-number">11.10.</span> <span class="toc-text">整数拆分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="toc-number">11.11.</span> <span class="toc-text">杨辉三角</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8-I"><span class="toc-number">11.12.</span> <span class="toc-text">买卖股票 I</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8-II"><span class="toc-number">11.13.</span> <span class="toc-text">买卖股票 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">11.14.</span> <span class="toc-text">判断子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">11.15.</span> <span class="toc-text">不同子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E6%95%B0%E9%87%8F"><span class="toc-number">11.16.</span> <span class="toc-text">回文子串数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">11.17.</span> <span class="toc-text">最长回文子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">11.18.</span> <span class="toc-text">最长回文子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="toc-number">11.19.</span> <span class="toc-text">最大正方形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">11.20.</span> <span class="toc-text">最长递增子序列的个数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE"><span class="toc-number">12.</span> <span class="toc-text">其他类型题目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">12.1.</span> <span class="toc-text">圆圈中最后剩下的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%98%E6%B3%95"><span class="toc-number">12.2.</span> <span class="toc-text">字符串乘法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E4%B8%80%E4%B8%AA%E7%9F%A9%E9%98%B5"><span class="toc-number">12.3.</span> <span class="toc-text">旋转一个矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84"><span class="toc-number">12.4.</span> <span class="toc-text">简化路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-number">12.5.</span> <span class="toc-text">合并区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="toc-number">12.6.</span> <span class="toc-text">简单计算器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86%E7%9F%A9%E9%98%B5"><span class="toc-number">12.7.</span> <span class="toc-text">对角线遍历矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97"><span class="toc-number">12.8.</span> <span class="toc-text">整数转罗马数字</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/05/18/projects/" title="无题"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/05/18/projects/" title="无题">无题</a><time datetime="2022-05-18T02:57:57.356Z" title="发表于 2022-05-18 10:57:57">2022-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/13/handwriting/" title="js题目"><img src="/img/JS.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="js题目"/></a><div class="content"><a class="title" href="/2022/05/13/handwriting/" title="js题目">js题目</a><time datetime="2022-05-13T04:21:10.000Z" title="发表于 2022-05-13 12:21:10">2022-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/12/OS/" title="操作系统知识点总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统知识点总结"/></a><div class="content"><a class="title" href="/2022/05/12/OS/" title="操作系统知识点总结">操作系统知识点总结</a><time datetime="2022-05-12T07:58:22.000Z" title="发表于 2022-05-12 15:58:22">2022-05-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/05/blog43-algorithms/" title="算法学习总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法学习总结"/></a><div class="content"><a class="title" href="/2022/04/05/blog43-algorithms/" title="算法学习总结">算法学习总结</a><time datetime="2022-04-05T08:01:22.000Z" title="发表于 2022-04-05 16:01:22">2022-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/05/blog44-optimization/" title="优化问题总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="优化问题总结"/></a><div class="content"><a class="title" href="/2022/04/05/blog44-optimization/" title="优化问题总结">优化问题总结</a><time datetime="2022-04-05T08:01:22.000Z" title="发表于 2022-04-05 16:01:22">2022-04-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Xing Ye</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hello stranger!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>