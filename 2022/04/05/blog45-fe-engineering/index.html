<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>前端工程化总结 | XingYeBlog</title><meta name="keywords" content="面试"><meta name="author" content="Xing Ye,632885485@qq.com"><meta name="copyright" content="Xing Ye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基本 Node 环境package.jsonnode 官方文档：https:&#x2F;&#x2F;docs.npmjs.com&#x2F;cli&#x2F;v8&#x2F;configuring-npm&#x2F;package-json package.json 中的关键属性：  name：当前库或包的名称。对于 name 的使用有一些限制，比如字符长度不能超过 214，必须使用 ascii 字符且不能有大写字母等，详情参考文档。 version：版本">
<meta property="og:type" content="article">
<meta property="og:title" content="前端工程化总结">
<meta property="og:url" content="http://example.com/2022/04/05/blog45-fe-engineering/index.html">
<meta property="og:site_name" content="XingYeBlog">
<meta property="og:description" content="基本 Node 环境package.jsonnode 官方文档：https:&#x2F;&#x2F;docs.npmjs.com&#x2F;cli&#x2F;v8&#x2F;configuring-npm&#x2F;package-json package.json 中的关键属性：  name：当前库或包的名称。对于 name 的使用有一些限制，比如字符长度不能超过 214，必须使用 ascii 字符且不能有大写字母等，详情参考文档。 version：版本">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/codes1.jpg">
<meta property="article:published_time" content="2022-04-05T08:01:22.000Z">
<meta property="article:modified_time" content="2023-02-14T16:05:15.908Z">
<meta property="article:author" content="Xing Ye">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/codes1.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2022/04/05/blog45-fe-engineering/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端工程化总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-15 00:05:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/pinkstar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/codes1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XingYeBlog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">前端工程化总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-05T08:01:22.000Z" title="发表于 2022-04-05 16:01:22">2022-04-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-14T16:05:15.908Z" title="更新于 2023-02-15 00:05:15">2023-02-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%8E%9F%E7%90%86/">原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="前端工程化总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="基本-Node-环境"><a href="#基本-Node-环境" class="headerlink" title="基本 Node 环境"></a>基本 Node 环境</h1><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>node 官方文档：<a target="_blank" rel="noopener" href="https://docs.npmjs.com/cli/v8/configuring-npm/package-json">https://docs.npmjs.com/cli/v8/configuring-npm/package-json</a></p>
<p>package.json 中的关键属性：</p>
<ul>
<li>name：当前库或包的名称。对于 name 的使用有一些限制，比如字符长度不能超过 214，必须使用 ascii 字符且不能有大写字母等，详情参考文档。</li>
<li>version：版本号，即 semver 版本。如果库是需要发布的，版本号就是最重要的属性。</li>
<li>main：即库的入口文件。在 main 定义的文件内导出的内容将会作为 require 的返回值，也就是说当用户下载并通过<code>require(&#39;xxx&#39;)</code>导入库时，导入的就是入口文件中的 export。如果没有定义，默认采取根目录下的 index.js 文件。</li>
<li>scripts：即可执行的命令。每个 scripts 都有自己的生命周期，</li>
<li>dependencies 和 devDependencies：详见下</li>
<li>engines：主要用于限制 node 和 npm 的版本。在 engines 字段中添加对 node 或 npm 版本的要求，如果用户的版本不符合，则会导致警告（npm）或报错（yarn）</li>
</ul>
<h2 id="npm-scripts-的生命周期"><a href="#npm-scripts-的生命周期" class="headerlink" title="npm scripts 的生命周期"></a>npm scripts 的生命周期</h2><p>每个 scripts 都可以为其创建一个 pre 版本和 post 版本，用于在这个 scripts 执行的前后分别执行。只要命名符合就可以执行。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;precompress&quot;</span>: <span class="string">&quot;&#123;&#123; executes BEFORE the `compress` script &#125;&#125;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;compress&quot;</span>: <span class="string">&quot;&#123;&#123; run command to compress files &#125;&#125;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;postcompress&quot;</span>: <span class="string">&quot;&#123;&#123; executes AFTER `compress` script &#125;&#125;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上每个内置的脚本都包含自己的一些 pre、post 等脚本。比如执行 npm install，实际上是按照这个顺序执行的：</p>
<ul>
<li>preinstall</li>
<li>install</li>
<li>postinstall</li>
</ul>
<p>执行 npm publish，是按照这个顺序执行的</p>
<ul>
<li>prepublishOnly: 发布时最重要的一个生命周期，在包的准备和打包之前运行，可以做一些整理、测试、构建等工作</li>
<li>prepack</li>
<li>prepare</li>
<li>postpack</li>
<li>publish</li>
<li>postpublish</li>
</ul>
<p>至于其他的可以参考<a target="_blank" rel="noopener" href="https://docs.npmjs.com/cli/v8/using-npm/scripts#npm-cache-add">官方文档</a></p>
<h3 id="dependencies-和-devDependencies"><a href="#dependencies-和-devDependencies" class="headerlink" title="dependencies 和 devDependencies"></a>dependencies 和 devDependencies</h3><p><code>devDependencies</code> 里面的插件只用于开发环境，不用于生产环境，<br><code>dependencies</code> 是需要发布到生产环境的。</p>
<h3 id="semver"><a href="#semver" class="headerlink" title="semver"></a>semver</h3><p>即安装库时后面的版本号，版本号有三个数，分别为<code>[major, minor, patch]</code>：</p>
<ul>
<li>major: 主版本号，该值不同的版本之间 api 不能兼容，比如 vue2 和 vue3</li>
<li>minor: 新增功能并且能保证向后兼容，相当于一次小更新</li>
<li>patch: 修复了一个向后兼容的 Bug 时，几乎不改变</li>
</ul>
<p>除了这三个数，有时候版本号前面还会带一个<code>^</code>或者<code>~</code>，这两个字符表示：</p>
<ul>
<li><code>^</code>：minor 和 patch 可以不同，即对于 <code>^1.2.3</code> 而言，它的版本号范围是 <code>[1.2.3, 2.0.0)</code>（区间左闭右开）</li>
<li><code>~</code>：patch 可以不同，对于 ~1.2.3 而言，它的版本号范围是 <code>[1.2.3, 1.3.0)</code></li>
</ul>
<p>当我们 npm i 时，默认的版本号是 ^，可最大限度地在向后兼容与新特性之间做取舍，但是这导致库的版本并不是一个确切的值而是一个范围，所以项目中使用的确切版本号实际上是在 yarn.lock/package-lock.json 中锁定的版本号。</p>
<ul>
<li>如果库的版本更新，但是在 lock 文件中依旧锁定，并且更新的范围在<code>^</code>或<code>~</code>的范围内，那就不会更新库的实际版本。</li>
<li>如果库的版本更新导致范围超出<code>^</code>或<code>~</code>的范围，即如果手动修改了 package.json 中的版本号，与 package-lock.json 中不是一致的版本范围。此时 npm i 将下载最新版本号，并重写 package-lock.json 中锁定的版本号。</li>
</ul>
<h2 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h2><p>官方文档：<a target="_blank" rel="noopener" href="https://docs.npmjs.com/cli/v8/configuring-npm/package-lock-json">https://docs.npmjs.com/cli/v8/configuring-npm/package-lock-json</a></p>
<blockquote>
<p>package-lock.json 会为 npm 修改 node_modules 树或 package.json 的任何操作自动生成。它描述了生成的确切树，以便后续安装能够生成相同的树，而不管中间依赖项更新如何。<br>该文件旨在提交到源存储库中，并用于各种目的：</p>
<ul>
<li>描述依赖关系树的单一表示，以保证团队成员、部署和持续集成安装完全相同的依赖关系。即 lock 文件中会展示每个包的依赖、依赖的依赖、依赖的依赖的依赖，直到展开到每一个包的确切版本以及 npm 链接等数据。相当于一棵完整的依赖树</li>
<li>为用户提供“时间旅行”到 node_modules 先前状态的工具，而无需提交目录本身。</li>
<li>通过可读的源代码控制差异促进树变化的更大可见性。</li>
<li>通过允许 npm 跳过以前安装的包的重复元数据解析来优化安装过程。</li>
<li>从 npm v7 开始，lockfiles 包含足够的信息来获得库的依赖树的完整结构，减少了读取 package.json 文件的需要，并显著提高性能。</li>
</ul>
</blockquote>
<p>packagelock.json/yarn.lock 用以锁定版本号，保证开发环境与生产环境的一致性，避免出现不兼容 API 导致生产环境报错<br>当有了 lock 文件时，每一个依赖的版本号都被锁死在了 lock 文件，每次依赖安装的版本号都从 lock 文件中进行获取，避免了不可测的依赖风险。</p>
<blockquote>
<p>一个问题: 当项目中没有 lock 文件时，生产环境的风险是如何产生的?<br>演示风险过程如下:<br>pkg 1.2.3: 首次在开发环境安装 pkg 库，为此时最新版本 1.2.3，dependencies 依赖中显示 ^1.2.3，实际安装版本为 1.2.3<br>pkg 1.19.0: 在生产环境中上线项目，安装 pkg 库，此时最新版本为 1.19.0，满足 dependencies 中依赖 ^1.2.3 范围，实际安装版本为 1.19.0，但是 pkg 未遵从 semver 规范，在此过程中引入了 Breaking Change，如何此时 1.19.0 有问题的话，那生产环境中的 1.19.0 将会导致 bug，且难以调试<br>如果使用 lock 文件锁住版本号，就会确保版本是可用的，减少可能出现的问题。</p>
</blockquote>
<h2 id="npm-install-发生了什么"><a href="#npm-install-发生了什么" class="headerlink" title="npm install 发生了什么"></a>npm install 发生了什么</h2><p><img src="https://pic.imgdb.cn/item/6277cfcf0947543129564ce3.jpg"></p>
<ol>
<li>npm install 执行后，会<strong>检查并获取 npm 配置</strong></li>
</ol>
<blockquote>
<p>优先级为:<br>项目级别的.npmrc 文件 &gt; 用户级别的.npmrc 文件 &gt; 全局的.npmrc 文件 &gt; npm 内置的.npmrc 文件</p>
</blockquote>
<p>.npmrc 文件就是 npm 的配置文件。查看 npm 的所有配置, 包括默认配置，可以通过下面的命令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config ls -l</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>检查当前目录下的 node_modules 是否已经包含了该包，如果有就不再下载。</p>
</li>
<li><p><strong>检查项目中是否有 package-lock.json 文件</strong>，根据 package-lock.json 的依赖关系递归构建依赖树，准备下一步的下载。<br>从 npm 5.x 开始，执行 npm install 时会自动生成一个 package-lock.json 文件。<br>package-lock.json 文件精确描述了 node_modules 目录下所有的包的树状依赖结构，每个包的版本号都是完全精确的。<br>因此 npm 会先检查项目中是否有 package-lock.json 文件，分为两种情况：</p>
</li>
</ol>
<ul>
<li>如果有，检查 package-lock.json 和 package.json 中声明的依赖是否一致<ul>
<li>一致：直接使用 package-lock.json 中声明的依赖，从缓存或者网络中加载依赖</li>
<li>不一致：各个版本的 npm 处理方式如上图</li>
</ul>
</li>
<li>如果没有，根据 package.json 递归构建依赖树，然后根据依赖树下载完整的依赖资源，在下载时会检查是否有相关的资源缓存<ul>
<li>存在：将缓存资源解压到 node_modules 中</li>
<li>不存在：从远程仓库下载资源包，并校验完整性，并添加到缓存，同时解压到 node_modules 中</li>
</ul>
</li>
</ul>
<ol start="4">
<li><p>npm 向 registry 查询模块压缩包的网址、最新版本等信息并<strong>下载资源包</strong>，存放在缓存目录中；<strong>解压资源包到当前项目的 node_modules 目录</strong>；并生成 package-lock.json 文件。</p>
</li>
<li><p>因为不同包的依赖很可能有重复的，为了避免重复安装一个依赖，会在解压时跳过已经拥有的包。构建依赖树时，不管是直接依赖还是子依赖，都会按照扁平化的原则，优先将其放置在 node_modules 根目录中(最新的 npm 规范), 在这个过程中，如果遇到相同的模块，会检查已放置在依赖树中的模块是否符合新模块的版本范围，如果符合，则跳过，不符合，则在当前模块的 node_modules 下放置新模块。</p>
</li>
</ol>
<hr>
<p>另外，在执行 npm install 或 npm update 命令下载依赖后，除了将依赖包安装在 node_modules 目录下外，还会在本地的缓存目录缓存一份。</p>
<p>再次安装依赖的时候，会根据 package-lock.json 中存储的信息生成一个唯一的 key，然后拿着 key 去目录中查找对应的缓存记录，如果有缓存资源，就把对应的二进制文件解压到相应的项目 node_modules 下面，省去了网络下载资源的开销。</p>
<h2 id="npm-run-发生了什么"><a href="#npm-run-发生了什么" class="headerlink" title="npm run 发生了什么"></a>npm run 发生了什么</h2><blockquote>
<ol>
<li>运行 npm run xxx 的时候，npm 会先在当前目录的 node_modules/.bin 查找要执行的程序，如果找到则运行；</li>
<li>没有找到则从全局的 node_modules/.bin 中查找，npm i -g xxx 就是安装到到全局目录；</li>
<li>如果全局目录还是没找到，那么就从 path 环境变量中查找有没有其他同名的可执行程序。</li>
</ol>
</blockquote>
<p>详见：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7078924628525056007">https://juejin.cn/post/7078924628525056007</a></p>
<p>npm run 可以运行定义在 package.json 中的脚本配置项。通常这些命令的启动项都是不存在在系统环境变量的，直接调用会报错，而 npm run 则会通过一系列机制保证其运行。<br>比如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;webpack serve --open&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack 直接在命令行中启动会报错，因为它并非一个可执行文件，并且操作系统中没有存在 webpack 这一条指令。</p>
<p>npm run 能正常运行的原因如下：</p>
<ol>
<li>安装依赖的时候，是通过 npm i xxx 来执行的，例如 <code>npm i webpack</code>，npm 在 安装这个依赖的时候，就会在<code>node_modules/.bin/</code> 目录中创建好这几个几个可执行文件。</li>
</ol>
<p><img src="https://pic.imgdb.cn/item/6277d2da094754312964b429.jpg"></p>
<p>这个目录不是任何一个 npm 包。目录下的文件，表示这是一个个软链接，打开文件可以看到文件顶部写着 #!/bin/sh ，表示这是一个 shell 脚本。<br>比如打开 webpack，里边是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">basedir=$(dirname &quot;$(echo &quot;$0&quot; | sed -e &#x27;s,\\,/,g&#x27;)&quot;)</span><br><span class="line"></span><br><span class="line">case `uname` in</span><br><span class="line">    *CYGWIN*|*MINGW*|*MSYS*) basedir=`cygpath -w &quot;$basedir&quot;`;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">if [ -x &quot;$basedir/node&quot; ]; then</span><br><span class="line">  exec &quot;$basedir/node&quot;  &quot;$basedir/../webpack/bin/webpack.js&quot; &quot;$@&quot;</span><br><span class="line">else</span><br><span class="line">  exec node  &quot;$basedir/../webpack/bin/webpack.js&quot; &quot;$@&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>这些被称为软链接。当执行 webpack 时，就会像脚本里边这样找到对应的 webpack.js 并执行。<br>在 package-lock.json 中，可以查找到一个 bin 的配置项，这一项就是 npm 对于软链接的目标执行文件的配置，这一项的值就是要链接到的具体的文件，就像这样：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;bin&quot;</span>:&#123;</span><br><span class="line">  <span class="attr">&quot;webpack&quot;</span>:<span class="string">&quot;bin/webpack.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>在 npm install 时，会将要运行的文件（即上面配置的 bin 对应的文件）软链接到 ./node_modules/.bin 目录下，而 npm 还会自动把 node_modules/.bin 加入$PATH，这样就可以直接作为命令运行依赖程序和开发依赖程序，不用全局安装了。这种软连接相当于一种映射，执行 npm run xxx 的时候，就会到 node_modules/bin 中找对应的映射文件，然后再找到相应的 js 文件来执行。</p>
</li>
<li><p>当执行<code>npm run start</code>命令时，npm 会到 ./node_modules/.bin 中找到<code>webpack</code>文件执行，相当于执行了<code>./node_modules/.bin/webpack start --open</code>。在系统终端中，相当于执行了<code>./node_modules/.bin/webpack start --open</code>；然后根据原先脚本的设置，将会用 node 去执行<code>node ../webpack/bin/webpack.js</code>，最后完成执行过程。</p>
</li>
</ol>
<blockquote>
<p>npx<br>npx 想要解决的主要问题，就是调用项目内部安装的模块，即前面说的不能直接运行诸如<code>webpack</code>这样的命令。可以通过<code>npx webpack</code>直接运行<br>npx 还可以避免全局安装包，比如<code>npx create-react-app myapp</code>这样的命令可以在没有安装 createreactapp 时直接使用。</p>
</blockquote>
<h1 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h1><blockquote>
<p>Babel 是一个工具链，主要用于将 ECMAScript 2015+ 代码转换为当前和旧浏览器或环境中向后兼容的 JavaScript 版本。babel 能做的事情有:<br>语法转换<br>通过 Polyfill 方式在目标环境中添加缺失的特性 （通过引入第三方 polyfill 模块，例如 core-js）<br>源码转换（codemods）,比如转换 React 的 jsx</p>
</blockquote>
<h2 id="babel-的基本使用"><a href="#babel-的基本使用" class="headerlink" title="babel 的基本使用"></a>babel 的基本使用</h2><p><a target="_blank" rel="noopener" href="https://www.jiangruitao.com/babel/quick-start/">https://www.jiangruitao.com/babel/quick-start/</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>babel 基本使用需要安装至少三个包，分别是 babel 的命令行工具、最常用的 preset，以及 babel 的核心库(core)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D @babel/cli @babel/preset-env @babel/core</span><br></pre></td></tr></table></figure>

<p>注意安装需要-D，因为 babel 只在开发环境下编译，编译完成后不再需要使用</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>babel 的所有配置，都离不开两个配置项：presets 和 plugins</p>
<ul>
<li><code>presets</code>指预设，是一组插件的集合，是一个数组；Babel 官方的 preset，我们实际可能会用到的其实就只有 4 个：<ul>
<li><code>@babel/preset-env</code>，最常用的，日常的转换只需要这个就可以；</li>
<li><code>@babel/preset-flow</code></li>
<li><code>@babel/preset-react</code>，用于转换 jsx</li>
<li><code>@babel/preset-typescript</code>，用于转换 ts</li>
</ul>
</li>
<li><code>plugins</code>指插件，插件的类型类似于 webpack 中的插件。babel 将文件翻译成 AST，经过插件的处理之后再转义成代码，因此插件才是 Babel 的核心。常用的插件现在只有一个：<ul>
<li><code>@babel/plugin-transform-runtime</code>，会将常用的辅助函数（即用来代替或提供新 api 的函数）保存，不用每次编译时都生成，减少代码</li>
</ul>
</li>
</ul>
<p>另外，插件和预设的运行规则如下：</p>
<ul>
<li>插件比预设先执行</li>
<li>插件执行顺序是插件数组从前向后执行</li>
<li>预设执行顺序是预设数组从后向前执行</li>
</ul>
<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><blockquote>
<p>配置文件的具体区别，参考<a target="_blank" rel="noopener" href="https://github.com/willson-wang/Blog/issues/100">https://github.com/willson-wang/Blog/issues/100</a></p>
</blockquote>
<p>babel 的配置文件有多种类型，主要有以下三种：</p>
<ul>
<li><code>babel.config.json</code>：官网推荐的类型，json 格式。适用于全局（包括 node_modules）都可能需要翻译的情况，最基本的配置如下：</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [...],</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，presets 中每一项可以是一个字符串，表示一个预设；如果这个预设要传入参数，就展开成数组：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;useBuiltIns&quot;</span>: <span class="string">&quot;entry&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插件也是同理。</p>
<ul>
<li><p><code>.babelrc</code>，脚手架中最常用的配置文件，实际上是<code>.babelrc.json</code>；适用于只在部分代码中需要转义的情况，比如只需要转义 src 下的代码而不需要改变 node_modules 下的，就可以使用它。<br>配置项和上面的没有任何区别</p>
</li>
<li><p><code>babel.config.js</code>和<code>.babelrc.js</code>，即 js 文件的配置，需要通过 module.exports 导出：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  这里只是举个例子，实际项目中，我们可以传入环境变量等来做处理</span></span><br><span class="line"> <span class="keyword">var</span> year = <span class="number">2020</span>;</span><br><span class="line"> <span class="keyword">var</span> presets = [];</span><br><span class="line"> <span class="keyword">if</span> (year &gt; <span class="number">2018</span>) &#123;</span><br><span class="line">   presets = [<span class="string">&quot;@babel/env&quot;</span>];</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   presets = <span class="string">&quot;presets&quot;</span>: [<span class="string">&quot;es2015&quot;</span>, <span class="string">&quot;es2016&quot;</span>, <span class="string">&quot;es2017&quot;</span>],</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">   <span class="string">&quot;presets&quot;</span>: presets,</span><br><span class="line">   <span class="string">&quot;plugins&quot;</span>: []</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>直接在<code>packages.json</code>中配置：</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;demo&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;babel&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;presets&quot;</span>: [<span class="string">&quot;es2015&quot;</span>, <span class="string">&quot;react&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span>: [<span class="string">&quot;transform-decorators-legacy&quot;</span>, <span class="string">&quot;transform-class-properties&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>配合 webpack 配置，同样是安装需要的包，以及<code>babel-loader</code>。详见<a target="_blank" rel="noopener" href="https://webpack.docschina.org/loaders/babel-loader/#install">https://webpack.docschina.org/loaders/babel-loader/#install</a></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm install -D babel-loader @babel/core @babel/preset-env webpack</span></span><br><span class="line"></span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.m?js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">presets</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>],</span><br><span class="line">          <span class="attr">plugins</span>: [<span class="string">&quot;@babel/plugin-proposal-object-rest-spread&quot;</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="polyfill"><a href="#polyfill" class="headerlink" title="polyfill"></a>polyfill</h4><p>polyfill 广义上讲是为环境提供不支持的特性的一类文件或库，即提供旧版本中没有的诸如 Promise 和 WeakMap 之类的新的内置组件、 Array.from 或 Object.assign 之类的静态方法、 Array.prototype.includes 之类的实例方法以及生成器函数等。</p>
<p>babel 官方有一个<code>@babel/polyfill</code>可以使用。<br>安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @babel/polyfill</span><br></pre></td></tr></table></figure>

<p><code>preset-env</code> 提供了一个 “useBuiltIns” 参数，当此参数设置为 “usage” 时，就会加载上面所提到的最后一个优化措施，也就是只包含你所需要的 polyfill。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;targets&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;edge&quot;</span>: <span class="string">&quot;17&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;firefox&quot;</span>: <span class="string">&quot;60&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;chrome&quot;</span>: <span class="string">&quot;67&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;safari&quot;</span>: <span class="string">&quot;11.1&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;useBuiltIns&quot;</span>: <span class="string">&quot;usage&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 polyfill 成功使用时，比如较低版本中缺少的 api 就会被通过<code>require</code>一个 url 的形式引入。</p>
<h4 id="babel-preset-env"><a href="#babel-preset-env" class="headerlink" title="@babel/preset-env"></a><code>@babel/preset-env</code></h4><p>参考<a target="_blank" rel="noopener" href="https://www.jiangruitao.com/babel/babel-preset-env/">https://www.jiangruitao.com/babel/babel-preset-env/</a></p>
<h4 id="babel-plugin-transform-runtime"><a href="#babel-plugin-transform-runtime" class="headerlink" title="@babel/plugin-transform-runtime"></a><code>@babel/plugin-transform-runtime</code></h4><p>参考<a target="_blank" rel="noopener" href="https://www.jiangruitao.com/babel/transform-runtime/">https://www.jiangruitao.com/babel/transform-runtime/</a></p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>babel 的启动通常是通过命令行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/babel src --out-dir lib</span><br></pre></td></tr></table></figure>

<p>表示将 src 下的所有文件都编译并输出到 lib 目录。<br>当然也可以通过 npx 或者 npm scripts：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;babel src --out-dir lib&quot;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">npx babel src --out-dir lib</span><br></pre></td></tr></table></figure>

<p>其他基本命令：(详见<a target="_blank" rel="noopener" href="https://www.babeljs.cn/docs/babel-cli">https://www.babeljs.cn/docs/babel-cli</a>)</p>
<ul>
<li><code>babel index.js</code>：直接编译指定文件，<strong>会输出到终端</strong></li>
<li><code>babel script.js --out-file script-compiled.js</code>：指定输出文件</li>
<li><code>babel script.js --watch --out-file script-compiled.js</code>：类似 webpack 的文件监听，源文件改变时会更新编译</li>
</ul>
<h1 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h1><blockquote>
<p>Vite 旨在利用生态系统中的新进展解决上述问题：浏览器开始原生支持 ES 模块，且越来越多 JavaScript 工具使用编译型语言编写。</p>
</blockquote>
<h2 id="依赖和源码"><a href="#依赖和源码" class="headerlink" title="依赖和源码"></a>依赖和源码</h2><p>Vite 通过在一开始将应用中的模块区分为<strong>依赖</strong>和<strong>源码</strong>两类，改进了开发服务器启动时间。</p>
<ul>
<li><p><code>依赖</code>：大多为在开发时不会变动的纯 JavaScript。一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高。依赖也通常会存在多种模块化格式（例如 ESM 或者 CommonJS）。<br>Vite 将会使用 <code>esbuild</code> 预构建依赖。Esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。<br>不仅是依赖的预构建，传统的使用 js 编译的很多步骤都被用<code>esbuild</code>代替，比如<code>tsc</code>、<code>jsx</code>、<code>sass</code>等等。</p>
</li>
<li><p><code>源码</code>：即用户代码，需要转换（例如 JSX，CSS 或者 Vue 组件），时常会被编辑。同时，并不是所有的源码都需要同时被加载，有可能是按照需要进行加载。</p>
</li>
</ul>
<p>Vite 使用 es6 Module 加载源码；因为 ESModule 是静态的、并且大多数时候是浏览器主要进行解析工作，再加上根据情景动态导入代码，要比先将代码打包成 bundle 再发送给浏览器的形式快很多。</p>
<h2 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h2><p>从热更新上，Vite 同时利用 HTTP 头来加速整个页面的重新加载，即利用到了协商缓存（源码）和强缓存（依赖），一旦被缓存将不需要再次请求。<br>并且 vite 利用 ES Module 来帮助进行热更新，又是大大提升了构建速度。</p>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>类似 webpack 的插件，vite 也可以显式配置插件。</p>
<p>插件需要被单独安装，添加到项目的 <code>devDependencies</code>中，然后像 webpack 一样在 plugins 数组中配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> legacy <span class="keyword">from</span> <span class="string">&quot;@vitejs/plugin-legacy&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&quot;vite&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    legacy(&#123;</span><br><span class="line">      <span class="attr">targets</span>: [<span class="string">&quot;defaults&quot;</span>, <span class="string">&quot;not IE 11&quot;</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>社区可用的插件可以见 <a target="_blank" rel="noopener" href="https://github.com/vitejs/awesome-vite#plugins">https://github.com/vitejs/awesome-vite#plugins</a><br>官方提供的插件只有基本的几个：<a target="_blank" rel="noopener" href="https://cn.vitejs.dev/plugins/">https://cn.vitejs.dev/plugins/</a><br>或者在这里搜素：<a target="_blank" rel="noopener" href="https://www.npmjs.com/search?q=vite-plugin&amp;ranking=popularity">https://www.npmjs.com/search?q=vite-plugin&amp;ranking=popularity</a></p>
<h2 id="依赖预构建"><a href="#依赖预构建" class="headerlink" title="依赖预构建"></a>依赖预构建</h2><p>通常在模块被安装后的首次运行，vite 会预构建依赖。主要目的如下：</p>
<ol>
<li>将作为 CommonJS 或 UMD 发布的依赖项转换为 ESModule。</li>
<li>将有许多内部模块的 ESModule 依赖关系转换（合并）为单个模块，以提高后续页面加载性能。</li>
</ol>
<p>在服务器已经启动之后，如果遇到一个新的依赖关系导入，而这个依赖关系还没有在缓存中，Vite 将重新运行依赖构建进程并重新加载页面。</p>
<h1 id="ESlint"><a href="#ESlint" class="headerlink" title="ESlint"></a>ESlint</h1><p>ESLint 是在 ECMAScript/JavaScript 代码中识别和报告模式匹配的工具，它的目标是保证代码的一致性和避免错误。<br>ESLint 使用 Espree 解析 JavaScript。<br>ESLint 使用 AST 去分析代码中的模式<br>ESLint 是完全插件化的。每一个规则都是一个插件并且你可以在运行时添加更多的规则。</p>
<h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>ESLint 是完全可配置的，也就说可以同时配置一些预设、插件和具体的某一项规则。<br>配置文件可以是：</p>
<ul>
<li>.eslintrc.* 文件，最常用的配置方式，后缀可以是 js、ts 或 json</li>
<li>package.json 中的 eslintConfig 字段，这个是 create-react-app 的默认配置方式</li>
</ul>
<p>基本配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;env&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// 指定环境</span></span><br><span class="line">    <span class="attr">&quot;browser&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;node&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;parserOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;ecmaVersion&quot;</span>: <span class="number">6</span>, <span class="comment">// es版本，推荐&quot;latest&quot;</span></span><br><span class="line">    <span class="attr">&quot;sourceType&quot;</span>: <span class="string">&quot;module&quot;</span>, <span class="comment">// 是否使用esmodule</span></span><br><span class="line">    <span class="attr">&quot;ecmaFeatures&quot;</span>: &#123;</span><br><span class="line">      <span class="comment">// 启用jsx，但是还需要特殊的react插件</span></span><br><span class="line">      <span class="attr">&quot;jsx&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;extends&quot;</span>: [<span class="string">&quot;eslint:recommended&quot;</span>, <span class="string">&quot;plugin:react/recommended&quot;</span>], <span class="comment">// 继承推荐的配置项</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [<span class="string">&quot;react&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;rules&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// 具体规则配置项</span></span><br><span class="line">    <span class="attr">&quot;semi&quot;</span>: <span class="string">&quot;error&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，插件、继承和规则三个是最主要的配置<br>具体配置项：<a target="_blank" rel="noopener" href="https://cn.eslint.org/docs/rules/">https://cn.eslint.org/docs/rules/</a></p>
<h1 id="CSS-Modules"><a href="#CSS-Modules" class="headerlink" title="CSS Modules"></a>CSS Modules</h1><p>CSS Modules 是模块化 css 的一种解决方案。考虑到在 Vue 中有诸如 scoped 这样的局部 css 实现，React 中如果想实现这样的效果就需要借助 CSS Modules。</p>
<p>React 的样式文件是全局的，即虽然可能只在一个组件文件中引入了样式，但这个样式的类名将会是全局的。这样就很容易造成干扰，如果类名相同，就会导致冲突和覆盖。因此可以借助 CSS Modules，使得项目中可以像加载 js 模块一样加载 css ，本质上通过一定自定义的命名规则生成唯一性的 css 类名，从根本上解决 css 全局污染，样式覆盖的问题。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>CSS Modules 直接使用没有什么意义，这里直接说和 react 的配合使用。</p>
<p>create-react-app 自带 CSS Modules，并且它的默认规则是识别后缀为<code>.modules.css</code>的文件为 modules css，而正常的<code>.css</code>文件会当作全局样式。因此可以直接在组件中引入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">&quot;./App.module.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;style.main&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&#123;style.title&#125;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入的 style 对象就是解析后的 modules css。注意这个对象不能解构，类名必须通过<code>style.xxx</code>的形式得到；</p>
<p>类名默认会被编译成一个哈希值，也可以自己配置编译的类名结果，添加一些文件名、样式名之类的，以便于调试的时候查找。<br>添加方法需要先<code>npm run eject</code>暴露配置，然后在 webpack.config.js 中找到下面这一段：<br><img src="https://pic.imgdb.cn/item/62df986bf54cd3f9373986db.jpg"></p>
<p>注释这一行是没有的，直接按照注释的这一行的写法添加即可，然后把下面的 getLocalIdent 去掉。其中几个项的含义如下：</p>
<ul>
<li>path：当前文件相对于根目录的路径，一般从 src 开始</li>
<li>name：当前文件名</li>
<li>local：当前样式对应的类名。</li>
<li>hash：随机哈希值，这个和 webpack 配置出口文件名的规则相同，通常<code>[hash:5]</code>就可以</li>
</ul>
<p>因此（个人觉得）比较方便的写法是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[path]_[name]-[local]_[hash:5]&quot;</span><br></pre></td></tr></table></figure>

<hr>
<p>一旦经过 css modules 处理的 css 文件类名 ，再引用的时候就已经无效了。因为声明的类名，已经被处理成了哈希形式。<br>因此可以像 create-react-app 一样，当需要 CSS Modules 时将后缀变为<code>.modules.css</code>即可，全局样式正常写在<code>.css</code>中</p>
<h2 id="和-sass-配合"><a href="#和-sass-配合" class="headerlink" title="和 sass 配合"></a>和 sass 配合</h2><p>同样是 create-react-app。首先安装好 sass（注意 create-react-app 不自带 sass，要手动安装）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i sass</span><br></pre></td></tr></table></figure>

<p>然后同样找到 webpack.config.js 中，就跟在上面说的那部分的下面一点，即解析 sass 的地方：<br><img src="https://pic.imgdb.cn/item/62df9ad6f54cd3f93747467c.jpg"></p>
<p>方法相同。</p>
<p>使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">&quot;./App.module.scss&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;style.header&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&#123;style.title&#125;</span>&gt;</span>no hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;style.main&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&#123;style.title&#125;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 sass 的大部分特性依旧还能正常用，比如变量、函数这一类。</p>
<p>关于嵌套问题，之前看到的教程说不能用嵌套的形式写类名了，但是我这里尝试还是可以的。<br>上面的代码，如果样式这样写：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="selector-class">.title</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="selector-class">.title</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">900</span>;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>title 会被编译成相同的结果：</p>
<p><img src="https://pic.imgdb.cn/item/62df9b60f54cd3f9374a531b.jpg"></p>
<p>但是由于父元素的类名不同，因此仍然是可以正常显示的</p>
<p>其他可以参考<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039846173">https://segmentfault.com/a/1190000039846173</a></p>
<h2 id="在-Vite-中使用"><a href="#在-Vite-中使用" class="headerlink" title="在 Vite 中使用"></a>在 Vite 中使用</h2><p>Vite 也自带了 css Modules 的配置。同样可以通过<code>.module.css</code>的后缀使用，基本使用和上面一样的。</p>
<p>唯一的区别是配置输出类名，需要这样配置：</p>
<p><img src="https://pic.imgdb.cn/item/62df9ef0f54cd3f9375e218c.jpg"></p>
<p>具体参考<a target="_blank" rel="noopener" href="https://cn.vitejs.dev/config/shared-options.html#css-modules">https://cn.vitejs.dev/config/shared-options.html#css-modules</a></p>
<p>并且 scss 等也是可以正常使用的，和上面一样</p>
<h2 id="与-classnames-库配合"><a href="#与-classnames-库配合" class="headerlink" title="与 classnames 库配合"></a>与 classnames 库配合</h2><p>react 原生动态添加多个 className 会报错</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">&#x27;./style.css&#x27;</span></span><br><span class="line"></span><br><span class="line">&lt;div className=&#123;style.class1 style.class2&#125;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>这种情况如果不使用字符串的话，就需要借助 classnames 库来实现。<br>文档：<a target="_blank" rel="noopener" href="https://github.com/JedWatson/classnames#readme">https://github.com/JedWatson/classnames#readme</a></p>
<hr>
<p>注意，类名在 css 文件中如果是连字符形式的（比如<code>light-theme</code>这样），就不能直接通过<code>style.light-theme</code>这样的形式使用，需要再配置一项：<br><img src="https://pic.imgdb.cn/item/62dfa303f54cd3f93774bc75.jpg"><br>camelCase 可以使得在 js 文件中用小驼峰代替连字符形式的类名，上面的就可以写成<code>style.lightTheme</code></p>
<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><p>Git 是目前世界上最先进的分布式版本控制系统。分布式体现在每个用户个人电脑上都是一个完整的版本库，而不需要像集中式那样集中将版本提交到一个网络平台上。如果想要交互版本信息，也只需要把双方的修改推送给对方就可以获取。分布式版本控制系统的安全性要高很多。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>git 中有三个主要的分区，分别是工作区、暂存区和版本库。严格来说，暂存区也是版本库的一部分</p>
<p><img src="https://pic1.imgdb.cn/item/6356176216f2c2beb15ea74b.jpg"></p>
<p>工作区就是当前目录，也就是初始化 git 库所在的目录。<br>版本库就是初始化后创建的.git 文件夹，里边包含了暂存区和各个分支。</p>
<ul>
<li>当使用 add 添加文件时，实际上就是把文件添加到了暂存区。暂存区内存储的是文件的修改，通过 git status 可以查看哪些文件在暂存区中。比如下面这段，readme.txt 是修改了，而 LICENSE 是新增加的，这两个都未被添加到暂存区（Changes not staged for commit 即修改未被暂存）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">	LICENSE</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<p>如果给两者都用 add 添加到暂存区，则会这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   LICENSE</span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure>

<p>即显示 Changes to be committed，暂存区将被提交。</p>
<ul>
<li>当使用 commit 提交文件时，就是把文件提交到了当前分支上，同时暂存区的内容会消失，并且这时会视作工作区是“干净的”（即 working tree clean）</li>
</ul>
<h3 id="分支和-HEAD-指针"><a href="#分支和-HEAD-指针" class="headerlink" title="分支和 HEAD 指针"></a>分支和 HEAD 指针</h3><p>commit 提交之后，每次 commit 都会按照时间顺序相互连接，形成一个链表。当我们创建分支时，就会形成一棵提交树。<br>commit tree 可能是部分重合的。每个分支都有一个指针指向当前分支所在的最后一个提交，这个指针移动就相当于版本回退和前进。</p>
<p>为了方便查看树中的所有节点，还有一个自由指针 HEAD。HEAD 指针指向的位置表示“当前值”，即它所在的分支就是当前分支<br>这个指针默认和 master 指针同步，即 Git 用 master 指向最新的提交，再用 HEAD 指向 master：</p>
<p><img src="https://pic1.imgdb.cn/item/63561cdc16f2c2beb166adb2.jpg"></p>
<p>当通过 git log 查看提交时，也可以看到最新的一次提交旁边有一个<code>(HEAD-&gt;master)</code>，表示 HEAD 正指向当前提交<br><img src="https://pic1.imgdb.cn/item/63561e8716f2c2beb1691f32.jpg"><br>如果用 checkout -b 创建并切换到一个新的分支，则 HEAD 会指向新分支的指针：</p>
<p><img src="https://pic1.imgdb.cn/item/63561d3216f2c2beb1672ac6.jpg"></p>
<p>实际上用 checkout 命令+任意提交的 id，就可以将 HEAD 指针从当前分离出来并指向目标提交。但此时 HEAD 指针相当于一个无主的指针，可以在其上提交，但他并不指向一个具体的分支，可能会导致不能合并。如果想要保持 HEAD 指向具体的分支，只需要<code>git checkout &lt;分支名&gt;</code>即可切换到指定分支。</p>
<p>另外为了和撤销修改区分，分支切换更推荐使用 switch：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建并切换到新的dev分支，可以使用：</span><br><span class="line">$ git switch -c dev</span><br><span class="line">直接切换到已有的master分支，可以使用：</span><br><span class="line">$ git switch master</span><br></pre></td></tr></table></figure>

<hr>
<p>在版本回退中，由于回退的依据常常是具体的某次提交，而输入 id 又非常麻烦。因此 HEAD 有一些可以访问其相对位置的语法。<br>HEAD 表示当前版本，<code>HEAD^</code>表示上一个版本，<code>HEAD~n</code>表示上 n 个版本<br>对分支指针也可也使用这种语法。比如<code>git checkout master^</code>表示切换到 master 分支的上一个节点</p>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>版本回退的核心是 commit。每个 commit 都可以看作是一个存档，工作区可以从任意一个保存的 commit 中恢复。</p>
<p>查看 commit 的方法是 git log。注意不是 git status，status 是用于查看暂存区和工作区状态的。</p>
<p>git log 命令显示从最近到最远的提交日志，包括提交的版本号（commit id）、提交人、提交时间、以及提交时的注释（-m 后的内容）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">commit eb34058d880bf18f701355a5601b26a8c5fa0860 (HEAD -&gt; master, test)</span><br><span class="line">Author: penghei &lt;632885485@qq.com&gt;</span><br><span class="line">Date:   Tue Aug 2 19:58:30 2022 +0800</span><br><span class="line"></span><br><span class="line">    third</span><br><span class="line"></span><br><span class="line">commit e77b1fc694de190185d53da1c573e40da36a3cfb</span><br><span class="line">Author: penghei &lt;632885485@qq.com&gt;</span><br><span class="line">Date:   Tue Aug 2 19:41:03 2022 +0800</span><br><span class="line"></span><br><span class="line">    second</span><br><span class="line"></span><br><span class="line">commit fc87038c63eceaa2f5bc8fdc2f5f1ed579d03bb1</span><br><span class="line">Author: penghei &lt;632885485@qq.com&gt;</span><br><span class="line">Date:   Tue Aug 2 19:34:43 2022 +0800</span><br><span class="line"></span><br><span class="line">    first</span><br></pre></td></tr></table></figure>

<p>如果想要版本回退，就应该使用 git reset 命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at e77b1fc second</span><br></pre></td></tr></table></figure>

<p>git reset 会导致回溯之后的最新的 commit 消失。比如这时再查看 git log，会发现 third 提交消失了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">commit e77b1fc694de190185d53da1c573e40da36a3cfb (HEAD -&gt; master, test)</span><br><span class="line">Author: penghei &lt;632885485@qq.com&gt;</span><br><span class="line">Date:   Tue Aug 2 19:41:03 2022 +0800</span><br><span class="line"></span><br><span class="line">    second</span><br><span class="line"></span><br><span class="line">commit fc87038c63eceaa2f5bc8fdc2f5f1ed579d03bb1</span><br><span class="line">Author: penghei &lt;632885485@qq.com&gt;</span><br><span class="line">Date:   Tue Aug 2 19:34:43 2022 +0800</span><br><span class="line"></span><br><span class="line">    first</span><br></pre></td></tr></table></figure>

<p>此时相当于 HEAD 指针从 third 提交指向了 second 提交，工作区的内容也改回了 second 提交时的状态。但是实际上 third 的 commit 并没有被删除；如果能找回其 commit id，也是可以返回的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard eb3405</span><br></pre></td></tr></table></figure>

<p>也就说，git reset 可以将工作区内容指向任意一个之前的 commit，并且这个过程是通过修改 HEAD 指针指向实现的。</p>
<h2 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h2><p>Git 跟踪并管理的是修改，而非文件。如果修改没有被 add 添加到暂存区，也就不会被 commit 记录</p>
<p><code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别。在 vscode 中也会显示某些行的变化，就是工作区和最新一次提交的区别。</p>
<p>注意 git 的回退单位是 commit；如果一次修改没有被提交，就不能恢复到这次修改。除非采用抛弃修改的方式，可以回到暂存区的状态，详见下：</p>
<hr>
<p><code>git checkout -- file</code>可以丢弃工作区的修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br></pre></td></tr></table></figure>

<p>这个命令可能有两种情况：</p>
<ul>
<li>readme.txt 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态，即回到最新的 commit 状态</li>
<li>readme.txt 已经添加到暂存区后，又作了修改，现在，撤销修改就回到<strong>添加到暂存区后</strong>的状态。</li>
</ul>
<p>也就说如果添加到暂存区后再修改，撤销修改就只能回退到暂存区的状态，除非使用 reset 回退 commit。<br>但是还可以通过<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD a.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       a.txt</span><br></pre></td></tr></table></figure>

<p>然后再使用<code>git checkout -- file</code>就可以恢复到最初的状态，即使已经提交到工作区。</p>
<hr>
<p>除了修改，文件的删除也可以被<code>git checkout -- file</code>恢复，但只能根据 commit 恢复，不可以通过工作区恢复。<br>只需要把删除看作是一种修改就可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add test.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add test.txt&quot;</span><br><span class="line"></span><br><span class="line">$ rm test.txt</span><br><span class="line"></span><br><span class="line"># 这个命令可以恢复删除的文件，内容是最新的commit</span><br><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure>

<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h3 id="创建和合并分支"><a href="#创建和合并分支" class="headerlink" title="创建和合并分支"></a>创建和合并分支</h3><p>创建和切换分支的简单操作在上面 HEAD 指针讲过，基本命令就是这几个：</p>
<ul>
<li><code>git checkout -b &lt;分支名&gt;</code>或<code>git switch -c &lt;分支名&gt;</code>可以创建并切换到新分支。这两个命令都相当于用<code>git branch &lt;分支名&gt;</code>创建新分支，然后再切换</li>
<li><code>git checkout &lt;分支名&gt;</code>或<code>git switch &lt;分支名&gt;</code>可以切换到指定分支，即把 HEAD 指针指向指定分支的头指针。切换之后，提交操作就会在该分支上</li>
</ul>
<p>接下来就是合并分支。在一个分支上使用<code>git merge &lt;分支名&gt;</code>，可以把 merge 后面的分支（称作副分支）合并到当前分支（主分支）<br>合并有两种情况：</p>
<ul>
<li><strong>无冲突</strong>，最常见的情况是副分支在主分支的基础上修改（完成几次提交），而主分支没有修改过。这时可以把副分支合并到主分支上，工作区内的状态就会变成副分支的最新修改，同时 HEAD 指针指向主分支。</li>
</ul>
<p><img src="https://pic1.imgdb.cn/item/63562cd616f2c2beb17f7f35.jpg"><br><img src="https://pic1.imgdb.cn/item/63562cca16f2c2beb17f7323.jpg"></p>
<p>这种合并被称为<code>Fast-forword</code>，相当于直接修改 master 指针的指向，让其指向 dev 即可。<br>合并完成之后还可以删除 dev 分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>有冲突</strong>，常见的情况是主分支在分出副分支后，两个分支都做了不同的修改并提交</li>
</ul>
<p><img src="https://pic1.imgdb.cn/item/63562d6716f2c2beb1802c4b.jpg"><br>这时就不能进行自动合并。如果试图将 bug 合并到 main，就会提示有冲突，并且还会在冲突文件中用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...某些内容</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt; bug</span><br></pre></td></tr></table></figure>

<p>你需要自己选择接收某个分支的内容，或者自己修改新的内容。不管怎么样，如果删掉<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>，git 就视为你解决了冲突，接下来就可以正常合并了。<br>但是并不需要 merge 命令，<strong>解决冲突后再在主分支添加并提交一次就可以了</strong>；用带参数的 git log 也可以看到分支的合并情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git commit -m &quot;conflict fixed&quot;</span><br><span class="line"></span><br><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   cf810e4 (HEAD -&gt; master) conflict fixed</span><br><span class="line">|\</span><br><span class="line">| * 14096d0 (bug) AND simple</span><br><span class="line">* | 5dc6824 &amp; simple</span><br><span class="line">|/</span><br><span class="line">* b17d20e branch test</span><br><span class="line">* d46f35e (origin/master) remove test.txt</span><br><span class="line">* b84166e add test.txt</span><br><span class="line">* 519219b git tracks changes</span><br><span class="line">* e43a48b understand how stage works</span><br><span class="line">* 1094adb append GPL</span><br><span class="line">* e475afc add distributed</span><br><span class="line">* eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure>

<h3 id="保存状态和-cherry-pick"><a href="#保存状态和-cherry-pick" class="headerlink" title="保存状态和 cherry-pick"></a>保存状态和 cherry-pick</h3><p>如果工作区有未添加到暂存区的修改，可以通过 git stash 保存当前工作区的修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev: 74df696 dev1</span><br></pre></td></tr></table></figure>

<p>保存之后，通过 git status 查看就会发现工作区没有新内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>这时就可以切换到其他分支任意执行操作。等到需要时，再切换回当前分支，通过<code>git stash list</code>查看历史保存，通过<code>git stash pop</code>恢复</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev: 74df696 dev1</span><br><span class="line"></span><br><span class="line">$ git stash pop</span><br><span class="line">On branch dev</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   b.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (90330a3b4bfe41fa9357c72194e79786709b205d)</span><br></pre></td></tr></table></figure>

<p>这种操作常用于正在开发时（dev），需要紧急修复一个位于 master 分支上的 bug（创建一个 bug 分支用于修复并合并回 master）</p>
<p>这时还有一个问题，dev 分支是早期从 master 分支分出来的，所以，这个 bug 其实在当前 dev 分支上也存在。同样的 bug，要在 dev 上修复，我们只需要把 bug 分支上修改 bug 的那个提交所做的修改“复制”到 dev 分支即可。</p>
<p>具体来说，假如此时在 master 上创建了一个 bug 分支，修改后提交，并合并到 master 上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b bug</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;bug fix 1&quot;</span><br><span class="line">[bug 3cb6cc3] bug fix 1</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">$ git switch master</span><br><span class="line">$ git merge --no-ff -m &quot;merged bug fix 1&quot; bug</span><br><span class="line">$ git branch</span><br><span class="line">  bug</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意<code>&quot;bug fix 1&quot;</code>这个提交，表示的就是修复 bug 的那个提交。如果我们想把这个修改也复制到 dev 上，只需要使用<code>git cherry-pick &lt;提交id&gt;</code>即可。<br>即在 dev 分支上，pick 指定的提交。注意 pick 之前要先用 stash pop 恢复现场：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git cherry-pick 3cb6cc3</span><br><span class="line">[dev a67ca95] bug fix 1</span><br><span class="line"> Date: Mon Oct 24 14:34:17 2022 +0800</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>cherry-pick 相当于一次新的提交，这里的<code>[dev a67ca95] bug fix 1</code>就表示了一个 id 不同，但提交信息相同的提交。</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>当你从远程仓库克隆时，实际上 Git 自动把本地的 master 分支和远程的 master 分支对应起来了，并且，远程仓库的默认名称是 origin。</p>
<p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git 就会把该分支推送到远程库对应的远程分支上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<p>如果要推送其他分支，比如 dev，就改成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure>

<p>git clone 默认只会加载 master 分支。如果想从远程库加载指定分支，必须创建远程 origin 的 dev 分支到本地</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure>

<p>执行之后，就会发现本地文件都改成了指定分支的内容，同时通过 git branch 也可以看到 dev 分支。<br>实际上这个命令就是建立了与远程库的<code>track</code>。如果没有 track 还需要手动创建，这个在下面多人冲突中还会说道</p>
<hr>
<p>当完成本地修改后，可以通过 git push 提交修改。<br>但是如果远程库被其他人提交过了，也就是说其他人的最新提交和你试图推送的提交有冲突（git 会提示你远程库在本地库的几个提交之前）。这时就需要先通过<code>git pull</code>拉取最新提交，然后在本地解决冲突，再提交回去。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">There is no tracking information for the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git-pull(1) for details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to set tracking information for this branch you can do so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; dev</span><br></pre></td></tr></table></figure>

<p>git pull 也失败了，原因是没有指定本地 dev 分支与远程 origin/dev 分支的链接，根据提示，设置 dev 和 origin/dev 的链接：<br>（注意这个执行结果在上面切换远程分支时也出现过。如果你本地的 dev 是通过<code>checkout -b dev origin/dev</code>这样来的，也就是说建立了 track，这一步就不会出现问题）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br><span class="line">Branch &#x27;dev&#x27; set up to track remote branch &#x27;dev&#x27; from &#x27;origin&#x27;.</span><br></pre></td></tr></table></figure>

<p>然后再 pull：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">Auto-merging env.txt</span><br><span class="line">CONFLICT (add/add): Merge conflict in env.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>提示合并失败。这里就和之前说的分支合并冲突的情况一样了；git 同样会在冲突文件中标记出冲突内容；修改冲突内容后再次提交，再 push 就没有问题了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;fix env conflict&quot;</span><br><span class="line">[dev 57c53ab] fix env conflict</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 6, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (4/4), done.</span><br><span class="line">Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   7a5e5dd..57c53ab  dev -&gt; dev</span><br></pre></td></tr></table></figure>

<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>Git的标签是版本库的快照，其实它就是指向某个commit的指针（分支可以移动，标签不能移动）<br>标签的主要目的是方便commit的标记。相比于哈希值id，tag明显更方便识别</p>
<p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure>
<p>默认标签是打在最新提交的commit上的。如果在后面加上指定的commit id，可以向指定id上添加标签</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v0.9 f52c633</span><br></pre></td></tr></table></figure>
<p>标签可以作为commit的代指。可以像使用commit一样使用tag</p>
<p>创建的标签都只存储在本地，不会自动推送到远程。<br>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>,或者，一次性推送全部尚未推送到远程的本地标签：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.0</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br><span class="line"></span><br><span class="line">$ git push origin --tags</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="/img/codes1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/04/05/blog44-optimization/"><img class="prev-cover" src="/img/codes1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">优化问题总结</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/29/blog42-react-review/"><img class="next-cover" src="/img/react.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">react（略深入的）复习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/04/05/blog44-optimization/" title="优化问题总结"><img class="cover" src="/img/codes1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-05</div><div class="title">优化问题总结</div></div></a></div><div><a href="/2022/05/13/handwriting/" title="js手写"><img class="cover" src="/img/JS.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-13</div><div class="title">js手写</div></div></a></div><div><a href="/2022/07/24/blog46-fe-design-pattern/" title="设计模式学习总结"><img class="cover" src="/img/codes1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-24</div><div class="title">设计模式学习总结</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/pinkstar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xing Ye</div><div class="author-info__description">a singleThreaded boy's blog</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/penghei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/penghei" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:632885485@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">A SingleThreaded Boy...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC-Node-%E7%8E%AF%E5%A2%83"><span class="toc-number">1.</span> <span class="toc-text">基本 Node 环境</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#package-json"><span class="toc-number">1.1.</span> <span class="toc-text">package.json</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#npm-scripts-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.2.</span> <span class="toc-text">npm scripts 的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dependencies-%E5%92%8C-devDependencies"><span class="toc-number">1.2.1.</span> <span class="toc-text">dependencies 和 devDependencies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#semver"><span class="toc-number">1.2.2.</span> <span class="toc-text">semver</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#package-lock-json"><span class="toc-number">1.3.</span> <span class="toc-text">package-lock.json</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#npm-install-%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">1.4.</span> <span class="toc-text">npm install 发生了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#npm-run-%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">1.5.</span> <span class="toc-text">npm run 发生了什么</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Babel"><span class="toc-number">2.</span> <span class="toc-text">Babel</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#babel-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">2.1.</span> <span class="toc-text">babel 的基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">2.1.1.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-number">2.1.2.</span> <span class="toc-text">配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#polyfill"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">polyfill</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babel-preset-env"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">@babel&#x2F;preset-env</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babel-plugin-transform-runtime"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">@babel&#x2F;plugin-transform-runtime</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91"><span class="toc-number">2.1.3.</span> <span class="toc-text">编译</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vite"><span class="toc-number">3.</span> <span class="toc-text">Vite</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%92%8C%E6%BA%90%E7%A0%81"><span class="toc-number">3.1.</span> <span class="toc-text">依赖和源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%83%AD%E6%9B%B4%E6%96%B0"><span class="toc-number">3.2.</span> <span class="toc-text">热更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="toc-number">3.3.</span> <span class="toc-text">主要功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6"><span class="toc-number">3.3.1.</span> <span class="toc-text">插件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E9%A2%84%E6%9E%84%E5%BB%BA"><span class="toc-number">3.4.</span> <span class="toc-text">依赖预构建</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ESlint"><span class="toc-number">4.</span> <span class="toc-text">ESlint</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-1"><span class="toc-number">4.1.</span> <span class="toc-text">配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSS-Modules"><span class="toc-number">5.</span> <span class="toc-text">CSS Modules</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">5.1.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C-sass-%E9%85%8D%E5%90%88"><span class="toc-number">5.2.</span> <span class="toc-text">和 sass 配合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8-Vite-%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="toc-number">5.3.</span> <span class="toc-text">在 Vite 中使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E-classnames-%E5%BA%93%E9%85%8D%E5%90%88"><span class="toc-number">5.4.</span> <span class="toc-text">与 classnames 库配合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#git"><span class="toc-number">6.</span> <span class="toc-text">git</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA"><span class="toc-number">6.1.1.</span> <span class="toc-text">分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E5%92%8C-HEAD-%E6%8C%87%E9%92%88"><span class="toc-number">6.1.2.</span> <span class="toc-text">分支和 HEAD 指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80"><span class="toc-number">6.2.</span> <span class="toc-text">版本回退</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E4%BF%AE%E6%94%B9"><span class="toc-number">6.3.</span> <span class="toc-text">管理修改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF"><span class="toc-number">6.4.</span> <span class="toc-text">分支</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF"><span class="toc-number">6.4.1.</span> <span class="toc-text">创建和合并分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E5%92%8C-cherry-pick"><span class="toc-number">6.4.2.</span> <span class="toc-text">保存状态和 cherry-pick</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="toc-number">6.5.</span> <span class="toc-text">远程仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C"><span class="toc-number">6.5.1.</span> <span class="toc-text">多人协作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE"><span class="toc-number">6.6.</span> <span class="toc-text">标签</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/15/blog47-nextjs/" title="next.js 学习"><img src="/img/nextjs.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="next.js 学习"/></a><div class="content"><a class="title" href="/2022/09/15/blog47-nextjs/" title="next.js 学习">next.js 学习</a><time datetime="2022-09-15T07:37:22.000Z" title="发表于 2022-09-15 15:37:22">2022-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/24/blog46-fe-design-pattern/" title="设计模式学习总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式学习总结"/></a><div class="content"><a class="title" href="/2022/07/24/blog46-fe-design-pattern/" title="设计模式学习总结">设计模式学习总结</a><time datetime="2022-07-24T08:21:22.000Z" title="发表于 2022-07-24 16:21:22">2022-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/11/blog42-react-source-code/" title="react原理浅析学习"><img src="/img/react.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="react原理浅析学习"/></a><div class="content"><a class="title" href="/2022/07/11/blog42-react-source-code/" title="react原理浅析学习">react原理浅析学习</a><time datetime="2022-07-11T06:07:32.000Z" title="发表于 2022-07-11 14:07:32">2022-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/18/projects/" title="无题"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/05/18/projects/" title="无题">无题</a><time datetime="2022-05-18T02:57:57.356Z" title="发表于 2022-05-18 10:57:57">2022-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/13/handwriting/" title="js手写"><img src="/img/JS.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="js手写"/></a><div class="content"><a class="title" href="/2022/05/13/handwriting/" title="js手写">js手写</a><time datetime="2022-05-13T04:21:10.000Z" title="发表于 2022-05-13 12:21:10">2022-05-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Xing Ye</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hello stranger!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>