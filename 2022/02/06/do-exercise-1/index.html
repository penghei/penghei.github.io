<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>HTML+CSS+JS+原理性知识刷题总结 | XingYeBlog</title><meta name="keywords" content="面试"><meta name="author" content="Xing Ye,632885485@qq.com"><meta name="copyright" content="Xing Ye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="网络相关题目常见的请求头和响应头请求头：  Accept: (客户端能接收的资源类型) Accept-Language: (客户端接收的语言类型) Connection: (维护客户端和服务端的连接关系) Host: (连接的目标主机和端口号) Referer: (告诉服务器我来自于哪里) User-Agent: (客户端版本号的名字) Accept-Encoding: (客户端能接收的压缩数据的">
<meta property="og:type" content="article">
<meta property="og:title" content="HTML+CSS+JS+原理性知识刷题总结">
<meta property="og:url" content="http://example.com/2022/02/06/do-exercise-1/index.html">
<meta property="og:site_name" content="XingYeBlog">
<meta property="og:description" content="网络相关题目常见的请求头和响应头请求头：  Accept: (客户端能接收的资源类型) Accept-Language: (客户端接收的语言类型) Connection: (维护客户端和服务端的连接关系) Host: (连接的目标主机和端口号) Referer: (告诉服务器我来自于哪里) User-Agent: (客户端版本号的名字) Accept-Encoding: (客户端能接收的压缩数据的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/codes1.jpg">
<meta property="article:published_time" content="2022-02-06T05:44:25.000Z">
<meta property="article:modified_time" content="2022-04-06T04:05:27.197Z">
<meta property="article:author" content="Xing Ye">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/codes1.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2022/02/06/do-exercise-1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'HTML+CSS+JS+原理性知识刷题总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-06 12:05:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/pinkstar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/codes1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XingYeBlog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">HTML+CSS+JS+原理性知识刷题总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-06T05:44:25.000Z" title="发表于 2022-02-06 13:44:25">2022-02-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-06T04:05:27.197Z" title="更新于 2022-04-06 12:05:27">2022-04-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/exercises/">exercises</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="HTML+CSS+JS+原理性知识刷题总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="网络相关题目"><a href="#网络相关题目" class="headerlink" title="网络相关题目"></a>网络相关题目</h1><h2 id="常见的请求头和响应头"><a href="#常见的请求头和响应头" class="headerlink" title="常见的请求头和响应头"></a>常见的请求头和响应头</h2><p>请求头：</p>
<ul>
<li><code>Accept</code>: (客户端能接收的资源类型)</li>
<li><code>Accept-Language</code>: (客户端接收的语言类型)</li>
<li><code>Connection</code>: (维护客户端和服务端的连接关系)</li>
<li><code>Host</code>: (连接的目标主机和端口号)</li>
<li><code>Referer</code>: (告诉服务器我来自于哪里)</li>
<li><code>User-Agent</code>: (客户端版本号的名字)</li>
<li><code>Accept-Encoding</code>: (客户端能接收的压缩数据的类型)</li>
<li><code>If-Modified-Since</code>: (缓存时间)</li>
<li><code>Cookie</code>(客户端暂存服务端的信息)</li>
<li><code>Date</code>: (客户端请求服务端的时间)</li>
</ul>
<p>响应头：</p>
<ul>
<li><code>Location</code>: (服务端需要客户端访问的页面路径)</li>
<li><code>Server</code>:(服务端的 Web 服务端名)</li>
<li><code>Content-Encoding</code>: (服务端能够发送压缩编码类型)</li>
<li><code>Content-Length</code>: (服务端发送的压缩数据的长度)</li>
<li><code>Content-Language</code>:(服务端发送的语言类型)</li>
<li><code>Content-Type</code>:(服务端发送的类型及采用的编码方式)</li>
<li><code>Last-Modified</code>: (服务端对该资源最后修改的时间)</li>
<li><code>Refresh</code>: (服务端要求客户端 1 秒钟后，刷新，然后访问指定的页面路径)</li>
<li><code>Content-Disposition</code>: (服务端要求客户端以下载文件的方式打开该文件)</li>
<li><code>Transfer-Encoding</code>: (分块传递数据到客户端）</li>
<li><code>Set-Cookie</code>:(服务端发送到客户端的暂存数据)</li>
<li><code>Expires</code>: (服务端禁止客户端缓存页面数据)</li>
<li><code>Cache-Control</code>: (服务端禁止客户端缓存页面数据)</li>
<li><code>Pragma</code>: (服务端禁止客户端缓存页面数据)</li>
<li><code>Connection</code>: (维护客户端和服务端的连接关系)</li>
<li><code>Date</code>: (服务端响应客户端的时间)</li>
</ul>
<h1 id="JS-题目总结（每天-30-道）"><a href="#JS-题目总结（每天-30-道）" class="headerlink" title="JS 题目总结（每天 30 道）"></a>JS 题目总结（每天 30 道）</h1><h2 id="函数参数更改影响原变量的问题"><a href="#函数参数更改影响原变量的问题" class="headerlink" title="函数参数更改影响原变量的问题"></a>函数参数更改影响原变量的问题</h2><p>如果参数是基本数据类型，函数内的参数实际上是该数据的复制，并不会影响原变量；<br>如果参数是引用数据类型，参数实际上是该变量的地址，因此修改该变量会影响原变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">b</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">a,obj</span>)</span>&#123;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">    obj.b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">change(a,obj)</span><br><span class="line"><span class="built_in">console</span>.log(a,obj)<span class="comment">// 1  &#123;b:1&#125;</span></span><br></pre></td></tr></table></figure>

<p>换句话说，基本数据类型内部作用域下的改变不会影响外部作用域，但是引用数据类型由于持有的是同一个地址，因此会影响。</p>
<h2 id="原始数据不可变"><a href="#原始数据不可变" class="headerlink" title="原始数据不可变"></a>原始数据不可变</h2><blockquote>
<p>所有基本类型的值都是<strong>不可改变的</strong>。但需要注意的是，基本类型本身和一个赋值为基本类型的变量的区别。变量会被赋予一个新值，而原值不能像数组、对象以及函数那样被改变。</p>
</blockquote>
<p>MDN 上的描述，所有的原始类型数据都是不可改变的。但是不可改变并不意味着持有该数据的变量不可改变，只是说这个数据本身不能改，当改动变量时实际上是给这个变量重新赋值。也就是说，<strong>基本类型值可以被替换，但不能被改变</strong>；改变的只是变量持有的值，而不是这个值本身</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> = <span class="number">2</span> <span class="comment">// 无效，原始数据不能改动</span></span><br><span class="line"><span class="string">&#x27;hello&#x27;</span> = <span class="string">&#x27;world&#x27;</span> <span class="comment">//同理</span></span><br><span class="line"><span class="string">&#x27;hello&#x27;</span>[<span class="number">0</span>] = <span class="string">&#x27;w&#x27;</span> <span class="comment">// 同理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">a + <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1 ,直接改变原数据无效</span></span><br><span class="line"></span><br><span class="line">a = a + <span class="number">1</span> <span class="comment">// 2 , 改变的是变量的值，而不是 1 这个数字本身</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对应的，引用数据类型（Object）是可以改变的。可以把<code>Object</code>想象成一个盒子，我们可以向盒子内部装各种东西，改变盒子内部就会导致改变这个盒子的状态（虽然盒子本身并没有改变）</p>
<h2 id="和-amp-amp-的返回值"><a href="#和-amp-amp-的返回值" class="headerlink" title="|| 和 &amp;&amp; 的返回值"></a>|| 和 &amp;&amp; 的返回值</h2><p>当符号两边是<code>true</code>或<code>false</code>时，返回值也是 boolean 值，会按照<code>与</code>和<code>或</code>返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> || <span class="literal">false</span>; <span class="comment">//true</span></span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="literal">false</span>; <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &gt; <span class="number">2</span> || <span class="number">2</span> == <span class="string">&quot;2&quot;</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>当符号两边有一个是其他类型的值，就会返回两个值的中的一个。<br>原则是，<code>||</code>会在前值为假时返回后值，<code>&amp;&amp;</code>会在前值为真时返回后值，其余都是返回前值，<strong>这种情况下返回的是具体的值，而不是布尔值</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span> || <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="string">&quot;&quot;</span> &amp;&amp; <span class="number">1</span>; <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="literal">true</span> || <span class="number">1</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果比较的一方是<code>undefined</code>或者<code>null</code>，则虽然这两者都为<code>falsy</code>，但是仍不会返回布尔值，而是可能返回<code>undefined</code>或者<code>null</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> || <span class="literal">undefined</span>; <span class="comment">// undefined</span></span><br><span class="line"><span class="literal">null</span> &amp;&amp; <span class="literal">undefined</span>; <span class="comment">// null</span></span><br><span class="line"><span class="literal">undefined</span> &amp;&amp; <span class="literal">undefined</span>; <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>因此通过这种方式给变量赋值时，一定要保证符号两边都是确定的值，而不要是<code>undefined</code>，否则可能导致结果并不是想要的布尔值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getRequest = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> truthy;</span><br><span class="line">  <span class="keyword">let</span> falsy;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟异步请求</span></span><br><span class="line">    truthy = <span class="literal">true</span>;</span><br><span class="line">    falsy = <span class="literal">false</span>;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  display(truthy, falsy);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> display = <span class="function">(<span class="params">truthy, falsy</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = truthy &amp;&amp; falsy;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getRequest(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="for-循环和-let、var"><a href="#for-循环和-let、var" class="headerlink" title="for 循环和 let、var"></a>for 循环和 let、var</h2><h3 id="同步情况"><a href="#同步情况" class="headerlink" title="同步情况"></a>同步情况</h3><p>看一个最简单的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// ReferenceError: i is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(j); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>for 循环会产生多个块级作用域，每一次循环都会产生一个块；另外 for 循环的括号中是高于循环产生的块、但低于外部的作用域。</p>
<p>let 存在块作用域，因此每个<code>i</code>单独保存，每个块中的 i 独立，不会影响其他块中的 i。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//let</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// i is not defined</span></span><br></pre></td></tr></table></figure>

<p>var 不存在块作用域，因此所有的<code>i</code>都是在一个 for 内部</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* var i = undefined; */</span></span><br><span class="line">&#123;</span><br><span class="line">  i = <span class="number">0</span>; <span class="comment">// i会被变量提升到外层</span></span><br><span class="line">  i++; <span class="comment">// 没有块级作用域</span></span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>另外，for 循环是“不满足退出”，因此最后的值一定是不满足条件的值。比如条件是<code>i &lt; 2</code>，那么输出值就会是第一个不满足条件的（即<code>i</code>为 2），而不是<code>i</code>等于 1</p>
<h3 id="异步情况"><a href="#异步情况" class="headerlink" title="异步情况"></a>异步情况</h3><p>一个很经典的题目是在 for 循环中启动定时器打印<code>i</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：一秒后同时输出 <code>0 1 2 2</code></p>
<p>setTimeout 会被放入定时器线程，而同步线程的 for 循环则会被先执行完。因此当共计 4 个回调函数开始执行时，for 循环已经被执行完成了</p>
<p>按照块分解如下：</p>
<p>let 定义的<code>i</code>会被依次放入每个任务中，因为循环产生的块会持有自己的<code>i</code>；每个<code>i</code>是块中自己维护的，初始值为 0，不会影响其他块中的<code>i</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1000</span>);</span><br><span class="line">    i++; <span class="comment">//这个i是这个块中自己维护的，初始值为0，不会影响其他块中的i</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1000</span>);</span><br><span class="line">    i++; <span class="comment">//这个i是这个块中自己维护的，初始值为1，不会影响其他块中的i</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> i_first = i; <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i_first), <span class="number">1000</span>);</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> i_second = i; <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i_second), <span class="number">1000</span>);</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>var 定义的变量在<code>setTimeout</code>内部引用时相当于外部 <code>var i</code> 的闭包；因此在 for 内部更改 i，会导致<code>setTimeout</code>的<code>i</code>闭包值改变</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="literal">undefined</span>;</span><br><span class="line">&#123;</span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  i++;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1000</span>); <span class="comment">//这里的i是外部 `var i` 的闭包</span></span><br><span class="line">  i++;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在 for 执行之后再对<code>i</code>进行操作，可以看到定时器中的<code>i</code>也改变了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1秒后输出2次3</span></span><br></pre></td></tr></table></figure>

<h2 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a><code>valueOf</code></h2><p>这个方法很少会用到；<br>当把一个对象转化为原始数据类型时，会调用对象上的该方法。默认调用的是<code>Object.prototype.valueOf()</code>方法，但是如果对象内部重写了该方法，会返回重写方法的返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + obj); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>调用对象 valueOf 方法的情况有：</p>
<ol>
<li>原始类型和该对象进行运算（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>、<code>**</code>）</li>
<li>用<code>==</code> / <code>&gt;=</code> / <code>&lt;=</code> / <code>&gt;</code> / <code>&lt;</code>把对象和原始数据类型进行比较</li>
</ol>
<h2 id="类的静态方法"><a href="#类的静态方法" class="headerlink" title="类的静态方法"></a>类的静态方法</h2><p>静态方法属于类本身，因此 class 的方法里，前面有 static，那么方法里的 this 是<strong>类本身</strong>；前面没有 static，那么方法里的 this 是类的实例化对象；<br>因此静态方法只能通过类本身调用，不能通过实例调用<br>另外静态方法允许和一般方法重名，因为他们所挂载的对象完全不一样。</p>
<h2 id="let-和-const-的暂时性死区-TDZ"><a href="#let-和-const-的暂时性死区-TDZ" class="headerlink" title="let 和 const 的暂时性死区(TDZ)"></a>let 和 const 的暂时性死区(TDZ)</h2><p>let 和 const 存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。<br>并且，一个块中如果已经有了 let 或 const 声明的变量，就不会再理会外部的同名变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  a = <span class="number">2</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="comment">/* 这一行之前的块内部都是暂时性死区 */</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不可引用不止是赋值操作，<code>typeof</code>/<code>instanceof</code>以及任何其他相关作为参数的操作都不可以，即只要出现就是错误的。</p>
</blockquote>
<p>原理在于，let 和 const 虽然不会像 var 一样变量提升，但是仍会在 js 解释阶段（即创建作用域阶段）先创建出该变量，然后在执行到正式声明那一行才可以使用。</p>
<h2 id="html-页面生命周期"><a href="#html-页面生命周期" class="headerlink" title="html 页面生命周期"></a>html 页面生命周期</h2><p>基本生命周期顺序如下：</p>
<ol>
<li><code>script</code>：解析同步 js 脚本；如果 js 放在页面最下部，这一步将延迟到<code>DOMContentLoaded</code>之后执行</li>
<li><code>readyState</code>：允许通过此事件监听 dom 加载状态，有三种情况；此时可能是<code>interactive</code>或<code>loading</code><ul>
<li><code>interactive</code>：准备加载</li>
<li><code>loading</code>：加载中</li>
<li><code>complete</code>：加载完成，会在后面触发</li>
</ul>
</li>
<li><code>DOMContentLoaded</code>：DOM 加载事件，触发时浏览器已完全加载 HTML，并构建了 DOM 树，但像 <code>&lt;img&gt;</code> 和样式表之类的外部资源可能尚未加载完成。该事件只能通过<code>addEventListener</code>捕获。</li>
<li><code>image onload</code>/<code>iframe onload</code>/<code>style onload</code>：加载上一步没有加载出来的外部资源，触发比如安置在<code>&lt;img&gt;</code>元素上的<code>onload</code>事件</li>
<li><code>readyState</code>: complete，即此时所有文档和资源都已经加载完成</li>
<li><code>window onload</code>：加载完成，此时已经完成了所有的加载工作，即启动的生命周期已经结束</li>
<li><code>beforeunload</code>：用户正在离开：我们可以检查用户是否保存了更改，并询问他是否真的要离开。</li>
<li><code>unload</code>：用户几乎已经离开了，但是我们仍然可以启动一些操作，例如发送统计数据。</li>
</ol>
<p>解释如下：</p>
<ol>
<li><p>script 同步的 JavaScript 脚本最先执行，它先于<code>DOMContentLoaded</code>事件执行。</p>
</li>
<li><p>此时可以通过<code>onreadystatechange</code>事件监听 document 的状态，会有三种状态；因此它在 Dom 准备前、js 同步脚本执行后就触发</p>
</li>
<li><p>当 DOM 准备就绪时，<code>DOMContentLoaded</code>事件在 document 上触发。 我们可以在这个阶段利用 JavaScript 来操作 DOM 元素。</p>
</li>
<li><p>所有脚本都执行完毕，除了那些外部使用异步（async）或延迟（defer）加载的脚本，图片和其他资源可能仍在载入过程中。</p>
</li>
<li><p>window 上的 onload 事件，在页面加载完所有资源后触发。 我们很少使用它，因为通常的操作不用等到最后才执行。</p>
</li>
</ol>
<p><code>document.readyState</code>表示文档的当前状态，可以在<code>onreadystatechange</code>事件中跟踪文档状态的变更。</p>
<ul>
<li><code>loading</code> – 文档正在载入。</li>
<li><code>interactive</code> – document 已经解析完毕时触发，几乎与<code>DOMContentLoaded</code>同时发生，但在<code>DOMContentLoaded</code>事件之前触发。</li>
<li><code>complete</code> – 文档和资源加载完成时触发，几乎与<code>window.onload</code>同时发生，但在<code>onload</code>事件之前触发。<br>一般来说，大多数的操作我们都应该放在 DOMContentLoaded 事件中执行，而不要放在 window.onload 中执行。</li>
</ul>
<p>当用户离开页面时，会触发后两个事件：</p>
<ul>
<li>window 上的<code>beforeunload</code>事件，该事件在用户准备离开页面，在<code>unload</code>事件之前触发。 如果<code>beforeunload</code>返回一个字符串，浏览器会给出用户是否真的想离开的提示。</li>
<li>window 上的<code>unload</code>事件，当用户最终离开时会触发该事件。在<code>unload</code>的事件处理程序中，我们只能做简单的事情，不涉及延迟或询问用户。由于这个限制，它很少使用。</li>
</ul>
<h2 id="js-全局对象"><a href="#js-全局对象" class="headerlink" title="js 全局对象"></a>js 全局对象</h2><p>js 中全局对象有两个概念：</p>
<ol>
<li>是指用户定义在<strong>全局作用域</strong>下的对象，即<code>var</code>定义的变量或者通过<code>function xxx()</code>定义的函数，会被自动挂载到 window 上；挂载之后可以通过<code>window.xx</code>或者<code>this</code>访问到。</li>
<li>js 的<strong>标准内置对象</strong>，并不是用户定义的，而是相当于 js 自带的一些对象和方法。实际上全局作用域包含内置对象</li>
</ol>
<p>标准内置对象很多，可以参考<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects</a><br>这里说几个主要的：</p>
<ol>
<li>内置方法，可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。</li>
</ol>
<ul>
<li><code>eval()</code></li>
<li><code>uneval()</code></li>
<li><code>isFinite()</code></li>
<li><code>isNaN()</code></li>
<li><code>parseFloat()</code></li>
<li><code>parseInt()</code></li>
<li><code>decodeURI()</code></li>
<li><code>decodeURIComponent()</code></li>
<li><code>encodeURI()</code></li>
<li><code>encodeURIComponent()</code></li>
<li>以及已废弃的<code>escape()</code>和<code>unescape()</code></li>
</ul>
<ol start="2">
<li>基本值属性，即：</li>
</ol>
<ul>
<li><code>Infinity</code></li>
<li><code>NaN</code></li>
<li><code>undefined</code></li>
<li><code>globalThis</code></li>
</ul>
<ol start="3">
<li>大多数不用定义直接引用的内置对象，比如所有数据类型的包装对象（<code>Number</code>、<code>Array</code>等），错误对象，ES6 新增的对象（<code>Promise</code>、<code>Reflect</code>、<code>Proxy</code>、<code>Map</code>、<code>Set</code>等）等。</li>
</ol>
<blockquote>
<p>注意，还有很多能直接使用的但是并非 js 内置对象，而是被挂载到了<code>window</code>上的。详见<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window">https://developer.mozilla.org/zh-CN/docs/Web/API/Window</a><br>常用的 window 上对象主要有：</p>
<ul>
<li><code>setTimeout/setInterval</code></li>
<li>console</li>
<li>alert</li>
<li><code>requestAnimationFrame</code></li>
<li><code>xhr</code>和<code>fetch</code></li>
<li>所有窗口大小相关的属性，比如<code>innerHeight</code>等</li>
</ul>
<p>基本上可以理解为，直接引用的对象除了 js 内置对象，基本都在 window 上。</p>
</blockquote>
<h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>delete 操作符用于删除对象的某个属性，不能被删除的特例有：</p>
<ul>
<li><strong><code>var</code>, <code>let</code>以及<code>const</code>创建的变量</strong></li>
<li>设置了<code>configurable:false</code>的属性</li>
<li>内置对象，不管是 window 提供的还是 js 内置的</li>
</ul>
<p>会被删除的除了对象属性，还有几个特例：</p>
<ul>
<li>非严格模式下未声明直接使用的变量，由于会被挂载到 window 上，因此会被直接删除</li>
<li><code>eval</code>中声明的变量</li>
<li>数组中的元素，删除后数组<code>length</code>并不改变，被删除的一项仍保留索引，但是值为<code>undefined</code>；</li>
</ul>
<blockquote>
<p>关于 delete 的返回值，对于所有情况都是 true，除非属性是一个自身的 不可配置的属性，在这种情况下，非严格模式返回 false，严格模式会报错</p>
</blockquote>
<h2 id="三种函数定义方式区别"><a href="#三种函数定义方式区别" class="headerlink" title="三种函数定义方式区别"></a>三种函数定义方式区别</h2><ol>
<li>函数声明，又叫函数语句；创建的函数是一个 Function 对象，具有 Function 对象的所有属性、方法和行为。<br>被声明的函数具有变量提升，可以在函数声明之前使用该函数；</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这种函数没有块级作用域，因此在条件或循环等块中声明依旧会被提升，但是不能使用。</p>
<p>并且，函数声明的提升优先级大于变量提升；也就是说如果前面还有一个同名的变量，函数声明将会覆盖它（let 和 const 不行，因为实际上 a 已经被声明到了前面，不能重复声明）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a(); <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a;</span><br><span class="line">a(); <span class="comment">// a is already been declared</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>MDN：<br>这种声明方式在不同的浏览器里可能有不同的效果。因此，不应该在生产环境代码中使用这种声明方式，应该使用函数表达式来代替。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// foo is not a function</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改成true是完全一样的</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>函数表达式，即声明一个变量是函数；函数表达式不会提升，所以不能在定义之前调用。<br>从声明角度，函数表达式可以用<code>var</code>或<code>let/const</code>定义；这两种方式的主要区别仍是在块级作用域上，但在执行到该语句之前变量都是<code>undefined</code>，都不能使用。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a(); <span class="comment">//a is not a function</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">a(); <span class="comment">//a is not a function</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// a is not defined</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，上面说到函数语句方式定义的函数，无论条件语句是 true 还是 false 都一样，都不会被提升；<br>这点使用函数表达式也是一样，只是不会有浏览器差异，结果一律都是 undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Error: a is not defined</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，这种定义方式都会把函数名直接和变量名统一，即不在<code>function</code>后再加名称；<br>加上也可以，被加上的函数名只能用于递归引用，不能在外调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Myfunc = <span class="function"><span class="keyword">function</span> <span class="title">YourFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  YourFunc();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">YourFunc(); <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>构造函数创建，即<code>new Function()</code>，语法：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>([arg1, arg2, ...argN], functionBody);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;return a + b&quot;</span>);</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该方法可以从字符串变为函数，几乎用不到；<br>这种方法创建的函数不能作为闭包，它内部的 outer 一定指向全局：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;alert(value)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> func;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFunc()(); <span class="comment">// error: value is not defined</span></span><br></pre></td></tr></table></figure>

<h2 id="函数参数作用域"><a href="#函数参数作用域" class="headerlink" title="函数参数作用域"></a>函数参数作用域</h2><p>函数有形参，形参会被添加到函数的作用域中，并且形参不会被重新定义（用 var 声明与形参同名的变量会被忽略，用 let 声明会报错），如果函数内声明一个和形参同名的函数，则内部声明的函数会覆盖参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">arg1, arg2, arg3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arg1; <span class="comment">// 声明被忽略</span></span><br><span class="line">  <span class="keyword">var</span> arg2 = <span class="string">&quot;hello&quot;</span>; <span class="comment">// var arg2 声明被忽略，arg2 = &quot;hello&quot; 被执行</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">arg3</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 函数声明会覆盖参数</span></span><br><span class="line">  <span class="built_in">console</span>.log(arg1, arg2, arg3);</span><br><span class="line">&#125;</span><br><span class="line">fun(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 1 &quot;hello&quot; [ƒ arg3() &#123;&#125;]</span></span><br></pre></td></tr></table></figure>

<p>实际上函数的参数是一个高于函数内部、低于外部的独立作用域，在函数被执行（传入具体参数）时确立其具体值</p>
<p>如果参数有默认值，则参数还会形成一个单独的作用域；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">x, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里的y默认值x会先从参数作用域中查找，即x是另一个参数，因此是2</span></span><br><span class="line">  <span class="built_in">console</span>.log(y); <span class="comment">// y === 2</span></span><br><span class="line">&#125;</span><br><span class="line">fun(<span class="number">2</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 内部作用域没有x，从外部找到x = 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(y); <span class="comment">// y === 1</span></span><br><span class="line">&#125;</span><br><span class="line">fun(<span class="number">2</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 默认参数和普通的参数一样，都是值的引用 */</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">x, y = x</span>) </span>&#123;</span><br><span class="line">  y.a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// &#123;a: 3&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">fun(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;a: 3&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果默认参数是函数，则这个函数相当于在参数作用域内部，和变量的情况是一致的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="string">&quot;outer&quot;</span>;</span><br><span class="line"><span class="comment">// 默认参数函数中的foo会从参数作用域先寻找，找到了foo变量为&#x27;other&#x27;，并且现在它是一个闭包</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">foo, func = () =&gt; foo</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(func());</span><br><span class="line">&#125;</span><br><span class="line">bar(<span class="string">&quot;other&quot;</span>); <span class="comment">// other</span></span><br></pre></td></tr></table></figure>

<h2 id="Commonjs"><a href="#Commonjs" class="headerlink" title="Commonjs"></a>Commonjs</h2><p>参考文章：<br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/05/commonjs-in-browser.html">http://www.ruanyifeng.com/blog/2015/05/commonjs-in-browser.html</a></p>
<p>浏览器不兼容 CommonJS 的根本原因，在于缺少四个 Node.js 环境的变量。</p>
<ul>
<li><code>module</code></li>
<li><code>exports</code></li>
<li><code>require</code></li>
<li><code>global</code></li>
</ul>
<p>只要能够提供这四个变量，浏览器就能加载 CommonJS 模块。</p>
<h2 id="会改变原数组和不改变的数组方法"><a href="#会改变原数组和不改变的数组方法" class="headerlink" title="会改变原数组和不改变的数组方法"></a>会改变原数组和不改变的数组方法</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904192671219719">https://juejin.cn/post/6844904192671219719</a></p>
<h2 id="import-和-export-default"><a href="#import-和-export-default" class="headerlink" title="import * 和 export default"></a><code>import *</code> 和 <code>export default</code></h2><p>当使用<code>import *</code>导入另一个模块中的全部导出变量时，会将所有导出的变量都合并为一个对象。比如下面的导出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// info.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">&quot;I love JavaScript&quot;</span>;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> info <span class="keyword">from</span> <span class="string">&quot;./info&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(info);</span><br></pre></td></tr></table></figure>

<p>输出是这样的：<br><img src="https://pic.imgdb.cn/item/624a58e3239250f7c57ac84a.jpg"></p>
<p>因此可以通过<code>info.xxx</code>来获取具体的导出值，甚至可以通过<code>info.default</code>获取默认导出值。<br>还可以通过在具名导入中用<code>as</code>获取默认导出的值：<br>实际上<code>default</code>只是导出对象的一个特殊属性，只是不能显式使用而已。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// info.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">&quot;I love JavaScript&quot;</span>;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> string, name, age &#125; <span class="keyword">from</span> <span class="string">&quot;./info&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string); <span class="comment">// &quot;I love JavaScript&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<p>并且默认导出和具名导出也是可以共存的。<br>还是上面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// info.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">&quot;I love JavaScript&quot;</span>;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> string <span class="keyword">from</span> <span class="string">&quot;./info&quot;</span>; <span class="comment">// &quot;I love JavaScript&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age &#125; <span class="keyword">from</span> <span class="string">&quot;./info&quot;</span>; <span class="comment">// &quot;Lydia&quot; 21</span></span><br></pre></td></tr></table></figure>

<p>唯一的限制是，一个模块只能有一个默认导出</p>
<h2 id="细碎知识点"><a href="#细碎知识点" class="headerlink" title="细碎知识点"></a>细碎知识点</h2><ol>
<li><code>var a = b = xxx</code>形式的赋值，会导致除了第一个之外其他变量都变成全局变量（比如这里的 b）</li>
<li><code>let</code>在全局作用域下声明的变量不会挂载到 window 上，但是<code>var</code>会</li>
<li>函数的<code>arguments</code>属性是一个<strong>可迭代对象</strong>，并不是一个数组，因此没有数组方法，但是拥有<code>length</code>属性；此外可以通过<code>Array.from</code>把他变成一个真正的数组，或者直接使用<code>[...arguments]</code>展开</li>
<li>this 绑定优先级：<code>new</code>绑定优先级 &gt; 显式绑定（<code>call</code> <code>bind</code> <code>apply</code>）优先级 &gt; 隐式绑定（对象调用）优先级 &gt; 默认绑定优先级</li>
<li><code>let</code>和<code>const</code>不能对变量重复声明，这一点不仅体现在自己不能重复声明自己，也体现在不能声明<code>var</code>声明过的变量和同名函数</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li><code>call(null)</code>或<code>call(undefined)</code>都会将 this 指向 window（严格模式是 undefined）；<code>apply</code>和<code>bind</code>也一样</li>
<li>如果使用<code>clearTimeout</code>清除定时器，已放入宏任务队列或者还在等待的回调都会被清除不再执行。</li>
<li>在<code>==</code>中，<code>null</code> 和 <code>undefined</code> 除了和彼此比较以外，与其他任何类型操作数进行相等性测试都为 false</li>
<li><code>class</code>和<code>let/const</code>一样都有暂时性死区和块级作用域，都不能提升。</li>
<li><code>import</code>引入的变量是只读的，对于基本类型来说，不能修改值，修改会报只读的错误（相当于<code>const</code>）；但是引用类型可以修改，并且修改会引起源对象的值也发生改变。</li>
<li>类中可以通过<code>#xxx</code>添加私有变量，在外部不可访问；注意这是确实存在的语法，而不是一种约定，当试图在外修改时会报错。同理 static 也是确实可以添加的静态字段和，而不只是一个约定</li>
<li><code>Object.freeze()</code>可以对对象进行<strong>浅</strong>冻结（不能对值为对象的属性生效），不能对属性进行添加，修改，删除</li>
<li>可选链操作符<code>?.</code>不仅可以访问普通的对象属性，还可以通过<code>arr?.[i]</code>形式访问数组或变量形式值；或者通过<code>obj.someFunc?.()</code>调用可能不存在的函数。</li>
</ol>
<h2 id="关于对象中定时器不会被回收的问题"><a href="#关于对象中定时器不会被回收的问题" class="headerlink" title="关于对象中定时器不会被回收的问题"></a>关于对象中定时器不会被回收的问题</h2><p>这个问题来源于一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> config = &#123;</span><br><span class="line">  <span class="attr">alert</span>: <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>),</span><br><span class="line">&#125;;</span><br><span class="line">config = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>当 config 为 null 时，看起来 config 已经被回收了，但是定时器依旧每秒输出 1。<br>这个例子的原文下说的是“<code>setInterval</code>的参数是一个箭头函数（所以上下文绑定到对象 config 了），回调函数仍然保留着对 config 的引用”<br>但是这显然不对，因为替换成非箭头函数也是一样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> config = &#123;</span><br><span class="line">  <span class="attr">alert</span>: <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>),</span><br><span class="line">&#125;;</span><br><span class="line">config = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>甚至，根本就不是引用和垃圾回收的问题。当直接在对象的属性中调用一个函数时，即使只是在声明，都会直接调用该函数，并把返回值赋给这个属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> config = &#123;</span><br><span class="line">  <span class="attr">alert</span>: <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(config) <span class="comment">// &#123;alert: 158&#125; 这个值是Interval的id，显然是返回值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> config = &#123;</span><br><span class="line">  <span class="attr">alert</span>: <span class="built_in">console</span>.log(<span class="string">&quot;aaa&quot;</span>); <span class="comment">// aaa</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 即使没有config.alert，在定义时会直接执行 console.log</span></span><br></pre></td></tr></table></figure>

<p>这时把 config 设为 null 确实回收了 config，但是并没有清除定时器，依旧在运行。</p>
<h2 id="node-查找模块顺序"><a href="#node-查找模块顺序" class="headerlink" title="node 查找模块顺序"></a>node 查找模块顺序</h2><p><img src="https://pic.imgdb.cn/item/6248f91c27f86abb2a36aade.jpg"></p>
<p>查找优先级如下：</p>
<ol>
<li>缓存的模块优先级最高</li>
<li>如果是内置模块，则直接返回，优先级仅次缓存的模块；</li>
<li>如果是绝对路径 / 开头，则从根目录找</li>
<li>如果是相对路径 ./开头，则从当前 require 文件相对位置找</li>
<li>如果文件没有携带后缀，先从 js、json、node 按顺序查找</li>
<li>如果是目录，则根据 <code>package.json</code>的 main 属性值决定目录下入口文件，默认情况为 index.js</li>
<li>如果文件为第三方模块，则会引入 <code>node_modules</code> 文件，如果不在当前仓库文件中，则自动从上级递归查找，直到根目录</li>
</ol>
<blockquote>
<p>最后一步的查找优先级：<br>如果在<code>/home/ry/projects/foo.js</code>文件里调用了 <code>require(&#39;bar.js&#39;)</code>，则 Node.js 会按以下顺序查找：</p>
<ol>
<li><code>/home/ry/projects/node_modules/bar.js</code></li>
<li><code>/home/ry/node_modules/bar.js</code></li>
<li><code>/home/node_modules/bar.js</code></li>
<li><code>/home/node_modules/bar/index.js</code>；（如果上面不存在，说明可能是模块名错误，就会从默认按照 index.js 查找）</li>
<li><code>/node_modules/bar.js</code>，即总根目录下的模块</li>
</ol>
</blockquote>
<h2 id="Promise-相关题目"><a href="#Promise-相关题目" class="headerlink" title="Promise 相关题目"></a>Promise 相关题目</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;timer1&quot;</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;timer2&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;start&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;start&#x27;</span><br><span class="line">&#x27;timer1&#x27;</span><br><span class="line">&#x27;promise&#x27;</span><br><span class="line">&#x27;timer2&#x27;</span><br></pre></td></tr></table></figure>

<p>注意<code>promise</code>在<code>timer2</code>之前，因为<code>Promise.resolve().then</code>内的是微任务，和<code>timer2</code>的<code>setTimeout</code>宏任务相比要更优先。<br>即会先执行完第一个<code>setTimeout</code>内的代码，才会执行第二个，并且第一个内的代码执行期间，第二个<code>setTimeout</code>仍然是异步宏任务，并不会和第一个一起同时把回调放入宏任务队列。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>注意<code>reject</code>会直接跳到 <code>catch</code>，忽略过程中的 <code>then</code>；而 <code>catch</code> 如果有返回值，则还会递交给下一个 <code>then</code>，并不会彻底结束。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="built_in">console</span>.err);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</span><br></pre></td></tr></table></figure>

<p><code>Promise</code> 的 <code>then</code> 中不能返回他自己，否则会报错。这点在手写 promise 中也体现过，进入 <code>then</code> 之后需要有一个判断，如果返回值是自己就会报错。</p>
<h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>).then(<span class="number">2</span>).then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>)).then(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p><code>.then</code> 或者 <code>.catch</code> 的参数期望是函数，传入非函数则会发生值透传。<br>透传是会将 <code>resolve</code> 的结果透传到第一个能接受的 <code>then</code> 里边，而并不会理会其他 <code>then</code> 或 <code>catch</code> 中的参数。如果一直没有，就会直接返回一个 <code>Promise</code> 对象，中间都不会处理。<br>从手写 promise 中可以看到，如果参数不是函数，就变成一个直接返回参数值的函数<code>(val)=&gt;val</code>，然后在下面的新<code>Promise</code>中直接返回上一个<code>resolve</code>值（即<code>this.value</code>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//判断参数是不是函数</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&quot;function&quot;</span> ? onFulfilled : <span class="function">(<span class="params">val</span>) =&gt;</span> val;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">let</span> returnValueFromThen = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">  .finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;finally2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;我是finally2返回的值&quot;</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;finally2后面的then函数&quot;</span>, res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;1&#x27;</span><br><span class="line">&#x27;finally2&#x27;</span><br><span class="line">&#x27;finally&#x27;</span><br><span class="line">&#x27;finally2后面的then函数&#x27; &#x27;2&#x27;</span><br></pre></td></tr></table></figure>

<p><code>finally</code>的特点：</p>
<ul>
<li>任何情况下都会调用，不管<code>fulfilled</code>还是<code>rejected</code></li>
<li>回调不接受参数，因此不能收到任何内部的值，也没法知道<code>Promise</code>最终的状态是<code>resolved</code>还是<code>rejected</code></li>
<li>返回的默认会是一个上一次的<code>Promise</code>对象的返回值，如果抛出的是一个异常则返回异常的<code>Promise</code>对象，也就是说如果<code>finally</code>位于中间，则他的返回值不会对其他<code>then</code>或<code>catch</code>有任何影响，相当于原封不动的传递。</li>
<li><code>finally</code>依然是一个微任务，和<code>then</code>和<code>catch</code>一样，按照微任务顺序执行</li>
</ul>
<h3 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(x);</span><br><span class="line">      <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runReject</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="string">`Error: <span class="subst">$&#123;x&#125;</span>`</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;, <span class="number">1000</span> * x)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.all([runAsync(<span class="number">1</span>), runReject(<span class="number">4</span>), runAsync(<span class="number">3</span>), runReject(<span class="number">2</span>)])</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1s后输出</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">// 2s后输出</span><br><span class="line">2</span><br><span class="line">Error: 2</span><br><span class="line">// 4s后输出</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p><code>Promise.all</code>的执行原则：</p>
<ol>
<li>所有任务并行执行，最终输出事件以最长任务为准；每个任务内部的同步代码会独立并行执行。</li>
<li>如果有一个任务<code>reject</code>或者抛出错误，就会触发<code>Promise.all</code>后面的<code>catch</code>，这时整个<code>Promise.all</code>状态变为<code>rejected</code>，不会再触发<code>then</code>；但是并不代表所有任务都不再执行，任务<strong>仍会继续</strong>执行，但不会有有效的返回结果。像上面的例子中虽然 3 秒时已经<code>rejected</code>，但是最后一个任务还是会执行，输出自己内部的<code>4</code>，并且不会再触发<code>then</code>或<code>catch</code></li>
</ol>
<h3 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 success&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;async1 end&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;srcipt start&quot;</span>);</span><br><span class="line">async1().then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;srcipt end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;script start&#x27;</span><br><span class="line">&#x27;async1 start&#x27;</span><br><span class="line">&#x27;promise1&#x27;</span><br><span class="line">&#x27;script end&#x27;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>await</code>紧挨的内容如果是普通代码，相当于<code>new Promise</code>内部的，其后的代码相当于<code>.then</code>；如果是<code>Promise</code>对象，则会等待这个<code>Promise resolve</code>并阻塞后面代码，如果该 Promise 没有返回值，就会一直在<code>pending</code>状态，一直阻塞。</p>
</blockquote>
<p>在<code>async1</code>中<code>await</code>后面的<code>Promise</code>是没有返回值的，也就是它的状态始终是<code>pending</code>状态，因此相当于一直在 await，await，await 却始终没有响应…<br>所以在<code>await</code>之后的内容是不会执行的，也包括<code>async1</code>后面的 <code>.then</code>。</p>
<h3 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;async1 success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">    reject(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">async1().then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res));</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;async2&#x27;</span><br><span class="line">Uncaught (in promise) error</span><br></pre></td></tr></table></figure>

<p><code>await</code>之后的代码相当于被包裹在了一个<code>then</code>中，因此执行条件是<code>await</code>的<code>promise</code>被<code>resolve</code>；对应的，如果这个<code>promise</code>被<code>reject</code>，那么结果就是其后的代码都不会执行了，而是直接跳到 catch（如果没有 catch 就直接抛出错误）。<br>上面的代码相当于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">    reject(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1&#x27;</span>);</span><br><span class="line">    resolve(<span class="string">&#x27;async1 success&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>显然后面的两个<code>then</code>中代码都不会执行。</p>
<hr>
<p>但是如果使用<code>try catch</code>包裹并捕获错误，那么将会在 catch 中将错误立即处理，并且继续执行之后的代码。<br>所以这段代码会正常执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&quot;error!!!&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&quot;async1 success&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1().then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line">(<span class="string">&quot;error!!!&quot;</span>);</span><br><span class="line">(<span class="string">&quot;async1&quot;</span>);</span><br><span class="line">(<span class="string">&quot;async1 success&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="9"><a href="#9" class="headerlink" title="9."></a>9.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;resolve3&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;timer1&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  resolve(<span class="string">&quot;resovle1&quot;</span>);</span><br><span class="line">  resolve(<span class="string">&quot;resolve2&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(p1);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;finally&quot;</span>, res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;resolve1&#x27;</span><br><span class="line">&#x27;finally&#x27; undefined</span><br><span class="line">&#x27;timer1&#x27;</span><br><span class="line">Promise&#123;&lt;resolved&gt;: undefined&#125;</span><br></pre></td></tr></table></figure>

<p>首先要说一下，<code>then</code>中执行完成后会紧接着把后面的下一个<code>then/finally/catch</code>放入微任务队列，如果连续接着很多 then 就会依次放入；这个过程中相当于微任务队列一直有任务，定时器等宏任务不会执行。<br>就比如本题中，虽然第一个<code>setTimeout</code>在同步阶段都已经被放入宏任务队列，但是仍会先执行<code>then</code>和<code>finally</code>中的代码，等这两个中的代码都被执行完后才会执行剩下的宏任务。</p>
<p>最后一个定时器打印出的 p1 其实是<code>.finally</code>的返回值，我们知道<code>.finally</code>的返回值如果在没有抛出错误的情况下默认会是上一个<code>Promise</code>的返回值，而这道题中.<code>finally</code>上一个<code>Promise</code>是<code>.then()</code>，但是这个<code>.then()</code>并没有返回值，所以 p1 打印出来的<code>Promise</code>的值会是<code>undefined</code>，如果你在定时器的下面加上一个<code>return 1</code>，则值就会变成 1。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="/img/codes1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/02/06/blog41-tsdeeping/"><img class="prev-cover" src="/img/typescript.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">typescript深入学习</div></div></a></div><div class="next-post pull-right"><a href="/2022/02/06/do-exercise-2/"><img class="next-cover" src="/img/codes1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">工程化、React以及其他知识刷题总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/02/06/do-exercise-2/" title="工程化、React以及其他知识刷题总结"><img class="cover" src="/img/codes1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-06</div><div class="title">工程化、React以及其他知识刷题总结</div></div></a></div><div><a href="/2022/04/05/do-exercise-3/" title="js编程题总结"><img class="cover" src="/img/codes1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-05</div><div class="title">js编程题总结</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/pinkstar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xing Ye</div><div class="author-info__description">a singleThreaded boy's blog</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/penghei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/penghei" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:632885485@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">A SingleThreaded Boy...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE"><span class="toc-number">1.</span> <span class="toc-text">网络相关题目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-number">1.1.</span> <span class="toc-text">常见的请求头和响应头</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JS-%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%EF%BC%88%E6%AF%8F%E5%A4%A9-30-%E9%81%93%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">JS 题目总结（每天 30 道）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%9B%B4%E6%94%B9%E5%BD%B1%E5%93%8D%E5%8E%9F%E5%8F%98%E9%87%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">函数参数更改影响原变量的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">2.2.</span> <span class="toc-text">原始数据不可变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C-amp-amp-%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.3.</span> <span class="toc-text">|| 和 &amp;&amp; 的返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-%E5%BE%AA%E7%8E%AF%E5%92%8C-let%E3%80%81var"><span class="toc-number">2.4.</span> <span class="toc-text">for 循环和 let、var</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%83%85%E5%86%B5"><span class="toc-number">2.4.1.</span> <span class="toc-text">同步情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%83%85%E5%86%B5"><span class="toc-number">2.4.2.</span> <span class="toc-text">异步情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#valueOf-NaN"><span class="toc-number">2.5.</span> <span class="toc-text">valueOf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">2.6.</span> <span class="toc-text">类的静态方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#let-%E5%92%8C-const-%E7%9A%84%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA-TDZ"><span class="toc-number">2.7.</span> <span class="toc-text">let 和 const 的暂时性死区(TDZ)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#html-%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.8.</span> <span class="toc-text">html 页面生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js-%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.9.</span> <span class="toc-text">js 全局对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#delete"><span class="toc-number">2.10.</span> <span class="toc-text">delete</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F%E5%8C%BA%E5%88%AB"><span class="toc-number">2.11.</span> <span class="toc-text">三种函数定义方式区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.12.</span> <span class="toc-text">函数参数作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Commonjs"><span class="toc-number">2.13.</span> <span class="toc-text">Commonjs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%9A%E6%94%B9%E5%8F%98%E5%8E%9F%E6%95%B0%E7%BB%84%E5%92%8C%E4%B8%8D%E6%94%B9%E5%8F%98%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.14.</span> <span class="toc-text">会改变原数组和不改变的数组方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#import-%E5%92%8C-export-default"><span class="toc-number">2.15.</span> <span class="toc-text">import * 和 export default</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%86%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">2.16.</span> <span class="toc-text">细碎知识点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%9B%9E%E6%94%B6%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.17.</span> <span class="toc-text">关于对象中定时器不会被回收的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node-%E6%9F%A5%E6%89%BE%E6%A8%A1%E5%9D%97%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.18.</span> <span class="toc-text">node 查找模块顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE"><span class="toc-number">2.19.</span> <span class="toc-text">Promise 相关题目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1"><span class="toc-number">2.19.1.</span> <span class="toc-text">1.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2"><span class="toc-number">2.19.2.</span> <span class="toc-text">2.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3"><span class="toc-number">2.19.3.</span> <span class="toc-text">3.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4"><span class="toc-number">2.19.4.</span> <span class="toc-text">4.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5"><span class="toc-number">2.19.5.</span> <span class="toc-text">5.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6"><span class="toc-number">2.19.6.</span> <span class="toc-text">6.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7"><span class="toc-number">2.19.7.</span> <span class="toc-text">7.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8"><span class="toc-number">2.19.8.</span> <span class="toc-text">8.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9"><span class="toc-number">2.19.9.</span> <span class="toc-text">9.</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/05/blog43-algorithms/" title="算法学习总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法学习总结"/></a><div class="content"><a class="title" href="/2022/04/05/blog43-algorithms/" title="算法学习总结">算法学习总结</a><time datetime="2022-04-05T08:01:22.000Z" title="发表于 2022-04-05 16:01:22">2022-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/05/do-exercise-3/" title="js编程题总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="js编程题总结"/></a><div class="content"><a class="title" href="/2022/04/05/do-exercise-3/" title="js编程题总结">js编程题总结</a><time datetime="2022-04-05T03:08:25.000Z" title="发表于 2022-04-05 11:08:25">2022-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/29/blog42-react-review/" title="react复习"><img src="/img/react.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="react复习"/></a><div class="content"><a class="title" href="/2022/03/29/blog42-react-review/" title="react复习">react复习</a><time datetime="2022-03-29T11:20:32.000Z" title="发表于 2022-03-29 19:20:32">2022-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/06/blog41-tsdeeping/" title="typescript深入学习"><img src="/img/typescript.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="typescript深入学习"/></a><div class="content"><a class="title" href="/2022/02/06/blog41-tsdeeping/" title="typescript深入学习">typescript深入学习</a><time datetime="2022-02-06T05:44:25.000Z" title="发表于 2022-02-06 13:44:25">2022-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/06/do-exercise-1/" title="HTML+CSS+JS+原理性知识刷题总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTML+CSS+JS+原理性知识刷题总结"/></a><div class="content"><a class="title" href="/2022/02/06/do-exercise-1/" title="HTML+CSS+JS+原理性知识刷题总结">HTML+CSS+JS+原理性知识刷题总结</a><time datetime="2022-02-06T05:44:25.000Z" title="发表于 2022-02-06 13:44:25">2022-02-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Xing Ye</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hello stranger!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>