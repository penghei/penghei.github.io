<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>typescript深入学习 | XingYeBlog</title><meta name="keywords" content="日常学习"><meta name="author" content="Xing Ye,632885485@qq.com"><meta name="copyright" content="Xing Ye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基本类型补充元组相当于类型的数组 1234type tuple &#x3D; [string, number];let x: tuple;x &#x3D; [&quot;hello&quot;, 10]; &#x2F;&#x2F; OKx &#x3D; [10, &quot;hello&quot;]; &#x2F;&#x2F; Error  元组和 js 的数组类似，实际上通过一些骚操作，也可以实现类似数组的 pop&#x2F;push&#x2F;shift 等功能： 12345678">
<meta property="og:type" content="article">
<meta property="og:title" content="typescript深入学习">
<meta property="og:url" content="http://example.com/2022/02/06/blog9-tsdeeping/index.html">
<meta property="og:site_name" content="XingYeBlog">
<meta property="og:description" content="基本类型补充元组相当于类型的数组 1234type tuple &#x3D; [string, number];let x: tuple;x &#x3D; [&quot;hello&quot;, 10]; &#x2F;&#x2F; OKx &#x3D; [10, &quot;hello&quot;]; &#x2F;&#x2F; Error  元组和 js 的数组类似，实际上通过一些骚操作，也可以实现类似数组的 pop&#x2F;push&#x2F;shift 等功能： 12345678">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/typescript.png">
<meta property="article:published_time" content="2022-02-06T05:44:25.000Z">
<meta property="article:modified_time" content="2023-02-14T16:12:20.237Z">
<meta property="article:author" content="Xing Ye">
<meta property="article:tag" content="日常学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/typescript.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2022/02/06/blog9-tsdeeping/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'typescript深入学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-15 00:12:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/pinkstar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/typescript.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XingYeBlog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">typescript深入学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-06T05:44:25.000Z" title="发表于 2022-02-06 13:44:25">2022-02-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-14T16:12:20.237Z" title="更新于 2023-02-15 00:12:20">2023-02-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/TypeScript/">TypeScript</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>57分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="typescript深入学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="基本类型补充"><a href="#基本类型补充" class="headerlink" title="基本类型补充"></a>基本类型补充</h1><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>相当于类型的数组</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tuple = [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">let</span> x: tuple;</span><br><span class="line">x = [<span class="string">&quot;hello&quot;</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&quot;hello&quot;</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>元组和 js 的数组类似，实际上通过一些骚操作，也可以实现类似数组的 pop/push/shift 等功能：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取T的序号，在S中取值。比如T中有两个元素，结果就是S中的前两个元素</span></span><br><span class="line"><span class="keyword">type</span> ReplaceValByOwnKey&lt;T, S <span class="keyword">extends</span> <span class="built_in">any</span>&gt; = &#123; [P <span class="keyword">in</span> keyof T]: S[P] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用函数剩余参数，把第一个参数提出来，剩余的给infer R，然后返回R就是除去第一个之后的数组</span></span><br><span class="line"><span class="keyword">type</span> ShiftAction&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = (<span class="function">(<span class="params">...args: T</span>) =&gt;</span> <span class="built_in">any</span>) <span class="keyword">extends</span> (</span><br><span class="line">  arg1: <span class="built_in">any</span>,</span><br><span class="line">  ...rest: infer R</span><br><span class="line">) =&gt; <span class="built_in">any</span></span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样是利用参数，把要插入的放在第一个参数上，最后返回整个args</span></span><br><span class="line"><span class="keyword">type</span> UnshiftAction&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], A&gt; = (<span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  args1: A,</span></span></span><br><span class="line"><span class="params"><span class="function">  ...rest: T</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="built_in">any</span>) <span class="keyword">extends</span> (...args: infer R) =&gt; <span class="built_in">any</span></span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和shift刚好相反，因此用shift之后的数量取；</span></span><br><span class="line"><span class="comment">// 比如shift之后是去掉首位的2个，那么pop就相当于去掉末尾的的2个，也就是只取0 1号</span></span><br><span class="line"><span class="keyword">type</span> PopAction&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = ReplaceValByOwnKey&lt;ShiftAction&lt;T&gt;, T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看不懂呜呜呜</span></span><br><span class="line"><span class="keyword">type</span> PushAction&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], E&gt; = ReplaceValByOwnKey&lt;</span><br><span class="line">  UnshiftAction&lt;T, <span class="built_in">any</span>&gt;,</span><br><span class="line">  T &amp; &#123; [k: <span class="built_in">string</span>]: E &#125;</span><br><span class="line">&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test ...</span></span><br><span class="line"><span class="keyword">type</span> tuple = [<span class="string">&quot;vue&quot;</span>, <span class="string">&quot;react&quot;</span>, <span class="string">&quot;angular&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> resultWithShiftAction = ShiftAction&lt;tuple&gt;; <span class="comment">// [&quot;react&quot;, &quot;angular&quot;]</span></span><br><span class="line"><span class="keyword">type</span> resultWithUnshiftAction = UnshiftAction&lt;tuple, <span class="string">&quot;jquery&quot;</span>&gt;; <span class="comment">// [&quot;jquery&quot;, &quot;vue&quot;, &quot;react&quot;, &quot;angular&quot;]</span></span><br><span class="line"><span class="keyword">type</span> resultWithPopAction = PopAction&lt;tuple&gt;; <span class="comment">// [&quot;vue&quot;, &quot;react&quot;]</span></span><br><span class="line"><span class="keyword">type</span> resultWithPushAction = PushAction&lt;tuple, <span class="string">&quot;jquery&quot;</span>&gt;; <span class="comment">// [&quot;vue&quot;, &quot;react&quot;, &quot;angular&quot;, &quot;jquery&quot;]</span></span><br></pre></td></tr></table></figure>

<p>元组还可以通过直接规定索引类型的形式一次取出所有类型成为一个联合类型；这点也适合对象的类型别名</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tuple = [<span class="string">&quot;vue&quot;</span>, <span class="string">&quot;react&quot;</span>, <span class="string">&quot;angular&quot;</span>];</span><br><span class="line"><span class="keyword">type</span> tupleVal1 = tuple[<span class="built_in">number</span>]; <span class="comment">// &quot;vue&quot; | &quot;react&quot; | &quot;angular&quot;</span></span><br><span class="line"><span class="keyword">type</span> tupleVal2 = tuple[<span class="built_in">string</span>]; <span class="comment">//报错：tuple中没有string索引的值</span></span><br><span class="line"><span class="keyword">type</span> tupleVal3 = tuple[<span class="built_in">any</span>]; <span class="comment">// &quot;vue&quot; | &quot;react&quot; | &quot;angular&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a>never 类型</h3><p>never 出现于：返回 error 或者死循环函数，或者其他一定不会被访问到的<br>比如最常见的死循环函数或者抛出错误的函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createError</span>(<span class="params">mess: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(mess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言除了 as，还可以用尖括号的形式</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br></pre></td></tr></table></figure>

<p>但是容易和 jsx 混淆， 因此不建议使用</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口可以理解为一个对象的类型，当然他不仅可以给对象注解，还可以是函数、数组等，但不能用于基本类型的注解。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>接口可以对数组使用。当用接口约束数组时，其实是把数组看作是一个对象，因此还可以同时约束数组的其他属性和方法。<br>如果想要给数组添加某种方法或重写方法，接口约束的方式可能很有用</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> MyNums &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">number</span>; <span class="comment">// 这里的index可以是string或number</span></span><br><span class="line">  length:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nums: MyNums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>


<h3 id="方法和函数"><a href="#方法和函数" class="headerlink" title="方法和函数"></a>方法和函数</h3><p>注意接口中的方法和函数定义相似但不同</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法，相当于一个对象内部</span></span><br><span class="line"><span class="keyword">interface</span> Animal&#123;</span><br><span class="line">    eat(food:<span class="built_in">string</span>):<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> animal:Animal = &#123;</span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params">food</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> food;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数，一般只能有一个，除非是函数重载</span></span><br><span class="line"><span class="keyword">interface</span> IFunc&#123;</span><br><span class="line">    (arg1:<span class="built_in">string</span>,...args:<span class="built_in">number</span>[]):<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> getSum:IFunc = <span class="function">(<span class="params">arg1,...args</span>)=&gt;</span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h3 id="任意索引签名"><a href="#任意索引签名" class="headerlink" title="任意索引签名"></a>任意索引签名</h3><p>任意索引签名指的是这种形式：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IValue &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  password: <span class="built_in">number</span>;</span><br><span class="line">  [prop: <span class="built_in">string</span>]: <span class="built_in">any</span>; <span class="comment">//可以添加任意属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>[prop: string]: any</code>表示键为字符串、值为任意的属性；当需要给对象添加原先不存在的属性时需要声明这种属性，表示一个任意的属性。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userInfo: IValue = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;zzx&quot;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&quot;0123456&quot;</span>, <span class="comment">//原先不存在的属性</span></span><br><span class="line">&#125;;</span><br><span class="line">userInfo.age = <span class="number">18</span>; <span class="comment">//添加属性</span></span><br><span class="line"><span class="built_in">console</span>.log(userInfo);</span><br></pre></td></tr></table></figure>

<ul>
<li>另外，该种属性的值类型必须包括所有值的类型，比如<code>[prop: string]: string</code>会报错， 因为没有包括 number，因此一般直接用 any。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IValue &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  password: <span class="built_in">number</span>;</span><br><span class="line">  [prop: <span class="built_in">string</span>]: <span class="built_in">string</span>; <span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用索引取得接口中的属性"><a href="#用索引取得接口中的属性" class="headerlink" title="用索引取得接口中的属性"></a>用索引取得接口中的属性</h3><p>接口可以通过<code>[propsName]</code>的形式取单个接口，还可以嵌套；</p>
<ul>
<li>接口中只有 symbol/number/string 三种类型键，因此取值也是这三种方式；</li>
<li>number 类型不会按顺序索引，比如<code>[0]</code>表示键为数字 0 的值，而不是第一项。</li>
<li>type 也是同理，与之类似的还有元组、联合类型</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="built_in">string</span>;</span><br><span class="line">  msg: IProps[<span class="string">&quot;method&quot;</span>];</span><br><span class="line">  <span class="number">0</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="number">1</span>: IProps[<span class="string">&quot;0&quot;</span>];</span><br><span class="line">  <span class="number">2</span>: IProps[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TProps = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="built_in">string</span>;</span><br><span class="line">  msg: TProps[<span class="string">&quot;method&quot;</span>];</span><br><span class="line">  <span class="number">0</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="number">1</span>: TProps[<span class="string">&quot;0&quot;</span>];</span><br><span class="line">  <span class="number">2</span>: TProps[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UProps = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> UProps1 = UProps[<span class="string">&quot;0&quot;</span>]; <span class="comment">//type UProps1 = string</span></span><br><span class="line"><span class="keyword">type</span> UProps2 = UProps[<span class="number">0</span>]; <span class="comment">//type UProps1 = string</span></span><br></pre></td></tr></table></figure>

<h3 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h3><p>类可以实现(implements)接口，类似 java 的接口；</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ICar &#123;</span><br><span class="line">  <span class="attr">speed</span>: <span class="built_in">number</span>;</span><br><span class="line">  canRun(): <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="title">implements</span> <span class="title">ICar</span> </span>&#123;</span><br><span class="line">  <span class="attr">speed</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">s: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.speed = s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">canRun</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.speed);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意类其实是分作<strong>静态部分</strong>和<strong>实例部分</strong>两个部分的，前者包括 static 定义的方法和变量以及构造函数，后者是其他部分；接口只能指定类的实例部分。</p>
<hr>
<p>类本身也是一种类型，因此接口其实可以继承一个类</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Control</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> state: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> SelectableControl <span class="keyword">extends</span> Control &#123;</span><br><span class="line">  select(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口继承类相当于是继承类的成员但不包括其实现；也就是只声明类的成员，但不实现。<br>并且如果接口继承的类中有 private 或 protected 类型，那么这个接口只能被原先类的子类实现（implements）</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> weight: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> IFruit <span class="keyword">extends</span> Fruit &#123;</span><br><span class="line">  eat(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherClass</span> <span class="title">implements</span> <span class="title">IFruit</span> </span>&#123;&#125; <span class="comment">//报错，因为OtherClass不是子类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> <span class="title">implements</span> <span class="title">IFruit</span> </span>&#123;</span><br><span class="line">  <span class="comment">//这样才可以</span></span><br><span class="line">  <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h3><p>可以利用接口，使得一个变量既可以是对象又可以作为函数调用</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Counter &#123;</span><br><span class="line">  (start: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">  interval: <span class="built_in">number</span>;</span><br><span class="line">  reset(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>&#123;&#125; <span class="keyword">as</span> Counter; <span class="comment">//这里是关键，把函数断言为Counter接口，使得定义的counter是Counter类型的</span></span><br><span class="line">  counter.interval = <span class="number">123</span>;</span><br><span class="line">  counter.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = getCounter();</span><br><span class="line">c(<span class="number">10</span>);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure>

<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h3 id="类的-getter-和-setter"><a href="#类的-getter-和-setter" class="headerlink" title="类的 getter 和 setter"></a>类的 getter 和 setter</h3><p>类也可以使用 getter 和 setter 来控制值的读写</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> _fullName: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">fullName</span>(): <span class="title">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._fullName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">fullName</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;wrong&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._fullName = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> xiaoming = <span class="keyword">new</span> Person();</span><br><span class="line">xiaoming.fullName = <span class="string">&quot;aa&quot;</span>; <span class="comment">//wrong</span></span><br></pre></td></tr></table></figure>

<h3 id="抽象类和方法"><a href="#抽象类和方法" class="headerlink" title="抽象类和方法"></a>抽象类和方法</h3><p>类似面向对象的语言，抽象类不能直接实例化, 必须要先继承；抽象方法没有具体方法体,必须继承后才能写。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="comment">//抽象类不能直接实例化, 必须要先继承</span></span><br><span class="line">  <span class="attr">speed</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">abstract</span> move(): <span class="built_in">void</span>; <span class="comment">//抽象方法没有具体方法体,必须继承后才能写</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">s: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.speed = s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMW</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">s: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  move(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`move with <span class="subst">$&#123;<span class="built_in">this</span>.speed&#125;</span>kph`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类当作接口"><a href="#类当作接口" class="headerlink" title="类当作接口"></a>类当作接口</h3><blockquote>
<p>类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。</p>
</blockquote>
<p>也就是说，类可以充当一个类似接口的效果，可以像上面接口中所述的给接口继承，或者直接给实例做注解</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Point3d <span class="keyword">extends</span> Point &#123;</span><br><span class="line">  <span class="attr">z</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point3d: Point3d = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h3 id="函数类型声明"><a href="#函数类型声明" class="headerlink" title="函数类型声明"></a>函数类型声明</h3><p>函数声明有两种</p>
<ul>
<li>一种是冒号型,声明被视作一个属性,需要在 interface 或者 type 的对象中</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Ifunc &#123;</span><br><span class="line">  (num: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Tfunc = &#123;</span><br><span class="line">  (num: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>另一种是箭头型,被视作函数,必须是 type,可以理解为函数类型变量</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TFunc = <span class="function">(<span class="params">num: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure>

<p>接口中含有名字的函数会被认作是对象中的方法；由于接口可以合并，因此同名不同参数和返回值的函数会被当作一个函数的重载。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Cloner &#123;</span><br><span class="line">  clone(animal: Sheep): Sheep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Cloner &#123;</span><br><span class="line">  clone(animal: Dog): Dog;</span><br><span class="line">  clone(animal: Cat): Cat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myCloners:Cloner&#123;</span><br><span class="line">  <span class="function"><span class="title">clone</span>(<span class="params">animal:Sheep|Dog|Cat</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>可选参数会被自动设置类型为<code>xxx|undifined</code></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">fname: <span class="built_in">string</span>, lname?: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lname) <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;fname&#125;</span> <span class="subst">$&#123;lname&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> fname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buildName(<span class="string">&quot;wang&quot;</span>);</span><br><span class="line">buildName(<span class="string">&quot;ming&quot;</span>, <span class="string">&quot;xiao&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>使用 es6 的默认值语法也可起到相应的效果</p>
<hr>
<p>除了使用可选参数，使得函数有任意个参数的方法还可以用剩余参数的方法</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAll</span>(<span class="params">num: <span class="built_in">number</span>, ...restNumber: <span class="built_in">number</span>[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!restNumber.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> restNumber) &#123;</span><br><span class="line">      sum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    sum += num;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addAll(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>另外，如果为了对不同参数执行不同操作，就需要函数的<strong>重载</strong></p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>重载相当于是给一个函数多种参数情况,根据你调用时的参数情况,在最后的实现中具体操作；<br>如果函数的返回值类型相同，那么就不需要使用函数重载。<br>最后函数的实现实际上并不算一个重载,但必须要把精确的定义放在前面，需要使用 <code>|</code>操作符或者<code>?:</code>操作符，把所有可能的输入类型全部包含进去。<br>比如下面这个例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padding</span>(<span class="params">all: <span class="built_in">number</span></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padding</span>(<span class="params">topAndBottom: <span class="built_in">number</span>, leftAndRight: <span class="built_in">number</span></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padding</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  top: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  right: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  bottom: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  left: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padding</span>(<span class="params">a: <span class="built_in">number</span>, b?: <span class="built_in">number</span>, c?: <span class="built_in">number</span>, d?: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!b &amp;&amp; !c &amp;&amp; !d) &#123;</span><br><span class="line">    b = c = d = a;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!c &amp;&amp; !d) &#123;</span><br><span class="line">    c = a;</span><br><span class="line">    d = b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">padding(<span class="number">1</span>);</span><br><span class="line">padding(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">padding(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，padding 可以有 1、2、4 个参数，不同参数对应的类型是不同的，比如一个参数表示全部，两个参数表示上下和左右，以此类推；<br>但是单独的函数重载不能实现执行效果，实际的代码还应该在最后一个函数中写明，并且要考虑之前各种参数的情况；最后一个<strong>不是重载</strong>，是函数的具体实现<br>比如上面代码中最后一个函数，需要有以下几点：</p>
<ol>
<li>至少有一个参数为必须，其他为<code>?:</code>表示的可选参数；也可以都是不必须，主要依赖于重载的制定；</li>
<li>要考虑到不同参数数量的情况；上面函数分别处理了参数为 1 个（全赋值为 a）和参数为 2 个（c=a,d=b）的情况</li>
<li>执行具体代码</li>
</ol>
<p>另外，最后函数实现必须要指明返回值，重载部分可以不需要</p>
<h3 id="ts-中的-this"><a href="#ts-中的-this" class="headerlink" title="ts 中的 this"></a>ts 中的 this</h3><p>ts 会自动指出可能会丢失 js 指向的问题，一般的解决方案是箭头函数。<br>比如下面一个经典的例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userInfo = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;zzx&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">19</span>,</span><br><span class="line">  <span class="function"><span class="title">createUserCard</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> and <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>`</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> cardPicker = userInfo.createUserCard();</span><br><span class="line"><span class="built_in">console</span>.log(cardPicker());</span><br></pre></td></tr></table></figure>

<p>如果在 js 中上面的例子会返回 undefined，因为单独调用<code>cardPicker</code>时 this 没有具体指向，会为 undefined；<br>但是 ts 会在 this 上报错（需要 tsconfig.json 的<code>--noImplicitThis</code>配置），告知你这里的 this 会被该函数隐藏，也就是相当于单独调用该 this 指向 window（严格模式下是 undefined）<br>因此可以这么写：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userInfo = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;zzx&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">19</span>,</span><br><span class="line">  <span class="function"><span class="title">createUserCard</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> and <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>`</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为箭头函数中的 this 默认指向上一层，也就是这个对象，因此不再会出错；</p>
<hr>
<p>但是此时 this 仍然是 any 类型，没有语法提示；ts 对于 this 提供了一个强大的功能：把 this 当作一个参数，指明 this 的类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IUser &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  createUserCard(): <span class="function">() =&gt;</span> <span class="built_in">string</span>; <span class="comment">//返回值为返回string的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userInfo: IUser = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;zzx&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">19</span>,</span><br><span class="line">  <span class="function"><span class="title">createUserCard</span>(<span class="params"><span class="built_in">this</span>: IUser</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//规定this的类型,把this视作一个参数,类型就是this本来所指的当前这个对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//这里不用箭头函数的话this会报错,因为如果调用该函数会使this失去指向</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> and <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>`</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样 this 就被说明清楚了，是指该对象本身。</p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>ts 泛型使得函数可以在调用时明确指定类型, 而不是一个 any 了事。</p>
<h3 id="泛型和函数"><a href="#泛型和函数" class="headerlink" title="泛型和函数"></a>泛型和函数</h3><p>最基本的泛型函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">echo</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="comment">//这里的T实际上是一种&quot;类型变量&quot;</span></span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> echo1 = echo&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> echo2 = echo&lt;<span class="built_in">number</span>&gt;(<span class="number">11</span>);</span><br><span class="line"><span class="keyword">let</span> echo3 = echo(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;); <span class="comment">//可以自己推断</span></span><br></pre></td></tr></table></figure>

<p>泛型可以理解为一种“类型变量”或者“类型参数”，类似于函数中的形参，调用时传入实参（具体类型），应用于各个类型注解上。</p>
<p>泛型函数的声明和函数类型声明类似，表示泛型的简括号被置于表示函数的括号前面，其他的相同：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型可以用type声明, 类似函数声明, 但是没有名字</span></span><br><span class="line"><span class="keyword">type</span> GenericsType = &lt;T&gt;<span class="function">(<span class="params">arg: T[]</span>) =&gt;</span> T[];</span><br><span class="line"><span class="keyword">type</span> GenericsType&lt;T&gt; = <span class="function">(<span class="params">arg: T[]</span>) =&gt;</span> T[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GenericsTypeObj = &#123;</span><br><span class="line">  &lt;T&gt;(arg: T[]): T[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">interface</span> IGenerics &#123;</span><br><span class="line">  &lt;T&gt;(arg: T[]): T[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>可以在接口上定义泛型，对函数来说类型别名也可以</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IGenericsFunc&lt;T&gt; &#123;</span><br><span class="line">  (arg: T[]): T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="keyword">type</span> genericsType&lt;T&gt; = <span class="function">(<span class="params">arg: T[]</span>) =&gt;</span> T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> echoOneFromList: IGenericsFunc&lt;<span class="built_in">number</span>&gt; = <span class="function">(<span class="params">args</span>) =&gt;</span> args[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>通过接口泛型可以更灵活使用接口。<br>除了泛型接口，类似的还有泛型类，但是没有泛型枚举和泛型命名空间</p>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> data: T[] = [];</span><br><span class="line">  push = <span class="function">(<span class="params">item: T</span>) =&gt;</span> <span class="built_in">this</span>.data.push(item);</span><br><span class="line">  pop = (): T | <span class="function"><span class="params">undefined</span> =&gt;</span> <span class="built_in">this</span>.data.shift();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> Queue&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">queue.push(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> x = queue.pop();</span><br></pre></td></tr></table></figure>

<h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>让泛型继承自某个接口来约束泛型, 相当于给泛型设置了默认值。<br>比如这个例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line">loggingIdentity([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line">loggingIdentity(&#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>这里规定泛型必须有 length 属性, 可以是一个数组, 或有 length 属性的对象。<br>也可以让泛型继承自一个类型别名，核心思路不变，就是把泛型必须的属性写在类型中。</p>
<hr>
<p>甚至还可以规定默认值，就和真正的函数一样：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> foo&lt;T <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">&quot;hello world&quot;</span>&gt; = T;</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">T: <span class="built_in">string</span> = <span class="string">&quot;hello world&quot;</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar: foo;</span><br><span class="line"><span class="comment">//bar === &#x27;hello world&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="类型兼容"><a href="#类型兼容" class="headerlink" title="类型兼容"></a>类型兼容</h1><p>ts 类型兼容是指，两个变量相互赋值、或者在函数参数中传递时会检查其兼容性。</p>
<blockquote>
<p>TypeScript 里的类型兼容性是基于结构子类型的。 结构类型是一种只使用其成员来描述类型的方式。 它正好与名义（nominal）类型形成对比。（在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明和/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。）</p>
</blockquote>
<p>比如 java 或 c 语言中，类型是明确指明的，不同类型不能赋值；但是 ts 是依据结构的，尤其是对于对象、数组这类非简单变量，只要结构有兼容性（比如属性互相包含）就有可能被互相赋值。</p>
<h3 id="变体"><a href="#变体" class="headerlink" title="变体"></a>变体</h3><h4 id="类型系统的父子关系"><a href="#类型系统的父子关系" class="headerlink" title="类型系统的父子关系"></a>类型系统的父子关系</h4><p>了解变体之前应该首先了解类型系统的父子关系。<br>子类型可以通过继承后继续添加新的属性，因此子类型的属性比父类型更多，更具体；在类型定义中<strong>属性更多的类型是子类型</strong>。</p>
<ul>
<li>在类型系统中，属性更多的类型是子类型。</li>
<li>在集合论中，属性更少的集合是子集。</li>
</ul>
<p><strong>子类型比父类型更加具体</strong>，这点很关键。注意是<strong>具体</strong>，而不一定是多的。</p>
<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>先看一个例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal = &#123;</span><br><span class="line">  <span class="attr">eat</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  sleep: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog = &#123;</span><br><span class="line">  <span class="attr">eat</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  sleep: <span class="built_in">boolean</span>;</span><br><span class="line">  weight: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal: Animal;</span><br><span class="line"><span class="keyword">let</span> dog: Dog;</span><br><span class="line"></span><br><span class="line">animal = dog; <span class="comment">// ✅ok</span></span><br><span class="line">dog = animal; <span class="comment">// ❌error!</span></span><br></pre></td></tr></table></figure>

<p>animal 是一个「更宽泛」的类型，它的属性比较少，所以更「具体」的子类型是可以赋值给它的，dog 上拥有 animal 所拥有的一切类型，赋值给 animal 是不会出现类型安全问题的。</p>
<p>也就是说，多的属性类型可以赋值给少的，但是少的不能赋值给多的；从可赋值性角度来说，子类型是可以赋值给父类型的，也就是 <code>父类型变量 = 子类型变量</code> 是安全的，因为子类型上涵盖了父类型所拥有的的一切属性。</p>
<p>这个特点叫做<strong>协变</strong>，即多可以赋给少，但是反过来不行。</p>
<blockquote>
<p>一种常见的泛型写法<code>&lt;T extends &#123;&#125;&gt;</code>也就是这个意思，这个约束了传入的参数一定是<code>&#123;&#125;</code>的子类型，也就是比<code>&#123;&#125;</code>要多任意属性的类型，比空多一个属性都算，即任何类型都可以。</p>
</blockquote>
<p>但是对于联合类型，这个情况恰恰相反：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Parent = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> Son = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> parent: Parent;</span><br><span class="line"><span class="keyword">let</span> son: Son;</span><br><span class="line"></span><br><span class="line">parent = son; <span class="comment">// ✅ok</span></span><br><span class="line">son = parent; <span class="comment">// ❌error! parent 有可能是 &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure>

<p>当 parent 取 c 时，son 的类型 Son 并没有包含”c”，因此不能赋值。</p>
<p>这种情况和上面恰恰相反，少的能赋值给多的，但是反过来不行。这种情况叫做<strong>逆变</strong></p>
<h4 id="变体-1"><a href="#变体-1" class="headerlink" title="变体"></a>变体</h4><p>变体有四种形式：</p>
<ul>
<li>协变（Covariant）：子类型比父类型更具体、属性更多，子类型可以赋值给父类型，父类型可以转换为子类型（扩展）。ts 中对象、数组的相互赋值都是协变的。</li>
<li>逆变（Contravariant）：和协变相反，子类型变为父类型（收缩）。</li>
<li>双向协变（Bivariant）：父子类型相互转化，ts 函数的参数就是双向协变的。</li>
<li>不变（Invariant）：父子类型不能转化</li>
</ul>
<p>这里先规定一种表示方法：</p>
<blockquote>
<p>A ≼ B 意味着 A 是 B 的子类型。<br>A → B 指的是以 A 为参数类型，以 B 为返回值类型的函数类型。<br>x : A 意味着 x 的类型为 A</p>
</blockquote>
<ul>
<li><p>ts 的对象和数组是协变的，因为一个包含另一个对象的对象可以赋给该对象</p>
</li>
<li><p>ts 的函数<strong>返回值类型是协变的，而参数类型是逆变的</strong>。注意这里的逆变协变并<strong>不是发生在函数调用</strong>，而是发生在函数间的比较和类型兼容时。</p>
<ul>
<li>返回值类型是协变的，意思是 <code>A ≼ B</code> 就意味着 <code>(T → A) ≼ (T → B) </code>，也就是返回值类型可以扩大；如果规定返回值为一个类型，但是传入一个更大的类型，是可以的。</li>
<li>参数类型是逆变的，意思是 <code>A ≼ B </code>就意味着 <code>(B → T) ≼ (A → T)</code> 。<br>参考这个例子：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func1 = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> a;</span><br><span class="line"><span class="keyword">let</span> func2 = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">boolean</span></span>) =&gt;</span> a;</span><br><span class="line"></span><br><span class="line">func1 = func2; <span class="comment">//error</span></span><br><span class="line">func2 = func1;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="比较对象"><a href="#比较对象" class="headerlink" title="比较对象"></a>比较对象</h3><p>如果 x 要兼容 y，那么 y 至少具有与 x 相同的属性；也就是多可以赋给少，但是少不能赋给多。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> AName &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> BName &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aname: AName;</span><br><span class="line"><span class="keyword">let</span> bname: BName;</span><br><span class="line">aname = bname;</span><br><span class="line">bname = aname; <span class="comment">//error，因为bname中的age属性aname没有</span></span><br></pre></td></tr></table></figure>

<p>aname 中的全部属性在 bname 中都有并且不冲突，因此可以把 bname 赋值给 aname。</p>
<p>从类型角度来说，BName 是 AName 的子类型，子类型可以转化为父类型，这就是协变。</p>
<p>对于函数参数也是这样的，参数如果被指明类型 A，B 类型是 A 类型的扩充，那么传入 B 类型并不会报错。当然这里指的是传参，并不是函数之间参数的比较；</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">n: IName</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">greet(bname); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<h3 id="比较函数"><a href="#比较函数" class="headerlink" title="比较函数"></a>比较函数</h3><p>函数的依据是参数列表，被赋值的 func2 必须有 func1 的所有参数且不冲突, 反过来就不行；</p>
<p>参数少的可以被赋给参数多的，反之不行。即参数只能变多不能变少；</p>
<p>从类型角度来说，func2 的参数是 func1 的子类，func2 可以变成 func1，即子类变成父类，是逆变；</p>
<p>注意这里对比的只是类型，和参数名无关。下面这个例子a和b名字不同，但是都是number类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func1 = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> a;</span><br><span class="line"><span class="keyword">let</span> func2 = <span class="function">(<span class="params">b: <span class="built_in">number</span>, c: <span class="built_in">boolean</span></span>) =&gt;</span> b;</span><br><span class="line"></span><br><span class="line">func1 = func2; <span class="comment">//error</span></span><br><span class="line">func2 = func1; <span class="comment">// func2的参数是func1的子类型，相当于func2可以“接住”func1的所有可能参数类型</span></span><br></pre></td></tr></table></figure>
<p>如果有返回值那就还要考虑返回值，即参数和返回值都要满足才能赋值。返回值的依据是源函数（右边的）的返回值类型必须是目标函数（左边的）返回值类型的子类型（即右边的返回值应该是左边的子类型，属性多的）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="function">() =&gt;</span> (&#123;<span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>&#125;);</span><br><span class="line"><span class="keyword">let</span> y = <span class="function">() =&gt;</span> (&#123;<span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">location</span>: <span class="string">&#x27;NewYork&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">x = y; <span class="comment">// y返回值是x返回值的的子类型</span></span><br><span class="line">y = x; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>


<p>可以参考这个例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> visitAnimal = <span class="function">(<span class="params">animal: Animal</span>) =&gt;</span> &#123;</span><br><span class="line">  animal.age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> visitDog = <span class="function">(<span class="params">dog: Dog</span>) =&gt;</span> &#123;</span><br><span class="line">  dog.age;</span><br><span class="line">  dog.bark();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">visitAnimal = visitDog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = &#123; <span class="attr">age</span>: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">visitAnimal(animal); <span class="comment">// ❌</span></span><br></pre></td></tr></table></figure>

<p>如果我们把<code>visitAnimal = visitDog</code>，现在 visitAnimal 是和 visitDog 一样的具体代码，即会访问参数的 bark 方法；这时传入一个没有 bark 方法的对象就会报错。</p>
<p>而反过来就不会，函数内部不会访问除了 age 之外的任何属性，因此是一定安全的。</p>
<h1 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h1><h3 id="交叉类型-amp-和-联合类型"><a href="#交叉类型-amp-和-联合类型" class="headerlink" title="交叉类型&amp; 和 联合类型|"></a>交叉类型<code>&amp;</code> 和 联合类型<code>|</code></h3><p>交叉类型是将多个类型合并为一个类型，包含了所需的所有类型的特性。<br>表示两个类型都具有, 对于对象型类型表示所有属性都拥有</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">f: T, l: U</span>): <span class="title">T</span> &amp; <span class="title">U</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="xml"><span class="tag">&lt;<span class="name">T</span> &amp; <span class="attr">U</span>&gt;</span>&#123;&#125;;</span></span><br><span class="line"><span class="xml">  for (let key in f) &#123;</span></span><br><span class="line"><span class="xml">    (res as any)[key] = (f as any)[key];</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  for (let key in l) &#123;</span></span><br><span class="line"><span class="xml">    (res as any)[key] = (l as any)[key];</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  return res;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">let mixins = mixin&lt;&#123; name: string &#125;, &#123; age: number &#125;&gt;(</span></span><br><span class="line"><span class="xml">  &#123; name: &quot;zzx&quot; &#125;,</span></span><br><span class="line"><span class="xml">  &#123; age: 19 &#125;</span></span><br><span class="line"><span class="xml">);</span></span><br></pre></td></tr></table></figure>

<hr>
<p>联合类型表示“或”，一般是数种类型的其中一种。<br>对象类型的联合类型只能确定共有的属性，比如下面这个例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> union1 &#123;</span><br><span class="line">  <span class="attr">run</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  walk: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> union2 &#123;</span><br><span class="line">  <span class="attr">run</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  speak: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUnion</span>(<span class="params"></span>): <span class="title">union1</span> | <span class="title">union2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">run</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">walk</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> res = getUnion();</span><br><span class="line">res.walk; <span class="comment">//报错, 只能访问共有的run</span></span><br></pre></td></tr></table></figure>

<p>虽然返回的对象中有 walk，但是由于只共有 run 这个属性，因此只能确定有该属性，其他的都不能直接取。<br>这种问题的解决方案有两种：</p>
<ul>
<li>类型断言，即令要取属性的变量为某种类型，然后取值即可</li>
<li>类型保护，即通过判断是哪种类型，采取不同的处理。类型保护其实就是一个判断是哪种联合类型的函数, 返回值是一个类型谓词</li>
</ul>
<p>比如下面这个例子是一个自定义的类型保护，原理就是判断某个类型是否含有某个属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">interface Dog &#123;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">  canBite: boolean;</span><br><span class="line">&#125;</span><br><span class="line">interface Cat &#123;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">  canCatch: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isDog</span>(<span class="params">animal: Dog | Cat</span>): <span class="title">animal</span> <span class="title">is</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (animal <span class="keyword">as</span> Dog).canBite !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clg</span>(<span class="params">arg: Cat | Dog</span>) </span>&#123;</span><br><span class="line">  isDog(arg) ? <span class="built_in">console</span>.log(<span class="string">&quot;Dog&quot;</span>) : <span class="built_in">console</span>.log(<span class="string">&quot;Cat&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clg(&#123; <span class="attr">name</span>: <span class="string">&quot;miaomiao&quot;</span>, <span class="attr">canCatch</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写法：</p>
<ul>
<li>一个判断是哪种类型的函数，返回是一个<strong>布尔值</strong>，可以通过类型断言返回确定是否含有一个对象的某个键；</li>
<li>返回类型可以直接定义为 boolean，但是更好的方式是用 is；用 <code>arg is typename</code> 的形式；is 运算符相当于缩小了类型范围，其中 <code>typename</code> 是参数类型之一，并且应该是当前判定的类型。比如判定是否为 Dog，那么就应该是 <code>animal is Dog</code></li>
</ul>
<p>除了自定义类型保护，也可以用 typeof 或 instanceof 来判断类型，后者主要用于类类型的判断。</p>
<h3 id="可选参数-1"><a href="#可选参数-1" class="headerlink" title="可选参数"></a>可选参数</h3><p>使用了 –strictNullChecks，可选参数会被自动地加上 | undefined:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">username: <span class="built_in">string</span>, userId?: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;username&#125;</span> <span class="subst">$&#123;userId!.length&#125;</span>`</span>; <span class="comment">//通过 ! 去除undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加<code>!</code>后缀可以去除了 null 和 undefined，或者用 || 或 if 判断也可以</p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何需要手写的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> str = <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> myFn&lt;T&gt; = <span class="function">() =&gt;</span> T;</span><br><span class="line"><span class="keyword">type</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类型别名可以在类型内部调用自己，这是一个很神奇的、类似递归的效果：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Tree&lt;T&gt; = &#123;</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">  left: Tree&lt;T&gt;;</span><br><span class="line">  right: Tree&lt;T&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是类型别名不能作为一个变量，不能被任何情况赋值、不能被继承或复制给其他类型别名。</p>
<h4 id="接口和类型别名的区别"><a href="#接口和类型别名的区别" class="headerlink" title="接口和类型别名的区别"></a>接口和类型别名的区别</h4><p>基本的写法区别不再赘述，其他的区别还有：</p>
<ul>
<li>类型别名可以给基本类型、部分高级类型（联合交叉）重新取名，接口不行</li>
<li>接口通过 extends 扩展，类型别名可以通过<code>&amp;</code>扩展；两者也可以相互扩展</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> PartialPointX &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Point <span class="keyword">extends</span> PartialPointX &#123;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PartialPointX = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> Point = PartialPointX &amp; &#123; <span class="attr">y</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PartialPointX = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">interface</span> Point <span class="keyword">extends</span> PartialPointX &#123;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PartialPointX &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Point = PartialPointX &amp; &#123; <span class="attr">y</span>: <span class="built_in">number</span> &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>接口可以定义多次，并将被视为单个接口，类型别名不可以</li>
<li>type 能使用 in 关键字生成映射类型（比如 forin 循环，或者<code>[key in Keys]</code>遍历），但 interface 不行。</li>
</ul>
<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><h4 id="索引签名"><a href="#索引签名" class="headerlink" title="索引签名"></a>索引签名</h4><p>首先要理解索引签名是什么</p>
<p>索引，就是根据一定的指向返回相应的值，比如数组的索引就是下标 0,1,2;<br>typescript 里的索引签名有两种：数字索引和字符串索引；<br>如下的<code>[xxx:xxx]:xxx</code>就是索引签名形式</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> numberIndex &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> objIndex &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> strIndex &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo: &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: &#123; <span class="attr">message</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line">&#125; = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>最后一种可以是自定义的索引签名类型，也就是规定每一个值都应当是<code>&#123;message:xxx&#125;</code>形式的。</p>
<h5 id="有限的索引"><a href="#有限的索引" class="headerlink" title="有限的索引"></a>有限的索引</h5><p>使用<code>in</code>可以从一组联合或者对象类型别名中取得有限个索引类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> index = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> indexType = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">string</span>;</span><br><span class="line">  b: <span class="built_in">string</span>;</span><br><span class="line">  c: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FormIndex = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> index]: <span class="built_in">any</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> FormIndexType = &#123;</span><br><span class="line">  <span class="comment">//这里可以自动确定值的类型，核心是keyof取得所指对象的key序列，因此后面可以取到；没有keyof则不行</span></span><br><span class="line">  [key <span class="keyword">in</span> keyof indexType]: indexType[key];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以使用泛型规定来源的类型，也可以利用泛型自动确定值的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FromGenericsIndex&lt;K <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> K]: <span class="built_in">any</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IndexFormGenerics&lt;T&gt; = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> keyof T]: T[key];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="索引操作符"><a href="#索引操作符" class="headerlink" title="索引操作符"></a>索引操作符</h4><p>ts 中直接访问对象属性可能会报没有属性的错误，因此可以借助 keyof 取得对象索引<br>比如这样一个 js 函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluck</span>(<span class="params">o, names</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> names.map(<span class="function">(<span class="params">n</span>) =&gt;</span> o[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ts 中是这样的</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluck</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">o: T, names: K[]</span>): <span class="title">T</span>[<span class="title">K</span>][] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> names.map(<span class="function">(<span class="params">n</span>) =&gt;</span> o[n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Jarid&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">35</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> strings: <span class="built_in">string</span>[] = pluck(person, [<span class="string">&quot;name&quot;</span>]);</span><br></pre></td></tr></table></figure>

<p>这里的 K 依赖于 T，不需要明确指明，调用时根据传入的参数确定<br>这里有两个操作符：</p>
<ul>
<li>索引类型查询操作符，即<code>keyof</code>，对于任何类型 T， keyof T 的结果为 T 上已知的公共属性名的联合，比如：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> personProps: keyof Person; <span class="comment">// &#x27;name&#x27; | &#x27;age&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这一点也可用于对象的 forin 遍历</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTestObj = &#123;</span><br><span class="line">  <span class="attr">prop1</span>: <span class="string">&quot;prop1&quot;</span>,</span><br><span class="line">  <span class="attr">prop2</span>: <span class="string">&quot;prop2&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> myKey = keyof <span class="keyword">typeof</span> myTestObj;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> myTestObj) &#123;</span><br><span class="line">  myTestObj[key <span class="keyword">as</span> myKey];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">let</span> key: keyof <span class="keyword">typeof</span> myTestObj;</span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> myTestObj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>索引访问操作符，即<code>T[K]</code>，表示 T 中的 K 属性的类型；比如这个例子中，当 K 取 name 时，<code>T[k]</code>就是 string，后面的[]表示数组类型（注意不是二维数组）</li>
</ul>
<h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><blockquote>
<p>TypeScript 提供了从旧类型中创建新类型的一种方式 — 映射类型。 在映射类型里，新类型以相同的形式去转换旧类型里每个属性。</p>
</blockquote>
<p>其实就是一种工具类，用于转换一个接口或者类型别名<br>常见的映射类型：</p>
<ul>
<li>Readonly，把所有属性转为可读<br>实现原理：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  [propsName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> ReadonlyPerson = Readonly&lt;Person&gt;;</span><br></pre></td></tr></table></figure>

<p>readonly 之后的部分相当于对原对象的遍历</p>
<ul>
<li>Partial，把所有类型转换为可选，原理和使用方法相同</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> PersonPartial = Partial&lt;Person&gt;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Pick&lt;T,P&gt;</code>，给出两个泛型，相当于提取取前一个泛型的 P 属性，实现如下：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IBus &#123;</span><br><span class="line">  <span class="attr">price</span>: <span class="built_in">number</span>;</span><br><span class="line">  weight: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> price = Pick&lt;IBus, <span class="string">&quot;price&quot;</span>&gt;; <span class="comment">//type price = &#123;price:number&#125;</span></span><br></pre></td></tr></table></figure>

<p>要求后者必须是前者的键之一</p>
<ul>
<li><code>Record&lt;T,P&gt;</code>，把 T 的属性值遍历转化为 P 类型，返回一个键为 T 值，值为 P 类型的对象类型。因此 T 只能是 string/number/symbol，P 可以是任意类型（对象的值可以是任意类型），但是一般用作对象或者接口，相当于创建了一个每一项都是该接口的类型。</li>
</ul>
<p>实现如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Record&lt;K <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span> | symbol, T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ICar &#123;</span><br><span class="line">  <span class="attr">price</span>: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> carList = <span class="string">&quot;bmw&quot;</span> | <span class="string">&quot;benz&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> cars = Record&lt;carList, ICar&gt;;</span><br><span class="line"><span class="comment">/*type cars = &#123;</span></span><br><span class="line"><span class="comment">    bmw:ICar;</span></span><br><span class="line"><span class="comment">    benz:ICar;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure>

<p>还有一些其他常用的类型：</p>
<ul>
<li><code>Exclude&lt;T, U&gt;</code> – 从 T 中剔除和 U 交集的类型，返回去除后的 T 类型；如果 T 是 U 的子集，即 T 全部被剔除，就返回 never；</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现</span></span><br><span class="line"><span class="keyword">type</span> Exclude&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T00 = Exclude&lt;<span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span> | <span class="string">&quot;d&quot;</span>, <span class="string">&quot;a&quot;</span> | <span class="string">&quot;c&quot;</span> | <span class="string">&quot;f&quot;</span>&gt;; <span class="comment">// &quot;b&quot; | &quot;d&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Extract&lt;T, U&gt;</code> – 保留 T 和 U 的交集，没有交集返回 never</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现</span></span><br><span class="line"><span class="keyword">type</span> Extract&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T01 = Extract&lt;<span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span> | <span class="string">&quot;d&quot;</span>, <span class="string">&quot;a&quot;</span> | <span class="string">&quot;c&quot;</span> | <span class="string">&quot;f&quot;</span>&gt;; <span class="comment">// &quot;a&quot; | &quot;c&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意这两个在判断上恰恰相反。</p>
<ul>
<li><code>NonNullable&lt;T&gt;</code> – 从 T 中剔除 null 和 undefined。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现</span></span><br><span class="line"><span class="keyword">type</span> NonNullable&lt;T&gt; = T <span class="keyword">extends</span> <span class="literal">null</span> | <span class="literal">undefined</span> ? <span class="built_in">never</span> : T;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ReturnType&lt;T&gt;</code> – 获取函数返回值类型。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现</span></span><br><span class="line"><span class="keyword">type</span> ReturnType&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...args: <span class="built_in">any</span></span><br><span class="line">) =&gt; infer R</span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>

<p>这个实现稍微有点复杂。</p>
<ol>
<li>首先<code>&lt;T extends (...args: any) =&gt; any&gt;</code>限制 T 是一个任意函数；</li>
<li>传入的类型 T 若能够赋值给 <code>(...args: any) =&gt; R</code> 则返回类型 R，也就是说如果 T 是函数就返回该函数的返回值；但是这个返回值恰恰是要去获得的，因此需要“推断”一下。<br>infer 表示一个“推断”；没有 infer 的话，ReturnType 实际上是要实现这样的效果：</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReturnType&lt;T&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; R ? R : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>

<p>也就是判断 T 是否可以赋值给 R，如果可以就返回 R（也就是要获取的返回值类型），不可以就返回 any；但是 R 我们事先不知道，也不能给出，就给 R 前面加上 infer，表示 R 由 T 的返回值推出。<strong>infer R 被放在 (…args: any) =&gt; infer R 函数类型的返回值处，因此推断出了 返回值 类型并赋值给 R 。</strong></p>
<blockquote>
<p>关于 infer，还常用作推断参数；既然我们已知 infer 推断和其位置有关，那么把 infer 放在参数中也可以表示推断参数类型，然后像推断返回值一样把获取的值存在一个泛型中（R）并返回回去。</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ParamType&lt;T <span class="keyword">extends</span> (arg: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (arg: infer R) =&gt; <span class="built_in">any</span></span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>

<p>另外，这种写法中等号右边的 extends 其实相当于程序中的<code>===</code>，也就是整体相当于返回 R 的三元运算符。<br>依照这个原理，可以用类型写出一些判断</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsNumber&lt;N&gt; = N <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="string">&quot;yes, is a number&quot;</span> : <span class="string">&quot;no, not a number&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>由于 infer 的类型推断，综合起来就可以把 infer 放在想要获取的地方并在运算后返回。<br>比如一个对元组的 shift 操作，等号右边就是利用函数剩余参数的性质，将第一个参数提取出来，剩下的部分作为 R 返回；</p>
<blockquote>
<p>其中 extends 在右边并不是单单相当于等号，与 infer 共用时可以理解为一个“转化”，就是把 extends 左边转化为右边的形式；</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ShiftAction&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = (<span class="function">(<span class="params">...args: T</span>) =&gt;</span> <span class="built_in">any</span>) <span class="keyword">extends</span> (</span><br><span class="line">  arg1: <span class="built_in">any</span>,</span><br><span class="line">  ...rest: infer R</span><br><span class="line">) =&gt; <span class="built_in">any</span></span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure>

<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>ts 的命名空间可以理解为一个模块，但不同于 ES6 的模块是以文件为单位的，namespace 更多的是封装一些小的模块进行调用<br>命名空间的基本使用：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> UserModule &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> IUserInfo &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> usernameRegExp = <span class="regexp">/^[a-zA-Z][0-9a-zA-Z]+$/</span>;</span><br><span class="line">  <span class="keyword">const</span> userList: IUserInfo[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> addUser = <span class="function">(<span class="params">userObj: IUserInfo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (usernameRegExp.test(userObj.name)) &#123;</span><br><span class="line">      userList.push(userObj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UserModule.addUser(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;zzx&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">19</span>,</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&quot;001&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码主要有这几个注意点：</p>
<ul>
<li>namespace 声明并包裹一堆代码，需要在外部引用的方法、变量、接口、类型等需要 export，其他的内部则不需要；</li>
<li>namespace 可以使内部的声明独立，也就是让外部其他变量或函数拥有和内部一样的命名；这样就可以减少重名的冲突。</li>
<li>使用时采用<code>name.xxx</code>的形式</li>
</ul>
<p>另外，命名空间还可以在文件间相互调用；调用的方式是专属的 reference 语法：在文件头部用<code>/// &lt;reference path=&quot;xxx.ts&quot; /&gt;</code>引用，其中 path 就是该文件的相对路径。引入后该文件定义的命名空间会和当前文件<strong>合并</strong>。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xxx.ts</span></span><br><span class="line"><span class="keyword">namespace</span> Food &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> Fruits &#123;</span><br><span class="line">    <span class="attr">taste</span>: <span class="built_in">string</span>;</span><br><span class="line">    hardness: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// yyy.ts</span></span><br><span class="line">&lt;reference path=<span class="string">&quot;xxx.ts&quot;</span> /&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> meat: Food.Meat;</span><br><span class="line"><span class="keyword">let</span> fruits: Food.Fruits;</span><br></pre></td></tr></table></figure>

<p>当涉及到多文件时，我们必须确保所有编译后的代码都被加载，也就是让 tsc 编译多个文件；这点在 webpack 等打包工具中不存在，但是仍要考虑</p>
<ol>
<li>第一种方式，把所有的输入文件编译为一个输出文件，需要使用–outFile 标记：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --outFile sample.js Test.ts</span><br></pre></td></tr></table></figure>

<p>编译器会根据源码里的引用标签自动地对输出进行排序 </p>
<ol start="2">
<li>编译多个 ts 文件，然后用多个 script 标签引入（好单纯的方法）。</li>
</ol>
<h1 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h1><blockquote>
<p>“声明合并”是指编译器将针对同一个名字的两个独立声明合并为单一声明。 合并后的声明同时拥有原先两个声明的特性。 任何数量的声明都可被合并；不局限于两个声明。</p>
</blockquote>
<h3 id="接口合并"><a href="#接口合并" class="headerlink" title="接口合并"></a>接口合并</h3><p>接口合并有两个主要规则：</p>
<ol>
<li>同名接口中<strong>非函数成员唯一</strong>；如果不唯一，<strong>类型也必须相同</strong>，否则会报错</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Box &#123;</span><br><span class="line">  <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line">  width: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Box &#123;</span><br><span class="line">  <span class="attr">scale</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">interface</span> Box &#123;</span><br><span class="line">  <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line">  width: <span class="built_in">number</span>;</span><br><span class="line">  scale: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>没有名称的函数成员不会引起冲突，即使完全一样；有名称的函数被视作对象中的方法，每个同名函数声明都会被当成这个函数的一个重载。当接口 A 与后来的接口 A 合并时，<strong>后面的接口具有更高的优先级</strong>。</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Cloner &#123;</span><br><span class="line">  clone(animal: Animal): Animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Cloner &#123;</span><br><span class="line">  clone(animal: Sheep): Sheep;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">interface</span> Cloner &#123;</span><br><span class="line">  clone(animal: Sheep): Sheep;</span><br><span class="line">  clone(animal: Animal): Animal; <span class="comment">//先声明的在后面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类型别名不可以被合并，同名的类型别名会冲突</strong>。</p>
<h3 id="命名空间合并"><a href="#命名空间合并" class="headerlink" title="命名空间合并"></a>命名空间合并</h3><p>与接口相似，同名的命名空间也会合并其成员。其合并的规则如下：</p>
<ul>
<li>命名空间导出的同名接口进行合并，构成单一命名空间内含合并后的接口。</li>
<li>命名空间导出的非接口成员会被加入到之前存在的命名空间中<ul>
<li>非导出成员不合并，只在原先的命名空间中可见</li>
<li>合并之后的成员当作统一个命名空间内，因此 const 和 let 声明的变量不能重复；函数同理</li>
</ul>
</li>
</ul>
<h1 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h1><h2 id="什么是声明文件？"><a href="#什么是声明文件？" class="headerlink" title="什么是声明文件？"></a>什么是声明文件？</h2><p>广义上说，声明文件就是我们在使用一些 js 库时的<code>@types/</code>文件，其中包含了 js 库的类型定义，使得其在 ts 文件中也可以使用。现在主流的 js 库都有发布到 npm 的@types 文件，但有些仍需要使用时去手动编写，或者自己开发的 js 模块也需要声明文件兼容 ts。<br>文件中只包含与类型相关的代码，不包含逻辑代码，它们的作用旨在为开发者提供类型信息，所以它们只在开发阶段起作用。</p>
<p>举个例子，现在在一个ts-react项目中，绝大多数模块都是ts类型的，但是这时创建了一个js的文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// someInfo.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> userInfo = &#123;</span><br><span class="line">  <span class="attr">username</span>:<span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">  age:<span class="number">18</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我希望引入someInfo.js文件到ts文件中，就会提示找不到someInfo.js的声明文件，因为他是一个js模块，ts不能得知它的类型。<br>为了让ts得知它的类型，我们不需要把他改编成ts文件，而是创建一个声明文件，把其中<strong>导出的变量、函数等</strong>声明一个类型，让ts能识别它。<br>我们在同目录下创建一个someInfo.d.ts文件：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> userInfo: &#123;</span><br><span class="line">  <span class="attr">username</span>:<span class="built_in">string</span>;</span><br><span class="line">  age:<span class="built_in">number</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们在ts文件中导入userInfo时，ts会自动解析someInfo.d.ts文件，并把其中的类型作为导入的类型。</p>
<p>对于js编写的库，也是类似的操作。但是不同的库的模块化方式有所不同，因此为库创建类型文件时有所不同。<br>比如jQuery在全局声明了一个<code>$</code>变量，因此我们就需要创建一个全局的global.d.ts文件，给<code>$</code>变量扩充类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> $ : &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="声明文件类型"><a href="#声明文件类型" class="headerlink" title="声明文件类型"></a>声明文件类型</h2><p>根据模块的不同，声明类型有不同，主要分为三类：</p>
<ul>
<li>全局变量：通过 <code>&lt;script&gt;</code> 标签引入第三方库，注入全局变量，常见的比如 jquery</li>
<li>npm 包：通过 <code>import foo from &#39;foo&#39;</code> 导入，符合 ES6 模块规范，即当前绝大多数包的方式</li>
<li>UMD 库：既可以通过 <code>&lt;script&gt;</code> 标签引入，又可以通过 import 导入，UMD 现在比较少用。</li>
</ul>
<p>这三类模块对应的声明文件存放位置、声明形式等都有所不同</p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局变量是最简单的一种场景。直接在声明文件中声明的变量、函数、接口、类型别名以及命名空间都可以被任意一个文件使用，相当于在所有文件顶部声明了全局变量，不需要任何导入导出。<br>全局变量声明文件存放位置应当直接在当前项目中，比如可以直接放在 src/@types 文件夹下。<br>主要语法：<br>​</p>
<ul>
<li><code>declare var</code> 声明全局变量</li>
<li><code>declare function</code> 声明全局方法</li>
<li><code>declare class</code> 声明全局类</li>
<li><code>declare enum</code> 声明全局枚举类型</li>
<li><code>declare namespace</code> 声明全局对象类型；如果对象是嵌套的，就在内部再声明一个命名空间，以此类推</li>
<li><code>interface</code> 和 <code>type</code> 声明全局类型</li>
</ul>
<p>举个栗子，比如我们的模块其中有一个文件中有这样的几个函数和变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloWorld</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HELLO = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hello = &#123;</span><br><span class="line">  <span class="attr">version</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">params</span>: <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据上面的规则，我们就可以书写这样的声明文件</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> HELLO: <span class="built_in">string</span>; <span class="comment">//常量声明，只需要标明类型</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">helloWorld</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="title">void</span></span>; <span class="comment">//函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> hello &#123;</span><br><span class="line">  <span class="comment">//表示对象</span></span><br><span class="line">  <span class="keyword">const</span> version: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">const</span> params: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以在任意 ts 文件中使用如上几个变量。其中 namespace 中的变量需要<code>hello.xxx</code>来访问</p>
<h3 id="npm-模块"><a href="#npm-模块" class="headerlink" title="npm 模块"></a>npm 模块</h3><p>如果需要自己书写模块的声明文件，采用 export 的形式编写</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>);</span><br><span class="line">  sayHi(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> Directions &#123;</span><br><span class="line">  Up,</span><br><span class="line">  Down,</span><br><span class="line">  Left,</span><br><span class="line">  Right,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Options &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> foo &#123;</span><br><span class="line">  <span class="keyword">const</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">namespace</span> bar &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然也可以先声明再导出，声明的方式和全局一样</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> name: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>);</span><br><span class="line">  sayHi(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="built_in">enum</span> Directions &#123;</span><br><span class="line">  Up,</span><br><span class="line">  Down,</span><br><span class="line">  Left,</span><br><span class="line">  Right,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Options &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; name, getName, Animal, Directions, Options &#125;;</span><br></pre></td></tr></table></figure>

<p>还可以使用<code>export default</code>默认导出；<br>注意，只有 function、class 和 interface 可以直接默认导出，其他的变量需要先定义（delcare）出来，再默认导出</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="built_in">enum</span> Directions &#123;</span><br><span class="line">  Up,</span><br><span class="line">  Down,</span><br><span class="line">  Left,</span><br><span class="line">  Right,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Directions;</span><br></pre></td></tr></table></figure>

<h2 id="扩展全局变量"><a href="#扩展全局变量" class="headerlink" title="扩展全局变量"></a>扩展全局变量</h2><p>利用 ts 中接口、命名空间可合并的特征，可以扩展全局变量。有两种方法扩展：</p>
<h3 id="1-直接扩展"><a href="#1-直接扩展" class="headerlink" title="1. 直接扩展"></a>1. 直接扩展</h3><p>在<code>.d.ts文件</code>中直接使用接口，比如扩展 String 类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> String &#123;</span><br><span class="line">  prependHello(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;foo&quot;</span>.prependHello();</span><br></pre></td></tr></table></figure>

<p>也可以使用 <code>declare namespace</code> 给已有的命名空间添加类型声明，也是在对应.d.ts 文件中</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> JQuery &#123;</span><br><span class="line">  <span class="keyword">interface</span> CustomOptions &#123;</span><br><span class="line">    <span class="attr">bar</span>: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> JQueryStatic &#123;</span><br><span class="line">  foo(options: JQuery.CustomOptions): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-npm-包扩展"><a href="#2-npm-包扩展" class="headerlink" title="2. npm 包扩展"></a>2. npm 包扩展</h3><p>使用 <code>declare global</code> 可以在 npm 包或者 UMD 库的声明文件中扩展全局变量的类型；注意不能直接像全局直接扩展一样，因为 es6 模块下只有 export 导出的才能被导入</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="built_in">global</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> String &#123;</span><br><span class="line">    prependHello(): <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>结尾的<code>export &#123;&#125;</code>用来告诉编译器这是一个模块的声明文件，而不是一个全局变量的声明文件，很重要！</p>
<h2 id="声明文件位置"><a href="#声明文件位置" class="headerlink" title="声明文件位置"></a>声明文件位置</h2><ol>
<li>目录 src/@types/，在 src 目录新建 @types 目录，在其中编写 .d.ts 声明文件，声明文件会自动被识别，可以在此为一些没有声明文件的模块编写自己的声明文件。实际上在 tsconfig.json 中 include 字段包含的范围内编写 .d.ts，都将被自动识别；</li>
<li>与被声明的 js 文件同级目录内，创建相同名称的 .d.ts 文件，这样也会被自动识别；</li>
<li>设置 package.json 中的 typings 属性值，如 ./index.d.ts. 这样系统会识别该地址的声明文件。同样当我们把自己的 js 库发布到 npm 上时，按照该方法绑定声明文件。</li>
<li>同过 npm 模块安装，如 @type/react ，它存放在 node_modules/@types/ 路径下</li>
</ol>
<h2 id="三斜线"><a href="#三斜线" class="headerlink" title="三斜线"></a>三斜线</h2><p>类似命名空间的相互引用，如果想使用另一个文件，而这个文件不支持 import 语法就要使用三斜线语法。一般来说 xxx.d.ts 就是不支持 import 语法的，因此多个声明文件的模块化就依赖于此。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules/@types/jquery/index.d.ts</span></span><br><span class="line"><span class="comment">/// &lt;reference types=&quot;sizzle&quot; /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path=&quot;JQueryStatic.d.ts&quot; /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path=&quot;JQuery.d.ts&quot; /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path=&quot;misc.d.ts&quot; /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path=&quot;legacy.d.ts&quot; /&gt;</span></span><br><span class="line"><span class="keyword">export</span> = jQuery;</span><br></pre></td></tr></table></figure>

<h2 id="自动生成声明文件"><a href="#自动生成声明文件" class="headerlink" title="自动生成声明文件"></a>自动生成声明文件</h2><p>ts 文件可以通过规定 tsc 的编译模式来自动生成声明文件<br>在 tsconfig.json 里面进行配置：</p>
<ul>
<li><code>declaration</code> 为每个 TS 文件生成 xx.d.ts 和 x.js 文件。</li>
<li><code>declarationDir</code> 设置生成 .d.ts 文件的目录</li>
<li><code>declarationMap</code> 对每个 .d.ts 文件，都生成对应的 .d.ts.map（sourcemap）文件</li>
<li><code>emitDeclarationOnly</code> 仅生成 .d.ts 文件，不生成 .js 文件</li>
</ul>
<h1 id="编译选项（tsconfig-json）"><a href="#编译选项（tsconfig-json）" class="headerlink" title="编译选项（tsconfig.json）"></a>编译选项（tsconfig.json）</h1><blockquote>
<p>如果一个目录下存在一个 tsconfig.json 文件，那么它意味着这个目录是 TypeScript 项目的根目录。 tsconfig.json 文件中指定了用来编译这个项目的根文件和编译选项。</p>
</blockquote>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>初始化操作有 2 种方式：</p>
<ol>
<li>手动在项目根目录（或其他）创建 tsconfig.json 文件并填写配置；</li>
<li>通过 tsc –init 初始化 tsconfig.json 文件。</li>
</ol>
<p>另外也可以为 tsc 命令指定参数 –project 或 -p 指定需要编译的目录，该目录需要包含一个 tsconfig.json 文件。指定后其他位置的 tsconfig 不再生效</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>tsconfig 主要由 8 个顶层属性组成，其中 compilerOptions 内还有几十个相关配置属性</p>
<p><img src="https://pic.imgdb.cn/item/627a15dd09475431290c29d8.png"><br><img src="https://pic.imgdb.cn/item/627a15f409475431290c62f2.png"></p>
<p>常用的顶层属性是如下四个：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">&quot;files&quot;</span>: [],</span><br><span class="line">  <span class="attr">&quot;include&quot;</span>: [<span class="string">&quot;src/**/*&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;exclude&quot;</span>: [<span class="string">&quot;node_modules&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>compilerOptions</code>是最大、最多配置项的部分，其中有几十个配置选项，后面会详述</li>
<li><code>files</code>指定要编译的 ts 文件，使用根目录下的相对路径表示</li>
<li><code>include</code>和<code>exclude</code>分别表示包括和排除的文件和目录。两者具有类似的 glob 通配符：<ul>
<li><code>*</code> 匹配 0 或多个字符（不包括目录分隔符）</li>
<li><code>?</code> 匹配一个任意字符（不包括目录分隔符）</li>
<li><code>**/</code> 递归匹配任意子目录</li>
</ul>
</li>
</ul>
<h3 id="compilerOptions-配置编译选项"><a href="#compilerOptions-配置编译选项" class="headerlink" title="compilerOptions 配置编译选项"></a>compilerOptions 配置编译选项</h3><p>编译选项配置非常繁杂，有很多配置，这里只列出常用的配置。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;incremental&quot;</span>: <span class="literal">true</span>, <span class="comment">// TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度</span></span><br><span class="line">    <span class="attr">&quot;tsBuildInfoFile&quot;</span>: <span class="string">&quot;./buildFile&quot;</span>, <span class="comment">// 增量编译文件的存储位置</span></span><br><span class="line">    <span class="attr">&quot;diagnostics&quot;</span>: <span class="literal">true</span>, <span class="comment">// 打印诊断信息</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;ES5&quot;</span>, <span class="comment">// 目标语言的版本</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;CommonJS&quot;</span>, <span class="comment">// 生成代码的模块标准，如果要使用import/export需要写成ES2015或es6；在webpack相关配置中必须是es6</span></span><br><span class="line">    <span class="attr">&quot;outFile&quot;</span>: <span class="string">&quot;./app.js&quot;</span>, <span class="comment">// 将多个相互依赖的文件生成一个文件</span></span><br><span class="line">    <span class="attr">&quot;lib&quot;</span>: [<span class="string">&quot;DOM&quot;</span>, <span class="string">&quot;ES2015&quot;</span>, <span class="string">&quot;ScriptHost&quot;</span>, <span class="string">&quot;ES2019.Array&quot;</span>], <span class="comment">// TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入&quot;ES2019.Array&quot;,</span></span><br><span class="line">    <span class="attr">&quot;allowJS&quot;</span>: <span class="literal">true</span>, <span class="comment">// 允许编译器编译JS，JSX文件</span></span><br><span class="line">    <span class="attr">&quot;checkJs&quot;</span>: <span class="literal">true</span>, <span class="comment">// 允许在JS文件中报错，通常与allowJS一起使用</span></span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;./dist&quot;</span>, <span class="comment">// 指定输出目录</span></span><br><span class="line">    <span class="attr">&quot;rootDir&quot;</span>: <span class="string">&quot;./&quot;</span>, <span class="comment">// 指定输出文件目录(用于输出)，用于控制输出目录结构</span></span><br><span class="line">    <span class="attr">&quot;declaration&quot;</span>: <span class="literal">true</span>, <span class="comment">// 生成声明文件，开启后会自动生成声明文件</span></span><br><span class="line">    <span class="attr">&quot;declarationDir&quot;</span>: <span class="string">&quot;./file&quot;</span>, <span class="comment">// 指定生成声明文件存放目录</span></span><br><span class="line">    <span class="attr">&quot;emitDeclarationOnly&quot;</span>: <span class="literal">true</span>, <span class="comment">// 只生成声明文件，而不会生成js文件</span></span><br><span class="line">    <span class="attr">&quot;sourceMap&quot;</span>: <span class="literal">true</span>, <span class="comment">// 生成目标文件的sourceMap文件</span></span><br><span class="line">    <span class="attr">&quot;inlineSourceMap&quot;</span>: <span class="literal">true</span>, <span class="comment">// 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中</span></span><br><span class="line">    <span class="attr">&quot;declarationMap&quot;</span>: <span class="literal">true</span>, <span class="comment">// 为声明文件生成sourceMap</span></span><br><span class="line">    <span class="attr">&quot;typeRoots&quot;</span>: [], <span class="comment">// 声明文件目录，默认时node_modules/@types</span></span><br><span class="line">    <span class="attr">&quot;types&quot;</span>: [], <span class="comment">// 加载的声明文件包</span></span><br><span class="line">    <span class="attr">&quot;removeComments&quot;</span>: <span class="literal">true</span>, <span class="comment">// 删除注释</span></span><br><span class="line">    <span class="attr">&quot;noEmit&quot;</span>: <span class="literal">true</span>, <span class="comment">// 不输出文件,即编译后不会生成任何js文件</span></span><br><span class="line">    <span class="attr">&quot;noEmitOnError&quot;</span>: <span class="literal">true</span>, <span class="comment">// 发送错误时不输出任何文件</span></span><br><span class="line">    <span class="attr">&quot;noEmitHelpers&quot;</span>: <span class="literal">true</span>, <span class="comment">// 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用</span></span><br><span class="line">    <span class="attr">&quot;importHelpers&quot;</span>: <span class="literal">true</span>, <span class="comment">// 通过tslib引入helper函数，文件必须是模块</span></span><br><span class="line">    <span class="attr">&quot;downlevelIteration&quot;</span>: <span class="literal">true</span>, <span class="comment">// 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span>: <span class="literal">true</span>, <span class="comment">// 开启所有严格的类型检查</span></span><br><span class="line">    <span class="attr">&quot;alwaysStrict&quot;</span>: <span class="literal">true</span>, <span class="comment">// 在代码中注入&#x27;use strict&#x27;</span></span><br><span class="line">    <span class="attr">&quot;noImplicitAny&quot;</span>: <span class="literal">true</span>, <span class="comment">// 不允许隐式的any类型</span></span><br><span class="line">    <span class="attr">&quot;strictNullChecks&quot;</span>: <span class="literal">true</span>, <span class="comment">// 不允许把null、undefined赋值给其他类型的变量</span></span><br><span class="line">    <span class="attr">&quot;strictFunctionTypes&quot;</span>: <span class="literal">true</span>, <span class="comment">// 不允许函数参数双向协变</span></span><br><span class="line">    <span class="attr">&quot;strictPropertyInitialization&quot;</span>: <span class="literal">true</span>, <span class="comment">// 类的实例属性必须初始化</span></span><br><span class="line">    <span class="attr">&quot;strictBindCallApply&quot;</span>: <span class="literal">true</span>, <span class="comment">// 严格的bind/call/apply检查</span></span><br><span class="line">    <span class="attr">&quot;noImplicitThis&quot;</span>: <span class="literal">true</span>, <span class="comment">// 不允许this有隐式的any类型</span></span><br><span class="line">    <span class="attr">&quot;noUnusedLocals&quot;</span>: <span class="literal">true</span>, <span class="comment">// 检查只声明、未使用的局部变量(只提示不报错)</span></span><br><span class="line">    <span class="attr">&quot;noUnusedParameters&quot;</span>: <span class="literal">true</span>, <span class="comment">// 检查未使用的函数参数(只提示不报错)</span></span><br><span class="line">    <span class="attr">&quot;noFallthroughCasesInSwitch&quot;</span>: <span class="literal">true</span>, <span class="comment">// 防止switch语句贯穿(即如果没有break语句后面不会执行)</span></span><br><span class="line">    <span class="attr">&quot;noImplicitReturns&quot;</span>: <span class="literal">true</span>, <span class="comment">//每个分支都会有返回值</span></span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span>: <span class="literal">true</span>, <span class="comment">// 允许export=导出，由import from 导入</span></span><br><span class="line">    <span class="attr">&quot;allowUmdGlobalAccess&quot;</span>: <span class="literal">true</span>, <span class="comment">// 允许在模块中全局变量的方式访问umd模块</span></span><br><span class="line">    <span class="attr">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span>, <span class="comment">// 模块解析策略，ts默认用node的解析策略，即相对的方式导入</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span>: <span class="string">&quot;./&quot;</span>, <span class="comment">// 解析非相对模块的基地址，默认是当前目录</span></span><br><span class="line">    <span class="attr">&quot;paths&quot;</span>: &#123;</span><br><span class="line">      <span class="comment">// 路径映射，相对于baseUrl</span></span><br><span class="line">      <span class="comment">// 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置</span></span><br><span class="line">      <span class="attr">&quot;jquery&quot;</span>: [<span class="string">&quot;node_modules/jquery/dist/jquery.min.js&quot;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;rootDirs&quot;</span>: [<span class="string">&quot;src&quot;</span>, <span class="string">&quot;out&quot;</span>], <span class="comment">// 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错</span></span><br><span class="line">    <span class="attr">&quot;listEmittedFiles&quot;</span>: <span class="literal">true</span>, <span class="comment">// 打印输出文件</span></span><br><span class="line">    <span class="attr">&quot;listFiles&quot;</span>: <span class="literal">true</span> <span class="comment">// 打印编译的文件(包括引用的声明文件)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TIPs"><a href="#TIPs" class="headerlink" title="TIPs"></a>TIPs</h1><h2 id="关于索引签名的区别"><a href="#关于索引签名的区别" class="headerlink" title="关于索引签名的区别"></a>关于索引签名的区别</h2><p><code>[P in T]</code>和<code>[P in keyof T]</code>有什么区别呢？什么时候该用 in，什么时候该用 in keyof？</p>
<ul>
<li><code>[P in T]</code>表示 T 一定是<code>string|number|symbol</code>或者他们的联合；因此 in 表示 T 是联合或者经过 keyof 取值的对象（其实还是联合）</li>
<li><code>[P in keyof T]</code>表示 T 是一个有索引的类型，比如对象、数组。keyof 取值之后就成为了字符串的联合</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IUser &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> union = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> getIn&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> T]: P;</span><br><span class="line">&#125;;</span><br><span class="line">getIn&lt;union&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type getIn = &#123;</span></span><br><span class="line"><span class="comment">    a: &quot;a&quot;;</span></span><br><span class="line"><span class="comment">    b: &quot;b&quot;;</span></span><br><span class="line"><span class="comment">    c: &quot;c&quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">getKey&lt;IUser&gt;</span><br><span class="line"><span class="keyword">type</span> getKey&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: P;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type getKey = &#123;</span></span><br><span class="line"><span class="comment">    name: &quot;name&quot;;</span></span><br><span class="line"><span class="comment">    age: &quot;age&quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<p>那索引之后的<code>P</code>和<code>T[P]</code>又分别表示什么呢？（按照上面的形式）</p>
<ul>
<li><code>P</code>一定是<strong>键</strong>，并且 P 应当是<code>number|string|symbol</code>之一。</li>
<li><code>T[P]</code>表示 T 中取 P 对应的值，也就要求 T 一定是<strong>接口或对象型的类型别名</strong>。如果 P 满足是键的话，T 就是该键对应的类型</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> getKey&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getKey&lt;IUser&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type getKey = &#123;</span></span><br><span class="line"><span class="comment">    name: string;</span></span><br><span class="line"><span class="comment">    age: number;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="强大的类型语法"><a href="#强大的类型语法" class="headerlink" title="强大的类型语法"></a>强大的类型语法</h2><p>ts 中的类型是一个完整的体系，以类型别名定义的类型几乎可以作为一个完整的语言来运作</p>
<h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><p>extends 位于类型别名等号右边时，就会产生不同于“约束”“继承”的功能。</p>
<ul>
<li><p>三元运算，让类型也可以有 if-else</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IsNumber&lt;N&gt; = N <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="string">&quot;yes, is a number&quot;</span> : <span class="string">&quot;no, not a number&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>三元运算中的 extends 相当于<code>===</code>，并会返回符合条件的结果。</p>
</li>
<li><p>和 infer 一起时表示“转换”<br>比如在元组中说过的 shift 代码：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ShiftAction&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = (<span class="function">(<span class="params">...args: T</span>) =&gt;</span> <span class="built_in">any</span>) <span class="keyword">extends</span> (</span><br><span class="line">  arg1: <span class="built_in">any</span>,</span><br><span class="line">  ...rest: infer R</span><br><span class="line">) =&gt; <span class="built_in">any</span></span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure>

<p>这里的 extends 就不是“等于”，而更多表示把一个<code>((...args: T) =&gt; any)</code>的函数转化为第一个参数提取出来的形式，并配合<code>infer R</code>把要求的 R 返回。</p>
</li>
<li><p>用于映射，通过<code>extends any</code>让任意类型都可以转化为想要的类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的 placeholder 可以键入任何你所希望映射成为的类型</span></span><br><span class="line"><span class="keyword">type</span> UnionTypesMap&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">any</span> ? <span class="string">&quot;placeholder&quot;</span> : <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">type</span> UnionTypesMap2Func&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">any</span> ? <span class="function">() =&gt;</span> T : <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">type</span> UnionTypesMap3Func&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">any</span> ? &#123; [k: <span class="built_in">string</span>]: T &#125; : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure>

<p><code>extends any</code>相当于抹平的对 T 的所有限制，然后就可以返回任何类型，也就是把 T 转化为任何想要的类型（placeholder 的类型仍需要含有 T，不能直接是 string 这样的简单类型）。</p>
</li>
</ul>
<h3 id="类型语言"><a href="#类型语言" class="headerlink" title="类型语言"></a>类型语言</h3><h4 id="类型支持作用域"><a href="#类型支持作用域" class="headerlink" title="类型支持作用域"></a>类型支持作用域</h4><p>泛型类型可以当作 js 中函数来看待，尖括号内是参数，等号后面是具体的函数体；结合之前说的三元运算、extends 就可以实现很多类型相关的处理，比如自定义工具类等。<br>既然相当于函数，类型泛型其实也像 js 函数一样有“作用域”，比如闭包：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">param: T</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> param;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myFooStr = Foo&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"><span class="comment">// const myFooStr: (param: string) =&gt; string</span></span><br><span class="line"><span class="comment">// myFooStr的类型和Foo函数中定义的相同，说明类型作为一个闭包跟在myFooStr上</span></span><br><span class="line"><span class="keyword">const</span> myFooNum = Foo&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"><span class="comment">// const myFooNum: (param: number) =&gt; number</span></span><br><span class="line"><span class="comment">// 由于闭包，类型也会保持相互独立，互不干涉</span></span><br></pre></td></tr></table></figure>

<h4 id="类型递归"><a href="#类型递归" class="headerlink" title="类型递归"></a>类型递归</h4><p>类型语法虽然不支持循环，但是因为类型别名可以自己引用自己的原因，使用递归可以相当于循环：<br>比如</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shift在前面元组中讲过</span></span><br><span class="line"><span class="keyword">type</span> combineTupleTypeWithTecursion&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], E = &#123;&#125;&gt; = &#123;</span><br><span class="line">  <span class="number">1</span>: E; <span class="comment">//键的1和0也可以是任何键，主要用于引用E方便返回</span></span><br><span class="line">  <span class="number">0</span>: combineTupleTypeWithTecursion&lt;ShiftAction&lt;T&gt;, E &amp; T[<span class="number">0</span>]&gt;; <span class="comment">//递归调用类型，相当于把第一个剔除之后放到E中然后继续</span></span><br><span class="line">&#125;[T <span class="keyword">extends</span> [] ? <span class="number">1</span> : <span class="number">0</span>]; <span class="comment">//判断T是否为空数组，为空则终止</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> test = [&#123; <span class="attr">a</span>: <span class="built_in">string</span> &#125;, &#123; <span class="attr">b</span>: <span class="built_in">number</span> &#125;];</span><br><span class="line"><span class="keyword">type</span> testResult = combineTupleTypeWithTecursion&lt;test&gt;; <span class="comment">// &#123; a: string; &#125; &amp; &#123; b: number; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//换成正常的ts代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">combineTupleTypeWithTecursion</span>(<span class="params">T: <span class="built_in">object</span>[], E: <span class="built_in">object</span> = &#123;&#125;</span>): <span class="title">object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> T.length</span><br><span class="line">    ? combineTupleTypeWithTecursion(T.slice(<span class="number">1</span>), &#123; ...E, ...T[<span class="number">0</span>] &#125;)</span><br><span class="line">    : E;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testData = [&#123; <span class="attr">a</span>: <span class="string">&quot;hello world&quot;</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">100</span> &#125;];</span><br><span class="line"><span class="comment">// 此时函数的返回值为 &#123; a: &#x27;hello world&#x27;, b: 100 &#125;</span></span><br><span class="line">combineTupleTypeWithTecursion(testData);</span><br></pre></td></tr></table></figure>

<p>类似的写法还可以完成 Concat(拼接元组):</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Concat&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], S <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = &#123;</span><br><span class="line">  <span class="number">0</span>: T;</span><br><span class="line">  <span class="number">1</span>: Concat&lt;Push&lt;T, S[<span class="number">0</span>]&gt;, Shift&lt;S&gt;&gt;; <span class="comment">//把S第一项插入T，并把S第一项去掉；Push是之前提到的方法</span></span><br><span class="line">&#125;[S <span class="keyword">extends</span> [] ? <span class="number">0</span> : <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//正常ts代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Concat</span>(<span class="params">T: <span class="built_in">any</span>[], S: <span class="built_in">any</span>[]</span>): <span class="title">any</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> S.length ? Concat(T.push(S[<span class="number">0</span>]), S.slice(<span class="number">1</span>)) : T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="es6-相关内容"><a href="#es6-相关内容" class="headerlink" title="es6 相关内容"></a>es6 相关内容</h2><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise 的具体类型定义肥肠复杂，这里只是简单说一下使用相关</p>
<ul>
<li>Promise 直接链式调用可以自动判断 resolve 的值类型</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">123</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> res.toString())</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> res.length)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res));</span><br></pre></td></tr></table></figure>

<ul>
<li>new Promise 调用需要手动规定类型，方法有两种，类型注解泛型规定和 Promise 本身的泛型规定</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>): <span class="title">Promise</span>&lt;<span class="title">string</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getValue().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>&lt;<span class="built_in">number</span>&gt;(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">123</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Map-和-Set"><a href="#Map-和-Set" class="headerlink" title="Map 和 Set"></a>Map 和 Set</h3><h4 id="Map-的创建"><a href="#Map-的创建" class="headerlink" title="Map 的创建"></a>Map 的创建</h4><p>和 js 一样，ts 中的 map 和 set 也有两中创建方式</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="literal">true</span>, <span class="literal">false</span>).set(<span class="number">1</span>, <span class="string">&quot;1&quot;</span>).set(<span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>, <span class="built_in">string</span> | <span class="built_in">number</span>&gt;([</span><br><span class="line">  [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([<span class="comment">//error:没有规定类型</span></span><br><span class="line">  [...]</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：第二种也就是初始化 map 的方式必须在泛型中注明类型否则会报错</p>
</blockquote>
<p>观察 Map 的类型定义可得 Map 有三种重载：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;K, V&gt;(iterable: Iterable&lt;<span class="keyword">readonly</span> [K, V]&gt;): <span class="built_in">Map</span>&lt;K, V&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span>(): <span class="built_in">Map</span>&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span>&lt;K, V&gt;(entries?: <span class="keyword">readonly</span> (<span class="keyword">readonly</span> [K, V])[] | <span class="literal">null</span> | <span class="literal">undefined</span>): <span class="built_in">Map</span>&lt;K, V&gt;</span><br></pre></td></tr></table></figure>

<p>其中第二种是最基础的类型，可以先用空值创建后续用 set 添加值，这种是不能有参数的；<br>第一种和第三种都强制要求注明类型，并返回一个该类型的 map；第三种就是初始化形式创建，第一种则是一个可迭代对象，比如设置了迭代器的 Object 或者另一个 map（是的，可以用一个 map 再创建一个 map）</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> mapFromMap = <span class="keyword">new</span> <span class="built_in">Map</span>(map);</span><br></pre></td></tr></table></figure>

<p>有一个缺陷是：map 只能大致规定键值的类型，不能像对象一样用接口来约束具体值；因此在遍历过程中可能需要类型断言或守卫。</p>
<h4 id="Map-相关操作"><a href="#Map-相关操作" class="headerlink" title="Map 相关操作"></a>Map 相关操作</h4><p>Map 的遍历和在 js 中没有太多区别：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="literal">true</span>, <span class="literal">false</span>).set(<span class="number">1</span>, <span class="string">&quot;1&quot;</span>).set(<span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="keyword">let</span> [key, value] = entry;</span><br><span class="line">&#125;</span><br><span class="line">map.forEach(<span class="function">(<span class="params">value, key, map</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果通过 set 形式添加值，key 和 value 都会被认作<code>any</code>，除非再创建时用泛型规定值。</p>
<p>还可以利用相关 API 在 object 和 Map 间相互转换<br>注意要求<code>tsconfig.ts</code>中<code>&quot;lib&quot;</code>配置至少有<code>ES2019</code>及以上</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mapObj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;zzx&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象变map</span></span><br><span class="line"><span class="keyword">const</span> mapFromObj = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(mapObj));</span><br><span class="line"><span class="built_in">console</span>.log(mapFromObj.entries());</span><br><span class="line"></span><br><span class="line"><span class="comment">//map变对象</span></span><br><span class="line"><span class="keyword">const</span> objFromMap = <span class="built_in">Object</span>.fromEntries(map);</span><br><span class="line"><span class="built_in">console</span>.log(objFromMap);</span><br></pre></td></tr></table></figure>

<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>Set 和 Map 类似，有两种创建的方式；但是 Set 可以初始化时不指明类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;3&quot;</span>]); <span class="comment">//不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>&lt;<span class="built_in">number</span> | <span class="built_in">string</span>&gt;([<span class="number">1</span>, <span class="string">&quot;2&quot;</span>, <span class="number">3</span>, <span class="string">&quot;4&quot;</span>]); <span class="comment">//这种更好</span></span><br><span class="line"></span><br><span class="line">set.add(<span class="number">5</span>).add(<span class="string">&quot;6&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> set.keys()) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> set.values()) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> set) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(set.has(<span class="number">7</span>));</span><br><span class="line"><span class="built_in">console</span>.log(set.size);</span><br><span class="line">set.delete(<span class="string">&quot;5&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Set 的重载有两个，第一个是和 Map 中一样的可迭代对象，第二个则是一个数组</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>(iterable?: Iterable&lt;unknown&gt; | <span class="literal">null</span> | <span class="literal">undefined</span>): <span class="built_in">Set</span>&lt;unknown&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span>&lt;T = <span class="built_in">any</span>&gt;(values?: <span class="keyword">readonly</span> T[] | <span class="literal">null</span> | <span class="literal">undefined</span>): <span class="built_in">Set</span>&lt;T&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到 set 中对类型有一个默认值 any，因此初始化不指明类型也不会报错</p>
<h1 id="TS-代码哲学"><a href="#TS-代码哲学" class="headerlink" title="TS 代码哲学"></a>TS 代码哲学</h1><ol>
<li>减少不必要的显式类型定义，尽可能多地使用类型推导，让类型的流动像呼吸一样自然。</li>
<li>尽可能少地使用 <code>any</code> 或 <code>as any</code>，注意这里并不是说不能用，而是你判断出目前情况下使用 <code>any</code> 是最优解。</li>
<li>如果确定要使用 <code>any</code> 作为类型，优先考虑一下是否可以使用 <code>unknown</code> 类型替代，毕竟 <code>any</code> 会破坏类型的流动。</li>
<li>尽可能少地使用 <code>as xxx</code>，如果大量使用这种方式纠正类型，那么大概率你对 <code>类型流动 </code>理解的还不够透彻。</li>
</ol>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/">日常学习</a></div><div class="post_share"><div class="social-share" data-image="/img/typescript.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/29/blog8-react-review/"><img class="prev-cover" src="/img/react.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">react（略深入的）复习</div></div></a></div><div class="next-post pull-right"><a href="/2022/02/02/RegExp/"><img class="next-cover" src="/img/canvas.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">正则表达式学习和常用正则</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/05/12/OS/" title="操作系统知识点总结"><img class="cover" src="/img/codes1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-12</div><div class="title">操作系统知识点总结</div></div></a></div><div><a href="/2021/12/05/blog1-h5-deeping/" title="前端知识深入--HTML5深入"><img class="cover" src="/img/Chrome.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-05</div><div class="title">前端知识深入--HTML5深入</div></div></a></div><div><a href="/2022/02/02/RegExp/" title="正则表达式学习和常用正则"><img class="cover" src="/img/canvas.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-02</div><div class="title">正则表达式学习和常用正则</div></div></a></div><div><a href="/2021/12/10/blog2-css-deeping/" title="CSS学习总结"><img class="cover" src="/img/CSS.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-10</div><div class="title">CSS学习总结</div></div></a></div><div><a href="/2021/12/02/blog4-web/" title="网络知识学习总结"><img class="cover" src="/img/web.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-02</div><div class="title">网络知识学习总结</div></div></a></div><div><a href="/2021/12/02/blog5-browser/" title="浏览器知识学习总结"><img class="cover" src="/img/Chrome.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-02</div><div class="title">浏览器知识学习总结</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/pinkstar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xing Ye</div><div class="author-info__description">a singleThreaded boy's blog</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/penghei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/penghei" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:632885485@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">A SingleThreaded Boy...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%A1%A5%E5%85%85"><span class="toc-number">1.</span> <span class="toc-text">基本类型补充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BB%84"><span class="toc-number">1.0.1.</span> <span class="toc-text">元组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#never-%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.2.</span> <span class="toc-text">never 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">1.0.3.</span> <span class="toc-text">类型断言</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.0.1.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-number">2.0.2.</span> <span class="toc-text">方法和函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D"><span class="toc-number">2.0.3.</span> <span class="toc-text">任意索引签名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E7%B4%A2%E5%BC%95%E5%8F%96%E5%BE%97%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">2.0.4.</span> <span class="toc-text">用索引取得接口中的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.0.5.</span> <span class="toc-text">类和接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.0.6.</span> <span class="toc-text">混合类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84-getter-%E5%92%8C-setter"><span class="toc-number">3.0.1.</span> <span class="toc-text">类的 getter 和 setter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">3.0.2.</span> <span class="toc-text">抽象类和方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%BD%93%E4%BD%9C%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.0.3.</span> <span class="toc-text">类当作接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-number">4.0.1.</span> <span class="toc-text">函数类型声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-number">4.0.2.</span> <span class="toc-text">可选参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">4.0.3.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ts-%E4%B8%AD%E7%9A%84-this"><span class="toc-number">4.0.4.</span> <span class="toc-text">ts 中的 this</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-number">5.0.1.</span> <span class="toc-text">泛型和函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.0.2.</span> <span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">5.0.3.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">5.0.4.</span> <span class="toc-text">泛型约束</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9"><span class="toc-number">6.</span> <span class="toc-text">类型兼容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E4%BD%93"><span class="toc-number">6.0.1.</span> <span class="toc-text">变体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB"><span class="toc-number">6.0.1.1.</span> <span class="toc-text">类型系统的父子关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC"><span class="toc-number">6.0.1.2.</span> <span class="toc-text">赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E4%BD%93-1"><span class="toc-number">6.0.1.3.</span> <span class="toc-text">变体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.0.2.</span> <span class="toc-text">比较对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0"><span class="toc-number">6.0.3.</span> <span class="toc-text">比较函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.</span> <span class="toc-text">高级类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B-amp-%E5%92%8C-%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.0.1.</span> <span class="toc-text">交叉类型&amp; 和 联合类型|</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0-1"><span class="toc-number">7.0.2.</span> <span class="toc-text">可选参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">7.0.3.</span> <span class="toc-text">类型别名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.0.3.1.</span> <span class="toc-text">接口和类型别名的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.0.4.</span> <span class="toc-text">索引类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D"><span class="toc-number">7.0.4.1.</span> <span class="toc-text">索引签名</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">7.0.4.1.1.</span> <span class="toc-text">有限的索引</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">7.0.4.2.</span> <span class="toc-text">索引操作符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.0.5.</span> <span class="toc-text">映射类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">8.</span> <span class="toc-text">命名空间</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%90%88%E5%B9%B6"><span class="toc-number">9.</span> <span class="toc-text">声明合并</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%90%88%E5%B9%B6"><span class="toc-number">9.0.1.</span> <span class="toc-text">接口合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%90%88%E5%B9%B6"><span class="toc-number">9.0.2.</span> <span class="toc-text">命名空间合并</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6"><span class="toc-number">10.</span> <span class="toc-text">声明文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%EF%BC%9F"><span class="toc-number">10.1.</span> <span class="toc-text">什么是声明文件？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.2.</span> <span class="toc-text">声明文件类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">10.2.1.</span> <span class="toc-text">全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#npm-%E6%A8%A1%E5%9D%97"><span class="toc-number">10.2.2.</span> <span class="toc-text">npm 模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">10.3.</span> <span class="toc-text">扩展全局变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%9B%B4%E6%8E%A5%E6%89%A9%E5%B1%95"><span class="toc-number">10.3.1.</span> <span class="toc-text">1. 直接扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-npm-%E5%8C%85%E6%89%A9%E5%B1%95"><span class="toc-number">10.3.2.</span> <span class="toc-text">2. npm 包扩展</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%E4%BD%8D%E7%BD%AE"><span class="toc-number">10.4.</span> <span class="toc-text">声明文件位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%96%9C%E7%BA%BF"><span class="toc-number">10.5.</span> <span class="toc-text">三斜线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6"><span class="toc-number">10.6.</span> <span class="toc-text">自动生成声明文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%EF%BC%88tsconfig-json%EF%BC%89"><span class="toc-number">11.</span> <span class="toc-text">编译选项（tsconfig.json）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">11.0.1.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-number">11.0.2.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#compilerOptions-%E9%85%8D%E7%BD%AE%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9"><span class="toc-number">11.0.3.</span> <span class="toc-text">compilerOptions 配置编译选项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TIPs"><span class="toc-number">12.</span> <span class="toc-text">TIPs</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.1.</span> <span class="toc-text">关于索引签名的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%A4%A7%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%AF%AD%E6%B3%95"><span class="toc-number">12.2.</span> <span class="toc-text">强大的类型语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#extends"><span class="toc-number">12.2.1.</span> <span class="toc-text">extends</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80"><span class="toc-number">12.2.2.</span> <span class="toc-text">类型语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%94%AF%E6%8C%81%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">12.2.2.1.</span> <span class="toc-text">类型支持作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E9%80%92%E5%BD%92"><span class="toc-number">12.2.2.2.</span> <span class="toc-text">类型递归</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#es6-%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9"><span class="toc-number">12.3.</span> <span class="toc-text">es6 相关内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise"><span class="toc-number">12.3.1.</span> <span class="toc-text">Promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map-%E5%92%8C-Set"><span class="toc-number">12.3.2.</span> <span class="toc-text">Map 和 Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Map-%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">12.3.2.1.</span> <span class="toc-text">Map 的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map-%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-number">12.3.2.2.</span> <span class="toc-text">Map 相关操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set"><span class="toc-number">12.3.2.3.</span> <span class="toc-text">Set</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TS-%E4%BB%A3%E7%A0%81%E5%93%B2%E5%AD%A6"><span class="toc-number">13.</span> <span class="toc-text">TS 代码哲学</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/15/nextjs/" title="next.js 学习"><img src="/img/nextjs.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="next.js 学习"/></a><div class="content"><a class="title" href="/2022/09/15/nextjs/" title="next.js 学习">next.js 学习</a><time datetime="2022-09-15T07:37:22.000Z" title="发表于 2022-09-15 15:37:22">2022-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/24/fe-design-pattern/" title="设计模式学习总结"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式学习总结"/></a><div class="content"><a class="title" href="/2022/07/24/fe-design-pattern/" title="设计模式学习总结">设计模式学习总结</a><time datetime="2022-07-24T08:21:22.000Z" title="发表于 2022-07-24 16:21:22">2022-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/11/blog8-react-source-code/" title="react原理浅析学习"><img src="/img/react.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="react原理浅析学习"/></a><div class="content"><a class="title" href="/2022/07/11/blog8-react-source-code/" title="react原理浅析学习">react原理浅析学习</a><time datetime="2022-07-11T06:07:32.000Z" title="发表于 2022-07-11 14:07:32">2022-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/18/projects/" title="无题"><img src="/img/codes1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/05/18/projects/" title="无题">无题</a><time datetime="2022-05-18T02:57:57.356Z" title="发表于 2022-05-18 10:57:57">2022-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/13/blog10-handwriting/" title="js手写"><img src="/img/JS.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="js手写"/></a><div class="content"><a class="title" href="/2022/05/13/blog10-handwriting/" title="js手写">js手写</a><time datetime="2022-05-13T04:21:10.000Z" title="发表于 2022-05-13 12:21:10">2022-05-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Xing Ye</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hello stranger!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>